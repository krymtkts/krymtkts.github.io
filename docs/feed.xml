<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><atom:link href="https://krymtkts.github.io/" rel="self" type="application/rss+xml"/><title>krymtkts</title><link>https://krymtkts.github.io/</link><description>krymtkts's personal blog</description><lastBuildDate>Sun, 20 Nov 2022 15:39:28 +0900</lastBuildDate><generator>clj-rss</generator><item><guid>https://krymtkts.github.io/posts/2022-11-20-writing-cmdlet-in-fsharp-pt7</guid><link>https://krymtkts.github.io/posts/2022-11-20-writing-cmdlet-in-fsharp-pt7</link><title>F#でコマンドレットを書いてる pt.7</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。
プロパティ指定の検索に対応しようとしていて、今日のはその思考整理のようなもの。 &lt;a href="https://github.com/krymtkts/pocof/issues/2"&gt;Add a property support. · Issue #2 · krymtkts/pocof&lt;/a&gt;&lt;/p&gt;&lt;p&gt;実は？ &lt;a href="https://github.com/jasonmarcher/poco"&gt;jasonmarcher/poco&lt;/a&gt; を使ってたときから今に至るまで、プロパティ指定の検索をあまりやってこなかった。
可能性は感じていて何なら使いたかったけど、プロパティをいちいち覚えて打つとかできなくて、使いこなせなかった。
なので pocof でそれを実装するからには、障壁を取り除いて簡単に使える機能にしたい。
そのため、まず pocof が機能に対応したと仮定してどんな風に使うか手を動かすイメージをして、そのあと今の pocof との差を表出させるようなことをしている。&lt;/p&gt;&lt;p&gt;このアプローチだけでも色々足りないものが見えてきて面白い。
pocof の時から今の pocof に至るまでの自分の使い方が非常に限定的だったのがよく分かる。
今の自分のユースケースの殆どは、文字列化されたオブジェクトに対して正規表現でフィルタできたら、それで済んでしまうのがわかった。&lt;code&gt;Where-Object&lt;/code&gt; でフィルタするタイミングを、実行してデータがわかったその時まで遅延させる、そんな使い方しかしてない。
だから今の pocof はほんとにそれを満たすだけのミニマルさになってて、欲を言えばツールが使用者に違った視点を与えるとかのフィードバックするとか、そいういうモノがないんやなと改めて感じている。&lt;/p&gt;&lt;p&gt;例えば、 poco の頃にあったスペース区切りで複数の and filter できる機能は pocof にはない。自分が使ってこなかったから作ってなかった。
でもプロパティ指定の検索をするとしたら、これは絶対に使いたい。 1 つのプロパティで絞り込んだとて満足な結果を得られることはないだろう。なんならこれらの複数のプロパティの絞り込みは and だけじゃなくて or でも結合させたい場面が出てくるだろう。
他にも、いま正規表現で &lt;code&gt;.+dir/*+.js&lt;/code&gt; とか書いてるのもスペース区切りで置き換えて &lt;code&gt;dir js&lt;/code&gt; でできたらタイプ数も減って楽でいいよなとか。(正規表現は正規表現で使ったらいいけどほとんどはもっと少ないルールに従ってフィルタできるであろうから)。
こんな感じで、ある 1 つの使い方から芋づる的に派生していく。
確信はないけど、こういった派生が自分の普段の使い方に変化をもたらす気配がしてる。&lt;/p&gt;&lt;p&gt;とりあえずこの複数のフィルタは composite query と(若干中二病的に)名付けて Issue を起こした。&lt;a href="https://github.com/krymtkts/pocof/issues/9"&gt;Support composite query · Issue #9 · krymtkts/pocof&lt;/a&gt;
やることのイメージが膨れ上がりそうやし、プロパティ指定の検索に必要な最低限を細かく刻んで機能を追加して、その後の成長はまた別に考えるのが良さそうかと考えている。&lt;/p&gt;&lt;p&gt;はじめに述べたプロパティ指定の検索も、この「普段の使い方に変化をもたらす」気配がしてる。
例えば、わたしは仕事が AWS のリソースを探るのによく使う AWS Tools for PowerShell 。
Cmdlet の出力をフィルタするのやプロパティの確認なんかで、何度か結果を出力したり変数に格納したり、ステップを踏むことが多い。
でもこれが pocof のインタラクティブな検索で試行錯誤できるようになれば、何度もコマンドを実行しなくても粘土をこねるみたいに try &amp;amp; error しやすくなったりしないかな？とか。
選択したプロパティが列になって検索結果に表示されることでわかりやすさが向上しそうだな、とか。&lt;/p&gt;&lt;p&gt;個人開発では主にゴミスクリプトしか書かないのもあって、改めて自分用のツールを育てる面白さがわかりだした。
個人的な嗜好として、あまり長く同じやり方を続けることを良しとしないのだけど、自分で自分のツールを開発するのってコレとめちゃくちゃ相性良いのでは？と最近思ったりしてる。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;全然関係ないけど .NET 7 出たし、 pocof もさっさと乗り換えてしまのが良さそう(今 .NET 6)。 prerelease なので気兼ねなくやれる。 .NET 7 対応した PowerShell 7.3 かなり速くなった気がするのよな(気だけ？)。その恩恵にあやかりたい。&lt;/p&gt;</description><pubDate>Sun, 20 Nov 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-11-12-clean-up-pwsh-modules</guid><link>https://krymtkts.github.io/posts/2022-11-12-clean-up-pwsh-modules</link><title>師走に向けて PowerShell モジュールの大掃除</title><description>&lt;p&gt;PowerShell あるあるなのだけど、過去のモジュールが溜まってしまって自分で掃除しないといけない。
開発中でもない限りモジュールを切り戻することもないので、一気に消す。これが PowerFighter(勝手に作った PowerShell 使いの呼び名)の嗜み。&lt;/p&gt;&lt;p&gt;ゆーてもこしらえてあるスクリプトを流すだけ。以下の通り。個人的に &lt;code&gt;-Scope AllUsers&lt;/code&gt; でモジュールを入れてるからそれに合わせた形となっている。
簡単のため改行を入れている。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# $PSGetPath.AllUsersModules をロードするために一度流す。
Get-InstalledModule
# Uninstall 対象の取り方。 AllUser 向けに入れてる場合。
Get-Module -ListAvailable | Where-Object -Property Path -Like "$($PSGetPath.AllUsersModules)*" `
| Group-Object -Property Name | Where-Object -Property Count -GT 1 `
| ForEach-Object { $_.Group | Sort-Object -Descending -Property Version | Select-Object -Skip 1 } `
| ForEach-Object { [pscustomobject]@{
        Name = $_.Name;
        RequiredVersion = "$($_.Version)$(if ($_.PrivateData.Values.PreRelease) {'-'+$_.PrivateData.Values.PreRelease} else {''})"
    } }

# 心配なときは以下の出力の最新バージョンが Hit してないことを目検する。
# Get-Module -ListAvailable | ? -Property Path -like "$($PSGetPath.AllUsersModules)*"

# エグゼキューション。
# はじめは -WhatIf アリで流し、処理する時心配なら Confirm で一個ずつ確認する。
Get-Module -ListAvailable | Where-Object -Property Path -Like "$($PSGetPath.AllUsersModules)*" `
| Group-Object -Property Name | Where-Object -Property Count -GT 1 `
| ForEach-Object { $_.Group | Sort-Object -Descending -Property Version | Select-Object -Skip 1 } `
| ForEach-Object { [pscustomobject]@{
        Name = $_.Name
        RequiredVersion = "$($_.Version)$(if ($_.PrivateData.Values.PreRelease) {'-'+$_.PrivateData.Values.PreRelease} else {''})"
    } } | Uninstall-Module -AllowPrerelease
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;prerelease なモジュールの削除も一緒に含めるため、ごちゃごちゃしている。
&lt;code&gt;-Version&lt;/code&gt; の指定を楽にする場合は &lt;code&gt;Get-InstalledModule&lt;/code&gt; を使ったらいいけど、モジュールごとに実行すると遅いし...と思って使ってない。&lt;/p&gt;&lt;p&gt;これで消しきれるかなと思ったけど、依存関係を忘れてたことでいくつかエラーをもらった。 2 周したらきれいになるかなと思いきや、以下のモジュールに関しては消しきれなかった。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Metadata&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;PackageManagement&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;PowerShellGet&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;これらは &lt;code&gt;AWS.Tools.Installer&lt;/code&gt; と &lt;code&gt;PowerShellGet&lt;/code&gt; が依存しており消せないとのこと。
先述のスクリプトでは最新版は確保するようになってあるし、壊れても入れ直したらいから、古いものに関してはやや強引に &lt;code&gt;-Force&lt;/code&gt; を付与して消し去る。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Get-Module -ListAvailable | Where-Object -Property Path -Like "$($PSGetPath.AllUsersModules)*" `
| Group-Object -Property Name | Where-Object -Property Count -GT 1 `
| ForEach-Object { $_.Group | Sort-Object -Descending -Property Version | Select-Object -Skip 1 } `
| ForEach-Object { [pscustomobject]@{
        Name = $_.Name
        RequiredVersion = "$($_.Version)$(if ($_.PrivateData.Values.PreRelease) {'-'+$_.PrivateData.Values.PreRelease} else {''})"
    } } | Uninstall-Module -AllowPrerelease -Force
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;この如何にも PowerFighter な近距離パワー型アプローチ、まさに PowerShell って感じ(いいたいだけ)。
穢れたモジュールフォルダを綺麗にできた。&lt;/p&gt;</description><pubDate>Sat, 12 Nov 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-11-06-publish-psjobcanattendance</guid><link>https://krymtkts.github.io/posts/2022-11-06-publish-psjobcanattendance</link><title>PSJobCanAttendance の公開</title><description>&lt;p&gt;自分が使う機能はおおよそできたので、 &lt;a href="https://github.com/krymtkts/PSJobCanAttendance"&gt;krymtkts/PSJobCanAttendance&lt;/a&gt; を PowerShell Gallery に公開した。&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.powershellgallery.com/packages/PSJobCanAttendance/1.0.1"&gt;PowerShell Gallery | PSJobCanAttendance 1.0.1&lt;/a&gt;&lt;/p&gt;&lt;p&gt;デバッグプリント仕込んだまま publish してしまって速攻パッチが上がっている。これ過去に何度かやらかしたので防ぎたいけど防げてない。横着せずにログレベルちゃんと使ってやれよというところか...&lt;/p&gt;&lt;p&gt;公開のために、&lt;a href="/posts/2022-10-30-prepare-to-publish-psjobcanattendance"&gt;前回見つけた&lt;/a&gt; 勤怠の実績を一覧する機能のバグを修正した。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;休暇があると日付と実績がずれる&lt;/li&gt;&lt;li&gt;最終日の実績が欠落する&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;休暇の実績を含めるようになったので、稼働していない日もひと目で分かる。&lt;/p&gt;&lt;p&gt;動作確認を行うにあたり、指定した月の勤怠の実績を出力できる必要があったため、それも実装した。
ついでにパイプラインからパラメータを受けるようにしたことで、複数月の勤務実績を取得するのも容易だ。しかも期間が連続していない実績を引っこ抜くことができる。この挙動、画面ではできないはず(使い道が思い浮かばんけど)。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# 何故か 8 月を飛ばして 7,9 月の実績を一覧するムーブ
7,9 | % {Get-Date -Month $_} | Get-JobCanAttendance
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ただいまこれ書いてて、休日出勤の実績がある場合にちゃんと一覧できるかな？と思いついたので動作確認してみる必要がありそう。ダメそうなら Issue 行き。&lt;/p&gt;&lt;h3 id="今後やること"&gt;今後やること&lt;/h3&gt;&lt;p&gt;勤怠管理サービスを CLI で処理できるようにするの、非公開のものも含めたらこれで 3 個目になった。
私的用途だと、大抵の勤怠管理で以下の機能を作ってきた。自動打刻は作れるが作らないのが良心。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;出退勤のリアルタイム打刻&lt;/li&gt;&lt;li&gt;事後の打刻(編集機能)&lt;/li&gt;&lt;li&gt;実績の一覧&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;今回のケースでいうと、あとコレができたらいいなーというのに以下がある。いずれもジョブカン勤怠管理ローカルな使い勝手を改善するものだ。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;グループが 1 つの場合に group_id の入力を省略できるようにする&lt;/li&gt;&lt;li&gt;実績の削除&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;まず 1 からできたらいい。 大抵の場合入力パラメータを減らせるから、楽さが増す。
2 は画面での編集が面倒でなければ普段作らないのだけど、今回のケースではほしいかなと思っている。理想はインタラクティブに削除対象を選べるようにしたいけど、まずは指定のパラメータで消すとこからやるか。&lt;/p&gt;&lt;p&gt;あと krymtkts/PSJobCanAttendance 自体 &lt;a href="https://github.com/krymtkts/PSMFAttendance"&gt;krymtkts/PSMFAttendance&lt;/a&gt; のコピペで作ったのもあって、今見るとなんか至らないイマイチな箇所がチラホラある。
それらを直したい気持ちもあるが、直したとて勤怠入力体験が良くなるわけでもないので、あんま動機づけにならない。&lt;/p&gt;&lt;p&gt;個人的には、 &lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の方をいじれてないから、さっさと勤怠スクリプトは終えてしまいたい。でも、やり始めたら気になって止めにくいのもあって止まらない状態が続いてる。要は惰性だ。
なのでリストアップしたものの、やる気がわかない場合はやらないかも...これぞ趣味プロの醍醐味(しらんけど)。&lt;/p&gt;</description><pubDate>Sun, 06 Nov 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-10-30-prepare-to-publish-psjobcanattendance</guid><link>https://krymtkts.github.io/posts/2022-10-30-prepare-to-publish-psjobcanattendance</link><title>PSJobCanAttendance の公開準備</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/PSJobCanAttendance"&gt;krymtkts/PSJobCanAttendance&lt;/a&gt; を PowerShell Gallery に公開する準備をしている。
一括編集機能に若干の改善をした。&lt;/p&gt;&lt;p&gt;従来は、パイプラインを使った一括編集が可能だったが、出勤とか退勤とかの打刻イベント毎にパイプを分ける必要があった。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# 従来はこんなん
@(12..16;20..22) | %{get-date "2022-09-$($_) 08:15:00+0900"} | Edit-JobCanAttendance -TimeRecordEvent work_start -AditGroupId 10
@(12..16;20..22) | %{get-date "2022-09-$($_) 12:00:00+0900"} | Edit-JobCanAttendance -TimeRecordEvent rest_start -AditGroupId 10
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これ自分で使ってみて結構面倒に感じて、時刻と打刻イベントをパイプラインで渡せるように調整した。
この調整により、 1 ヶ月分の出勤・休憩の開始＆終了を一気に登録できる様になってしまった。怠惰が捗る(打刻を必要とする勤怠管理なのは触れてはならない)。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# 1 ~ 31 日の間で 7 日、 10 日、土日を除いた日に出勤と休憩開始・終了を一括登録する。
1..31 | ? {$_ -notin 7,10 } | % {get-date -Day $_} | ? -Property DayOfWeek -notin 0,6 | % {
    [PSCustomObject]@{
        TimeRecordEvent='work_start'
        RecordTime= Get-Date -Date $_ -Hour 8 -Minute 15 -Second 0
    }
    [PSCustomObject]@{
        TimeRecordEvent='rest_start'
        RecordTime= Get-Date -Date $_ -Hour 12 -Minute 0 -Second 0
    }
    [PSCustomObject]@{
        TimeRecordEvent='rest_end'
        RecordTime= Get-Date -Date $_ -Hour 13 -Minute 0 -Second 0
    }
} | Edit-JobCanAttendance -AditGroupId 10 -Verbose​
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これには &lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.management.automation.parameterattribute.valuefrompipelinebypropertyname?view=powershellsdk-1.1.0"&gt;ValueFromPipelineByPropertyName&lt;/a&gt; を使った。
Cmdlet のパラメータにパイプラインの入力オブジェクト(&lt;code&gt;hashtable&lt;/code&gt; は No)が持つ同名プロパティをマッピングできるので、複数のパラメータをバインドできる。
これ自分の書いた Cmdlet で使うことなかったので、いい勉強になった。&lt;/p&gt;&lt;p&gt;その後 PSScriptAnalyzer の指摘を修正して、さて公開しよう、というところで登録済みの勤怠を一覧するところにバグが見つかった。
登録した日と勤怠の実績がずれるバグで、これは直したいな～というやつなので、公開はまた先送り・未遂に終わった。&lt;/p&gt;&lt;p&gt;続く。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;あと別の文脈で、放置していた&lt;a href="https://github.com/krymtkts/PSMFAttendance"&gt;krymtkts/PSMFAttendance&lt;/a&gt;にメンテの予定がないよとアナウンスを追記した。これで Archive する準備も整った(まだしてない)。&lt;/p&gt;&lt;p&gt;これまた別の文脈で、現職では Slack に日報を投稿してから退勤するようにしてるので、そこから投稿時間を拾って退勤実績を作るようにしたいと考えている。
そのために Slack からメッセージの一覧を取得し、 PSJobCanAttendance での一括編集にもっていきたい。&lt;/p&gt;&lt;p&gt;過去に似たようなことをしたとき、 &lt;a href="https://github.com/RamblingCookieMonster/PSSlack"&gt;RamblingCookieMonster/PSSlack&lt;/a&gt; を使った。
しかし PSSlack は 2021 年頃の Slack API の変更に追いついてないので、使うには自力でパッチする必要がある。
(パッチは来てるが適用されていない &lt;a href="https://github.com/RamblingCookieMonster/PSSlack/pull/115"&gt;Fix API deprecation 2021-02-24 by simonfagerholm · Pull Request #115 · RamblingCookieMonster/PSSlack&lt;/a&gt;)。&lt;/p&gt;&lt;p&gt;以前使った時はそうしたが、面倒なので .NET の Slack のモジュールとか探してなんとかしたい。
でも、どのモジュールがいいんか...と調べるのも面倒なので、悩み中。&lt;/p&gt;</description><pubDate>Sun, 30 Oct 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-10-23-cleaning-my-pwsh-profile</guid><link>https://krymtkts.github.io/posts/2022-10-23-cleaning-my-pwsh-profile</link><title>PowerShell の My Profile を掃除する</title><description>&lt;p&gt;PowerShell の profile を Gist で管理してるのだけど、この度掃除をした。&lt;/p&gt;&lt;p&gt;&lt;a href="https://gist.github.com/krymtkts/f8af667c32b16fc28a815243b316c5be"&gt;My PowerShell profile.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;片手間にできる範囲しかやらなかったので、使ってないモジュールと関数の取り除きが主。あとは順番をちょっと入れ替えてみたり、把握してなかった全貌を眺めてみた。&lt;/p&gt;&lt;p&gt;これらの取り除きついでに、供養がてら何のためにつかってたのかとか振り返ってみる。&lt;/p&gt;&lt;h3 id="モジュール取り除き"&gt;モジュール取り除き&lt;/h3&gt;&lt;p&gt;&lt;a href="https://github.com/mklement0/ClipboardText"&gt;mklement0/ClipboardText: Universal clipboard text support for PowerShell, notably also in PowerShell Core (cross-platform) and Windows PowerShell v2-v4&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.powershellgallery.com/packages/ClipboardText/0.1.8"&gt;ClipboardText&lt;/a&gt; というモジュール。コレなんで使ってたのかすら忘れてしまったけど、結構使ってた記憶がある。
&lt;code&gt;Set-ClipboardText&lt;/code&gt; &lt;code&gt;Get-ClipboardText&lt;/code&gt; が使えるようになる。
PowerShell Core を使い始めた頃はクリップボード操作の Cmdlet がなくてできなかったとかそんな理由だったか？&lt;/p&gt;&lt;p&gt;今やフツーに &lt;code&gt;Set-Clipboard&lt;/code&gt; &lt;code&gt;Get-Clipboard&lt;/code&gt; 使ってるので不要になったけどずっと消してなかった。今までありがとう、消した。&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.powershellgallery.com/packages/poco/1.1.0"&gt;poco&lt;/a&gt;も残ってるかな？と思ったが、そうでもなかった。
(変え漏れを除けば)意外にも &lt;a href="https://www.powershellgallery.com/packages/pocof/0.2.0-alpha"&gt;pocof&lt;/a&gt; への変更は忘れてなかったらしい。&lt;/p&gt;&lt;p&gt;あとモジュールは跡形もなかったが、昔 &lt;a href="https://www.powershellgallery.com/packages/GoogleCloud/1.0.1.10"&gt;GoogleCloud&lt;/a&gt; を使って勉強してたときの名残があったのでそれも消した。
このモジュールもう 4 年くらいメンテされてない様子、残念やけど多分重要でないんだろうな。&lt;/p&gt;&lt;h3 id="関数取り除き"&gt;関数取り除き&lt;/h3&gt;&lt;h4 id="明らかな消し忘れ-virtualbox-関連"&gt;明らかな消し忘れ。 VirtualBox 関連&lt;/h4&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function Start-VBoxMachine() {
    vboxmanage list vms | Select-Pocof -CaseSensitive | Out-String -Stream | Select-String -Pattern '\{(.+)\}' | ForEach-Object { vboxmanage startvm ($_.Matches[0].Groups['1'].Value) --type headless }
}

function Stop-VBoxMachine() {
    vboxmanage list runningvms | Select-Pocof -CaseSensitive | Out-String -Stream | Select-String -Pattern '\{(.+)\}' | ForEach-Object { vboxmanage controlvm ($_.Matches[0].Groups['1'].Value) poweroff }
}

function Get-RunningVBoxMachines() {
    vboxmanage list runningvms
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;こんなのがあった。VirtualBox の GUI を介さずに VM の起動・停止をするための奴らだったか確か。
前々職でコンテナ移行しきれてない秘伝の開発環境 VM がチラホラあって、それで使ってた記憶がある。あの VM ちゃん達は今も元気に VM してるのだろうか。
もはや使うこともないので消す。でも供養がてら Gist に残しておいた。&lt;/p&gt;&lt;p&gt;&lt;a href="https://gist.github.com/krymtkts/47f70697cbe006e81d7fd801e1e3b351"&gt;krymtkts/scripts-for-virtualbox.ps1&lt;/a&gt;&lt;/p&gt;&lt;h4 id="なんだコレ-find-ぽいやつ"&gt;なんだコレ。 &lt;code&gt;find&lt;/code&gt; ぽい？やつ&lt;/h4&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function find {
    [CmdletBinding()]
    param(
        [string]$path = '.',
        [Parameter(Mandatory = $True,
            ValueFromPipeline = $True)]
        [string[]]$name,
        [switch]$delete
    )

    begin {
    }

    process {
        foreach ($n in $Name) {
            if ($delete) {
                Get-ChildItem -Recurse -Path $path | Where-Object -Property Name -Like $n | Remove-Item
            }
            else {
                Get-ChildItem -Recurse -Path $path | Where-Object -Property Name -Like $n
            }
        }
    }

    end {
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;なんか薄っすらと、 &lt;code&gt;Makefile&lt;/code&gt; から &lt;code&gt;find&lt;/code&gt; 呼ぶときに何のシェルか考えるの面倒で PowerShell で &lt;code&gt;find&lt;/code&gt; 作ろうとしてた覚えがあるのだけど、それをいつやってたのかわからない。いま使ってもないのでなんでここにあるのか不明。
消す。&lt;/p&gt;&lt;h4 id="何故-profile-に足したクソデカテキストファイルを作る関数"&gt;何故 profile に足した？クソデカテキストファイルを作る関数&lt;/h4&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function New-TextFile {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        [string]
        $Name,
        [Parameter()]
        [long]
        $Byte = [Math]::Pow(1024, 3),
        [Parameter()]
        [int]
        $Basis = [Math]::Pow(1024, 2)
    )
    begin {
        if (Test-Path $Name) {
            Write-Error 'overrides currently not supported.'
            return
        }
        $Remains = $Byte % $Basis
        $Per = $Byte / $Basis
    }
    process {
        1..$Per | ForEach-Object { 'x' * $Basis | Add-Content $Name -Encoding ascii -NoNewline }
        if ($Remains -ne 0) {
            'x' * $Remains | Add-Content $Name -Encoding ascii -NoNewline
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;前に書いた &lt;a href="/posts/2022-03-13-create-huge-text-file-in-pwsh"&gt;PowerShell でクソデカテキストファイルを作る&lt;/a&gt; の関数版だと思われる。
わざわざ profile に入れておいたのはなんでだろう。スクリプトにするだけで良いのでは...過去の自分に問いたい。消した。&lt;/p&gt;&lt;h4 id="psake-の-auto-completer-壊れてるで"&gt;&lt;code&gt;psake&lt;/code&gt; の auto completer 壊れてるで...&lt;/h4&gt;&lt;p&gt;あと今回の掃除を通して &lt;code&gt;psake&lt;/code&gt; の auto completer 壊れてるやんと言うのに気づいたので、直した。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Invoke-psake&lt;/code&gt; の存在チェックをしてあったら &lt;code&gt;Register-ArgumentCompleter&lt;/code&gt; するようにしてた。
けど、どっかのタイミングから &lt;code&gt;invoke-psake&lt;/code&gt; が &lt;code&gt;invoke-cpsake&lt;/code&gt; になってて、 auto completer が登録されなくなってた。&lt;/p&gt;&lt;p&gt;auto completer 周り、 &lt;code&gt;aws_completer&lt;/code&gt; で &lt;code&gt;Register-ArgumentCompleter&lt;/code&gt; 設定するとこも、 AWS CLI 1 の頃から使ってたのもあり AWS CLI 2 では要らなくなった部分がある(良くないけど PyPI からモジュール取ってたときの名残)。
今回は対応を先送りにした。&lt;/p&gt;&lt;h3 id="おわり"&gt;おわり&lt;/h3&gt;&lt;p&gt;そこまで消すものなかったな、というのが率直な感想だが、掃除してないな～という profile だった。&lt;/p&gt;&lt;p&gt;コマンドの存在をチェックしてから関数とか auto completer 登録するみたいなの増えてるので、この辺共通化したいなあ。
でも共通化しだすとファイル分割もしたくなり、結局のところ今の Gist から取ってくるの終焉に向かうのでは...と思った。&lt;/p&gt;&lt;p&gt;なんかより良い(楽な) PowerShell の Profile 管理手段ないかなー。&lt;/p&gt;</description><pubDate>Sun, 23 Oct 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-10-16-writing-cmdlet-in-fsharp-pt6</guid><link>https://krymtkts.github.io/posts/2022-10-16-writing-cmdlet-in-fsharp-pt6</link><title>F#でコマンドレットを書いてる pt.6</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。&lt;/p&gt;&lt;p&gt;&lt;code&gt;hashtable&lt;/code&gt; サポートした。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;やはり &lt;code&gt;IDictionary&lt;/code&gt; 実装用に特別処理みたいなのを書いてあげないといけないかなーという気が若干してる。コイツ以外にも色々出てきたら面倒なので気が向かないけど、特別扱いなのはたしかにそうなので。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;前回コメントしていた実装方針にした。先のことはわからないので、いま想定できない未来は未来の自分に託す。&lt;/p&gt;&lt;p&gt;これによって &lt;code&gt;pocof&lt;/code&gt; は &lt;code&gt;hashtable&lt;/code&gt; のエントリをフィルタできるようになった。 クエリは &lt;code&gt;hashtable&lt;/code&gt; の &lt;code&gt;Key&lt;/code&gt; / &lt;code&gt;Value&lt;/code&gt; それぞれに適用される。こんな感じ ↓。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;@{a='1';b='2';c='3';d='a1';e='b2'} | pocof -NonInteractive -Query a

# Name                           Value
# ----                           -----
# a                              1
# d                              a1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ただしフィルタして得られる値は &lt;code&gt;hashtable&lt;/code&gt; ではなく、 &lt;code&gt;Object[]&lt;/code&gt; (中身は &lt;code&gt;System.Collections.DictionaryEntry&lt;/code&gt;) になる。
一瞬 &lt;code&gt;hashtable&lt;/code&gt; に戻したいかな～と思ったが、色々使い道を模索しているときに以下のようなおもしろ利用法あるとわかったので、そのケースで不都合ありそうでやめた。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# 十把一絡げ
$misc = @(Get-Date; @{a=1;b=2;c=3}; (10..15))

# Sunday, 16 October, 2022 15:25:19
#
# Key   : c
# Value : 3
# Name  : c
#
#
# Key   : b
# Value : 2
# Name  : b
#
#
# Key   : a
# Value : 1
# Name  : a
#
# 10
# 11
# 12
# 13
# 14
# 15

$misc | pocof -NonInteractive -Query 15

# Sunday, 16 October, 2022 15:25:19
# 15
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因みにこういったケースの活用方法はまだ見出していない。ただなんかこのファジーな検索あると面白そうなので残している。例えば、色んなものを array に詰め込んでおいて後でから見ようってアプローチとかになるんではないかと。
仕事の製品コードにこういうの見つけたら卒倒しそうやけど、自分が terminal でなんかデータを捏ねくり回すときにあったら、新たな世界が開けるのでは？的な。しらんけど。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/PowerShell/GraphicalTools"&gt;&lt;code&gt;Out-ConsoleGridView&lt;/code&gt;&lt;/a&gt; はこういう事できなくて、同じ型が揃ってないとエラーになる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$misc | Out-ConsoleGridView
# Out-ConsoleGridView: Object reference not set to an instance of an object.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/where-object?view=powershell-7.2"&gt;&lt;code&gt;Where-Object&lt;/code&gt;&lt;/a&gt; は流石懐が深くて、 &lt;code&gt;-FilterScript&lt;/code&gt; を使えば同様のことができる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$misc | ? {$_ -match 15}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ひとまず &lt;code&gt;hashtable&lt;/code&gt; サポートも終えたので、 プロパティ指定でフィルタする機能を実装する気持ちが高まってきてる。
だけど、このファジーなフィルタの発見によって、フィルタ対象の array に登場する型をチェックしてプロパティを得て...みたいなことが必要になり、面倒さが増した。&lt;/p&gt;&lt;p&gt;率直に言ってコレだるいｗのだけど、こういう楽しみって趣味プロならではの醍醐味じゃないかな。第一ユーザが自分なので、自分が納得できないモノは許容し難いのよな。&lt;/p&gt;&lt;p&gt;まだまだゆるく長く楽しめそうな気配がしていて、良い。&lt;/p&gt;</description><pubDate>Sun, 16 Oct 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-10-09-replace-battery-of-razer-stealth</guid><link>https://krymtkts.github.io/posts/2022-10-09-replace-battery-of-razer-stealth</link><title>Razer Blade Stealth 13 (2017)のバッテリーを換装する</title><description>&lt;p&gt;My Laptop は Razer Blade Stealth 13 2017 モデルなのだが、流石に経年劣化が目立つようになってきた。
バッテリーの膨張だ。&lt;/p&gt;&lt;p&gt;Razer Blade Stealth 13 は美しいアルミ削り出しボティなのだけど、ここ 1 年くらいは底面が何か弧を描いてんな～と感じていたものの、実用上支障がなかったので放置していた。
ところが、夏を過ぎた頃になって蓋を締めたときにピッチリ閉まらなくなってきて「あ、これはヤバイな」と感じた。
早急に交換が必要だと(あんま放置すると筐体の歪みが戻らなくなる)。&lt;/p&gt;&lt;p&gt;もう 4,5 年ものなので CPU の遅さや RAM の少なさ(16GB)も目立つといえば目立つのだけど、 PC のスタートアップやソフトウェアのアップデートに時間がかかる以外ではまだ開発したりゲームする上で対して不満はない状態(仕事だとイライラしそうだが)なので、&lt;del&gt;円安世界で不要な出費を抑えるためにも&lt;/del&gt;バッテリーを交換して長く使おうと考えた。&lt;/p&gt;&lt;p&gt;参考にした記事 →&lt;a href="https://neareal.com/3353/"&gt;RazerBlade のバッテリーを換装する – NEAREAL&lt;/a&gt;&lt;/p&gt;&lt;p&gt;ホントのところは iFixit のリペアキット込み込みバッテリが欲しかったのだけど、おま国で購入できなかった(結果無駄にアカウントだけ作ってしまった)。&lt;/p&gt;&lt;p&gt;なもんで Razer Blade Stealth 13 2017 モデルの型番を Amazon.co.jp で調べて、交換バッテリーをサクッと見つけた。何個もあったので一番安いのを選ぶ。
&lt;a href="https://www.amazon.co.jp/gp/product/B0B6139PBJ"&gt;購入したバッテリ&lt;/a&gt;&lt;/p&gt;&lt;p&gt;この判断が良くなかったのか、発送から到着まで 1 ヶ月以上かかった。「コロナ禍の影響で香港で物流が滞っている」と聞いたけど果たして...&lt;/p&gt;&lt;p&gt;正規バッテリじゃないみたいなので心配といえば心配だったけど、届いた品を見たら &lt;strong&gt;デル(株)&lt;/strong&gt; て書いてたし、 PSE マークもあった。でも &lt;code&gt;㈱&lt;/code&gt; の印字がみょーにずれてる。やっぱ模造品かな。&lt;/p&gt;&lt;p&gt;このバッテリ到着までの長い待ち時間の間にもどんどん膨らみ続け(最近特に酷かった)、タッチパッドのところが一目でわかるくらいに弧を描くようになった。もう限界や...というところで先日バッテリが届いたのでようやく換装に着手できた。&lt;/p&gt;&lt;h3 id="換装する"&gt;換装する&lt;/h3&gt;&lt;p&gt;換装で触った範囲、バックパネルとバッテリの固定には 3 種類のネジが使われており、それぞれに対応するドライバが必要だった。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;バックパネル
&lt;ul&gt;&lt;li&gt;トルクス T6 x 8 箇所&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;バッテリ
&lt;ul&gt;&lt;li&gt;プラス #1 x 6 箇所&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;バッテリコネクタの蓋
&lt;ul&gt;&lt;li&gt;プラス #0 x 2 箇所&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;バックパネルのネジを外すと自然とバックパネルが浮き上がった。かなりのエネルギーが抑圧されていたらしい。恐ろしすぎる。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2022-10-09-laptop/floating-back-panel.jpg" alt="自動的に浮かび上がるバックパネル" /&gt;&lt;/p&gt;&lt;p&gt;先程 &lt;strong&gt;バッテリコネクタの蓋&lt;/strong&gt;と書いたけど、バッテリのコネクタを覆うようにプラ板がついてた。恐らく外れないようにするための固定器具だが、コイツが後で困る。&lt;/p&gt;&lt;p&gt;バッテリはめてみたら 1 箇所だけ 0.3 mm ほどネジ穴とずれてしまってバッチリはまらなかった。仕方ないのでその一箇所だけ無理やりネジ込んだ。&lt;/p&gt;&lt;p&gt;そしてバッテリのコネクタ、フラットケーブルが長過ぎる...折りたたまないと接続できない。ここで先程のバッテリコネクタの蓋が組み合わさり、うまくはめるためにピンセットで絶妙な畳み込みをする必要があった。&lt;/p&gt;&lt;p&gt;以下の写真で波打つフラットケーブルとビミョーにずれた &lt;code&gt;㈱&lt;/code&gt; が確認できる。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2022-10-09-laptop/waving-flat-cable.jpg" alt="長過ぎて接続すると波打つフラットケーブル" /&gt;&lt;/p&gt;&lt;p&gt;バッテリコネクタの蓋の隙間に畳み込まれたフラットケーブル。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2022-10-09-laptop/convoluted-flat-cable.jpg" alt="バッテリコネクタの蓋の隙間にねじ込まれるフラットケーブル" /&gt;&lt;/p&gt;&lt;p&gt;バッテリの新旧を見比べてみる。古い方(下)からははち切れんばかりのエネルギーを感じる。ほんまに危なっかしいな。爆発する前に新バッテリが届いてほんと良かった。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2022-10-09-laptop/before-after.jpg" alt="スマートな新バッテリ(上)とダイナマイトな旧バッテリ(下)" /&gt;&lt;/p&gt;&lt;h3 id="換装後"&gt;換装後&lt;/h3&gt;&lt;p&gt;換装前後で明らかに差を感じられる。異様に熱くならなくなってファンが回らなくなった。&lt;/p&gt;&lt;p&gt;ただ &lt;code&gt;powercfg.exe /BATTERYREPORT&lt;/code&gt; でバッテリ容量が取れない。 これってどうやったら解消されるんだろう？バッテリ残容量も 100% を指しててホンマか？というお気持ち。&lt;/p&gt;&lt;p&gt;&lt;code&gt;powercfg.exe /ENERGY&lt;/code&gt; したらバッテリの容量が取れないというエラーになった。&lt;/p&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;Battery:Battery Capacity Unknown
The battery capacity could not be determined. This may indicate a firmware (BIOS) problem.
Battery ID	RazerRazer Blade Stealth
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;バッテリ容量わからないと残容量もわからないのでは？再起動したら認識されるときもあって、その時は 41% だった。Razer Blade Stealth はバッテリ容量が少ないと赤いランプが灯るのだが、そこも真っ赤っ赤。試しに置きっぱなしにしてたら電力不足でシャットダウンしてた。&lt;/p&gt;&lt;p&gt;どうしたもんかと調査してみたところ、バッテリ交換後は使い切る → フル充電を数回繰り返すと良い、というような情報があったので参考にして 12,3 時間充電してみた。&lt;/p&gt;&lt;p&gt;よく見たら Amazon のバッテリのページにも同じようなことが書いてた。不自然な日本語でわからなかった。無理に日本語にせず英語にでもしたらいいのに。充電の部分がすっぱり抜けてて当初わからなかった。以下引用&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;''' 1.新しいバッテリを正常に使用する前に、容量を 10%程度に放電してからサイクルを 3 ～ 4 回満たしてください。0%まで放電しないように注意してください。そうすると、バッテリが壊れやすくなります。
'''&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;充電後、今朝改めて &lt;code&gt;powercfg.exe /BATTERYREPORT&lt;/code&gt; してみたところ、 98% 48,949 mWh まで表示されるようになった。規格は 53.6Wh なのでまだまだ上まで充電されるのかな。
&lt;code&gt;powercfg.exe /ENERGY&lt;/code&gt; のバッテリ容量のエラーも解消された。
あと何度か繰り返してみて状況見てみるつもり。&lt;/p&gt;&lt;p&gt;正直なところ筐体が歪んでしまったかもな～と思っていたが、換装後はバッチリ元の平坦さを取り戻せた。たとえ模造品であろうと今のところは満足度が高い。
放電充電繰り返して規格 MAX まで充電されるまでちょっと様子見。&lt;/p&gt;</description><pubDate>Sun, 09 Oct 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-10-02-writing-cmdlet-in-fsharp-pt5</guid><link>https://krymtkts.github.io/posts/2022-10-02-writing-cmdlet-in-fsharp-pt5</link><title>F#でコマンドレットを書いてる pt.5</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。ほぼ実装におけるメモ、壁打ち。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/PowerShell/GraphicalTools"&gt;Out-ConsoleGridView&lt;/a&gt;を見て &lt;code&gt;hashtable&lt;/code&gt; をフィルタできるのいいな～と思ったので、 &lt;code&gt;hashtable&lt;/code&gt; サポートを始めている。誰得な機能ではあれど、これがあると自分にとって利用の幅が広がる。&lt;/p&gt;&lt;p&gt;&lt;code&gt;ProcessRecord&lt;/code&gt; メソッドにおいて、 &lt;code&gt;IDictionary&lt;/code&gt; 実装の場合のみ展開した要素を内部で保持するようにしてみた。一見して煩雑なので、なんかマシにしたい。 &lt;code&gt;list&lt;/code&gt; にして &lt;code&gt;list&lt;/code&gt; 外すあたりがどーにも。&lt;/p&gt;&lt;pre&gt;&lt;code class="diff"&gt;     override __.ProcessRecord() =
-        input &amp;lt;- List.append input &amp;lt;| List.ofArray __.InputObject
+        let entries: list&amp;lt;obj&amp;gt; =
+            List.ofArray __.InputObject
+            |&amp;gt; List.collect (fun (o: PSObject) -&amp;gt;
+                match o.BaseObject with
+                | :? IDictionary as dct -&amp;gt;
+                    Seq.cast&amp;lt;DictionaryEntry&amp;gt; dct
+                    |&amp;gt; Seq.cast&amp;lt;obj&amp;gt;
+                    |&amp;gt; Seq.toList
+                | _ as o -&amp;gt; [ o ])
+
+        input &amp;lt;- List.append input entries
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;破壊的な操作ならすぐマシなのが思いつくが、ちょっと寝かせる。とはいえそっちでスッキリするならそっちがいいかな。
いや待て、ここまで書いて &lt;code&gt;fold&lt;/code&gt; の方がスッキリする気が...してきたので後でやってみる。&lt;/p&gt;&lt;h3 id="追記2022-10-03"&gt;追記(2022-10-03)&lt;/h3&gt;&lt;p&gt;要らんコードも取り除いてこうした。幾分マシかなあ。&lt;/p&gt;&lt;pre&gt;&lt;code class="diff"&gt;     override __.ProcessRecord() =
-        input &amp;lt;- List.append input &amp;lt;| List.ofArray __.InputObject
+        input &amp;lt;-
+            List.ofArray __.InputObject
+            |&amp;gt; List.fold
+                (fun acc o -&amp;gt;
+                    match o.BaseObject with
+                    | :? IDictionary as dct -&amp;gt;
+                        Seq.cast&amp;lt;obj&amp;gt; dct
+                        |&amp;gt; Seq.fold (fun a d -&amp;gt; d :: a) acc
+                    | _ as o -&amp;gt; o :: acc)
+                input

     override __.EndProcessing() =
+        input &amp;lt;- List.rev input
&lt;/code&gt;&lt;/pre&gt;&lt;hr /&gt;&lt;p&gt;この変更を加えることで &lt;code&gt;hashtable&lt;/code&gt; の各要素を扱えるようになるけど、依然フィルタした結果は得られない。&lt;/p&gt;&lt;p&gt;&lt;code&gt;pocof&lt;/code&gt; はいま内部的に各要素の &lt;code&gt;ToString&lt;/code&gt; メソッドの結果に対して LINQ のクエリをかけてる。
そのため &lt;code&gt;DictionaryEntry&lt;/code&gt; のような &lt;code&gt;ToString&lt;/code&gt; の結果が自身のクラスを示す文字列 &lt;code&gt;System.Collections.DictionaryEntry&lt;/code&gt; を返す場合、使い物にならない。&lt;/p&gt;&lt;p&gt;未実装のプロパティ指定可能にする機能があればまあ使えるので先にやるべきと考えるが、プロパティ未指定時の挙動が定義できてないといけない。
常時プロパティ指定なんてしないので、 &lt;code&gt;ToString&lt;/code&gt; に値が反映されないタイプのオブジェクトの場合に、デフォルトでフィルタ可能な挙動を定義する必要がある。あーこっちのが大事やわ。
やはり &lt;code&gt;IDictionary&lt;/code&gt; 実装用に特別処理みたいなのを書いてあげないといけないかなーという気が若干してる。コイツ以外にも色々出てきたら面倒なので気が向かないけど、特別扱いなのはたしかにそうなので。&lt;/p&gt;&lt;p&gt;つづく&lt;/p&gt;</description><pubDate>Sun, 02 Oct 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-09-24-psjobcanattendance</guid><link>https://krymtkts.github.io/posts/2022-09-24-psjobcanattendance</link><title>PowerShell でジョブカン勤怠管理を操作する</title><description>&lt;p&gt;現職について半年が経とうとしている。幸運なことに毎日忙しく過ごしており打刻もままならん(&lt;del&gt;単にいつも忘れてるだけ&lt;/del&gt;)。
なので、またアレを作った。打刻スクリプトだ。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/PSJobCanAttendance"&gt;krymtkts/PSJobCanAttendance&lt;/a&gt;&lt;/p&gt;&lt;p&gt;現職は&lt;a href="https://jobcan.ne.jp/"&gt;ジョブカン勤怠管理&lt;/a&gt;を使ってるので、また新しく作る必要があった。
とはいえ&lt;a href="https://github.com/krymtkts/PSMFAttendance"&gt;krymtkts/PSMFAttendance&lt;/a&gt;をベースに開発(コピペ)しているので、構造的には同じ。
異なるのはスクレイピングの部分だけといって過言ない。&lt;/p&gt;&lt;p&gt;個人的に考える目玉機能は以下の 2 つ。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;OTP 対応&lt;/li&gt;&lt;li&gt;一括編集&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;1 については、認証時に OTP を取得する &lt;code&gt;ScriptBlock&lt;/code&gt; 差し込めるようにしてある。現職では都合が良いことに 1Password を使わせえてもらえてるので、 &lt;a href="https://developer.1password.com/docs/cli/get-started/"&gt;op&lt;/a&gt; を使って取得した OTP が渡せるのだ。
&lt;code&gt;ScriptBlock&lt;/code&gt; がない場合は入力を求めるプロンプトになる。&lt;/p&gt;&lt;p&gt;2 については、自分の現職における勤務実績の入れ方を考えると、絶対必要だったものだ。
現職はフレックスでかなりゆるいのでほぼ勤怠管理無いに等しいが、打刻は求められている。ただ自身が怠惰なせいもあり、3 週間くらい打刻を忘れていて〆前に急いで入力するなんてことが多発している。これを楽にこなすためにも、今回は絶対に一括編集機能を作りたかった。休憩時間が自動入力の設定じゃないようなので、打刻漏れしたときの作業の重さは尚更だ。&lt;/p&gt;&lt;p&gt;以下のようにパイプを使った一括編集ができる。端的に言って、楽過ぎてヤバい(打刻しろ)。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;@(12..16;20..22) | %{get-date "2022-09-$($_) 08:15:00+0900"} | Edit-JobCanAttendances -TimeRecordEvent work_start -AditGroupId 10
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上記の様な感じで試しに 3 週ほどの実績をドバドバと書き込んでみたが、リクエストが拒否されることもなく使えて一安心だった。
今回の打刻スクリプトを作るにあたり、毎度のごとく利用規約はチェック済みだ。&lt;a href="https://jobcan.ne.jp/aup"&gt;利用規約｜ジョブカン勤怠管理&lt;/a&gt;を確認したが、こういうスクリプトを作ることに関し問題なさそうだった。&lt;/p&gt;&lt;p&gt;本当は 2022 年夏頃には一通り作ってたのだけど、その後 2 ヶ月位使わずに来てたので、この週末でまとめ上げた。来週から実際に使ってみて、熟れてきたら PowerShell Gallery に公開しようと考えている。&lt;/p&gt;&lt;p&gt;今回作ってみて気づいたこと。&lt;a href="https://github.com/krymtkts/PSMFAttendance"&gt;krymtkts/PSMFAttendance&lt;/a&gt; を作ったときは、同サービスの前例が 1 つくらいしかなかったのに、今回は前例を探せば結構ヒットした。
「No.1 勤怠管理」の名は伊達じゃないな！と思わせるものがあった(何様)。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;&lt;a href="/posts/2021-11-27-psmfattendance"&gt;前に作った Money Forward クラウド勤怠のやつ&lt;/a&gt;は、前職を離れて実行環境がないからもうメンテもできないし、そろそろ Archive してもイイ気がする。
バグ残ったママだけど直して動作確認できないからしゃーない。&lt;/p&gt;</description><pubDate>Sat, 24 Sep 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-09-18-data-ide-data-station-build-notes</guid><link>https://krymtkts.github.io/posts/2022-09-18-data-ide-data-station-build-notes</link><title>データ IDE DataStation のビルド関連メモ</title><description>&lt;p&gt;ちょっと前に &lt;a href="https://datastation.multiprocess.io/"&gt;DataStation&lt;/a&gt; という OSS の IDE を知った。
GitHub の repo はこちら。&lt;a href="https://github.com/multiprocessio/datastation"&gt;multiprocessio/datastation: App to easily query, script, and visualize data from every database, file, and API.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;データベース・ファイル・HTTP リクエストまで多様なデータソースへの接続をサポートしてたり、簡単にグラフ化、コードで加工したり、とにかく良い。 Notebook みたいといえばそんな感じ。&lt;/p&gt;&lt;p&gt;ちょっとコントリしたいネタがあり、その動作確認のためにビルドして実行する必要があった。その時の手順・つまづきポイントを備忘のために雑メモで記しておく。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;DataStation のアーキテクチャについてはこちらのメモにある。そんなに詳しくないので自力で色々読んだり試したりした方がイイか。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/multiprocessio/datastation/blob/66b77f0cfe41040c49fe1e42e6f267b59f45b5bf/ARCHITECTURE.md"&gt;datastation/ARCHITECTURE.md at main · multiprocessio/datastation&lt;/a&gt;&lt;/p&gt;&lt;h3 id="デスクトップアプリのビルドと実行"&gt;デスクトップアプリのビルドと実行&lt;/h3&gt;&lt;p&gt;&lt;a href="https://github.com/multiprocessio/datastation/blob/66b77f0cfe41040c49fe1e42e6f267b59f45b5bf/HACKING.md"&gt;datastation/HACKING.md at main · multiprocessio/datastation&lt;/a&gt;&lt;/p&gt;&lt;p&gt;手順はこれを参照した。でも試してる途中でよくわからなくなってくるので、&lt;a href="https://github.com/multiprocessio/datastation/blob/66b77f0cfe41040c49fe1e42e6f267b59f45b5bf/package.json"&gt;&lt;code&gt;package.json&lt;/code&gt;&lt;/a&gt; を読んで各スクリプトが何者かは読んだ方がイイかも(実際そうした)。&lt;/p&gt;&lt;p&gt;ビルドと実行には WSL2 を使う。 手順に記載のある通り Windows でもできるっぽい(&lt;a href="https://jmeubank.github.io/tdm-gcc/"&gt;tdm-gcc&lt;/a&gt;というのを使う)けど、なんか面倒な気配がしたので Linux で楽をする。いつかチャレンジしてもよいが今ではないと判断した。
GCC は Go の SQLite3 モジュールをビルドするので必要っぽい。&lt;/p&gt;&lt;p&gt;ビルドの事前準備には依存関係のインストールスクリプトが用意されてる(CI 用だけど)。それを使って楽をする。
&lt;a href="https://github.com/multiprocessio/datastation/blob/66b77f0cfe41040c49fe1e42e6f267b59f45b5bf/scripts/ci/prepare_linux.sh"&gt;datastation/prepare_linux.sh&lt;/a&gt;&lt;/p&gt;&lt;p&gt;DataStation のデスクトップアプリは Electron アプリの様子。
以下のビルド実行時に権限が必要だったのと、それによって &lt;code&gt;--no-sandbox&lt;/code&gt; が必要になった。&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;sudo yarn build-desktop --no-sandbox
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;このビルド実行でライブラリが不足しているのがわかり、以下を参考にパッケージをインストールした。なんのエラーが出たかはメモを失念したが、 lib* が足りない系。
足りない依存関係は皆 Electron のビルドに必要なものばかりだった。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://akinov.hatenablog.com/entry/2021/04/04/151851"&gt;Puppeteer でライブラリ不足 libraries: libatk-1.0.so.0 - ノンカフェインであなたにやさしい&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/electron/electron-quick-start/issues/486#issuecomment-1153535808"&gt;Missing shared libraries · Issue #486 · electron/electron-quick-start&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;この依存関係のインストール後にビルドが成功するようになったが、実行すると SQLite3 のエラーになった。
内容は SQLite3 が古いと言われるものだった(メモ失念)。エラーログを見る限りこれの解消には Electron の再ビルドが必要なようだった(これあとから見てもピンとくるのかわからん。エラーログをメモらなかったことが悔やまれる)。&lt;/p&gt;&lt;p&gt;↓ の記事を参考にした覚えあり。
&lt;a href="https://stackoverflow.com/questions/46384591/node-was-compiled-against-a-different-node-js-version-using-node-module-versio"&gt;npm - Node - was compiled against a different Node.js version using NODE_MODULE_VERSION 51 - Stack Overflow&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;./node_modules/.bin/electron-rebuild
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ここまでやって初めて ↓ のコマンドで Electron アプリを動かして動作確認できるようになった(理解のために結局 &lt;code&gt;package.json&lt;/code&gt; に書かれたスクリプトを直で叩くようになる)。&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;yarn electron --trace-warning --unhandled-rejection=warn build/desktop.js --no-sandbox
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="runner-の-ut"&gt;runner の UT&lt;/h3&gt;&lt;p&gt;DataStation のデスクトップアプリはいわばフロントエンドで、データソースとの接続やデータ読み取りは Go で書かれた &lt;a href="https://github.com/multiprocessio/datastation/tree/main/runner"&gt;datastation/runner&lt;/a&gt; で行われてるようだった。&lt;/p&gt;&lt;p&gt;なので UT の実行に関しては先述のディレクトリで &lt;code&gt;go test&lt;/code&gt; するだけで OK だった。とはいえ前の節で先述した通り、 GCC に依存したモジュールのビルドがあるので WSL2 でやるのが良かろう。&lt;/p&gt;&lt;p&gt;終。&lt;/p&gt;</description><pubDate>Sun, 18 Sep 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-09-10-writing-cmdlet-in-fsharp-pt4</guid><link>https://krymtkts.github.io/posts/2022-09-10-writing-cmdlet-in-fsharp-pt4</link><title>F#でコマンドレットを書いてる pt.4</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。&lt;/p&gt;&lt;p&gt;めちゃめちゃ放置してたのだけど、 8 月末くらいから触れるようになってきたので、気になる部分ですぐ変えられる部分を書き換えて、 PowerShell Gallery に公開した。 &lt;a href="/posts/2022-05-07-start-to-write-cmdlet-by-fsharp"&gt;はじめたころ&lt;/a&gt;から 4 ヶ月くらい経ったのか。&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.powershellgallery.com/packages/pocof/0.1.0-alpha"&gt;PowerShell Gallery | pocof 0.1.0-alpha&lt;/a&gt;&lt;/p&gt;&lt;p&gt;現時点に公開する動機としては、自分の普段遣いでは未だ &lt;code&gt;poco&lt;/code&gt; を使ってるというのもあって、折角なのでそれを &lt;code&gt;pocof&lt;/code&gt; に変えようと考えた次第だ。
一部機能に関しては未実装なので、オプションはコメントアウトして隠した形で公開している。&lt;/p&gt;&lt;p&gt;大きい変更としては、PowerShell オブジェクトを作成せずに &lt;code&gt;PSCmdlet&lt;/code&gt; のサブクラスの中で PowerShell の Cmdlet を呼び出す方法がわかったので、その辺を書き換えた。
これが非常に参考になった →&lt;a href="https://github.com/PowerShell/PowerShell/issues/12137"&gt;InvokeCommand.InvokeScript not returning Output · Issue #12137 · PowerShell/PowerShell&lt;/a&gt;&lt;/p&gt;&lt;p&gt;DLL の モジュールを公開するのは初めてだったので、これまた躓きつつも先達の知恵を借りて乗り越えられた。
これ → &lt;a href="https://webcoder.info/fspsmodule.html"&gt;Writing a PowerShell Core Module With F#, A Complete Guide | Brianary&lt;/a&gt;&lt;/p&gt;&lt;p&gt;結局始めた頃はフォルダ指定の公開でええんちゃうかと思ってたが、 &lt;code&gt;Import-Module&lt;/code&gt; してから公開する方がめっちゃ楽なので、参照元に従いそう変えちゃった(こだわり無し)。
そもそもこの記事がなかったら &lt;code&gt;pocof&lt;/code&gt; はサクッと始めてなかったので、感謝しかない。&lt;/p&gt;&lt;p&gt;それと特に意図があった訳ではないが、 &lt;a href="https://docs.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-module-manifest?view=powershell-7.2"&gt;PowerShell Module Manifest&lt;/a&gt; で使ったことがなかった &lt;code&gt;PreRelease&lt;/code&gt; を使ってみたりもした。&lt;/p&gt;&lt;p&gt;公開にあたっての目玉機能は何もない。何なら &lt;code&gt;poco&lt;/code&gt; の機能で未だ実装してないものもある。
ただいくつか自分が &lt;code&gt;poco&lt;/code&gt; を使っていて困ってたことは、これで解消される。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;正規表現パターンの記述中にエラーで落ちない&lt;/li&gt;&lt;li&gt;クエリ記述中に左右カーソル移動ができる(buggy な疑いアリ)&lt;/li&gt;&lt;li&gt;(あとテスト用の非対話モード ← 普段利用ではまじで意味ないけどテストが楽)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;今後欲しい機能としては、とりあえず自分の使い方だと、プロパティ周り。
プロパティ指定のフィルタとプロパティ入力の補完ができたら相当楽になる。表示するプロパティが選べたりしたら最高。&lt;/p&gt;&lt;p&gt;&lt;code&gt;pocof&lt;/code&gt; で印字されたアイコングリフが &lt;code&gt;??&lt;/code&gt; になってたり他にも色々未実装・直さないといけない点あれど、自分が普段使うツールを自分の手でコントロールできる(しかも学習まで兼ねて)というのは、イイことやなと改めて思った。&lt;/p&gt;</description><pubDate>Sat, 10 Sep 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-09-03-the-cui-ver-of-out-grid-view</guid><link>https://krymtkts.github.io/posts/2022-09-03-the-cui-ver-of-out-grid-view</link><title>Out-GridView の CUI 版 Out-ConsoleGridView</title><description>&lt;p&gt;最近知ったのだけど、 &lt;code&gt;Out-GridView&lt;/code&gt; の PowerShell Team 謹製 CUI 版 &lt;code&gt;Out-ConsoleGridView&lt;/code&gt; があったらしい。これが使えるヤツだったら &lt;code&gt;poco&lt;/code&gt; も今作ってる &lt;code&gt;pocof&lt;/code&gt; も要らんやん、と思った。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/PowerShell/GraphicalTools"&gt;PowerShell/GraphicalTools: Modules that mix PowerShell and GUIs/CUIs! - built on Avalonia and gui.cs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;元々 CUI 使ってるのに &lt;code&gt;Out-GridView&lt;/code&gt; で GUI 表示しないとインタラクティブな絞り込みできないのがイヤで &lt;a href="https://github.com/peco/peco"&gt;peco&lt;/a&gt; を使ってたってのがある。
&lt;code&gt;peco&lt;/code&gt; は PowerShell に最適化されてないから、その後オブジェクトのまま取り扱える &lt;a href="https://github.com/jasonmarcher/poco"&gt;jasonmarcher/poco&lt;/a&gt; にたどり着いた。
その後 &lt;code&gt;poco&lt;/code&gt; の独自実装を自分で始めたのが &lt;a href="https://github.com/krymtkts/pocof"&gt;&lt;code&gt;pocof&lt;/code&gt;&lt;/a&gt;(F# の練習がてら)。&lt;/p&gt;&lt;p&gt;なもんで、 &lt;code&gt;Out-GridView&lt;/code&gt; の CUI 版があってもしイイ感じに使えるのなら、この長年の変遷に終止符を打つんちゃうかな的な。&lt;/p&gt;&lt;p&gt;以下 &lt;code&gt;README.md&lt;/code&gt; に従い試す。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Install-Module Microsoft.PowerShell.ConsoleGuiTools -AllowPrerelease -Scope AllUsers
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Get-ChildItem | Out-ConsoleGridView
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src="/img/2022-09-03-capture/capture.png" alt="水色の背景に印字される ls の結果" /&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;space&lt;/code&gt; キーでオブジェクトを選択するか &lt;code&gt;Ctrl+A&lt;/code&gt; で全選択して、 &lt;code&gt;Enter&lt;/code&gt; で選択した結果を出力する。
&lt;code&gt;-Filter&lt;/code&gt; オプションに渡した値で初期表示がフィルタリングされた形になる。そのままタイプしてもフィルタ入力できない。&lt;code&gt;Tab&lt;/code&gt; キーを押してフィルタのテキストにフォーカスできる。
フィルタは正規表現のみみたい。不正なパターンを入れたらちゃんとエラー表示されてエライ。
必ず結果を洗濯した状態で&lt;code&gt;Enter&lt;/code&gt; 押さないと結果が得られないのはちょっとメンドイ。
わたしは使わないけどマウスコントロール(クリックどころかスクロールまで)できるのもすごいな。
背景変わるの好きになれないので、今後色とかキーとかのオプション充実したりするかなあ。
インクリメンタルサーチじゃないのも微妙に好みじゃない操作性だ。&lt;/p&gt;&lt;p&gt;&lt;code&gt;poco&lt;/code&gt;、 &lt;code&gt;pocof&lt;/code&gt; 共にバッファを元に戻すとレイアウトの崩れが起きるのだけど、 &lt;code&gt;Out-ConsoleGridView&lt;/code&gt; は崩れない。素晴らしい。
表示域にないスクロール可能な部分は吹っ飛んでしまうけど、崩れない方法は真似させてもらいたい(MIT ライセンスなので)。けど、コード読んだ感じどこかわからなかった。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Out-ConsoleGridView&lt;/code&gt; は CmdLet の出力に &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.formatviewdefinition?view=powershellsdk-7.0.0"&gt;FormatViewDefinition Class (System.Management.Automation) | Microsoft Docs&lt;/a&gt;を自前で作ってるみたい。
なので PowerShell で表示される内容とちょっと違う。
それ故か、例えば &lt;code&gt;Get-InstalledModule&lt;/code&gt; のような情報量の多い結果を表示するとちょっと悲しい感じになってしまった。 &lt;code&gt;format.ps1xml&lt;/code&gt; が利用されないせいかな。しかしこのクラス使い方がわからなかったので勉強になるわ。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Get-InstalledModule | Out-ConsoleGridView
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src="/img/2022-09-03-capture/jam-packed-capture.png" alt="すし詰めに印字される Get-InstalledModule の結果" /&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;pocof&lt;/code&gt; でやりたいことと方向性が違うなあという感じなので、作ってるものを今すぐブン投げ捨てる必要はなかったようだ。こちらの開発は趣味プロで続けようと思った。しかしコード参考にできるものが増えたのでとても助かるなぁ。&lt;/p&gt;</description><pubDate>Sat, 03 Sep 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-08-27-bump-bootstrap</guid><link>https://krymtkts.github.io/posts/2022-08-27-bump-bootstrap</link><title>Bootstrap のバージョンを上げる</title><description>&lt;p&gt;先週の記事を書いたあとで、何の気なしに &lt;a href="https://web.dev/measure/"&gt;Measure page quality - web.dev&lt;/a&gt; で当ブログの測定をした。
そこで既知の脆弱性があるライブラリ (&lt;code&gt;Bootstrap@3.3.0&lt;/code&gt; と &lt;code&gt;jQuery@1.11.0&lt;/code&gt;)使うなよ！みたいなレポートがでたので、 Bootstrap の更新を思い立った。&lt;/p&gt;&lt;p&gt;変更した内容 → &lt;a href="https://github.com/krymtkts/krymtkts.github.io/commit/c4adeacb06fe759b787646bba5fb698c1f688c94"&gt;Upgrade bootstrap from 3 to 5. · krymtkts/krymtkts.github.io@c4adeac&lt;/a&gt;&lt;/p&gt;&lt;p&gt;ブログ作成当時の記事(&lt;a href="/posts/2019-01-10-make-blog-with-clojure"&gt;Clojure でブログを作った&lt;/a&gt;)を見ると、このブログのテーマは Cryogen 備え付けのテーマである &lt;code&gt;blue_centered&lt;/code&gt; をコピって作ったものだった。
そのままずっと使ってるので、当然の如くテンプレで利用しているライブラリも古いままだったという訳だ。&lt;/p&gt;&lt;p&gt;さて、 Bootstrap のマイグレーションは当然ドキュメントがあるわけだが、&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://getbootstrap.com/docs/4.0/migration/"&gt;Migrating to v4 · Bootstrap&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://getbootstrap.com/docs/5.0/migration/"&gt;Migrating to v5 · Bootstrap v5.0&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;今回は&lt;del&gt;手抜きによる&lt;/del&gt; v3 → v5 という飛び級であるし、わたし自身は Bootstrap に慣れてないので、とりあえずマイグレーションで対応するのは目で見て影響がある範囲のみとした。マイグレーションとしては正攻法な感じじゃなくて、割りと雑な感じだ。&lt;/p&gt;&lt;p&gt;それらの変更は例えば CSS のセレクタの変更だったり、 &lt;code&gt;class&lt;/code&gt; 属性の変更だったりだ。一応レスポンシブなデザインなので PC とモバイル(ブラウザのエミュレータだけど)も見ている。ちょいちょい以前と違うデザインにした・或いは意図せず変わった箇所もある。&lt;/p&gt;&lt;p&gt;途中コンテンツを空で更新したままデプロイしてしまうしょーもないミスがあったが、再度コンテンツを生成して事なきを得た。
これ Cryogen の差分ビルドの影響でちょいちょいやらかすのだけど、普段は人間力でカバーしていたところを今回はできず、デプロイしてしまった次第。この記事の投稿時点で設定を見直した。&lt;/p&gt;&lt;p&gt;今回の VerUp により Best Practices は 92 -&amp;gt; 100 に、 あと Performance も 93 -&amp;gt; 94 と意図せず微妙な好影響があった。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;before
&lt;ul&gt;&lt;li&gt;&lt;img src="/img/2022-08-27-capture/before.png" alt="変更前は Performance 93 Accessibility 97 Best Practices 92 SEO 92" /&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;after
&lt;ul&gt;&lt;li&gt;&lt;img src="/img/2022-08-27-capture/after.png" alt="変更後は Performance 94 Accessibility 97 Best Practices 100 SEO 92" /&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Bootstrap 5 では CSS カスタムプロパティでフォントサイズとか色とか変えられるみたいなので、このブログ用に再定義してるスタイルのいくつかは不要になるんじゃないかな。
これを機にちょっと見直すのもありかも知れない。あるいは別の静的サイトジェネレータに乗り換えるとか。他にやることなくなったらそれも一興か。&lt;/p&gt;&lt;p&gt;終。&lt;/p&gt;</description><pubDate>Sat, 27 Aug 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-08-20-osc-133-in-win-term</guid><link>https://krymtkts.github.io/posts/2022-08-20-osc-133-in-win-term</link><title>Windows Terminal で OSC133 する</title><description>&lt;p&gt;先週は盆の関係で時間が取れず書くのをサボった。まあその前の日曜に余分に書いてたし相殺したことにしておく。&lt;/p&gt;&lt;p&gt;きょうは Windows Terminal でもシェル統合みたいなのができるらしいと気づいたので、それを試す。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;ちょっと古い Windows Terminal Preview のリリースノートを見てて気づいた。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/microsoft/terminal/releases/tag/v1.15.1862.0"&gt;Release Windows Terminal Preview v1.15.186 · microsoft/terminal&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;Get-GitHubRelease -OwnerName microsoft -RepositoryName terminal -Tag v1.15.1862.0 | select -ExpandProperty body | % {$_ -split "`n"} | sls -Pattern '\[Experimental\]' -Context 0,10&lt;/code&gt; で雑に抽出。&lt;/p&gt;&lt;blockquote&gt;&lt;ul&gt;&lt;li&gt;[Experimental] We now support scrollbar marks! (#12948) (#13163) (#13291) (#13414)
&lt;ul&gt;&lt;li&gt;Use the &lt;code&gt;addMark&lt;/code&gt; action to add a scrollbar mark
&lt;ul&gt;&lt;li&gt;The &lt;code&gt;color&lt;/code&gt; optional parameter can be used to specify a color&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Use the &lt;code&gt;scrollToMark&lt;/code&gt; action with a specified &lt;code&gt;direction&lt;/code&gt; parameter to scroll between the marks&lt;/li&gt;&lt;li&gt;Use the &lt;code&gt;clearMark&lt;/code&gt; action to remove a selected mark&lt;/li&gt;&lt;li&gt;Use the &lt;code&gt;clearAllMarks&lt;/code&gt; action to remove all scrollbar marks&lt;/li&gt;&lt;li&gt;The &lt;code&gt;experimental.autoMarkPrompts&lt;/code&gt; profile setting can be set to &lt;code&gt;true&lt;/code&gt; to automatically mark each prompt
&lt;ul&gt;&lt;li&gt;NOTE: This uses the FTCS_PROMPT sequence from FinalTerm, &lt;code&gt;OSC 133 ; A&lt;/code&gt;, which we now support! (#13163)&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;The &lt;code&gt;experimental.showMarksOnScrollbar&lt;/code&gt; profile setting can also be set to &lt;code&gt;true&lt;/code&gt; to display the marks on your scrollbar&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p&gt;ほう？
プロンプトに自動でマーカーを付けられる様になったらしい。&lt;/p&gt;&lt;p&gt;この機能使いたかったが、端末乗り換えて profile にシーケンス足して...みたいなのが必要っぽかったのでメンドイなーと思ってけど、端末だけで対応できるのなら非常に楽。&lt;/p&gt;&lt;p&gt;これはやりたい。試してみる。&lt;/p&gt;&lt;h3 id="windows-terminal-の設定"&gt;Windows Terminal の設定&lt;/h3&gt;&lt;p&gt;利用している Windows Terminal Preview のバージョンは Version: 1.15.2282.0 だった。&lt;/p&gt;&lt;p&gt;以下のような感じの設定で試す。実際の &lt;code&gt;settings.json&lt;/code&gt; は他の設定でゴチャついているので、要所だけ切り抜いた。&lt;/p&gt;&lt;pre&gt;&lt;code class="json"&gt;{
  "$help": "https://aka.ms/terminal-documentation",
  "$schema": "https://raw.githubusercontent.com/microsoft/terminal/main/doc/cascadia/profiles.schema.json",
  "actions": [
    {
      "command": {
        "action": "addMark",
        "color": "#CB4B16"
      },
      "keys": "ctrl+m"
    },
    {
      "command": {
        "action": "scrollToMark",
        "direction": "previous"
      },
      "keys": "ctrl+up"
    },
    {
      "command": {
        "action": "scrollToMark",
        "direction": "next"
      },
      "keys": "ctrl+down"
    },
    {
      "command": "clearAllMarks",
      "keys": "ctrl+d"
    }
  ],
  "profiles": {
    "defaults": {
      "experimental.autoMarkPrompts": true,
      "experimental.showMarksOnScrollbar": true
    },
  },
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;JSON Schema については、&lt;code&gt;https://aka.ms/terminal-profiles-schema&lt;/code&gt; の方はバージョンが古いので Preview 使ってると色々不都合がある。ので repo 直で見る。&lt;/p&gt;&lt;p&gt;試してみて、とりあえずすべて期待通りに動くのがわかった。&lt;/p&gt;&lt;p&gt;はじめスクロールバーに色がつかなくて、はて？だったけど、これは &lt;code&gt;settings.json&lt;/code&gt; の記述が間違ってたからだった。
&lt;code&gt;experimental.autoMarkPrompts&lt;/code&gt;, &lt;code&gt;experimental.showMarksOnScrollbar&lt;/code&gt; は &lt;code&gt;profiles&lt;/code&gt; 直下じゃない。
&lt;code&gt;profiles.defaults&lt;/code&gt; に書かないとダメ。&lt;/p&gt;&lt;p&gt;これに気づいたのは &lt;a href="https://github.com/microsoft/terminal/blob/c12987af415c5e0911d7a0a81b8494fbe6307328/doc/cascadia/profiles.schema.json#L2177-L2181"&gt;&lt;code&gt;settings.json&lt;/code&gt; の JSON Schema のここ&lt;/a&gt;見たら、 &lt;code&gt;Profile&lt;/code&gt; 毎の property であることがわかったから。&lt;/p&gt;&lt;p&gt;ドキュメントにもこの機能出てた。あとから気づいたわ。
&lt;a href="https://docs.microsoft.com/en-us/windows/terminal/customize-settings/profile-advanced#scroll-marks-preview"&gt;Scroll marks (Preview)- Windows Terminal Advanced Profile Settings | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;ドキュメントの方は、タイトルも「Advanced profile settings in Windows Terminal」 やし、こっちならパっと見で気づけたかな...まあよし。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;今回この件を調べてから、 &lt;a href="https://github.com/microsoft/terminal/issues/11000"&gt;megathread: Scrollbar Marks · Issue #11000 · microsoft/terminal&lt;/a&gt; という巨大な Issue を見つけた。
きょう試した experimental な feature もここ由来のもの。&lt;/p&gt;&lt;p&gt;まだ VS Code のそれに比べると相当しょぼい。
またコマンドの成功・失敗に対応してマーカーの色分けがつくとかもない。
けど、この Issue 見るにそれらはそのうちやるっぽい(&lt;code&gt;category&lt;/code&gt; というやつかな)。なので、 subscribe しておいて新しいのが来たら是非試したい。&lt;/p&gt;&lt;p&gt;普段仕事で使う標準出力が長い &lt;code&gt;cdk&lt;/code&gt; とか AWS Tools for PowerShell とかの実行結果を飛び回るのに、こんなに有効な機能が来たことは喜ばしい。
来週の仕事から早速使う。&lt;/p&gt;&lt;h3 id="余談"&gt;余談&lt;/h3&gt;&lt;p&gt;ついでに &lt;code&gt;useAcrylic = true&lt;/code&gt; じゃないとき、 &lt;code&gt;opacity&lt;/code&gt; だけで古き良き透過にできるのにも気づいた。
Windows 11 で ver1.12 から使えたらしい...気づくのに時間がかかったけど、これもやりたかったことのひとつなので、良い。&lt;/p&gt;&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/windows/terminal/customize-settings/profile-appearance#transparency"&gt;Opacity - Windows Terminal Appearance Profile Settings | Microsoft Docs&lt;/a&gt;&lt;/p&gt;</description><pubDate>Sat, 20 Aug 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-08-07-git-says-the-local-repo-is-not-yours</guid><link>https://krymtkts.github.io/posts/2022-08-07-git-says-the-local-repo-is-not-yours</link><title>git で local repo が自分のものじゃないとなったやつ</title><description>&lt;p&gt;今日はブログ書くつもり無かったけど、これまた起こったらなんかハマりそうやなーと思ったので、したためた。&lt;/p&gt;&lt;p&gt;何があったかわからんが、 git に local repo の所有権が自分にないと言われてエラーになった。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; git status
fatal: detected dubious ownership in repository at 'C:/Users/takatoshi/dev/github.com/krymtkts/Get-GzipContent'
To add an exception for this directory, call:

        git config --global --add safe.directory C:\Users\takatoshi\dev\github.com\krymtkts\Get-GzipContent
Set the environment variable GIT_TEST_DEBUG_UNSAFE_DIRECTORIES=true and run
again for more information.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;safe.directory&lt;/code&gt; が設定されているパスなのだけど。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; git config --list | ? {$_ -like 'safe*'}
safe.directory=C:/Users/takatoshi/dev/*
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;GIT_TEST_DEBUG_UNSAFE_DIRECTORIES&lt;/code&gt; でデバッグメッセージを有効化できるそうなのでしてみたところ、以下の様なのが出た。
最近使ってた local repo では出なくて、&lt;del&gt;放置してた&lt;/del&gt; 最近ご無沙汰だった repo で出ている。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; $env:GIT_TEST_DEBUG_UNSAFE_DIRECTORIES=$true
PS&amp;gt; git status
warning: 'C:/Users/takatoshi/dev/github.com/krymtkts/Get-GzipContent/.git' is owned by:
        'S-1-5-32-544'
but the current user is:
        'S-1-5-21-3808303910-2770483448-703627078-1001'
fatal: detected dubious ownership in repository at 'C:/Users/takatoshi/dev/github.com/krymtkts/Get-GzipContent'
To add an exception for this directory, call:

        git config --global --add safe.directory C:/Users/takatoshi/dev/github.com/krymtkts/Get-GzipContent
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;owner が違う...なんで owner 変わってしまってたんだろう。ユーザー 1 人しかいないのに。
あーハイハイ、と想像がついたので試したところ、管理者権限でならエラーが出ない。&lt;/p&gt;&lt;p&gt;どうも過去に管理者権限で作成した local repo の所有者が Administrator になってた模様。それが最近の Git for Windows の更新で検知されるようになったんだ。&lt;/p&gt;&lt;p&gt;Windows で所有者を変更する方法を調べてみて、それっぽい手順があったのでそれに倣う。
Windows のこの辺の昨日全然知らないので、どっかのタイミングで調べないといけないな。
&lt;a href="https://theitbros.com/using-takeown-exe-command-to-take-ownership-of-file-or-folder/#:~:text=You%20can%20change%20the%20owner,%3E%20Advanced%20%3E%20Owner%20%3E%20Change."&gt;Using Takeown.exe Command to Take Ownership of a File or Folder – TheITBros&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;takeown /F C:\Users\takatoshi\dev\github.com\krymtkts\Get-GzipContent /R
# SUCCESS: The file (or folder):  ....
# えげつない量の印字...
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; git status
On branch master
Your branch is up to date with 'origin/master'.

nothing to commit, working tree clean
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;イイね。直せた。
他のディレクトリも所有者を変えた。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;takeown.exe /f . /r | Out-Null
# えげつない量の印字を無に帰す...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;終。&lt;/p&gt;</description><pubDate>Sun, 07 Aug 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-08-06-usecase-of-get-gzipcontent</guid><link>https://krymtkts.github.io/posts/2022-08-06-usecase-of-get-gzipcontent</link><title>Get-GzipContent のユースケース</title><description>&lt;p&gt;以前 &lt;a href="https://github.com/krymtkts/Get-GzipContent"&gt;krymtkts/Get-GzipContent: Get-Content for gzip files.&lt;/a&gt; というのを作って &lt;a href="https://www.powershellgallery.com/packages/Get-GzipContent/0.1.2"&gt;PowerShell Gallery&lt;/a&gt; に公開した。&lt;/p&gt;&lt;p&gt;当時 gzip された JSON を扱う機会が多かった。
その時の職場は bash 文化だったのだけど、自分のローカルでは PowerShell を使うし...ということで、モジュールが欲しかった。
この PowerShell で gzip を展開するコード自体よく知られてるパターンらしかったけど、登録されてるモジュールがなかったので、自分で作った。ちゃんと探したら似たモジュールはあったのだろうけど、周辺モジュールもドカッと入るのは期待するところでないので、単機能のモジュールを作ったんだ確か。&lt;/p&gt;&lt;p&gt;最近になってまた gzip されたファイルを扱う機会が増えたので、改めて使う機会が来たのだけど...これちょっとイマイチやなーと思っている。&lt;/p&gt;&lt;p&gt;CloudFront のアクセスログで&lt;a href="https://docs.aws.amazon.com/ja_jp/AmazonCloudFront/latest/DeveloperGuide/AccessLogs.html#LogFileFormat"&gt;標準ログ&lt;/a&gt;というのがあるのだけど、こいつは gzip された TSV で、これを PowerShell で取り扱うのに以下の関数を作った。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function ConvertFrom-CloudFrontAccessLog {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true,
            Position = 0,
            ValueFromPipeline = $true,
            ValueFromPipelineByPropertyName = $true,
            HelpMessage = 'Path to one or more locations.')]
        [Alias('PSPath')]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Path
    )
    begin {
        $header = 'date', 'time', 'x-edge-location', 'sc-bytes', 'c-ip', 'cs-method', 'cs(Host)', 'cs-uri-stem', 'sc-status', 'cs(Referer)', 'cs(User-Agent)', 'cs-uri-query', 'cs(Cookie)', 'x-edge-result-type', 'x-edge-request-id', 'x-host-header', 'cs-protocol', 'cs-bytes', 'time-taken', 'x-forwarded-for', 'ssl-protocol', 'ssl-cipher', 'x-edge-response-result-type', 'cs-protocol-version', 'fle-status', 'fle-encrypted-fields', 'c-port', 'time-to-first-byte', 'x-edge-detailed-result-type', 'sc-content-type', 'sc-content-len', 'sc-range-start', 'sc-range-end'
    }
    process {
        $Path | ForEach-Object { (zcat $_) -split "`n" } | ConvertFrom-Csv -Delimiter "`t" -Header $header
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;ForEach-Object { (zcat $_) -split "`n" }&lt;/code&gt; ここがイケてない。まじで使いにくい。
改行コードずつ &lt;code&gt;Write-Object&lt;/code&gt; するようにしてないから、自分で分割しないといけなくなってしまっている。当時は改行なし JSON ばかり取り扱ってたので、全く気づかなかったのかなと思っている(しらん)。&lt;/p&gt;&lt;p&gt;↓ こうできたらすごくイイ気がする。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$Path | zcat | ConvertFrom-Csv -Delimiter "`t" -Header $header
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;breaking change なのもあるしバージョン 1 にするかーとか思っている。後方互換のスイッチ要るかな？とか分割単位を指定できるのが良いのかな？とか考え出すと、やる気が...
ま、 &lt;code&gt;Get-Content&lt;/code&gt; と似た動きにしたいってのがあるので、 &lt;code&gt;-Delimiter&lt;/code&gt; かなー。&lt;/p&gt;&lt;p&gt;でも、とりあえず数年後し？のセルフ使用レビューを経てツールを改善しよ...という気になったので、自分のために書いたモジュールでもあるし自分が必要な範囲で直そ。使ってる人がおこになったらちょっと考える。&lt;/p&gt;&lt;p&gt;さっさと直したらいいのだけど、動機づけとしてこの記事をしたためた。
あとはやるだけ... &lt;a href="https://github.com/krymtkts/Get-GzipContent/issues/3"&gt;Add the &lt;code&gt;-Delimiter&lt;/code&gt; option like &lt;code&gt;Get-Content&lt;/code&gt;. · Issue #3 · krymtkts/Get-GzipContent&lt;/a&gt;&lt;/p&gt;</description><pubDate>Sat, 06 Aug 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-07-30-practice-build-aws-tools-for-powrshell</guid><link>https://krymtkts.github.io/posts/2022-07-30-practice-build-aws-tools-for-powrshell</link><title>AWS Tools for PowerShell のビルド素振り</title><description>&lt;p&gt;今年は積極的に？ AWS Tools for PowerShell を使ってることもあって、また Issue 書くことあるかなー、なんなら PR 書いて貢献した方がいいよなと考えるに至り、 &lt;a href="https://github.com/aws/aws-tools-for-powershell"&gt;aws/aws-tools-for-powershell&lt;/a&gt; のビルドを素振りしてみた。
残念ながら、 contribution 関連でビルドの方法がレクチュアされてる文書とかなかったので、手探りでやってる。&lt;/p&gt;&lt;p&gt;まず、サービス毎の膨大なプロジェクトがあるし、試しに単体のプロジェクトをビルドしたかったのだけど、関連付く DLL が無くてビルドできなかった。 &lt;code&gt;Amazon.Runtime&lt;/code&gt; とかいうやつ？ この repo 内のどれかのプロジェクトでビルドされるんだろうけど。&lt;/p&gt;&lt;p&gt;&lt;code&gt;buildtools/&lt;/code&gt; 配下を見ると、どうも CI が CodeBuild らしい(当然のごとく)。この &lt;code&gt;buildtools/ci.buildspec.yml&lt;/code&gt; の中に記載されている全体のビルドで使ってるプロジェクトなら上手くいきそうな雰囲気がしたので、これでフルビルドを試した。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;dotnet --version
# 6.0.302
dotnet build .\buildtools\build.proj
# めちゃくちゃ大量のビルドログが出力される...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ところがこのフルビルドしだしたらクッソ重い...ビルドが終わらない。
わたしの Razer blade stealth 2018 モデルだと CPU 使用率が天井に貼り付いて、過去にない位にヒートアップしてて心配な気持ちにさせてくれた。&lt;/p&gt;&lt;p&gt;結果、 41 分かかってなんとかビルドに成功した。&lt;/p&gt;&lt;p&gt;で、出力結果を見たら改行コードが変わってしまったみたいでエグい差分が発生してしまった。
元コードは全部 &lt;code&gt;LF&lt;/code&gt; なのだけど、 Windows でのビルドによって &lt;code&gt;CRLF&lt;/code&gt; になってしまったみたい。CodeBuild では .NET Core 3.1 でビルドしてるから .NET の関連ツールを使ってても &lt;code&gt;LF&lt;/code&gt; になるんやろが、こちとら Windows 。
どこで変わったか調査して再発を防ぎたいけど、別の機会にする。&lt;/p&gt;&lt;p&gt;これで基盤的な DLL は生成されたであろうし、サービス個別のプロジェクトのビルドを試すと、うまくいった。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;dotnet build .\modules\AWSPowerShell\Cmdlets\Lambda\AWS.Tools.Lambda.csproj
# ...中略...
#
# Build succeeded.
#     0 Warning(s)
#     0 Error(s)
#
# Time Elapsed 00:00:01.81
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;テストは PowerShell で Cmdlet に対して行う Pester のやつがあるのみで、かつこれらの内容を見てると当然のごとく AWS リソースがある前提。なので、多分個人では金がかかってできないやつ。デプロイ用の CFn とかもないし。
PR のワークフローで対処してんのかなー。&lt;/p&gt;&lt;p&gt;想定以上に時間がかかったけど、とりあえずなんか修正したいときに手元でビルドするための知識は貯まった。
フルビルドで改行コードが書き換わってしまう、サービス単体のビルドに必要な最小限の依存関係を理解する、辺りが宿題かな。&lt;/p&gt;</description><pubDate>Sat, 30 Jul 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-07-23-glue-tagging-cmdlet-not-used-by-anyone-in-the-world</guid><link>https://krymtkts.github.io/posts/2022-07-23-glue-tagging-cmdlet-not-used-by-anyone-in-the-world</link><title>世界中の誰にも使われていない？ Glue のタグ付け Cmdlet</title><description>&lt;p&gt;現職にて AWS のコストを可視化すべく、既存の AWS リソースにひたすらコスト配分タグを付与していく作業をしている(勝手に)。
Cost Explorer を眺めてコストのかかり具合を見るのは、 AWS の醍醐味というか楽しみだと思ってるのだけど、あんまり共感を得られたことがない。&lt;/p&gt;&lt;p&gt;タグ付けには&lt;a href="https://docs.aws.amazon.com/ARG/latest/userguide/tag-editor.html"&gt;タグエディタ&lt;/a&gt;を使ってしまっても良いのだけど、折角なので、何を実行したかを形に残せしたい。
そこで &lt;a href="https://aws.amazon.com/powershell/"&gt;AWS Tools for PowerShell&lt;/a&gt; でやってる&lt;sup id="fnref-1"&gt;&lt;a class="footnote-ref" href="#fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt;のだけど、とあるサービスだけなんか他のサービスのタグ付け Cmdlet は作法が違ってた。&lt;/p&gt;&lt;p&gt;Glue 君のことね。 &lt;a href="https://docs.aws.amazon.com/powershell/latest/reference/items/Add-GLUEResourceTag.html"&gt;Glue: Add-GLUEResourceTag Cmdlet | AWS Tools for PowerShell&lt;/a&gt;&lt;/p&gt;&lt;p&gt;この御方なんか知らんけど &lt;code&gt;Tag[]&lt;/code&gt; じゃなくて &lt;code&gt;hashtable&lt;/code&gt; を受けつける。コレまた当然のごとく Reference にはサンプルコード載ってないので、念のためググるかーと思いググったところ...&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2022-07-23-capture/aws-tools-for-pwsh.png" alt="9 件しかヒットしない Add-GLUEResourceTag" /&gt;&lt;/p&gt;&lt;p&gt;9 件しかヒットしなかった(2022-07-22 時点)。マジで？
世界中で誰も使ってないのか、はたまたショボ過ぎて誰も記事にしないのか。&lt;/p&gt;&lt;p&gt;因みに使い方には困ることもなく、実行した結果も期待通り、ちゃんとタグが付いてた。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$AccountId = Get-STSCallerIdentity | Select-Object -ExpandProperty Account
$Region = Get-DefaultAWSRegion | Select-Object -ExpandProperty Region
$Tag = @{
    'service' = 'my-service'
    'stage' = 'dev'
    'cost' = 'my-service-dev'
}
Get-GLUECrawlerList | ForEach-Object {
    # Glue Crawler の ARN が `Get-GLUECrawler` から持ってこれなくて、みすぼらしく手で組んでる。
    Add-GLUEResourceTag -ResourceArn "arn:aws:glue:${Region}:${AccountId}:crawler/$($_.Name)" -TagsToAdd $Tag
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href="https://aws.amazon.com/jp/about-aws/whats-new/2019/03/aws-glue-now-supports-resource-tagging/"&gt;AWS Glue でリソースタグがサポートされて 3 年ばかり経ってる&lt;/a&gt;けどみんな使ってないのかなーとか、他にも使われてない Cmdlet があるんやろなーと、思いを馳せた。&lt;/p&gt;&lt;p&gt;AWS CLI の方はというと &lt;code&gt;"aws glue tag-resource"&lt;/code&gt; で 3 件しかヒットしなかった。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2022-07-23-capture/aws-cli.png" alt="3 件しかヒットしない &amp;quot;aws glue tag-resource&amp;quot;" /&gt;&lt;/p&gt;&lt;p&gt;しかしながらヒットした記事は実行例が分かるものになってて、こう...なんか AWS Tools for PowerShell の人気の無さが際立つなーと感じた。&lt;/p&gt;&lt;h3 id="他を見る"&gt;他を見る&lt;/h3&gt;&lt;p&gt;雑だが、 AWS Tools for PowerShell のリソースタグ関連の Cmdlet で、タグのパラメータの型が何か調べるスクリプトを書いた。 CRUD 全部の Cmdlet が含まれるのであまり正確ではない。&lt;/p&gt;&lt;p&gt;わたしは AWS Tools for PowerShell の特定のモジュールしか入れてないから全体はわからんけど、傾向は見られる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# AWS.Tools.* modules must be imported first to get all property information.
Get-Module -Name *AWS* | Import-Module
Get-Command *Tag* | Where-Object -Property Source -Like '*aws*' | ForEach-Object {
    [pscustomobject]@{
        Name = $_.Name
        TagParameterType = $_.Parameters.Values | Where-Object -Property Name -Like '*tag*' | Select-Object -ExpandProperty ParameterType
    }
} | Where-Object -Property TagParameterType -NE $Null | Group-Object TagParameterType

# Count Name
# ----- ----
#    31 System.String[]
#     8 Amazon.IdentityManagement.Model.Tag[]
#     4 System.Collections.Hashtable
#     3 {System.String[], System.String[]}
#     3 Amazon.CodeDeploy.Model.Tag[]
#     3 System.String
#     2 Amazon.OpenSearchService.Model.Tag[]
#     2 Amazon.AutoScaling.Model.Tag[]
#     2 Amazon.EC2.Model.Tag[]
#     2 Amazon.S3.Model.Tag[]
#     2 Amazon.Redshift.Model.Tag[]
#     2 Amazon.CertificateManager.Model.Tag[]
#     1 Amazon.ECS.Model.Tag[]
#     1 Amazon.CloudWatch.Model.Tag[]
#     1 Amazon.SimpleNotificationService.Model.Tag[]
#     1 Amazon.StepFunctions.Model.Tag[]
#     1 Amazon.SecretsManager.Model.Tag[]
#     1 Amazon.ECR.Model.Tag[]
#     1 Amazon.RDS.Model.Tag[]
#     1 Amazon.KeyManagementService.Model.Tag[]
#     1 Amazon.KinesisFirehose.Model.Tag[]
#     1 Amazon.DynamoDBv2.Model.Tag[]
#     1 Amazon.ECR.ImageTagMutability
#     1 Amazon.ElasticLoadBalancingV2.Model.Tag[]
#     1 Amazon.ElastiCache.Model.Tag[]
#     1 Amazon.QuickSight.Model.Tag[]
#     1 Amazon.EventBridge.Model.Tag[]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;*.Tag[]&lt;/code&gt; が多数派かなーと。 &lt;code&gt;31 System.String[]&lt;/code&gt; これは多分削除とか取得かな。
ただしこいつら &lt;code&gt;*.Tag[]&lt;/code&gt; グループの中でも、 プロパティが &lt;code&gt;Key&lt;/code&gt; だったり &lt;code&gt;TagKey&lt;/code&gt; だったりの派閥があるので、ほんま「みんな違ってみんないい」的状態。&lt;/p&gt;&lt;p&gt;おわり。&lt;/p&gt;&lt;div class="footnotes"&gt;&lt;hr /&gt;&lt;ol&gt;&lt;li id="fn-1"&gt;&lt;p&gt;既存リソースは IaC じゃないので、コマンドでタグ付けするため。&lt;/p&gt;&lt;a href="#fnref-1" class="footnote-backref"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description><pubDate>Sat, 23 Jul 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-07-16-aws-cdk-with-fsharp-pt2</guid><link>https://krymtkts.github.io/posts/2022-07-16-aws-cdk-with-fsharp-pt2</link><title>F# の AWS CDK で EventPattern の記述を無理やり通す</title><description>&lt;p&gt;&lt;a href="/posts/2022-07-03-aws-cdk-with-fsharp"&gt;前&lt;/a&gt;に書いた、 F# の AWS CDK で EventRule のパターンが正しいのにエラーとなるやつ。&lt;/p&gt;&lt;p&gt;こういうのをしたいところ、&lt;/p&gt;&lt;pre&gt;&lt;code class="yaml"&gt;EventPattern:
  source:
    - aws.s3
  detail-type:
    - Object Created
  detail:
    bucket:
      name:
        - Ref: バケツ
    object:
      key:
        - prefix: test/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以下の記述だとエラーになる。&lt;/p&gt;&lt;pre&gt;&lt;code class="fsharp"&gt;EventPattern =
    EventPattern(
        Source = [| "aws.s3" |],
        DetailType = [| "Object Created" |],
        Detail =
            dict [ ("bucket", dict [ ("name", [| bucket.BucketName |]) ])
                    ("object", dict [ ("key", [| dict [ ("prefix", "test/") ] |]) ]) ]
    )
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;Unhandled exception. System.ArgumentException: Could not infer JSII type for .NET type 'IDictionary`2' (Parameter 'type')
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;この Issue っぽい。
&lt;a href="https://github.com/aws/jsii/issues/1044"&gt;DotNet: Unable to pass interface instance through in a Dictionary&amp;lt;string, object&amp;gt; · Issue #1044 · aws/jsii&lt;/a&gt;&lt;/p&gt;&lt;p&gt;けど、 &lt;code&gt;IDictionary&amp;lt;string,obj&amp;gt;&lt;/code&gt; は使えてる部分もあって微妙に違うしなー。
より詳細な型がここ(&lt;code&gt;EventPattern&lt;/code&gt;)にはないし、どないすりゃいいんじゃ。&lt;/p&gt;&lt;p&gt;色々とこねくり回した末に、 CFn のリソースを直接上書きすることで回避できるのがわかった。
&lt;a href="https://docs.aws.amazon.com/cdk/v2/guide/cfn_layer.html#cfn_layer_raw"&gt;Escape hatches - AWS Cloud Development Kit (CDK) v2&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/aws-cdk-fsharp-trial"&gt;krymtkts/aws-cdk-fsharp-trial&lt;/a&gt; からコードを抜粋する。&lt;/p&gt;&lt;p&gt;配列内に &lt;code&gt;IDictionary&amp;lt;string,obj&amp;gt;&lt;/code&gt; がいると型が解決できなようだったので、空の配列で定義しておき、後でから &lt;code&gt;IDictionary&amp;lt;string,obj&amp;gt;&lt;/code&gt; 要素を差し込む！野蛮過ぎる...&lt;/p&gt;&lt;pre&gt;&lt;code class="fsharp"&gt;    let rule =
        Rule(
            this,
            "bucket-event",
            RuleProps(
                RuleName = "buckt-event",
                Description = "bucket event.",
                EventPattern =
                    EventPattern(
                        Source = [| "aws.s3" |],
                        DetailType = [| "Object Created" |],
                        // NOTE: cannot write like below because JSII is unable to use `IDictionary&amp;lt;string, object&amp;gt;` inside the array.
                        // Detail =
                        //     dict [ ("bucket", dict [ ("name", [| bucket.BucketName |]) ])
                        //            ("object", dict [ ("key", [| dict [ ("prefix", "test/") ] |]) ]) ]
                        Detail =
                            dict [ ("bucket", dict [ ("name", [| bucket.BucketName |]) ])
                                   ("object", dict [ ("key", [||]) ]) ]
                    )
            )
        )

    // NOTE: the escape hatch for IDictionary&amp;lt;string, object&amp;gt;` inside the array is raw overrides.
    do
        match rule.Node.DefaultChild with
        | :? CfnRule as ep -&amp;gt; ep.AddPropertyOverride("EventPattern.detail.object.key.0", dict [ "prefix", "test/" ])
        | _ -&amp;gt; failwith "You passed a wrong variable that is not of type CfnRule!"

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;cdk synth&lt;/code&gt; でエラーせずに、以下の出力が得られるようになった。&lt;/p&gt;&lt;pre&gt;&lt;code class="yaml"&gt;bucketeventF2FCD38A:
  Type: AWS::Events::Rule
  Properties:
    Description: bucket event.
    EventPattern:
      detail:
        bucket:
          name:
            - Ref: sourcebucketE323AAE3
        object:
          key:
            - prefix: test/
      detail-type:
        - Object Created
      source:
        - aws.s3
    Name: buckt-event
    State: ENABLED
    Targets:
      - Arn:
          Fn::GetAtt:
            - samplefunctionAA39FD5B
            - Arn
        Id: Target0
  Metadata:
    aws:cdk:path: AwsCdkFsharpStack/bucket-event/Resource
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;宣言的に書きたいのにこんなツギハギが要るとか、めちゃくちゃ不便極まりない。&lt;/p&gt;&lt;p&gt;これは F# のせいじゃないけど、この .NET の不便な側面を許容してまで F# で CDK したいかというと、まずないな...と思った。これに関連して AWS CDK の Issue をちょいちょい調べたが、 .NET や Java で CDK するの辛そうやな..とうっすら思えた。茨の道を突き進むなりの良さがあるのだろうか。&lt;/p&gt;&lt;p&gt;改めて、仕事は素直に TypeScript を採用して良かったと実感した。&lt;/p&gt;</description><pubDate>Sat, 16 Jul 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-07-09-tips-for-sending-http-requests-pwsh</guid><link>https://krymtkts.github.io/posts/2022-07-09-tips-for-sending-http-requests-pwsh</link><title>PowerShell で大量の HTTP リクエストを送る場合の Tips</title><description>&lt;p&gt;大量のアクセスログがほしい事情で、テスト環境に大量のリクエストを送りつける必要があった。&lt;/p&gt;&lt;p&gt;JMeter とか Gatling 使えば済む話なのだけど、すぐに使い回せるものがなかったし、パパっとやってしまいたかったので PowerShell を使ってみたら、エラーになった。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$requests = 'aaa=10&amp;amp;bbb=20', 'aaa=11&amp;amp;bbb=21', 'aaa=12&amp;amp;bbb=22'
$requests * 100000 | ForEach-Object -Parallel {
    Invoke-WebRequest -Method Get -Uri "https://$using:testDomaain?$_"
    $jitter = Get-Random -Minimum 3 -Maximum 23
    Start-Sleep -Milliseconds (95 + $jitter) # 待ち
} -ThrottleLimit 100 | ConvertTo-Json | Set-Content ./responses.json
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;こういうのでタコ殴りにすると...&lt;/p&gt;&lt;p&gt;&lt;code&gt;Only one usage of each socket address (protocol/network address/port) is normally permitted&lt;/code&gt;&lt;/p&gt;&lt;p&gt;15000 件を超えた辺りでこうなった。なんだ？ググる。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://social.msdn.microsoft.com/Forums/aspnet/en-US/ab5e4f6d-e96a-4bef-bba2-870eda412ea3/systemnetsocketssocketexception-only-one-usage-of-each-socket-address-protocolnetwork?forum=AzureFunctions"&gt;System.Net.Sockets.SocketException: Only one usage of each socket address (protocol/network address/port) is normally permitted&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;ポートが枯渇するんだと。 PowerShell の実装を見た訳じゃないけど、 大量に実行された &lt;code&gt;Invoke-WebRequest&lt;/code&gt; で &lt;code&gt;HttpClient&lt;/code&gt; を大量作成したのであろうことは、想像するに易い。&lt;/p&gt;&lt;p&gt;同じ &lt;code&gt;HttpClient&lt;/code&gt; を使い回せば良いらしいので、そうした。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$requests = 'aaa=10&amp;amp;bbb=20', 'aaa=11&amp;amp;bbb=21', 'aaa=12&amp;amp;bbb=22'
$h = New-Object System.Net.Http.HttpClient
$requests * 100000 | ForEach-Object -Parallel {
    ($using:h).GetAsync("https://$using:testDomaain?$_").GetAwaiter()
    $jitter = Get-Random -Minimum 3 -Maximum 23
    Start-Sleep -Milliseconds (95 + $jitter) # 待ち
} -ThrottleLimit 100 | ForEach-Object {$_.GetResult()} | ConvertTo-Json | Set-Content ./responses.json
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;そんだけ。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;参照
&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/Azure/azure-functions-host/issues/1806"&gt;Need Official Guidance On using HttpClient in Functions · Issue #1806 · Azure/azure-functions-host&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://blog.ironmansoftware.com/powershell-async-method/"&gt;Calling Async .NET Methods from PowerShell&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</description><pubDate>Sat, 09 Jul 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-07-03-aws-cdk-with-fsharp</guid><link>https://krymtkts.github.io/posts/2022-07-03-aws-cdk-with-fsharp</link><title>F# で AWS CDK して躓いてる</title><description>&lt;p&gt;最近仕事で AWS CDK を使ってみたが、非常に良い感触だった。
仕事では TypeScript を採用したが、テンプレートが提供されている言語を見るとなんと F# がいるではないか。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; cdk init --list
Available templates:
* app: Template for a CDK Application
   └─ cdk init app --language=[csharp|fsharp|go|java|javascript|python|typescript]
* lib: Template for a CDK Construct Library
   └─ cdk init lib --language=typescript
* sample-app: Example CDK Application with some constructs
   └─ cdk init sample-app --language=[csharp|fsharp|go|java|javascript|python|typescript]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;単に「C# のクラス用意したから継承して使ってや～」的なもので F# 向けに調整されてないだろうが、コレ誰が使うねんという気がしたので、試してみた。&lt;/p&gt;&lt;p&gt;参考にした前例たち。非常に参考にさせてもらった。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://awsmaniac.com/functional-programming-with-aws-cdk/"&gt;Functional Programming with AWS CDK | AWS Maniac&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://cloudgnosis.org/fsharp/fsharp-for-the-cloud-worker/part5.html"&gt;Part 5 - AWS Cloud Development Kit (CDK) — Cloudgnosis collection 0.1 documentation&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr /&gt;&lt;p&gt;まずテンプレからプロジェクトを生成した素の状態で CFn を作成してみる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;cdk init sample-app --language=fsharp
cdk synth
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ちゃんと CFn をビルドできた。 どんなコードが出るか知りたかったので &lt;code&gt;sample-app&lt;/code&gt; を使ったが、ここで &lt;code&gt;app&lt;/code&gt; テンプレを使うと、利用されない &lt;code&gt;this&lt;/code&gt; が残ってるので警告が出る。でも勿論 CFn をビルドできる。&lt;/p&gt;&lt;p&gt;記述に関しては TypeScript など他の言語と大差なさそう。ただ予想通り C# との相互運用は前提になってる。
宣言的に記述する箇所については &lt;code&gt;let&lt;/code&gt; バインディングして、 リソースに手続き的に何かすると &lt;code&gt;do&lt;/code&gt; バインディングみたい。&lt;/p&gt;&lt;p&gt;試しに S3 と Lambda を EventBridge で繋いでみたい。&lt;/p&gt;&lt;p&gt;F# の CDK では &lt;code&gt;Amazon.CDK&lt;/code&gt; に必要な Construct が全部入りしてるみたい。なので &lt;code&gt;Amazon.CDK.xxx&lt;/code&gt; みたいな感じでポチポチ &lt;code&gt;.&lt;/code&gt; を刻んでいけば、ドキュメントがなくてもそれなりに探せる。&lt;/p&gt;&lt;p&gt;F# は言語固有モジュールが無いので、ここに例えば Lambda を足すとすると、個別にビルドする感じになる。あれめちゃくちゃ楽で好きなんやけど、 .Net 向けにはない。
プロジェクトを別途足す方向で作るらしい。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# テンプレなかったので探してインストール
dotnet new lambda.EmptyFunction --search
dotnet new --install Amazon.Lambda.Templates

dotnet new lambda.S3 --output . --name api --language "F#"

cd src
dotnet sln add api
&lt;/code&gt;&lt;/pre&gt;&lt;hr /&gt;&lt;p&gt;stack をザーッと書いてみたが、めちゃくちゃつまづきどころがある。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;open System.Collections&lt;/code&gt; したら &lt;code&gt;Stack&lt;/code&gt; が競合するので注意&lt;/li&gt;&lt;li&gt;&lt;code&gt;MemorySize&lt;/code&gt;に&lt;code&gt;128&lt;/code&gt; を渡してたら Ionide や &lt;code&gt;dotnet build&lt;/code&gt; ではエラー検知できなかったが、 &lt;code&gt;cdk synth&lt;/code&gt; でエラー(めんどくせ)
&lt;ul&gt;&lt;li&gt;&lt;code&gt;MemorySize&lt;/code&gt;を&lt;code&gt;128&lt;/code&gt;から&lt;code&gt;(Some 128.0 |&amp;gt; Option.toNullable)&lt;/code&gt;に&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;必須プロパティがビルドまでわからないのつらい&lt;/li&gt;&lt;li&gt;&lt;code&gt;EventPattern&lt;/code&gt; の &lt;code&gt;IDictionary&amp;lt;string,obj&amp;gt;&lt;/code&gt;を一息で書くのかなりキツイ(まじでめんどい)
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Value&lt;/code&gt; の型が揃わないところは個別に &lt;code&gt;let&lt;/code&gt; してあとで組み合わせたり&lt;/li&gt;&lt;li&gt;&lt;code&gt;dict&lt;/code&gt; に食わせる &lt;code&gt;tuple&lt;/code&gt; はきっちりカッコで囲むと先述の &lt;code&gt;let&lt;/code&gt; が不要になった&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;EventPattern&lt;/code&gt; の &lt;code&gt;Detail&lt;/code&gt; が &lt;code&gt;cdk synth&lt;/code&gt; でエラーになる&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Prefix のパターンをやりたいのだけど、 &lt;a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-patterns-content-based-filtering.html#eb-filtering-prefix-matching"&gt;Content filtering in Amazon EventBridge event patterns - Amazon EventBridge&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="yaml"&gt;EventPattern:
  source:
    - aws.s3
  detail-type:
    - Object Created
  detail:
    bucket:
      name:
        - Ref: バケツ
    object:
      key:
        - prefix: test/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以下の記述だとエラーになる。&lt;/p&gt;&lt;pre&gt;&lt;code class="fsharp"&gt;EventPattern =
    EventPattern(
        Source = [| "aws.s3" |],
        DetailType = [| "Object Created" |],
        Detail =
            dict [ ("bucket", dict [ ("name", [| bucket.BucketName |]) ])
                    ("object", dict [ ("key", [| dict [ ("prefix", "test/") ] |]) ]) ]
    )
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;Unhandled exception. System.ArgumentException: Could not infer JSII type for .NET type 'IDictionary`2' (Parameter 'type')
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;dict [ ("prefix", "test/") ]&lt;/code&gt; の代わりに文字列を渡してると問題なくなるけど、それってスキーマ違反なんですけど。
この辺 TypeScript は困った記憶ないので、参ったなという感じ。&lt;/p&gt;&lt;p&gt;この辺の回答が出たら割りと参考になるかもなーと思って見ている。&lt;a href="https://github.com/aws/aws-cdk/discussions/20894"&gt;How to set detail on an eventpattern in java · Discussion #20894 · aws/aws-cdk&lt;/a&gt;
単純に F# 力の低さに起因して記述できないだけだといいけど。&lt;/p&gt;&lt;p&gt;もうちょっと深掘したいが今週はここまで。
とりあえず repo は作った。 &lt;a href="https://github.com/krymtkts/aws-cdk-fsharp-trial"&gt;krymtkts/aws-cdk-fsharp-trial&lt;/a&gt;&lt;/p&gt;</description><pubDate>Sun, 03 Jul 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-06-26-writing-cmdlet-in-fsharp-pt3</guid><link>https://krymtkts.github.io/posts/2022-06-26-writing-cmdlet-in-fsharp-pt3</link><title>F#でコマンドレットを書いてる pt.3</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。&lt;/p&gt;&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.powershell?view=powershellsdk-7.0.0"&gt;PowerShell Class&lt;/a&gt; を使って、現在の runspace を引き継がせるとかはちょっとわかりまして、 (F# というか .NET)の世界で PowerShell の表示文字列を取り回すには PowerShell Class を使い最後に &lt;code&gt;Out-String&lt;/code&gt; した結果を取り回すのが典型っぽいのはわかった。&lt;/p&gt;&lt;p&gt;ただやっぱり PowerShell の力を借りない方法を諦めきれずにいた。
また今後プロパティ指定での検索を実装していったときに、指定したプロパティはなんか色付けするとかしようとしたらこっちの方が絶対やりやすいだろうというのを感じてたので、&lt;a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/composite-formatting"&gt;Composite formatting&lt;/a&gt; を使ってどうにかできないものか考えていた。&lt;/p&gt;&lt;p&gt;が、結論としては PowerShell の力を借りるのが良いのでは～...というところまできた。&lt;/p&gt;&lt;p&gt;結局のところ &lt;code&gt;format.ps1xml&lt;/code&gt; に従って PowerShell で表示が制御されるので、 F# の中で &lt;code&gt;PSObject.Properties&lt;/code&gt; を見たとてどいつを優先表示したらいいかわからん。またこの &lt;code&gt;Properties&lt;/code&gt; から表示するテーブルを作るのは &lt;code&gt;hashtable&lt;/code&gt; や &lt;code&gt;array&lt;/code&gt; が引数の場合には適応したくないし、となると型でパターンマッチして～となる。
考えるとここにこだわるのはもっとプロパティでの絞り込みとかの他の機能を実装したあとでいいかなーという気になってきた。&lt;/p&gt;&lt;p&gt;&lt;code&gt;format.ps1xml&lt;/code&gt; もそうだけど PowerShell 内部実装に対する基礎知識(&lt;code&gt;PSPropertyInfo&lt;/code&gt;とかまじで情報ない)がやっぱ圧倒的に不足してるから、蓄積されるまでは黙って PowerShell に従うが良いかと考えを改めた。
であれば、もう PowerShell Class を使う方向に倒して、検索中のプロパティを &lt;code&gt;Format-Table&lt;/code&gt; の &lt;code&gt;-Properties&lt;/code&gt; で表示するようにしようかな、という選択肢もありかなと。&lt;/p&gt;&lt;p&gt;いったんこの形で検索中の表示を進めれば、他に組み込んでおきたい機能、例えばプロパティ指定の検索とかに取りかかれる。
週末の 1,2 時間が主な開発時間なので、亀な進捗の中でも実装を進められる判断が必要かなー。それもまた一興。&lt;/p&gt;</description><pubDate>Sun, 26 Jun 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-06-19-belatedly-parallel-foreach-object</guid><link>https://krymtkts.github.io/posts/2022-06-19-belatedly-parallel-foreach-object</link><title>今更 ForEach-Object -Parallel</title><description>&lt;p&gt;今更だが、直列だと長時間かかる処理を分散させるために &lt;code&gt;ForEach-Object -Parallel&lt;/code&gt; を使う必要があった。
困ったというほどでもないけど、真面目に使ったことなかったので、今回学んだ気をつけポイントをまとめる。
(毎度の如く PowerShell でそれをやる必要は全くなかったが、ぱっと手を動かしたくてついやってしまった)&lt;/p&gt;&lt;ul&gt;&lt;li&gt;参照
&lt;ul&gt;&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/powershell/powershell-foreach-object-parallel-feature/"&gt;PowerShell ForEach-Object Parallel Feature - PowerShell Team&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/powershell/module/psworkflow/about/about_foreach-parallel?view=powershell-5.1"&gt;about Foreach-Parallel - PowerShell | Microsoft Docs&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/61273189/how-to-pass-a-custom-function-inside-a-foreach-object-parallel/61273544#61273544"&gt;powershell - How to pass a custom function inside a ForEach-Object -Parallel - Stack Overflow&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr /&gt;&lt;h3 id="並列数の制御"&gt;並列数の制御&lt;/h3&gt;&lt;p&gt;&lt;code&gt;-Parallel&lt;/code&gt; はとにかく遅い。異なる runspace が作成されそこで実行されるからだ。
なのでとにかく計算時間がかかるんやというような処理だけ渡すようにした方がいい。&lt;/p&gt;&lt;p&gt;今回は、あらかじめ &lt;code&gt;ThrottleLimit&lt;/code&gt; と同じ数の &lt;code&gt;InputObject&lt;/code&gt; に調整して重いコマンドを打つ方針を使った。
消えては立ち上がり x2 するような書き方をした方ではやはり runspace 作成のオーバーヘッドが、処理時間という形で顕著に見られた。
スクリプトブロックが消えては立ち上がり x2 しないように、スクリプトブロック内で重い 1 処理を実行する方が良かった(AWS のリソースを一括操作するやつだからできたことだけど)。&lt;/p&gt;&lt;p&gt;1 ヵ月分のデータを加工する必要があって、対象日毎に 1 処理にすることができたので、それを約 30 並列でやった。
イメージ ↓&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$begin = (Get-Date -Day 1 -Hour 0 -Minute 0 -Second 0 -Millisecond 0)
$end = $begin.AddMonths(1).AddDays(-1)
$dateRange = @()
while ($begin -le $end) {
    $dateRange += $begin
    $begin = $begin.AddDays(1)
}
$dateRange | ForEach-Object -ThrottleLimit $dateRange.Length -Parallel {
    # 長時間かかる処理.
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="スクリプトブロック外のリソース参照"&gt;スクリプトブロック外のリソース参照&lt;/h3&gt;&lt;p&gt;&lt;code&gt;$using:&lt;/code&gt; 修飾子をつけたら変数を参照できる。
ただしスクリプトブロックや関数には使えない。&lt;/p&gt;&lt;p&gt;関数をどうしても使いまわしたいときは、文字列に変換した上で取り込む技もある。 &lt;a href="https://stackoverflow.com/questions/61273189/how-to-pass-a-custom-function-inside-a-foreach-object-parallel/61273544#61273544"&gt;powershell - How to pass a custom function inside a ForEach-Object -Parallel - Stack Overflow&lt;/a&gt;&lt;/p&gt;&lt;p&gt;が、スクリプトブロック内でしか使わないのであればその中に関数を定義してしまったほうが楽か。
&lt;a href="https://devblogs.microsoft.com/powershell/powershell-foreach-object-parallel-feature/#comment-171"&gt;最もクリーンな方法でオススメらしいし&lt;/a&gt;、実際にそうした。&lt;/p&gt;&lt;p&gt;(&lt;code&gt;Import-Module&lt;/code&gt; すればいいのだけどいちいちモジュールを作らないこともあろう)&lt;/p&gt;&lt;p&gt;技を使うとこうなる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function Get-Identity {
    param (
        [Parameter(Mandatory,
            Position = 0,
            ValueFromPipeline
        )]
        [PSObject]
        $Value
    )
    process {
        $Value
    }
}

$funcDef = ${function:Get-Identity}.ToString()

function Test-UsingFuncInParallel {
    [CmdletBinding()]
    param ()

    1..30 | ForEach-Object -Parallel {
        ${function:Get-Identity} = $using:funcDef
        $_ | Get-Identity | Write-Host
    } -ThrottleLimit 30
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;技を使わない版。当然ながらスクリプトブロックは間延びする。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function Test-UsingFuncInParallel {
    [CmdletBinding()]
    param ()

    1..30 | ForEach-Object -Parallel {
        function Get-Identity {
            param (
                [Parameter(Mandatory,
                    Position = 0,
                    ValueFromPipeline
                )]
                [PSObject]
                $Value
            )
            process {
                $Value
            }
        }

        $_ | Get-Identity | Write-Host
    } -ThrottleLimit 30
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使う関数が多いとスクリプトブロックも伸びがちなので、使い分けを検討した方が良かろう。
用途次第だが、わたしの場合は先述の通り並列数 MAX ピッタリに調整した &lt;code&gt;InputObject&lt;/code&gt; を使て長時間の処理を流すだろうから、 runspace の作成のコストはそれほど気にならない。スクリプトブロックの中がごちゃごちゃしないことのメリットがあるかも知れん。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;あと微妙にハマったのが &lt;code&gt;$PSCmdlet&lt;/code&gt; の参照。&lt;/p&gt;&lt;p&gt;&lt;code&gt;$using:&lt;/code&gt; つけ忘れてると単に &lt;code&gt;$null&lt;/code&gt; なだけなのでエラーメッセージ見てもピンときにくい。&lt;/p&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;Line |
   2 |          if ($PSCmdlet.ShouldProcess($_, 'Write-Host')) {
     |              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     | You cannot call a method on a null-valued expression.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;さらに関数の呼び出し時はカッコで囲む必要がある。カッコがないと Parse Error。&lt;/p&gt;&lt;pre&gt;&lt;code class="diff"&gt; function Test-ShouldProcessInParallel {
     [CmdletBinding(SupportsShouldProcess)]
     param ()

     1..30 | ForEach-Object -Parallel {
-        if ($using:PSCmdlet.ShouldProcess($_, 'Write-Host')) {
+        if (($using:PSCmdlet).ShouldProcess($_, 'Write-Host')) {
             $_ | Write-Host
         }
     } -ThrottleLimit 30
 }
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;ParserError:
Line |
   6 |          if ($using:PSCmdlet.ShouldProcess($_, 'Write-Host')) {
     |              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     | Expression is not allowed in a Using expression.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;あとなんか見慣れぬエラーになる時があったが忘れた。再現できたら追記したい。&lt;/p&gt;</description><pubDate>Sun, 19 Jun 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-06-12-writing-cmdlet-in-fsharp-pt2</guid><link>https://krymtkts.github.io/posts/2022-06-12-writing-cmdlet-in-fsharp-pt2</link><title>F#でコマンドレットを書いてる pt.2</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。&lt;/p&gt;&lt;p&gt;平日仕事の方ばっかりやってるので亀な進捗だ。
ひとまず&lt;a href="/posts/2022-06-05-whitespace-comparison-in-pwsh"&gt;&lt;code&gt;System.Management.Automation.WildcardPattern&lt;/code&gt; の使い方がわかった&lt;/a&gt; のを皮切りに、 &lt;code&gt;-like&lt;/code&gt;,&lt;code&gt;-match&lt;/code&gt;,&lt;code&gt;-eq&lt;/code&gt; あたりのフィルタを実装した。&lt;/p&gt;&lt;p&gt;あとプロパティを指定しての絞り込みとかを実装してないが、これは &lt;code&gt;PSObject&lt;/code&gt; から目当てのプロパティを拾ってマッチするだけなので、多分むずくないだろう。&lt;/p&gt;&lt;p&gt;いま一番頭を悩ませている課題は、絞り込みを確定するまでの間印字する内容についてだ。
やはり PowerShell でインタラクティブなフィルタリングをするのであれば、印字する内容も PowerShell の &lt;code&gt;Format-Table&lt;/code&gt; ライクな印字をしたい。
例えば &lt;a href="https://github.com/devblackops/Terminal-Icons"&gt;Terminal-Icons&lt;/a&gt; を使っていたら、カラフルな &lt;code&gt;Get-ChildItem&lt;/code&gt; の結果のママ絞り込みしたい。ただそのやり方がさっぱり分からない。&lt;/p&gt;&lt;p&gt;全くわからんなりに、とりあえず F# 内から PowerShell を実行する練習として、 &lt;code&gt;PowerShell.Create&lt;/code&gt; でコマンドレットを動かしてみただけというコードは動かしてみた。&lt;/p&gt;&lt;pre&gt;&lt;code class="fsharp"&gt;[&amp;lt;Cmdlet(VerbsDiagnostic.Test, "Pocof")&amp;gt;]
[&amp;lt;OutputType(typeof&amp;lt;PSObject&amp;gt;)&amp;gt;]
type TestPocofCommand() =
    inherit PSCmdlet()

    override __.EndProcessing() =
        __.WriteObject
        &amp;lt;| PowerShell
            .Create()
            .AddCommand("Get-ChildItem")
            .AddCommand("Format-Table")
            .Invoke() // まじで意味ない
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;このへんまだ調査不足のため、以下に記すのはメモ書きレベル。つか &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.powershell?view=powershellsdk-7.0.0"&gt;PowerShell Class&lt;/a&gt; だけでなく PowerShell SDK のドキュメントむずくない？
全体的に読んでてもよくわからん(愚痴)。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;これをやろうとしたら &lt;a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_format.ps1xml?view=powershell-7.2"&gt;Format.ps1xml&lt;/a&gt; が反映された状態の文字列を F# 内で作らないといけないが、 F# 内で &lt;code&gt;PowerShell.Create&lt;/code&gt; したとてセッションの引き継ぎができるのかがわからん
&lt;ul&gt;&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.powershell.create?view=powershellsdk-7.0.0#system-management-automation-powershell-create(system-management-automation-runspacemode)"&gt;PowerShell.Create&lt;/a&gt; あたりでどうにかなりそうに見えるけど試せてない&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;PowerShell SDK の中には &lt;code&gt;FormatTableCommand&lt;/code&gt; という名のまさに &lt;code&gt;Format-Table&lt;/code&gt; そのものがあるが、こいつの Input に &lt;code&gt;SelectPocofCommand&lt;/code&gt; からデータを食わす方法がわからん
&lt;ul&gt;&lt;li&gt;これも多分実行時に引数で渡せるようにみえるけど(略) &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.powershell.invoke?view=powershellsdk-7.0.0#system-management-automation-powershell-invoke-1(system-collections-ienumerable)"&gt;PowerShell.Invoke Method&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;これらが想定通りで期待の Output が得られたとて、正直な気持ちは F# 内で PowerShell の実行エンジン作ってまでやりたくないなー(なんか重そう)、もっと簡単に &lt;code&gt;Format-Table&lt;/code&gt; の出力を得る方法はないんかいな、というお気持ち&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;code&gt;System.Management.Automation.WildcardPattern&lt;/code&gt; みたいな外部から見える場所に PowerShell 内部で使ってる機能がいい感じに提供されてたらいいのだけど、そんな感じではなさそう。&lt;/p&gt;&lt;p&gt;見た目に動きのある機能実装ができたときの嬉しさはやっぱひとしおなので、取り組みたい、けどまだ情報＆能力的に不足してるなーというところ。何やるにしても手を動かせるまでに異様に時間がかかる。
ひとまずは調査継続しつつ他の課題潰していくか。&lt;/p&gt;&lt;p&gt;ほんま仕事とは一切接点無くて趣味プロとして最高のテーマになってる。&lt;/p&gt;</description><pubDate>Sun, 12 Jun 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-06-05-whitespace-comparison-in-pwsh</guid><link>https://krymtkts.github.io/posts/2022-06-05-whitespace-comparison-in-pwsh</link><title>PoweShell で半角スペース(U+0020) -eq 全角スペース(U+3000) が True となる</title><description>&lt;p&gt;転職して 3 ヶ月目を迎えた。
入社以降は何の因果か CRM の導入をやることになり、既存データ(スプレッドシート)の以降のために PowerShell を駆使している。&lt;/p&gt;&lt;p&gt;そんな中で今まで知らなかった PowerShell の表情をいくつも知ることができ(例えばコレとか)、なんやかんやで楽しんでいる。&lt;/p&gt;&lt;p&gt;その中で度肝を抜かれたのが、今日のテーマ。&lt;/p&gt;&lt;p&gt;&lt;code&gt;' '&lt;/code&gt;(U+0020) &lt;code&gt;-eq&lt;/code&gt; &lt;code&gt;' '&lt;/code&gt;(U+3000) が &lt;code&gt;True&lt;/code&gt; となる。&lt;/p&gt;&lt;p&gt;PowerShell 7 と Windows PowerShell 5.1 で試した。&lt;/p&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;Name                           Value
----                           -----
PSVersion                      7.2.4
PSEdition                      Core
GitCommitId                    7.2.4
OS                             Microsoft Windows 10.0.22000
Platform                       Win32NT
PSCompatibleVersions           {1.0, 2.0, 3.0, 4.0…}
PSRemotingProtocolVersion      2.3
SerializationVersion           1.1.0.1
WSManStackVersion              3.0
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;Name                           Value
----                           -----
PSVersion                      5.1.22000.653
PSEdition                      Desktop
PSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}
BuildVersion                   10.0.22000.653
CLRVersion                     4.0.30319.42000
WSManStackVersion              3.0
PSRemotingProtocolVersion      2.3
SerializationVersion           1.1.0.1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;7 だと &lt;code&gt;True&lt;/code&gt; 、 5.1 だと &lt;code&gt;False&lt;/code&gt; だ。
&lt;code&gt;-ceq&lt;/code&gt; だと 7 でも &lt;code&gt;False&lt;/code&gt; を返すので &lt;code&gt;-ieq&lt;/code&gt; の判定が違うのだけど、 PowerShell Core からこうなんだろうか？
PowerShell の実装を追ってみたが、追いきれなかった。 めちゃくちゃ&lt;a href="https://github.com/PowerShell/PowerShell/blob/87f621eb1fa94f1d114b0cc4a5fb7aab5d3133c9/src/System.Management.Automation/engine/parser/Compiler.cs#L5804%E3%83%BCL5806"&gt;ココ&lt;/a&gt;っぽいのだけど、 LINQ に由来するクラス &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.expressions.dynamicexpression.dynamic?view=net-6.0#system-linq-expressions-dynamicexpression-dynamic(system-runtime-compilerservices-callsitebinder-system-type-system-linq-expressions-expression-system-linq-expressions-expression)"&gt;DynamicExpression&lt;/a&gt; とかの知識がないのでまだ調査中。&lt;/p&gt;&lt;p&gt;どう説明したらいいか悩むのが、いくつか試してみていてわかってきたのは、 &lt;code&gt;String&lt;/code&gt; の &lt;code&gt;-ieq&lt;/code&gt; でこの事象が見られること。 &lt;code&gt;Char&lt;/code&gt; だと起こらない。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;' ' -ieq '　' # True
([char][int]'0x20') -ieq ([char][int]'0x3000')  # Char だと False
([string][char][int]'0x20') -ieq ([string][char][int]'0x3000') # String だと True
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;そしてもう 1 つ、 Unicode で General category が Separator, space と定義されているものが等値と判定されること。&lt;/p&gt;&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Whitespace_character#Unicode"&gt;Whitespace character - Wikipedia&lt;/a&gt; の表が非常にわかりやすい。ここから以下のテストコードを作成し、先述の事実を導いた。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;'0x0009', '0x000A', '0x000B', '0x000C', '0x000D', '0x0020', '0x0085', '0x00A0', '0x1680', '0x2000', '0x2001', '0x2002', '0x2003', '0x2004', '0x2005', '0x2006', '0x2007', '0x2008', '0x2009', '0x200A', '0x2028', '0x2029', '0x202F', '0x205F', '0x3000' | % { [PSCustomObject]@{
    CodePoint = $_
    isEquals = ([string][char][int]$_) -eq ' '
}}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;CodePoint isEquals
--------- --------
0x0009       False
0x000A       False
0x000B       False
0x000C       False
0x000D       False
0x0020        True
0x0085       False
0x00A0        True
0x1680        True
0x2000        True
0x2001        True
0x2002        True
0x2003        True
0x2004        True
0x2005        True
0x2006        True
0x2007        True
0x2008        True
0x2009        True
0x200A        True
0x2028       False
0x2029       False
0x202F        True
0x205F        True
0x3000        True
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;あーココまで来ると、意図的な挙動 ≒ 仕様というのに当たりがつく。
なので .NET の String クラスの挙動を見てみると...&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;' '.Equals('　', [StringComparison]::CurrentCultureIgnoreCase) # True

'0x0009', '0x000A', '0x000B', '0x000C', '0x000D', '0x0020', '0x0085', '0x00A0', '0x1680', '0x2000', '0x2001', '0x2002', '0x2003', '0x2004', '0x2005', '0x2006', '0x2007', '0x2008', '0x2009', '0x200A', '0x2028', '0x2029', '0x202F', '0x205F', '0x3000' | % { [PSCustomObject]@{
&amp;gt;     CodePoint = $_
&amp;gt;     isEquals = ([string][char][int]$_).Equals(' ', [StringComparison]::CurrentCultureIgnoreCase)
&amp;gt; }}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;CodePoint isEquals
--------- --------
0x0009       False
0x000A       False
0x000B       False
0x000C       False
0x000D       False
0x0020        True
0x0085       False
0x00A0        True
0x1680        True
0x2000        True
0x2001        True
0x2002        True
0x2003        True
0x2004        True
0x2005        True
0x2006        True
0x2007        True
0x2008        True
0x2009        True
0x200A        True
0x2028       False
0x2029       False
0x202F        True
0x205F        True
0x3000        True
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;StringComparison.InvariantCultureIgnoreCase&lt;/code&gt; は同じ結果。 &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; は違う結果となった。&lt;/p&gt;&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.stringcomparison?view=net-6.0"&gt;StringComparison Enum (System) | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;全然知らんかった...また世の中に恥を晒してしまったと共に、1 つ学んだわ。
まだ確かな情報源を得たわけじゃないけど、きっと世の中のﾄﾞｯﾄﾈｯﾀｰにとっては常識なんやろなあ。
手始めに ↓ コレちゃんと読むようにしよう...&lt;/p&gt;&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/best-practices-strings"&gt;Best Practices for Comparing Strings in .NET | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;ちなみにこの調査において、 &lt;code&gt;-like&lt;/code&gt; には &lt;code&gt;System.Management.Automation.WildcardPattern&lt;/code&gt; が使われていて、しかも公開されてるクラスというのがわかった。こんなのがあるの知らなかったわ。&lt;/p&gt;&lt;p&gt;そのまま &lt;a href="https://github.com/krymtkts/pocof#readme"&gt;pocof&lt;/a&gt; のワイルドカード検索で利用することにした。↓ こういう使い方。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;([System.Management.Automation.WildcardPattern]"*ui*").IsMatch('kouiuno')
&lt;/code&gt;&lt;/pre&gt;</description><pubDate>Sun, 05 Jun 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-05-28-writing-cmdlet-in-fsharp</guid><link>https://krymtkts.github.io/posts/2022-05-28-writing-cmdlet-in-fsharp</link><title>F#でコマンドレットを書いてる</title><description>&lt;p&gt;&lt;a href="/posts/2022-05-07-start-to-write-cmdlet-by-fsharp"&gt;以前 F# で PowerShell コマンドレットを書き始めた&lt;/a&gt;と書いた。&lt;/p&gt;&lt;p&gt;ひと月くらいかけて主に休みの日にちょいちょい書き進めてきて、最近最低限動くようになったので public repo にした。
&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt;&lt;/p&gt;&lt;p&gt;まだ激ショボな機能しかない。
プロパティを指定してフィルタリングするとか、フィルタリングした見た目をこれまたテーブルフォーマットにするとか、 PowerShell ならではの良さをまだ全然作り込めてない。&lt;/p&gt;&lt;p&gt;さっぱり作り方がわからん &lt;code&gt;Format-Table&lt;/code&gt; とか &lt;code&gt;-like&lt;/code&gt; とか PowerShell のクラスをそのまま使いたい気分。無理やったら組むねんけど。&lt;/p&gt;&lt;p&gt;&lt;code&gt;ls | pocof&lt;/code&gt; したら Terminal Icons で鮮やかになったままフィルタリングされてほしいのよなー。
この辺が組み込めたら、 PowerShell Gallery で公開したい。&lt;/p&gt;&lt;p&gt;現状正規表現でのフィルタリングくらいしかまともに使えるものがなく亀速な進捗だけど、Cmdlet を書いたり F# で書いたのも初めてだったから、楽しく取り組めた。&lt;/p&gt;&lt;p&gt;前にも書いた通り、これは poco の多言語フォークなんやけど、その動機としては poco の未実装だったり使いにくいところが起因してツール自体をあまり使いこなせてなかったところがある。
自分自身あまりツールの使い込みは得意じゃなくて、なんなら自分流にアレンジできるタイプのツールしか使いこなせない。&lt;/p&gt;&lt;p&gt;DIY キーボードとかまさにその典型例なんやけど、キーバインディングが自分の制御下に置かれた途端ブラインドタッチができるようになったりしたので、何かと自分用に手を加えないといけないんだろう。&lt;/p&gt;&lt;p&gt;でもこれで poco というか pocof は自分の制御下に置いたのでなんか色々試してみたいお気持ち。&lt;/p&gt;&lt;p&gt;F# の書き心地に関しては、まだ慣れない点もあれど結構気に入ってる。 &lt;code&gt;else&lt;/code&gt; は矯正してほしいところやけど。&lt;/p&gt;&lt;p&gt;着手前は試しにコンピュート式書いてみたいなーとか考えてたが、いまんとこ使おうと思えば使えるけど敢えて使うほどでもない感じで、使い所ない。
大したことやってないからパターンマッチや高階関数使ってるだけでもサクサクできる。
.NET 自体かなり久しぶりなこと(PowerShell つかってるけど全然 .NET に踏み込んでない...)と、 .NET と F# の世界の境界がまだ自分の中で曖昧で、そのへんは書きながら学んでいきたいなーという感じ。&lt;/p&gt;&lt;p&gt;何にせよ趣味プロのちょうどいいネタを見つけた。当分はこれで遊ぶ。&lt;/p&gt;</description><pubDate>Sat, 28 May 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-05-22-customize-my-worn-out-705</guid><link>https://krymtkts.github.io/posts/2022-05-22-customize-my-worn-out-705</link><title>使い古しの Logicool M 705 をカスタマイズする</title><description>&lt;p&gt;もう 15 年くらい使っている Logicool の M705 がある。&lt;/p&gt;&lt;h3 id="この-m705-について"&gt;この M705 について&lt;/h3&gt;&lt;p&gt;この M705 は、昔ロジクールに勤めていた友人からもらったものだ。
現行モデルは多分これ → &lt;a href="https://www.logicool.co.jp/ja-jp/products/mice/m705m-wireless-mouse.910-005303.html"&gt;3 年の電池寿命を提供するロジクール M705m マラソン ワイヤレスマウス&lt;/a&gt;&lt;/p&gt;&lt;p&gt;もらってから数年の間はそんなに使ってなかったが、尋常でない電池寿命とハードデューティさに気づき、以降メインとして使っている。&lt;/p&gt;&lt;p&gt;わたしはマウスを「つまみ持ち」する。この M705 はわたしの持ち方に、クリックの押し込みの深さとか、軽く指を曲げた状態での親指と小指の間隔がバッチリハマっていて、同じマウスをずっと使っている。&lt;/p&gt;&lt;p&gt;トラッキングの位置が他のマウスとは結構違っていて、若干操作に癖を感じていたが、そこは慣れだったような記憶がある。&lt;/p&gt;&lt;p&gt;一時期左クリックがチャタリングを起こしたことがあって、数週間別のマウスに乗り換えて使わない時期があったのだが、放置中に直って以降はチャタリングも起こらなくなった(何故)。&lt;/p&gt;&lt;h3 id="異変"&gt;異変&lt;/h3&gt;&lt;p&gt;この M705 だが、グリップ力強化かなんかの理由で、マウスの両サイドがラバーというかやわらかい合成樹脂でできている。
これが利用から 10 年も経った頃から異変を感じるようになった。ボコボコしてきたり擦れるだけでラバーが削れたり。&lt;/p&gt;&lt;p&gt;最近知ったが、これは合成樹脂のブリーディングとかブリードアウトという現象のようだ。合成樹脂の成分自体が分離しだしてるから、拭き取ったりしてどうにかなるものでないということだった。&lt;/p&gt;&lt;p&gt;ここ数年は症状の進行も激しく、指で押すだけで指紋がつくくらいにラバーが劣化していた。&lt;/p&gt;&lt;p&gt;マウスを買い替えることも検討したが、まだメカニカルな部分は動くし、新しいマウスを選ぶのも結構労力がかかるよなーというのが悩みだった。
そこで思い切って、このベタベタボロボロラバーを取り除こうと考えた。&lt;/p&gt;&lt;h3 id="カスタマイズする"&gt;カスタマイズする&lt;/h3&gt;&lt;p&gt;M705 のベタベタボロボロラバーを取り除き、手元にあった黒のテーピングを重ねて貼ることにした。テーピングならラバー部分の形状に合わせることも簡単だし、親指＆小指の接触部分が汚れたとしてもまた貼り直せばいいだけなので、我ながら良いアイデアだ。&lt;/p&gt;&lt;p&gt;ベタボロラバーを取り除くのには、大型刃のカッターナイフと、細かい部分にはデザインナイフを利用した。いずれもオルファだ。&lt;/p&gt;&lt;p&gt;分解してみてわかったが、ラバーのボコボコしていた部分には溶け出した液状の謎成分が溜まっており、中々グロテスクだった。
このマウスはプラスチックの骨格みたいなところにラバーをはめ込み＆貼り付けしてるような構造をしていて、プラスチック部分を極力傷つけないようにした。&lt;/p&gt;&lt;p&gt;小指側のラバーを取り除くのは非常に簡単だった。単にプラウチック部分の弧に合わせてカッターをすべらせるだけでスイスイ剥がせた。&lt;/p&gt;&lt;p&gt;親指側は形状的に窪んでいるので結構難しく、デザインナイフを使ってできるだけ細やかに処理した。特に親指部分のスイッチ(旧モデルにのみあるやつ。進む・戻るボタンじゃなく親指の位置にある)は可動部のラバーを取り除くと空洞になる。配線にカッターのはが届くので慎重に作業する必要があった。&lt;/p&gt;&lt;p&gt;分解を進めると、樹脂の劣化の進行具合が、指に触れる箇所とそうでない箇所で大きく異なるのが見て取れた。
劣化が進んだ箇所はグズグズで、刃を滑らせるのも簡単だったが、親指側の指が触れない部分等は結構元のママの硬度のようで、ちょっと力が必要だった。&lt;/p&gt;&lt;p&gt;ベタボロラバーを取り除いたあとにはテーピングを施す。&lt;/p&gt;&lt;p&gt;曲面へ一枚で貼り付けるのは面倒なので、いくつかの面でテーピングを区切りそれを組み合わせて貼り付けた。
やはり強度面で元のベタボロラバーに大きく劣るので、少なくても二重、親指ん可動部は三重にテーピングすることで強度を持たせてみた。&lt;/p&gt;&lt;h3 id="感想"&gt;感想&lt;/h3&gt;&lt;p&gt;アイデアができてからは、作業に対した時間もかからなかったし、中々やってみてよかった。&lt;/p&gt;&lt;p&gt;結構長い期間をベタボロラバーの状態で触ってきたので、テーピングのサラサラした手触りになって中々新鮮味がある。&lt;/p&gt;&lt;p&gt;まだ使ってみて一週間程度なので、この後どの程度テーピング部分に汚れが蓄積していくかは見えていないが、まあ半年とかのスパンで交換できれば良いか。&lt;/p&gt;&lt;p&gt;お気に入りのマウスをより良い状態に改善し、継続して使い続ける術を新たに身に着けた。&lt;/p&gt;</description><pubDate>Sun, 22 May 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-05-14-think-about-alignment-of-full-width-chars</guid><link>https://krymtkts.github.io/posts/2022-05-14-think-about-alignment-of-full-width-chars</link><title>East Asian な全角文字をキーに使った場合のアラインメントについて考える</title><description>&lt;p&gt;掲題のとおりである。
ここでいうアラインメントはメモリの話じゃなくて、字面上の整列のことを指す。&lt;/p&gt;&lt;p&gt;自分の中でもどうあるべきかまだ結論が出せてないので、考えをまとめるために書く。&lt;/p&gt;&lt;h3 id="問題"&gt;問題&lt;/h3&gt;&lt;p&gt;いま、 &lt;a href="https://github.com/PowerShell/PSScriptAnalyzer"&gt;PSScriptAnalyzer&lt;/a&gt; で全角文字をキーに持つ hashtable を整形したとき期待どおりにならなのだけど、どう解決するのがいいのだろう？と悩んでる。&lt;/p&gt;&lt;p&gt;一応弁解しておくと、わたしの気持ちとしては「そんなところに全角文字使うとか危なげなことやめようや」だ。&lt;/p&gt;&lt;p&gt;ところが、今やってる仕事でスプレッドシートのデータをシステムに取り込むにあたり、それらをいくつかの CSV に分解・再構築する必要があって、その中でこのテーマに直面した。 PSCustomObject を CSV に変換する形でスクリプトを作ってるので、全角文字が識別子になるのだ。&lt;/p&gt;&lt;p&gt;普通に自分が書く範囲だとこんなの書かないので、最近まで気づかなかった。&lt;/p&gt;&lt;p&gt;VS Code で PowerShell を書くと、自動整形には &lt;a href="https://github.com/PowerShell/PSScriptAnalyzer"&gt;PSScriptAnalyzer&lt;/a&gt; の &lt;code&gt;Invoke-Formatter&lt;/code&gt; が使われる。この戻り値が整形後のコードになるのだけど、ここで今回のテーマに直面する。&lt;/p&gt;&lt;p&gt;問題は以下のコードで再現できる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$settings = @{
    IncludeRules = @(
        'PSAlignAssignmentStatement'
    )

    Rules = @{
        PSAlignAssignmentStatement = @{
            Enable = $true
            # PSAlignAssignmentStatement.CheckHashtable が真だと、
            # hashtable の要素の並びを整形してくれる。
            CheckHashtable = $true
        }
    }
}

$script = @'
$test = @{
    A = 0
    ABC = 0
    ABCDE = 0
    Ａ = 0
    ＡＢＣ = 0
    ＡＢＣＤＥ = 0
}
'@
Invoke-Formatter -ScriptDefinition $script -Settings $settings
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;出力はこうなる。これは期待のとおりではない。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$test = @{
    A     = 0
    ABC   = 0
    ABCDE = 0
    Ａ     = 0
    ＡＢＣ   = 0
    ＡＢＣＤＥ = 0
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;わたしはこうなってほしいと考える。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$test = @{
    A          = 0
    ABC        = 0
    ABCDE      = 0
    Ａ         = 0
    ＡＢＣ     = 0
    ＡＢＣＤＥ = 0
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;PSScriptAnalyzer のコードを調べて、 PSScriptAnalyzer 的には PowerShell のパーサが返した列番号(&lt;code&gt;EndColumnNumber&lt;/code&gt;)の通りに整形してるのがわかった。
&lt;a href="https://github.com/PowerShell/PSScriptAnalyzer/blob/58c44234d44dfd0db35bb532906963e08fde8621/Rules/AlignAssignmentStatement.cs#L194"&gt;PSScriptAnalyzer/AlignAssignmentStatement.cs GetHashtableCorrections の L194&lt;/a&gt;&lt;/p&gt;&lt;p&gt;次に PowerShell のパーサを直接調べる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$script = @'
$test = @{
    A = 0
    ABC = 0
    ABCDE = 0
    Ａ = 0
    ＡＢＣ = 0
    ＡＢＣＤＥ = 0
}
'@

function getColumnNumberString {
    param (
        $Extent
    )
    "start $($Extent.StartColumnNumber.ToString().PadLeft(2)) end $($Extent.EndColumnNumber.ToString().PadLeft(2))"
}

$ast = [System.Management.Automation.Language.Parser]::ParseInput($script, [ref]$null, [ref]$null)
$hashAst = $ast.FindAll({ $args[0] -is [System.Management.Automation.Language.HashtableAst] }, $true)
$hashAst.KeyValuePairs | ForEach-Object {
    # Item1 がキーの情報、 Item2 は '=' の情報
    $e1, $e2 = $_.Item1.Extent, $_.Item2.Extent
    "key $(getColumnNumberString($e1)) | '=' $(getColumnNumberString($e2))"
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;出力はこうなって、全角文字の表示幅は考慮されてないのがわかる。&lt;/p&gt;&lt;pre&gt;&lt;code class="txt"&gt;key start  5 end  6 | '=' start  9 end 10
key start  5 end  8 | '=' start 11 end 12
key start  5 end 10 | '=' start 13 end 14
key start  5 end  6 | '=' start  9 end 10
key start  5 end  8 | '=' start 11 end 12
key start  5 end 10 | '=' start 13 end 14
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;じゃあこれは PowerShell のバグなのか？とまで考えを至らせると、いやパーサは表示する文字の幅を意識する必要あるか？と思えるので、これは誰が解決する問題なんや...と思っているのが、今の状況。&lt;/p&gt;&lt;h3 id="他の言語を調べる"&gt;他の言語を調べる&lt;/h3&gt;&lt;p&gt;他の事例を調べて、全角文字を含むキーや識別子をアラインメントするとどうなるか比べてみる。&lt;/p&gt;&lt;p&gt;とはいえ、他の言語でアラインメントするようなフォーマットかける言語何があったっけ？
少なくとも Python は違ったし、思いついたのは Go だけ。
Go 以外にも思いついたら追加したい。&lt;/p&gt;&lt;h4 id="go"&gt;Go&lt;/h4&gt;&lt;p&gt;こんな中身の &lt;code&gt;test.go&lt;/code&gt; があるとする。&lt;/p&gt;&lt;pre&gt;&lt;code class="go"&gt;package main

type person struct {
	A int
	ABC int
	ABCDE int
	Ａ int
	ＡＢＣ int
	ＡＢＣＤＥ int
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これに &lt;code&gt;gofmt ./test.go&lt;/code&gt; すると次の通り。&lt;/p&gt;&lt;pre&gt;&lt;code class="go"&gt;package main

type person struct {
        A     int
        ABC   int
        ABCDE int
        Ａ     int
        ＡＢＣ   int
        ＡＢＣＤＥ int
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;やっぱり！ PowerShell の結果と同じ。&lt;/p&gt;&lt;h3 id="現時点の理解"&gt;現時点の理解&lt;/h3&gt;&lt;p&gt;現実的には、パーサやフォーマッタがフォントの文字幅を考慮しないし、アラインメントしないのが妥当な落とし所なのかな。
気持ちとしては、全角文字を含んだとしても綺麗にアラインメントしてほしいが、それもエッジケースなのでそんなに困ることがない。&lt;/p&gt;&lt;p&gt;とはいえ Unicode 文字の演算子とかポツポツあるし、幅の規定が厳格であればフォーマッタあたりで解消したいテーマではある気がする。&lt;/p&gt;&lt;p&gt;なんか締まらない締めになった。&lt;/p&gt;&lt;p&gt;とりあえず自分用の覚書としては、 PSScriptAnalyzer は &lt;code&gt;PSAlignAssignmentStatement.CheckHashtable=$false&lt;/code&gt; で利用すればこの問題に悩まされることもないので、オススメする。&lt;/p&gt;</description><pubDate>Sat, 14 May 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-05-07-start-to-write-cmdlet-by-fsharp</guid><link>https://krymtkts.github.io/posts/2022-05-07-start-to-write-cmdlet-by-fsharp</link><title>F#で PowerShell コマンドレットを書き始めた</title><description>&lt;p&gt;勉強がてら、F# で PowerShell のコマンドレットを書きはじめる。
↓ を参考にやる。ただし .NET 6.0 を対象にする。&lt;/p&gt;&lt;p&gt;&lt;a href="https://webcoder.info/fspsmodule.html"&gt;Writing a PowerShell Core Module With F#, A Complete Guide | Brianary&lt;/a&gt;&lt;/p&gt;&lt;p&gt;初めての要素が多いので、ゆっくり進める。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;F# でアプリ書くのが初&lt;/li&gt;&lt;li&gt;コマンドレットを書くのが初&lt;/li&gt;&lt;li&gt;dotnet CLI を使った開発が初&lt;/li&gt;&lt;li&gt;その他 PowerShell 系のツール(&lt;a href="https://github.com/pester/Pester"&gt;Pester&lt;/a&gt;,&lt;a href="https://github.com/PowerShell/platyPS"&gt;platyPS&lt;/a&gt;)をちゃんと使うのが初
&lt;ul&gt;&lt;li&gt;参考にする記事にはないが、ビルドスクリプトも &lt;a href="https://github.com/psake/psake"&gt;psake&lt;/a&gt; で書く&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;題材としては、&lt;a href="https://github.com/jasonmarcher/poco"&gt;poco&lt;/a&gt; の再実装をしてみるつもり。&lt;/p&gt;&lt;p&gt;諸々のツールが出てくるので一覧しておく。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;GitHub の Repo の作成に &lt;a href="https://github.com/microsoft/PowerShellForGitHub"&gt;PowerShellForGitHub&lt;/a&gt;&lt;/li&gt;&lt;li&gt;remote repo の管理に &lt;a href="https://github.com/x-motemen/ghq"&gt;ghq&lt;/a&gt;&lt;/li&gt;&lt;li&gt;コミット署名のために &lt;a href="https://community.chocolatey.org/packages/Gpg4win"&gt;Gpg4win&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="repo-とプロジェクトを作成する"&gt;repo とプロジェクトを作成する&lt;/h3&gt;&lt;p&gt;動くものになるまでは private repo で運用する。動かないなら公開しても意味がないからね。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# private repo を作成する。
$owner = 'krymtkts'
$module = 'pocof'
New-GitHubRepository -RepositoryName 'pocof' -Private

# remote repo を clone する。
ghq get -p (Get-GitHubRepository -OwnerName $owner -RepositoryName $module | Select-Object -ExpandProperty ssh_url)
cd "$(ghq root)/$(ghq list $module)"

# initial commit を刻む。
gpg-connect-agent reloadagent /bye # &amp;lt;- gpg-agent が立ち上がってこないので先に起こす。
git commit --allow-empty -m 'Initial commit.'
dotnet new sln

# 空のプロジェクトを作成。
dotnet new classlib --language 'F#' --framework net6.0 -o src/$module
dotnet sln add src/$module/$module.fsproj
cd src/$module
# PowerShell 開発の依存関係を追加。
dotnet add package PowerShellStandard.Library
New-ModuleManifest "$module.psd1"
'&amp;lt;helpItems schema="maml" xmlns="http://msh" /&amp;gt;' | Set-Content "$module.dll-Help.xml" -Encoding utf8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これで repo と空の F# プロジェクト &lt;code&gt;pocof.fsproj&lt;/code&gt; ができた。
次に、記事に記載の通り、 &lt;code&gt;pocof.fsproj&lt;/code&gt; に必要な情報を加筆する。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;PropertyGroup&lt;/code&gt; に &lt;code&gt;Version&lt;/code&gt; 属性を追加&lt;/li&gt;&lt;li&gt;&lt;code&gt;ItemGroup&lt;/code&gt; 属性を追加して、コピーするファイルを記載する&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;また PowerShell のモジュール情報を &lt;code&gt;pocof.psd1&lt;/code&gt; 書き込む。
コマンドレットなので、 &lt;code&gt;RootModule&lt;/code&gt; を書き忘れるとコマンドがインポートできないのでご注意(書き忘れてて &lt;code&gt;Import-Module&lt;/code&gt; しても使えない！となった)。&lt;/p&gt;&lt;p&gt;あと作成後に気づいたのだが、 作成された &lt;code&gt;*.sln&lt;/code&gt; 等のエンコーディングが UTF8 with BOM だったり改行が CRLF だったりするので、それらを UTF8 と LF に手で補正した。&lt;/p&gt;&lt;p&gt;最後に 空の XML-based help file を作成しているが、これは &lt;code&gt;Get-Help&lt;/code&gt; で使うヘルプファイルで、後で PlatyPS で上書きされるやつ。
&lt;a href="https://docs.microsoft.com/en-us/powershell/scripting/developer/help/naming-help-files?view=powershell-7.2"&gt;Naming Help Files - PowerShell | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;h3 id="f-開発環境を準備する"&gt;F# 開発環境を準備する&lt;/h3&gt;&lt;p&gt;わたしは VS Code を使っているので、F# 用の拡張機能を入れる。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://marketplace.visualstudio.com/items?itemName=Ionide.Ionide-fsharp"&gt;Ionide for F# - Visual Studio Marketplace&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;F# でフォーマッタといえば &lt;code&gt;fantomas&lt;/code&gt; のようなのだけど、個別に入れなくても Ionide がうまく拾えるらしい。 &lt;a href="https://github.com/ionide/ionide-vscode-fsharp/issues/1346"&gt;Formatting Settings · Issue #1346 · ionide/ionide-vscode-fsharp&lt;/a&gt;&lt;/p&gt;&lt;h3 id="コードを編集する"&gt;コードを編集する&lt;/h3&gt;&lt;p&gt;自動生成されたコードを編集する。
記事に記載のものだとパラメータに &lt;code&gt;Position&lt;/code&gt; がなくて Pester こけそうなのと、自分のやりたいことに合わせた引数を書くなど諸々の調整をする。&lt;/p&gt;&lt;p&gt;Pester のテストコードも作成する。テストコードは &lt;code&gt;tests&lt;/code&gt; ディレクトリ配下に配置した。&lt;/p&gt;&lt;h3 id="ビルドテスト実行"&gt;ビルド＆テスト実行&lt;/h3&gt;&lt;p&gt;記事に記載の通りだと typo があったり &lt;code&gt;Import-Module&lt;/code&gt; 前に削除があって消えてしまう等ある。
編集して実行した。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ModuleName = Resolve-Path ./src/* | Split-Path -Leaf
Import-LocalizedData -BindingVariable module -BaseDirectory (Resolve-Path ./src/*) -FileName "$ModuleName.psd1"
if ($module.ModuleVersion -ne (Resolve-Path ./src/*/*.fsproj | Select-Xml '//Version/text()').Node.Value) {
    throw 'Module manifest (.psd1) version does not match project (.fsproj) version.'
}
dotnet publish
cp (Resolve-Path ./src/*/bin/Debug/*/publish/FSharp.Core.dll) (Resolve-Path ./src/*/bin/Debug/*/) -Verbose

# import して Pester 実行。
# モジュールのバージョンであったり export される Cmdlet が正しいかなど見る。
Import-Module (Resolve-Path ./src/*/bin/Debug/*/publish/*.psd1) -Force
Invoke-Pester
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;あとこれらを &lt;code&gt;psake&lt;/code&gt; で実行できるように &lt;code&gt;psakefile.ps1&lt;/code&gt; に記載した。&lt;/p&gt;&lt;p&gt;F# のプロジェクトだったら &lt;a href="https://github.com/fsprojects/FAKE"&gt;FAKE&lt;/a&gt; を使った方がいいのかなーと考えていた。となると、依存する &lt;a href="https://fsprojects.github.io/Paket/"&gt;Paket&lt;/a&gt; も入れないといけない。いま &lt;code&gt;dotnet&lt;/code&gt; CLI で管理してたのでいらないかなーと思った。
また、今回作りたいのは PowerShell のコマンドレットなので、 周辺のツールも PowerShell だ。これをいちいち &lt;code&gt;fake.cmd&lt;/code&gt; や &lt;code&gt;dotnet fake build&lt;/code&gt;を介して実行するのなんかダルいな...と億劫だったので、 FAKE の導入は見送ることにした。&lt;/p&gt;&lt;h3 id="ドキュメントを生成する"&gt;ドキュメントを生成する&lt;/h3&gt;&lt;p&gt;記事では &lt;a href="https://github.com/PowerShell/platyPS"&gt;platyPS&lt;/a&gt; を使っているのでそれに従う。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# 事前にビルドしたモジュールを Import-Module しておく。
New-MarkdownHelp -Module pocof -OutputFolder ./docs -ErrorAction SilentlyContinue
# dll-Help.xml を作るときに実行する。
New-ExternalHelp docs -OutputPath (Resolve-Path ./src/*/) -Force
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;コメントに記した通り、他のタスクと依存関係にある。こういうのは &lt;code&gt;psakefile.ps1&lt;/code&gt; にまとめる。&lt;/p&gt;&lt;p&gt;ヘルプの作成元は Markdown をオリジナルとする方針。&lt;/p&gt;&lt;h3 id="powershell-gallery-へのリリース"&gt;PowerShell Gallery へのリリース&lt;/h3&gt;&lt;p&gt;まだやらないけど手順だけ確立しておく。&lt;/p&gt;&lt;p&gt;記事に記載のものだと、ビルドコンフィグレーションを Release にして Import、その後 Import したモジュールを公開、という手順になっている。&lt;/p&gt;&lt;p&gt;個人的にやったことがあるのはフォルダを指定して公開する方だけなので、どっちにするかなーと悩んでいる。間違って古い Import 済みモジュールを公開するミスとかないのかな、というのが疑問。&lt;/p&gt;&lt;p&gt;ま、勉強のためのものであるし、やったことない方を接客的に選んでみるのも一興か。コマンドレットが正しくエクスポートできているか、リリース前にテストするにもこの方法を取るのが良さそうだし。&lt;/p&gt;&lt;p&gt;とはいえ記事に記載の通りやると、自分が普段利用している PowerShell Module のパスに直でリリース前のモジュールを打ち込んでしまう。
これはちょっと実用始めたら困りそうなので、ディレクトリを変える必要がある。
となると結局いつものパス指定でのリリース方式でええんちゃうか...&lt;/p&gt;&lt;p&gt;いずれを選択するかはまた検討したい。&lt;/p&gt;&lt;p&gt;また、これらのリリースタスクも &lt;code&gt;psakefile.ps1&lt;/code&gt; に定義するものとする。&lt;/p&gt;&lt;h3 id="おわりに"&gt;おわりに&lt;/h3&gt;&lt;p&gt;これでひとまず準備完了。
ほぼ記事に記載のとおりやってきたけど、ちょいちょい自分用に変えたり、新しい要素については色々調べながらやってるので、進捗は亀のスピードだった。
動くものをこしらえれたら public repo にしよう。&lt;/p&gt;&lt;p&gt;現時点で不足しているとわかっている点もある。
今回書きたいコマンドレットはインタラクティブなものなので、きっと Pester でテストできない点が出てくる。
それらは &lt;a href="https://fsprojects.github.io/FsUnit/"&gt;FsUnit&lt;/a&gt; を使って可能な限りテストを書きたい所存。&lt;/p&gt;&lt;p&gt;あと困っているのが、参考にしている記事にも記載があったが、 DLL への参照が切れなくてファイルを消したりできなくなる(&lt;code&gt;Remove-Module&lt;/code&gt; 忘れとかでなく)。いまは都度 PowerShell のセッションを作り直してるけど相当に面倒なので、原因を突き止めてどうにかしたいな。&lt;/p&gt;&lt;p&gt;未経験のものに触れるのは普段得られない刺激があって良い。&lt;/p&gt;</description><pubDate>Sat, 07 May 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-04-29-good-bye-omp-module</guid><link>https://krymtkts.github.io/posts/2022-04-29-good-bye-omp-module</link><title>さよなら oh-my-posh モジュール</title><description>&lt;p&gt;いつものように PowerShell Module を更新して PowerShell を立ち上げると次のようなメッセージが表示された。&lt;/p&gt;&lt;pre&gt;&lt;code class="txt"&gt;Hey friend

In an effort to grow oh-my-posh, the decision was made to no
longer support the PowerShell module. Over the past year, the
added benefit of the module disappeared, while the burden of
maintaining it increased.

However, this doesn't mean oh-my-posh disappears from your
terminal, it just means that you'll have to use a different
tool to install it.

All you need to do, is follow the migration guide here:

https://ohmyposh.dev/docs/migrating
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;あら... oh-my-posh 3 から Go で実装されて、マルチプラットフォームなプロンプトテーマエンジンになってたけど、ついにその時が来たか...という感じ。&lt;/p&gt;&lt;p&gt;とりあえず使えなくなる(というか更新できなくなる)と困るので、&lt;a href="https://ohmyposh.dev/docs/migrating"&gt;移行手順&lt;/a&gt; に記載された移行手順を行うことにした。&lt;/p&gt;&lt;h3 id="わたしの移行手順"&gt;わたしの移行手順&lt;/h3&gt;&lt;p&gt;記載の順番にやってもいいけど、慎重を期すため順番を変えた。&lt;/p&gt;&lt;p&gt;まず &lt;code&gt;oh-my-posh&lt;/code&gt; が &lt;code&gt;PATH&lt;/code&gt; にある状態で、 &lt;code&gt;Set-PoshPrompt&lt;/code&gt; を &lt;code&gt;oh-my-posh init pwsh&lt;/code&gt; に変え、プロンプトの表示をチェックした。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# Set-PoshPrompt -Theme ~/.oh-my-posh.omp.json
oh-my-posh init pwsh --config ~/.custom.omp.json | Invoke-Expression
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然のごとくきれいに出力されるので、 PowerShell Module から置き換える。&lt;/p&gt;&lt;p&gt;&lt;a href="https://ohmyposh.dev/docs/installation/windows"&gt;Windows 向けの公式なインストール手順&lt;/a&gt;では &lt;code&gt;winget&lt;/code&gt;, &lt;code&gt;scoop&lt;/code&gt; それか手動での更新になっている。&lt;/p&gt;&lt;p&gt;でもわたしは永らく &lt;code&gt;chocolatey&lt;/code&gt; を使っていることもあり、有志が公開してくれているパッケージを利用する。見たところバージョンも最新に追随していていい感じ。
&lt;a href="https://community.chocolatey.org/packages/oh-my-posh#versionhistory"&gt;Chocolatey Software | Oh-My-Posh 7.74.3&lt;/a&gt;&lt;/p&gt;&lt;p&gt;管理者権限で &lt;code&gt;cmd&lt;/code&gt; を開き、インストールする。補足：PowerShell でもインストールできるが、PowerShell 自体を &lt;code&gt;chocolatey&lt;/code&gt; でインストールしているのもあり &lt;code&gt;chocolatey&lt;/code&gt; でのインストールは &lt;code&gt;cmd&lt;/code&gt; で行うようにしている。&lt;/p&gt;&lt;pre&gt;&lt;code class="cmd"&gt;choco install oh-my-posh -y
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;このインストールの最後に、&lt;/p&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;PROFILE: C:\Users\takatoshi\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1
oh-my-posh has been added to your profile. You may wish to append 'Set-PoshPrompt paradox' to set a theme
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;と言われたが、 Windows PowerShell のプロファイルはおろかどこにも加筆されてないようだった。&lt;/p&gt;&lt;p&gt;管理者権限で PowerShell を起動し、 oh-my-posh の Powershell Module を削除する。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Uninstall-Module oh-my-posh -AllVersions
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Import-Module oh-my-posh&lt;/code&gt; は元々書いてなかったので削除なし。代わりにプロファイルの中でインストール・更新するモジュール名を管理しているので、そこから取り除いた。&lt;/p&gt;&lt;p&gt;以上。&lt;/p&gt;&lt;h3 id="感想"&gt;感想&lt;/h3&gt;&lt;p&gt;何事もなく移行できて良かった。&lt;/p&gt;&lt;p&gt;ただこれを機に、もう oh-my-posh にこだわらず、 &lt;a href="https://starship.rs/"&gt;Starship&lt;/a&gt; みたいなもっとイケてるプロンプトテーマエンジンに積極的に乗り換えてもいいかなーと思えてきた。&lt;/p&gt;&lt;p&gt;元々 oh-my-posh を使ってたのは、 2018 年頃の PowerShell でいい感じの Powerline ができる唯一のツールだったからだ(わたしの観測範囲では。もう一つその名の通り Powerline というモジュールがあったが満足の行くカスタマイズができなかった&lt;sup id="fnref-1"&gt;&lt;a class="footnote-ref" href="#fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt;)。
テーマを PowerShell で書けて、PowerShellGet からインストールできるのも楽だった。&lt;/p&gt;&lt;p&gt;とはいえ、それがマルチプラットフォームに対応した oh-my-posh の足枷になったみたいやけど。&lt;/p&gt;&lt;p&gt;逆に利用者の立場からいえば、 oh-my-posh が明確に PowerShell に特化しなくなったということ。
これは、わたしが Power Fighter(勝手に作った PowerShell 使いの呼び名)であるから oh-my-posh を使い続けていたという理由もなくなったことになる。&lt;/p&gt;&lt;p&gt;oh-my-posh が Go で書き換わったときに一番気に入らなかったのは &lt;em&gt;&lt;strong&gt;設定ファイルが JSON&lt;/strong&gt;&lt;/em&gt; なとこなので、そのフラストレーションを解消するいい機会をもらったのかも知れない。&lt;/p&gt;&lt;div class="footnotes"&gt;&lt;hr /&gt;&lt;ol&gt;&lt;li id="fn-1"&gt;&lt;p&gt;まだあったわ →&lt;a href="https://www.powershellgallery.com/packages/PowerLine/3.4.0"&gt;PowerShell Gallery | PowerLine 3.4.0&lt;/a&gt;&lt;/p&gt;&lt;a href="#fnref-1" class="footnote-backref"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description><pubDate>Fri, 29 Apr 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-04-23-aws-rehabilitation</guid><link>https://krymtkts.github.io/posts/2022-04-23-aws-rehabilitation</link><title>AWS リハビリのハマり集</title><description>&lt;p&gt;現職は半年ぶりの AWS ということで、ちまちまリハビリをしている。
諸々忘れてたりものによってはハマっている現状。記憶に定着させるため、ハマったところを記す。&lt;/p&gt;&lt;h3 id="hello-world-以外の-sam-init-できません"&gt;Hello World 以外の &lt;code&gt;sam init&lt;/code&gt; できません&lt;/h3&gt;&lt;p&gt;AWS SAM は前職でも使っていたが、久しぶりに触ったら詰まるところがあったので書いておく。&lt;/p&gt;&lt;p&gt;久しぶりに &lt;code&gt;sam init&lt;/code&gt; すると 100%エラーで終わる。端末は Windows 11。
こんな風に ↓。&lt;/p&gt;&lt;pre&gt;&lt;code class="log"&gt;Cloning from https://github.com/aws/aws-sam-cli-app-templates (process may take a moment)
Error: Can't find application template quick-start-web - check valid values in interactive init.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href="https://github.com/aws/aws-sam-cli/issues/3692#issuecomment-1070222512"&gt;Unable to create Serverless API using SAM v1.40.0 · Issue #3692 · aws/aws-sam-cli&lt;/a&gt;&lt;/p&gt;&lt;p&gt;どうも Windows 限定の問題らしい。 &lt;code&gt;sam&lt;/code&gt; が使う template repository を &lt;code&gt;git clone&lt;/code&gt; できないという深刻なやつ。
AWS SAM の一時ディレクトリを消して、手動で &lt;code&gt;git clone&lt;/code&gt; したら解消する。これは Issue は Closed になっているものの、中々気付かんし原因を究明したい気がする。&lt;/p&gt;&lt;h3 id="mfa-有効化されたアクセスキーの使い方忘れた"&gt;MFA 有効化されたアクセスキーの使い方忘れた&lt;/h3&gt;&lt;p&gt;タイトルの通り。&lt;/p&gt;&lt;p&gt;そのまま使うとワンタイムパスの入力を求められないが、一時クリデンシャルを発行するときに出る。&lt;/p&gt;&lt;p&gt;昔は MFA が必要な switch role するときに aws-mfa を使っていたが、 この度 AWS Tools for PowerShell で自分の利用ケースのみシンプルにこしらえた。
ワンタイムパスワードの入力には 1Password の CLI である &lt;a href="https://developer.1password.com/docs/cli/get-started"&gt;&lt;code&gt;op&lt;/code&gt;&lt;/a&gt; を使うと究極に楽。現職で 1Password を使ってるので導入したみた。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$env:AWS_REGION = 'ap-northeast-1'
$user = 'krymtkts'
$AWSLogin = 'AWS'
$c = Get-STSSessionToken -SerialNumber (Get-IAMMFADevice -UserName $user).SerialNumber -TokenCode (op item get $AWSLogin --otp) -ProfileName $user
$env:AWS_ACCESS_KEY_ID = $c.AccessKeyId
$env:AWS_SECRET_ACCESS_KEY = $c.SecretAccessKey
$env:AWS_SESSION_TOKEN = $c.SessionToken
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;楽～。これは PowerShell の profile に関数書いておいた。&lt;/p&gt;&lt;h3 id="aws-tools-for-powershell-は自動補完で一覧する-profile-を絞り込んでる"&gt;AWS Tools for PowerShell は自動補完で一覧する profile を絞り込んでる&lt;/h3&gt;&lt;p&gt;&lt;code&gt;.aws/credentials&lt;/code&gt; にこういう profile があるとする。これ、 &lt;code&gt;mfa_serial&lt;/code&gt; が紛れ込んでる。&lt;/p&gt;&lt;pre&gt;&lt;code class="ini"&gt;[profile]
aws_access_key_id = XXXXXXXXXXXXXXXXXXXX
aws_secret_access_key = XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
mfa_serial = xxx
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;AWS CLI のタブ補完コマンド &lt;code&gt;aws_completer&lt;/code&gt; はこういうのがあっても問題なく profile を一覧できるが、 AWS Tools for PowerShell では一覧されなくなる。 &lt;code&gt;mfa_serial&lt;/code&gt; 以外には &lt;code&gt;role_arn&lt;/code&gt;, &lt;code&gt;source_profile&lt;/code&gt; があると一覧されなくなる。&lt;/p&gt;&lt;p&gt;これ初めて知った。今後は、書き間違ってるから一覧されないんだ～と思いつくことができるが、一発目だったのでとても時間がかかった。ドキュメントに書いてる挙動なんかな～しらんけど。今度調べたい(いつ)。&lt;/p&gt;&lt;p&gt;続くかも。&lt;/p&gt;</description><pubDate>Sat, 23 Apr 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-04-16-convert-hatena-xml-to-md</guid><link>https://krymtkts.github.io/posts/2022-04-16-convert-hatena-xml-to-md</link><title>古のはてなダイアリー XML を Markdwon に変換する(いい感じに)</title><description>&lt;p&gt;先日 Google ドライブの中に眠っていた XML を発掘した。古のはてなダイアリーからエクスポートされたやつだこれ。&lt;/p&gt;&lt;p&gt;昔、プレーンテキストで日記をつけ始める前に、誰に見せるでもないブログを書いていた。何度かブログサービスに書いては止めるを繰り返していた。
そのうち最も最近までやってたのがはてなダイアリーで、そのバックアップがこれっぽい。
178 記事、2009 ~ 2011 の 3 年間もあるのに、すっかり忘れていた。&lt;/p&gt;&lt;p&gt;これはぜひ今の日記に統合したい。ということではてなダイアリーの XML を Markdown に変換して取り込むことにした。&lt;/p&gt;&lt;h3 id="変換する"&gt;変換する&lt;/h3&gt;&lt;p&gt;今回は Pandoc を使わず純粋に PowerShell だけで処理する。
Pandoc で&lt;a href="https://help.hatenablog.com/entry/text-hatena-list"&gt;はてな記法&lt;/a&gt;から Markdown に変換できるが、ごく一部の記事は既に日記があって追記しないといけないこともあり、PowerShell だけでやる方が融通が利く。&lt;/p&gt;&lt;p&gt;XML なら PowerShell の主戦場なので、何をするにも楽だ。
使っているはてな記法もおおよそパターンマッチで置換できる(鬼の連続置換)。&lt;/p&gt;&lt;p&gt;引用だけ正規表現での変換がわからんけど、一桁件数しかなかったので、手で書き換える。&lt;/p&gt;&lt;p&gt;以下変換スクリプト。 &lt;code&gt;hatena2md.ps1&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;[CmdletBinding()]
param (
    [Parameter(
        Mandatory,
        HelpMessage = "XML Path of hatena diary.")]
    [ValidateScript({
            if (-Not ($_ | Test-Path) -or ($_ -notmatch "\.xml")) {
                throw "The file specified in the XmlPath argument must be XML."
            }
            return $True
        })]
    [System.IO.FileInfo]
    $XmlPath,
    [Parameter(
        Mandatory,
        HelpMessage = "Output Path of Markdown diaries.")]
    [ValidateScript({
            if (-Not (Test-Path $_ ) -or -not (Test-Path $_ -PathType Container)) {
                throw "The BlogPath argument must be a folder."
            }
            return $True
        })]
    [System.IO.FileInfo]
    $BlogPath
)

$xml = [XML](Get-Content $XmlPath)
Write-Host "Convert $($xml.diary.day.Length) hatena XML to Markdown."

$xml.diary.day | ForEach-Object {
    $date = Get-Date $_.date -ErrorAction SilentlyContinue
    if (-not $?) {
        Write-Error "Cannot convert diary of $($_.date)"
        return
    }
    $diaryPath = "$BlogPath/$($date.Year)/$($date.ToString('yyyy-MM'))/$($date.toString('dd')).md"
    Get-ChildItem $diaryPath -ErrorAction SilentlyContinue | Out-Null
    if ($?) {
        Write-Host "Add Content to exists diary of $($_.date)"
        $InvokeContent = 'Add-Content'
        $content = @"

## はてなの日記

"@
    }
    else {
        Write-Host "Create new diary of $($_.date)"
        $InvokeContent = 'Set-Content'
        mkdir -Force (Split-Path $diaryPath -Parent) | Out-Null
        $content = @"
# $($date.ToString('yyyy-MM/dd (ddd)'))

## はてなの日記

"@
    }
    $content += (
        $_.body -split "`n" | ForEach-Object {
            $_ `
                -replace '^\*\d+\*(.+)$', "### `$1`n" `
                -replace '^=+$', "`n---`n" `
                -replace '^--(.+)', '    - $1' `
                -replace '^-(.+)', '- $1' `
                -replace '^\+\+(.+)', '    1. $1' `
                -replace '^\+(.+)', '1. $1' `
                -replace '\&amp;gt;\|(\w+)\|', "`n```````$1" `
                -replace '(\&amp;gt;\|\||\&amp;gt;\|)', "`n``````" `
                -replace '(\|\|\&amp;lt;|\|\&amp;lt;)', "```````n" `
                -replace '\[(.+?)\:title=(.+?)]', '[$2]($1)'
        }) -join "`n"
    $content | &amp;amp; $InvokeContent -Path $diaryPath -Encoding utf8 -NoNewline | Out-Null
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;はてなダイアリーの XML から、自分の日記の構造に変換している。
はてなダイアリーの記事にはわかりやすく「はてなの日記」というセクションを設ける。&lt;/p&gt;&lt;p&gt;基本ファイルを作成するが、既存のファイルが存在する場合は、追記する。
先述の通りセクションがあるので追記しても自然だ。&lt;/p&gt;&lt;p&gt;ディレクトリ構造は&lt;a href="/posts/2022-04-02-convert-textile-to-md"&gt;前回の Textile → Markdown 変換&lt;/a&gt; で記した通り ↓ 。 1 つの XML からこの形にファイルを出力する。&lt;/p&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;+---2013
|   +---2013-01
|   |       17.textile
|   ︙      ︙
︙
\---2022
   +---2022-01
   ︙
   \---2022-03
            01.md
            ︙
            31.md
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;実行する。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;. .\hatena2md.ps1 -XmlPath $XmlPath -BlogPath $BlogPath
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="変換後の処理"&gt;変換後の処理&lt;/h3&gt;&lt;p&gt;変換後のファイルから&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; で検索して該当するものを一覧し、書き換える。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;ls -File -Recurse | ? {cat $_ | % {$_ -split "`n"} | ? {$_ -match '^&amp;gt;&amp;gt;'}} | select -Property FullName
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ココに来て順序付きリストの数字をやっぱりインクリメントしたい(前のステップでは&lt;code&gt;1.&lt;/code&gt;固定でいいかと思ってた)...ということで一部書き直した。&lt;/p&gt;&lt;p&gt;最後に全体を &lt;a href="https://prettier.io/"&gt;Prettier&lt;/a&gt; で清書する。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;prettier --write .
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最終チェックをして完了。&lt;/p&gt;&lt;h3 id="まとめ"&gt;まとめ&lt;/h3&gt;&lt;p&gt;Textile からの変換よりも、量が 1/10 程度と少なかったこともあり、簡単にできた。&lt;/p&gt;&lt;p&gt;コンテンツそれ自体は中々に青臭く、読んでると「わー！！！」と声を上げたくなるところもある。
ただ人生の転機が集中した期間だったこともあって、興味深い内容だった。貴重なログなので、これまた自己分析に使いたい。&lt;/p&gt;</description><pubDate>Sat, 16 Apr 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-04-09-jobchange-2022</guid><link>https://krymtkts.github.io/posts/2022-04-09-jobchange-2022</link><title>転職した 2022</title><description>&lt;p&gt;また転職した。&lt;a href="/posts/2021-09-28-jobchange-2021"&gt;前回の転職&lt;/a&gt;から半年しか経ってないけど。&lt;/p&gt;&lt;p&gt;退職前に諸々の誓約書に署名してるので諸々の守秘義務があり、多くを語ることはできない。
結構高く評価してもらってたのに辞めた理由を語るとすれば、ただひとえに「音楽性の違い」が原因かな。
あ、入社して知り合った 1 ヶ月パイセンが信頼のおける人だったのは良かった。&lt;/p&gt;&lt;p&gt;幸運にも、より良い条件で次のご縁があったので、これは自分の真摯な姿勢が信頼を紡いできたおかげなんかなーと自分自身を讃えてみる。讃えてみるテスト。&lt;/p&gt;&lt;p&gt;結果的にジョブホッパーみたいになってしまったから、ヘッドハンター()とかには「キャリアに傷がついてる」とかいちびられそうだが、こちとら仕事はちゃんと納めたからええのよ。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;この半年の間で伸びたところもなくはないけど、結構停滞感みたいなのを感じていた。
結局半年の間、技術情報を交換したり意見することもないし、あらゆる権限がなくて何なら自分の Google アカウントのアバターを変更する権限もなかった。全然人に会うこともなくコミュニケーションは週 1 回くらいとかだったので、初対面の人と会話したり、単に送るメッセージ考えるのも疲れるというのが現状。&lt;/p&gt;&lt;p&gt;自分の職掌にはクラウドの「ク」もなく、全く触ることがなかったので、使っていない筋肉が随分衰えてしまった。
細かいことを忘れてるので、現職でしょーもないことであっても「アレ？どうやっけ？」となったりする。まだリハビリ中。&lt;/p&gt;&lt;p&gt;また、ビジネスサイドの声から遠ざかっていたことで、言葉の理解力とか肌感覚が鈍った気がする。ここもリハビリ中。&lt;/p&gt;&lt;p&gt;たった 1 週間程働いてみこの感覚なので、これからも他の衰えに気づくことが度々あるだろう。&lt;/p&gt;&lt;p&gt;いずれの衰えも「強くてニューゲーム」できると嬉しいけど、そこはやってみないとわからんから、ただただ真摯に取り組むのみやな。自分の変化に気づけてるだけでアドバンテージかな。&lt;/p&gt;&lt;p&gt;それにしても久しぶりに「仕事してる！」という実感があって良い。これはまさに「音楽性」が一致した結果なんかな。しらんけど。&lt;/p&gt;&lt;p&gt;ただのポエムになった。&lt;/p&gt;</description><pubDate>Sat, 09 Apr 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-04-02-convert-textile-to-md</guid><link>https://krymtkts.github.io/posts/2022-04-02-convert-textile-to-md</link><title>Textile を Markdown に変換する(いい感じに)</title><description>&lt;p&gt;プレーンテキストで日記をつけ始めて今年で 9 年目になったぽい。
その日記だが、昔 Redmine を使ってたこともあって、最初の 5 年位の間 &lt;a href="https://textile-lang.com/"&gt;Textile&lt;/a&gt; で日記を書いていた時期がある。
この頃の文書を Markdown に変換したいと度々思っていたが、最近重い腰を上げて取り組み始めた。&lt;/p&gt;&lt;p&gt;マークアップ言語の相互変換といえば、やはり Haskell で書かれた &lt;a href="https://pandoc.org/"&gt;Pandoc&lt;/a&gt; やろーというのが個人的なイメージ。簡単なケースで永らく使ってきたが、今回は困ったというか一筋縄ではいかない点が出てきた。&lt;/p&gt;&lt;p&gt;例えば、 Pandoc で過去の日記を Textile から Markdown に変換するとしたらこんな感じのコマンドになる。&lt;/p&gt;&lt;p&gt;(以降は視認性を確保するため、実際に実行したコマンドに改行を含めて記載する)&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;pandoc --from=textile --to=gfm+east_asian_line_breaks `
       --shift-heading-level-by=-4 --eol=lf --wrap=preserve `
       ./diary.textile --output=./diary.md
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参照 &lt;a href="https://pandoc.org/MANUAL.html"&gt;Pandoc - Pandoc User’s Guide&lt;/a&gt;&lt;/p&gt;&lt;p&gt;結構いい感じの結果を導くオプションの組み合わせに手間取った。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;改行に半角スペース 2 つを使い、表の syntax も使うので &lt;code&gt;gfm+east_asian_line_breaks&lt;/code&gt;&lt;/li&gt;&lt;li&gt;見出しのレベルを変えるための &lt;code&gt;shift-heading-level-by=-4&lt;/code&gt; を指定
&lt;ul&gt;&lt;li&gt;Redmine の見た目上 &lt;code&gt;h5.&lt;/code&gt; にしてた(確か)&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;改行コードは LF で統一する &lt;code&gt;--eol=lf&lt;/code&gt;&lt;/li&gt;&lt;li&gt;長い行に空白があると折り返そうとするので &lt;code&gt;--wrap=preserve&lt;/code&gt; 原文を維持する&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;仮に日記が以下のような記述とする。&lt;/p&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;h5. 見出し

# 順序付きリスト1
** 箇条書きリスト1-1
# 順序付きリスト2
** bullet listアイテム2-1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
* 箇条書きリスト3
## 箇条書きリスト3-1
箇条書きリスト3-1の 改行したコンテンツ

* *箇条書きリスト2*
箇条書きリスト2。
|_.行1|1|
|_.行2|20|

* *箇条書きリスト3*
&amp;lt;pre&amp;gt;
コード
&amp;lt;/pre&amp;gt;
テキスト

|_.行1|1|
|_.行2|20|

    |_.行1|1|
    |_.行2|20|

&amp;lt;pre&amp;gt;&amp;lt;code class='sh'&amp;gt;
コード
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これを先述のコマンドで Textile から Markdown に変換すると...&lt;/p&gt;&lt;pre&gt;&lt;code class="md"&gt;# 見出し

\# 順序付きリスト1

箇条書きリスト1-1

\# 順序付きリスト2

bullet listアイテム2-1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

-   箇条書きリスト3
    1.  箇条書きリスト3-1  
        箇条書きリスト3-1の 改行したコンテンツ

&amp;lt;!-- --&amp;gt;

-   **箇条書きリスト2**  
    箇条書きリスト2。  
    \|\_.行1\|1\|  
    \|\_.行2\|20\|

&amp;lt;!-- --&amp;gt;

-   **箇条書きリスト3**
        コード

      
    テキスト

| 行1 | 1   |
|-----|-----|
| 行2 | 20  |

\|\_.行1\|1\|  
\|\_.行2\|20\|

    &amp;lt;code class='sh'&amp;gt;
    コード
    &amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;このように、おもしろいことになる。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;順序付きリストと箇条書きリストが同じレベルに存在すると、後ろの方(この場合箇条書きリスト)しか変換できない
&lt;ul&gt;&lt;li&gt;これは事前に混在するリストを Textile から取り除くしかないか&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;リストと文の間の過剰な空白が気持ち悪い
&lt;ul&gt;&lt;li&gt;まだどうにかできそうなオプションを見つけられていないので、これは Textile -&amp;gt; Markdown 変換後に Prettier で変換する必要があるか&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;新たに挿入された謎の HTML コメントの行は、以下の Pandoc の仕様によるらしい
&lt;ul&gt;&lt;li&gt;&lt;a href="https://pandoc.org/MANUAL.html#ending-a-list"&gt;Ending a list | Pandoc - Pandoc User’s Guide&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;blockquote&gt;&lt;p&gt;To “cut off” the list after item two, you can insert some non-indented content, like an HTML comment, which won’t produce visible output in any format:&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;表の変換は、箇条書きに連続しない＆インデントされていない箇所に限り、 Markdown の Table Syntax に変換される&lt;/li&gt;&lt;li&gt;当時の Redmine で使えなかったこともあり、コードブロックを &lt;code&gt;&amp;lt;pre&amp;gt;&amp;lt;code class='lang'&amp;gt;&lt;/code&gt; で表現していた。これが Markdown に変換したとき &lt;code&gt;pre&lt;/code&gt; 要素だけ解釈されてしまう&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;1,4 は Pandoc で変換をかける前に手で直さざるを得ないので、正規表現に引っかかる範囲は一括変換をかける。1000 超える Textile ファイルがあるので流石に手作業は無理、可能な限り一括変換や。&lt;/p&gt;&lt;p&gt;2, 3, 5 は変換後に対処する。これも機械的にどうにでもできそうか。&lt;/p&gt;&lt;p&gt;日記のディレクトリ構造はこのような形になっており、変換作業はルートディレクトリから行う。&lt;/p&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;+---2013
|   +---2013-01
|   |       17.textile
|   |       18.textile
|   ︙      ︙
|   \---2013-12
︙
\---2022
   +---2022-01
   ︙
   \---2022-03
            01.md
            ︙
            31.md
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(色々 try &amp;amp; error して変換していたので、 入力の手間を省く目的でわかりきったコマンドはエイリアスを多用している)&lt;/p&gt;&lt;h3 id="4-の解消"&gt;4 の解消&lt;/h3&gt;&lt;p&gt;インデントされている表はなかったが、箇条書きの後に表が記載されているパターンがあり、そのうち、以下の 2 パターンがあった。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;箇条書き直後に表がある&lt;/li&gt;&lt;li&gt;箇条書きの後、更に文を挟んだ後に表がある&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;この 2 を引っ掛けるパターンを書くのに難儀した。
何故なら、表の syntax の行末に余分に空白や不要な文字がついていて、どうにもわたしの正規表現力では引っ掛けられない。&lt;/p&gt;&lt;p&gt;どうにもうまくできないので妥協して、 2 回に分けて変換する。&lt;/p&gt;&lt;p&gt;1 については雑ながらも一括変換可能。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;ls -Recurse -File *.textile |
? {(cat $_.FullName ) -join "`n" | sls -Pattern '(\*|#).+\n\|'} |
%{
    $file = $_.FullName
    ((cat $file) -join "`n") -replace '((\*|#).+\n)(\|)',"`$1`n`$3" |
        Set-Content $file -NoNewline
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;改行コードは LF を使うので &lt;code&gt;-NoNewLine&lt;/code&gt; だ。&lt;/p&gt;&lt;p&gt;2 はリストアップして清書がてら手メンテ...&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# ファイル一覧をクリップボードへ
ls -Recurse -File *.textile | ? {
    (cat $_.FullName ) -join "`n" | sls -Pattern '\n[^\*#\|].+\n\|'
} | select -ExpandProperty FullName | Set-Clipboard
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="1-の解消"&gt;1 の解消&lt;/h3&gt;&lt;p&gt;Textile を見るに、箇条書きの後に太字 &lt;code&gt;*〇〇*&lt;/code&gt; を書いて見出しの代わりにしたかったような気配がするので、それを除外した順序づき/箇条書きリストを変換の対象にする。&lt;/p&gt;&lt;p&gt;番号を参照していたりすると文脈が失われるので、一括変換できるか対象 23 件を目検したところ、レベル誤りだったり単に順序付きリストにし忘れているだけの箇所だったり。
それぞれに対処の仕方が異なるので、仕方ないがリストアップした対象を清書がてら手メンテ(2 回目)...&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# ファイル一覧をクリップボードへ
ls -Recurse -File *.textile | ? {
    (cat $_.FullName | ? {$_ -match '(^\*\s[^\*]|^#\s[^\*])'}) -join "`n" |
        sls -Pattern '(\*.+\n#|#.+\n\*)'
} | select -ExpandProperty FullName | Set-Clipboard
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="textile---markdown-の変換"&gt;Textile -&amp;gt; Markdown の変換&lt;/h3&gt;&lt;p&gt;先述の通りのオプションで Pandoc を実行する。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;ls -Recurse -File *.textile | %{
    pandoc `
        --from=textile --to=gfm+east_asian_line_breaks `
        --shift-heading-level-by=-4 --eol=lf `
        $_.FullName --output="$($_.Directory)\$($_.Name -replace 'textile','md')"
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="3-の解消"&gt;3 の解消&lt;/h3&gt;&lt;p&gt;変換後、まず最初に &lt;code&gt;&amp;lt;!-- --&amp;gt;&lt;/code&gt; を取り除く。最後に Prettier を実行してきれいな状態にしたいからだ。&lt;/p&gt;&lt;p&gt;置換対象が Pandoc によって追加されたコメントだけなのか調べる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; ls -Recurse -File *.md | % {cat $_.FullName | sls -Pattern '^&amp;lt;!--.+--&amp;gt;'} | group

Count Name                      Group
----- ----                      -----
 2275 &amp;lt;!-- --&amp;gt;                  {&amp;lt;!-- --&amp;gt;, &amp;lt;!-- --&amp;gt;, &amp;lt;!-- --&amp;gt;, &amp;lt;!-- --&amp;gt;…}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;問題ないようなので一括置換する。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;ls -Recurse -File *.md | ? {sls -Path $_.FullName -Pattern '^&amp;lt;!--.+--&amp;gt;'} | %{
    $file = $_.FullName
    (cat $file | ? {$_ -notmatch '^&amp;lt;!--.+--&amp;gt;'}) -join "`n" |
        Set-Content $file -NoNewline
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;この一括変換結果、1000 超のファイルの差分に問題ないか &lt;code&gt;git diff --word-diff&lt;/code&gt; で見る。流石に多いので変更をグルーピングして見た。全部同じ変換結果なら1つにまとまる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;git diff --word-diff | ? {$_ -match '\[(\+|-)'} | group
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;この置換により HTML コメント削除後は空行が 2 行になり、かつ文末の改行が消えてしまうが、後に行う Prettier で補修される(はず)。&lt;/p&gt;&lt;h3 id="5-の解消"&gt;5 の解消&lt;/h3&gt;&lt;p&gt;幸い、&lt;code&gt;class&lt;/code&gt; 属性なしの &lt;code&gt;code&lt;/code&gt; タグはなかった。&lt;/p&gt;&lt;p&gt;&lt;code&gt;&amp;lt;code class="${language}"&lt;/code&gt; → &lt;code&gt;```${language}&lt;/code&gt; 、 &lt;code&gt;&amp;lt;/code&amp;gt;&lt;/code&gt; → &lt;code&gt;```&lt;/code&gt; へ変換する。一緒にやるイメージがなかったので 2 回置換する。
同時に、&lt;code&gt;pre&lt;/code&gt; タグが変換されたことによる半角スペース 4 個 があると文章のインデントと合わず正しくレンダリングできないので、取り除く。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;ls -Recurse -File *.md | ? {sls -Path $_.FullName -Pattern '&amp;lt;code class='} | % {
    $file = $_.FullName
    (cat $file | % {
        $_ -replace '\s{0,4}&amp;lt;code class="(\w+)"&amp;gt;','```$1' `
           -replace '\s{0,4}&amp;lt;/code&amp;gt;','```'
    }) -join "`n" | Set-Content $file -NoNewline
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="2-の解消"&gt;2 の解消&lt;/h3&gt;&lt;p&gt;&lt;a href="https://prettier.io/"&gt;Prettier&lt;/a&gt; を使う。数年前から Markdown の整形に使っているのでそれに合わせる。&lt;/p&gt;&lt;p&gt;&lt;code&gt;ForEach-Object&lt;/code&gt; して 1 ファイルずつ &lt;code&gt;prettier&lt;/code&gt; を実行するとそこそこに遅い。 &lt;a href="https://en.wikipedia.org/wiki/Glob_(programming)"&gt;glob&lt;/a&gt; にまとめた方が速く実行できるので、ちょっとパターンが雑だがそのようにする。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;prettier --write "**/{$((
    ls -Recurse -File *.textile | select -ExpandProperty DirectoryName |
    Split-Path -Leaf | group | select -ExpandProperty Name ) -join ',')}/*.md"
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;が、先述のコマンドを実行したあとでPrettier 導入前から Markdown で書いていた古い日記もあまり綺麗でないことが判明した。
なので、全体的に整形してしまう。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;prettier --write .
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;このとき箇条書きの書き忘れが見つかった。後述するような箇条書きがあると、 &lt;code&gt;prettier&lt;/code&gt; に見出しと判断されてレイアウトが崩れるので、事前に手で取り除く。&lt;/p&gt;&lt;pre&gt;&lt;code class="txt"&gt;- Bad な bullet list
  -
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="最終チェック"&gt;最終チェック&lt;/h3&gt;&lt;p&gt;ココまで来たらもう大丈夫やろう、という感じで最終チェックしてたら、ココに来て痛恨のミス。
どうも箇条書き/順序付きリストの階層を誤っていると変換に失敗するようだった。
1 の解消のときに回収しきれていないかった。&lt;/p&gt;&lt;p&gt;before.&lt;/p&gt;&lt;pre&gt;&lt;code class="textile"&gt;** 壊れる箇条書きリスト
#### 壊れる順序付きリスト
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;after.&lt;/p&gt;&lt;pre&gt;&lt;code class="textile"&gt;壊れる箇条書きリスト

\#### 壊れる順序付きリスト
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;調べてみたら 50 ファイルくらい結構派手にぶち壊れている部分があった。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;ls -Recurse -File *.md | ? {sls -Path $_.FullName -Pattern '\\(\*|#)\s'} |
    select -ExpandProperty FullName
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これらは textile の段階から手直しし、 Textile → Markdown の変換からやり直す。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;ls -Recurse -File *.md | ? {sls -Path $_.FullName -Pattern '\\(\*|#)\s'} | % {
    pandoc `
        --from=textile --to=gfm+east_asian_line_breaks `
        --shift-heading-level-by=-4 --eol=lf `
        ($_.FullName -replace '.md','.textile') --output="$($_.FullName)"
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;この後で先に行っていた 2,3,5 の変換をすれば、期待の変換結果が得られた。&lt;/p&gt;&lt;h3 id="後始末"&gt;後始末&lt;/h3&gt;&lt;p&gt;最後に、残しておいた Textile を全て削除する。当然、削除対象が正しいことを確認した後に消す。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# Dry run.
rm * -Include *.textile -Recurse -WhatIf
# Execution.
rm * -Include *.textile -Recurse
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="まとめ"&gt;まとめ&lt;/h3&gt;&lt;p&gt;なかなか手間がかかったが、うまくできた。
今回の移行作業の中で、検知していない見落としもあるはずなので、そういうものは見つけたときに対処するものとする。&lt;/p&gt;&lt;p&gt;以下気づき。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Pandoc のオプションが大量にあり選ぶのが大変だが、おかげで期待する変換がしやすい
&lt;ul&gt;&lt;li&gt;2013 年位からちょくちょく使うがこんなにゴテゴテとオプションをつけたのは初めて&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;「息の長くなりそうなドキュメント」は事前にわからないので、普段からきれいなフォーマットにすれば、後々変換する機会があっても手間が省ける&lt;/li&gt;&lt;li&gt;プレーンテキストは正義&lt;/li&gt;&lt;li&gt;複数行またがるタイプの正規表現のパターン記述力が足りない&lt;/li&gt;&lt;li&gt;日記に事象と感情の変化をセットで書いていたので、あとから見ても面白い。自己分析に使えそう&lt;/li&gt;&lt;/ul&gt;</description><pubDate>Sat, 02 Apr 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-03-26-merge-blog-repo</guid><link>https://krymtkts.github.io/posts/2022-03-26-merge-blog-repo</link><title>Blog 用 Git repositories のマージ</title><description>&lt;p&gt;&lt;a href="/posts/2022-03-05-customize-cryogen"&gt;Cryogen の更新&lt;/a&gt; で 2 つに別れていた repo を統合できるようになったので、した。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/krymtkts.github.io"&gt;krymtkts/krymtkts.github.io&lt;/a&gt; に &lt;a href="https://github.com/krymtkts/blog-cryogen"&gt;krymtkts/blog-cryogen&lt;/a&gt; の歴史をすべて引き込む。&lt;/p&gt;&lt;p&gt;元は 1 つのコンテンツを 2 つに分けてるだけなので、統合は簡単だった。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;git switch --create feature/merge-repo

# Move existing blog contents.
mkdir docs
ls -Exclude docs | %{mv $_.Name ./docs }
git add .
git commit -m "Move blog files to 'docs'."
# Merge generator repo.
git remote add upstream ssh://git@krymtkts.github.com:krymtkts/blog-cryogen.git
git fetch upstream
git merge --allow-unrelated-histories upstream/master
# miscellaneous work.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;次に GitHub Pages の Source を &lt;code&gt;/docs&lt;/code&gt; に変えて表示確認する。
PR 作成後、GitHub Pages の対象 branch をマージ用の branch に向けて、 GitHub Actions による deploy を確認した。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;GitHub Pages の Source を &lt;code&gt;master&lt;/code&gt; の &lt;code&gt;/(root)&lt;/code&gt;-&amp;gt; &lt;code&gt;feature/merge-repo&lt;/code&gt; の &lt;code&gt;/docs&lt;/code&gt; に変えて deploy 確認&lt;/li&gt;&lt;li&gt;PR をマージ＆ branch を残す&lt;/li&gt;&lt;li&gt;GitHub Pages の Source を &lt;code&gt;feature/merge-repo&lt;/code&gt; の &lt;code&gt;/docs&lt;/code&gt; -&amp;gt; &lt;code&gt;master&lt;/code&gt; の &lt;code&gt;/docs&lt;/code&gt; に変えて deploy 確認&lt;/li&gt;&lt;li&gt;&lt;code&gt;feature/merge-repo&lt;/code&gt; を消す&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;branch を消したときに自動で Source を追随してくれんのかも知れんが、 壊れたら面倒なので 1 手順ずつ確認した。&lt;/p&gt;&lt;p&gt;スッキリした。&lt;/p&gt;</description><pubDate>Sat, 26 Mar 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-03-19-useful-usafe-of-gist-permalink</guid><link>https://krymtkts.github.io/posts/2022-03-19-useful-usafe-of-gist-permalink</link><title>Gist の便利な使い方 ~ Permalink</title><description>&lt;p&gt;今更ながら最近知った。 Gist の Raw コンテンツの URL からコミットハッシュを取り除けば常に最新のリビジョンへの Permalink になる。&lt;/p&gt;&lt;p&gt;&lt;a href="https://stackoverflow.com/questions/16589511/how-do-i-get-the-raw-version-of-a-gist-from-github/16589638#16589638"&gt;How do I get the raw version of a gist from github? - Stack Overflow&lt;/a&gt;&lt;/p&gt;&lt;p&gt;これを使えば、ローカルで patch を当てるのにめちゃくちゃ役に立つと気づいた。
ダウンロードの保存先を patch したいコード直にしたらそれで終わり。
patch を当てたいファイルの数だけ Gist 作らなあかんやんけ、というのはあれど、あまりに多い場合は Gist の中に複数ファイル置くとかかな。まだその規模まで届いてないのでそこはまあよい。&lt;/p&gt;&lt;p&gt;これとか。 &lt;a href="https://krymtkts.github.io/posts/2021-08-30-patch-to-vscode-extension"&gt;VS Code の拡張機能に ローカル patch する&lt;/a&gt;&lt;/p&gt;&lt;p&gt;メンテナがもう活動してないっぽくて PR がマージされることもないので、ローカル patch するのが手っ取り早い。&lt;/p&gt;&lt;p&gt;Gist に変更対象のコードを置いて、こういう関数を作りまして、実行すればパッチが完了する。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function Edit-EverMonkey {
    $evermonkey = '~\.vscode\extensions\michalyao.evermonkey-2.4.5'
    if (-not $evermonkey) {
        Write-Verbose 'There is no evermonkey.'
        return
    }
    $params = @{
        Uri     = 'https://gist.githubusercontent.com/krymtkts/8a5a3a5a7e1efe9db7f2c6bbda337571/raw/converterplus.js'
        OutFile = "$evermonkey\out\src\converterplus.js"
    }
    Invoke-WebRequest @params
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;あとこれ。&lt;a href="/posts/2021-07-11-my-terminal-icons"&gt;Terminal-Icons のアイコングリフのコードポイントを変えたい&lt;/a&gt;&lt;/p&gt;&lt;p&gt;version up の度にいっつも自分用グリフを上書きしてるけど、それが楽になる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function Edit-TerminalIcons {
    $ti = Get-Module Terminal-Icons -ErrorAction SilentlyContinue
    if (-not $ti) {
        Write-Error 'Terminal-Icons not found. install it!'
        return
    }
    $params = @{
        Uri     = 'https://gist.githubusercontent.com/krymtkts/4457a23124b2db860a6b32eba6490b03/raw/glyphs.ps1'
        OutFile = "$(Split-Path $ti.Path -Parent)\Data\glyphs.ps1"
    }
    Invoke-WebRequest @params
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;他に PowerShell の profile も Gist で管理しているので、複数の端末間で共有するのに使っている。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function Update-Profile {
    $profilehome = ($PROFILE | Split-Path -Parent)
    $params = @{
        Uri     = 'https://gist.githubusercontent.com/krymtkts/f8af667c32b16fc28a815243b316c5be/raw/Microsoft.PowerShell_profile.ps1'
        OutFile = "$profilehome/Microsoft.PowerShell_profile.ps1"
    }
    Invoke-WebRequest @params

    if (-not (Test-Path "$profilehome\Microsoft.VSCode_profile.ps1")) {
        New-Item -ItemType HardLink -Path $profilehome -Name 'Microsoft.VSCode_profile.ps1' -Value "$profilehome\Microsoft.PowerShell_profile.ps1"
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;便利だ。&lt;/p&gt;</description><pubDate>Sat, 19 Mar 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-03-13-create-huge-text-file-in-pwsh</guid><link>https://krymtkts.github.io/posts/2022-03-13-create-huge-text-file-in-pwsh</link><title>PowerShell でクソデカテキストファイルを作る</title><description>&lt;p&gt;先日、クソデカテキストファイルを作成しなければならない場面があり、以下のスクリプトをしたためた。
Windows なので単にサイズが大きいだけのファイルなら &lt;code&gt;fsutil createnew&lt;/code&gt; を使えるけど、クソデカテキストファイルを作る手段は知らなかったからだ。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Set-Content kusodeka.txt -Encoding ascii -NoNewline -Value ('x' * [Math]::Pow(1024, 3))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;このスクリプト、 Out of Memory でエラー終了する。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; Set-Content kusodeka.txt -Encoding ascii -NoNewline -Value ('x' * [Math]::Pow(1024, 3))
OperationStopped: Exception of type 'System.OutOfMemoryException' was thrown.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;どうも文字列の確保できる最大サイズの制限みたい。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; 'x' * [Math]::Pow(1024, 3) | Out-Null
OperationStopped: Exception of type 'System.OutOfMemoryException' was thrown.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;↓ のサイズならいける。 1GB - 32B からはエラーになる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;'x' * ([Math]::Pow(1024, 3)-33) | Out-Null
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;答えは.NET の&lt;code&gt;String&lt;/code&gt;クラスのドキュメントに書いてた →&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.string?redirectedfrom=MSDN&amp;amp;view=net-6.0"&gt;String Class (System) | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The maximum size of a String object in memory is 2-GB, or about 1 billion characters.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;2GB には到底届いてないし、今回引っかかってるのは後者か。
ほーん、という感じ。最大の文字列長とか考えたこともなかったわ。&lt;/p&gt;&lt;p&gt;因みにこの最大文字数の超過エラーを回避してクソデカテキストファイルを作るには、以下のようにデータを分割して小分けに書き込みする必要がある。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;1..1024 | Add-Content kusodeka.txt -Encoding ascii -NoNewline -Value ('x' * [Math]::Pow(1024, 2))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ついでに調べた PowerShell の配列の上限は、添字の型であろう &lt;code&gt;int&lt;/code&gt; の範囲っぽいがドキュメントは見当たらなかった。これはまた PowerShell のソースコードでも読むか。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# いける
[int]::MinValue..[int]::MaxValue | Out-Null

# いけない(int の演算エラーかこれ)
[int]::MinValue..([int]::MaxValue + 1) | Out-Null
# &amp;gt; OperationStopped: Value was either too large or too small for an Int32.

# いけない(カッコで評価されちゃい overflow か)
([int]::MinValue..[int]::MaxValue) | Out-Null
# OperationStopped: Arithmetic operation resulted in an overflow.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;世の中まだ知らないことがいっぱいあるもんやなあ。&lt;/p&gt;&lt;h3 id="2022-03-15-追記"&gt;2022-03-15 追記&lt;/h3&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# これが限界ぽい。
(1..2147483591) | Out-Null

(1..2147483592) | Out-Null
# OperationStopped: Array dimensions exceeded supported range.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;でエラー。この場合ちゃんと Array の range の問題だとエラーに出る。
カッコを入れてなかったら評価が端折られて期待の振る舞いをしていなかった。&lt;/p&gt;&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.array?view=net-6.0#remarks"&gt;Array Class (System) | Microsoft Docs&lt;/a&gt; に記載のカッコの中に該当するわけやな。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The array size is limited to a total of 4 billion elements, and to a maximum index of 0X7FEFFFFF in any given dimension (0X7FFFFFC7 for byte arrays and arrays of single-byte structures).&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code class="powershell"&gt;[long]::Parse('7FFFFFC7',[System.Globalization.NumberStyles]::HexNumber)
# 2147483591
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;いやー、スッキリした！&lt;/p&gt;</description><pubDate>Sun, 13 Mar 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-03-05-customize-cryogen</guid><link>https://krymtkts.github.io/posts/2022-03-05-customize-cryogen</link><title>Cryogen のカスタマイズ</title><description>&lt;p&gt;&lt;a href="/posts/2022-02-27-issue-with-cryogen-version-bump"&gt;前回の投稿&lt;/a&gt;で、 &lt;a href="https://cryogenweb.org/"&gt;Cryogen&lt;/a&gt; のバージョンアップに伴い Cryogen 自体のカスタマイズが必要だとを書いた。&lt;/p&gt;&lt;p&gt;カスタマイズ自体はかなり簡単にできたのだが、 Clojure 経験不足だからか正直なところドキュメントの記載だけではピンと来なかった。
ということで、またわからなくなること必至のため記しておく。&lt;/p&gt;&lt;p&gt;&lt;code&gt;cryogen-core&lt;/code&gt; のバージョンは &lt;code&gt;0.4.1&lt;/code&gt; だ。&lt;/p&gt;&lt;p&gt;対象のドキュメント &lt;a href="https://cryogenweb.org/docs/customizing-cryogen.html#customizing-the-code"&gt;Cryogen: Customizing/Extending Cryogen&lt;/a&gt; を以下に全文引用する。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;You can copy the &lt;code&gt;cryogen-core.compiler&lt;/code&gt; namespace directly into your project (where it will override the one from the cryogen-core.jar) and modify it to your liking. It is not very long or complicated and is quite easy to modify. That is &lt;a href="https://github.com/cryogen-project/cryogen-docs/blob/fd601c857cc88f7cb633a41c47b4c692e1522ed8/src/cryogen/compiler.clj"&gt;what we did for this site&lt;/a&gt; (although it uses a much older version of cryogen-core, you may still use the same strategy today).&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;機械翻訳にリンクを添えた ↓&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;cryogen-core.compiler&lt;/code&gt; 名前空間をプロジェクトに直接コピーし（cryogen-core.jar のものを上書きします）、好みに応じて変更することができます。これはそれほど長くもなく、複雑でもなく、非常に簡単に修正することができます。このサイトでは、&lt;a href="https://github.com/cryogen-project/cryogen-docs/blob/fd601c857cc88f7cb633a41c47b4c692e1522ed8/src/cryogen/compiler.clj"&gt;このような方法&lt;/a&gt;をとっています（かなり古いバージョンの cryogen-core を使用していますが、現在でも同じ方法をとることができます）。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;早い話が「Cryogen の公式ページのコードを真似ろ」。&lt;/p&gt;&lt;p&gt;はじめはナンノコッチャと思ったのだけど、Cryogen の repo のコードを眺めて「&lt;a href="https://github.com/cryogen-project/cryogen-core/blob/31bcbfdad59e8eaed4a6d417682e51ef1e90982c/src/cryogen_core/compiler.clj"&gt;&lt;code&gt;cryogen_core/compiler.clj&lt;/code&gt;&lt;/a&gt;をコピって自分でサイトジェネレータを書いたらええんやで？」だと理解した。&lt;/p&gt;&lt;p&gt;Cryogen のエントリポイントは &lt;code&gt;cryogen/core.clj&lt;/code&gt; と &lt;code&gt;cryogen/server.clj&lt;/code&gt; があるが、いずれもサイトジェネレータは &lt;code&gt;cryogen-core.compiler&lt;/code&gt; 名前空間の &lt;code&gt;compile-assets-timed&lt;/code&gt; を呼び出してるだけなので、これを &lt;code&gt;cryogen_core/compiler.clj&lt;/code&gt; からコピった自分用ジェネレータに変える、という趣旨らしい。&lt;/p&gt;&lt;p&gt;とった手順は以下の通り。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href="https://github.com/cryogen-project/cryogen-core/blob/31bcbfdad59e8eaed4a6d417682e51ef1e90982c/src/cryogen_core/compiler.clj"&gt;&lt;code&gt;cryogen_core/compiler.clj&lt;/code&gt;&lt;/a&gt; をコピって自分のサイトのコードに &lt;code&gt;src/cryogen/compiler.clj&lt;/code&gt; として配置する&lt;/li&gt;&lt;li&gt;&lt;code&gt;src/cryogen/compiler.clj&lt;/code&gt; を自分の必要な形に書き換える
&lt;ul&gt;&lt;li&gt;今回デフォルトの Cryogen から変えたかったのは、 RSS フィードの要約機能を取り除いて HTML 全文載せるようにすることだった&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/cryogen-project/cryogen-core/blob/31bcbfdad59e8eaed4a6d417682e51ef1e90982c/src/cryogen_core/compiler.clj#L474-L487"&gt;&lt;code&gt;add-description&lt;/code&gt;&lt;/a&gt; 関数の中で利用されている &lt;code&gt;util/enlive-&amp;gt;plain-text&lt;/code&gt; を &lt;code&gt;util/enlive-&amp;gt;html-text&lt;/code&gt; に変更、&lt;code&gt;add-description&lt;/code&gt; に依存する関数 &lt;code&gt;compile-assets&lt;/code&gt;, &lt;code&gt;compile-assets-timed&lt;/code&gt; を &lt;code&gt;cryogen.compiler&lt;/code&gt; に定義した&lt;/li&gt;&lt;li&gt;それ以外の関数は &lt;code&gt;cryogen-core.compiler&lt;/code&gt; を参照する&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;cryogen/core.clj&lt;/code&gt; と &lt;code&gt;cryogen/server.clj&lt;/code&gt; で、 &lt;code&gt;compile-assets-timed&lt;/code&gt; の名前空間を &lt;code&gt;cryogen-core.compiler&lt;/code&gt; → &lt;code&gt;cryogen.compiler&lt;/code&gt; に変える&lt;/li&gt;&lt;li&gt;&lt;code&gt;lein serve&lt;/code&gt; してエラーがない＆期待の出力になっていれば完了&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;これで概ね自分が期待する出力を得られるようになった(はず)。
気付かないところで破壊的な変更をしているかも知れないので、それは経過観測していく。この投稿をした後で RSS フィードが本当に届くか心配だ。&lt;/p&gt;&lt;p&gt;あと既知の問題として、新たに追加された &lt;code&gt;lein serve:fast&lt;/code&gt; がちゃんと動いてんのかこれ？ であったり、 Markdown 保存時の再生成が怪しかったりする。
これらは、ちまちま直していきたい。&lt;/p&gt;&lt;p&gt;これで repo の統合だったり GitHub Action 化が見えてきた。&lt;/p&gt;</description><pubDate>Sat, 05 Mar 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-02-27-issue-with-cryogen-version-bump</guid><link>https://krymtkts.github.io/posts/2022-02-27-issue-with-cryogen-version-bump</link><title>Cryogen バージョンアップに伴う困りごと</title><description>&lt;p&gt;このブログを作るのに &lt;a href="https://github.com/cryogen-project/cryogen"&gt;Cryogen&lt;/a&gt; を利用している。
作った当初から一切のバージョンアップをしていなかったのだが、先週からちまちま手を動かし始めた。&lt;/p&gt;&lt;p&gt;最近の Cryogen では出力先のディレクトリを指定できる様になっているので、 &lt;code&gt;docs&lt;/code&gt; 出力するようにすれば今 &lt;a href="https://github.com/krymtkts/blog-cryogen"&gt;krymtkts/blog-cryogen&lt;/a&gt; と &lt;a href="https://github.com/krymtkts/krymtkts.github.io"&gt;krymtkts/krymtkts.github.io&lt;/a&gt; の 2 つに別れている repo を統合できる。
そも、出力結果を repo の管理下に置かず Github Actions で済ます選択もできるようになるんじゃないかな。&lt;/p&gt;&lt;p&gt;新しい Cryogen では雛形のディレクトリ構造が変わっているのだが、このバージョンアップによるマイグレーション自体は大したことはない。雑に言えば以下のタスクがあるだけだ。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;新しい Cryogen で雛形を作成する
&lt;ul&gt;&lt;li&gt;雛形に含まれるポストや利用しないテーマ等を取り除いておく&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;既存のコンテンツとテーマを 1 に移動する
&lt;ul&gt;&lt;li&gt;&lt;code&gt;resources\templates\themes&lt;/code&gt; -&amp;gt; &lt;code&gt;themes&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;resources\templates\img&lt;/code&gt; -&amp;gt; &lt;code&gt;content\img&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;resources\templates\md&lt;/code&gt; -&amp;gt; &lt;code&gt;content\md&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;config.edn&lt;/code&gt; 新しいパラメータに書き換える&lt;/li&gt;&lt;li&gt;&lt;code&gt;lein serve&lt;/code&gt; で出力して確認&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;一通り手を動かしてみて、tag へのリンクが壊れたりの細かいバグはあったが、概ね破壊的な変更なく OK やなというところまではできた。&lt;/p&gt;&lt;p&gt;ところが困ったことに、RSS Feed の出力だけは大きく変わってしまうのを避けられなかった。どうも新しい Cryogen では RSS Feed への出力は要約だけにする仕様に変わったらしい。
ワークアラウンドとして、&lt;code&gt;config.edn&lt;/code&gt; の &lt;code&gt;blocks-per-preview&lt;/code&gt; の数値を大きくすれば要約に全文を含めることはできる。でもそれまで可能だった HTML での埋め込みはできなくなってしまった。
&lt;a href="https://github.com/cryogen-project/cryogen/issues/241"&gt;RSS feed: only publishes article's "summary" · Issue #241 · cryogen-project/cryogen&lt;/a&gt;&lt;/p&gt;&lt;p&gt;コード的にこの辺。 ページの &lt;code&gt;description&lt;/code&gt; が Feed に出力されるのだが、 plain text 以外の選択肢がない。なんでや。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/cryogen-project/cryogen-core/blob/31bcbfdad59e8eaed4a6d417682e51ef1e90982c/src/cryogen_core/compiler.clj#L474-L487"&gt;cryogen-core/compiler.clj at 31bcbfdad59e8eaed4a6d417682e51ef1e90982c · cryogen-project/cryogen-core&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;(defn add-description
  "Add plain text `:description` to the page/post for use in meta description etc."
  [{:keys [blocks-per-preview description-include-elements]
    :or   {description-include-elements #{:p :h1 :h2 :h3 :h4 :h5 :h6}}}
   page]
  (update
    page :description
    #(cond
       (false? %) nil  ;; if set via page meta to false, do not set
       % %    ;; if set via page meta, use it
       :else (-&amp;gt;&amp;gt; (enlive/select
                    (preview-dom blocks-per-preview (:content-dom page))
                    [(set description-include-elements)])
                  (util/enlive-&amp;gt;plain-text)))))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href="https://github.com/cryogen-project/cryogen-core/blob/31bcbfdad59e8eaed4a6d417682e51ef1e90982c/src/cryogen_core/util.clj#L38-L41"&gt;cryogen-core/util.clj at 31bcbfdad59e8eaed4a6d417682e51ef1e90982c · cryogen-project/cryogen-core&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;(defn enlive-&amp;gt;plain-text [node-or-nodes]
  (-&amp;gt;&amp;gt; node-or-nodes
       (enlive/texts)
       (apply str)))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;RSS リーダー利用者としての個人的な意見だが、正直なところ技術ブログなんかであれば全文マークアップ可能な状態で配信してほしい。割と RSS リーダーだけ読んで済ませることも多い。
最近はフィードに全文載っけないのが主流ぽくはあるが、これは多分広告表示とかアクセス解析のためにサイトを訪れてほしいからであって、そういう動機がないのであれば全文配信しない理由がない。&lt;/p&gt;&lt;p&gt;なのでわたしのブログもそのようにしていたのだけど、このバージョンアップでそれができなくなるのは個人的にちょっと受け入れられないと判断した。
RSS リーダーでこのブログを購読する最有力ユーザはわたし自身なので、自分の意見が一番えらい。&lt;/p&gt;&lt;p&gt;現状だとどうしようないのだが、 Cryogen 自体に手を入れることができるのでそれをやってみようとしている。&lt;/p&gt;&lt;p&gt;&lt;a href="https://cryogenweb.org/docs/customizing-cryogen.html#customizing-the-code"&gt;Cryogen: Customizing/Extending Cryogen - Customizing the code&lt;/a&gt;&lt;/p&gt;&lt;p&gt;続く。&lt;/p&gt;</description><pubDate>Sun, 27 Feb 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-02-19-i-cant-graduate-from-tortoise-git</guid><link>https://krymtkts.github.io/posts/2022-02-19-i-cant-graduate-from-tortoise-git</link><title>Tortoise Git から卒業できない</title><description>&lt;p&gt;今どきの Git の使い手は、 「CLI で使ってない奴はニワカ」みたいな硬派な人とか、&lt;a href="https://www.gitkraken.com/"&gt;GitKraken&lt;/a&gt; とかのイケてる Git クライアントや VS Code で &lt;a href="https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens"&gt;GitLens&lt;/a&gt; やら &lt;a href="https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph"&gt;Git Graph&lt;/a&gt; 使ってる勢なんじゃないだろうか。&lt;/p&gt;&lt;p&gt;わたしは長らく &lt;a href="https://tortoisegit.org/"&gt;TortoiseGit&lt;/a&gt; から卒業できないでいる。&lt;/p&gt;&lt;p&gt;コミットやログ、ブランチやリセットやマージ等諸々の基本的な操作は全部 CLI でやるが、ある操作だけは TortoiseGit でやるのが楽過ぎて手放せないでいる。それは歴史の改竄だ。&lt;/p&gt;&lt;p&gt;わたしも VS Code ユーザなので、勿論 GitLens やら Git Graph を使ったことはある。
だが、殊この歴史の改竄については Tortoise Git を超えてない(機能を知らんだけかも知らんが)。
&lt;a href="https://github.com/jesseduffield/lazygit"&gt;jesseduffield/lazygit&lt;/a&gt; だけはわたしの要求を満たせそうな素晴らしいツールに感じたのだが、 &lt;a href="https://github.com/microsoft/terminal"&gt;Windows Terminal&lt;/a&gt; で利用すると&lt;code&gt;┐&lt;/code&gt;とかの描画幅がワイド判定されて画面がクチャクチャになってしまう(わたしが pwsher でなくコマンドプロンプターならバッチリはまったであろうツールだ)。&lt;/p&gt;&lt;p&gt;具体的に言うと、 &lt;a href="https://tortoisegit.org/docs/tortoisegit/tgit-dug-cherrypick.html"&gt;Cherry picking&lt;/a&gt; がめちゃくちゃ便利でずっと使ってるのだけど、みんな歴史を改竄しないのだろうか。
わたしが歴史を改竄するのは、まだ一度もリモートに push していないローカルで育てたブランチを、デビュー前に清書するためだ。ローカルで思いのままに吐き散らしたコミット粒度及びログを、push 前に整えるのはプログラマの嗜みだ。&lt;/p&gt;&lt;p&gt;使用例は以下の通り。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;思いのままにコミットを積み上げる&lt;/li&gt;&lt;li&gt;リセット前にタグを打つ&lt;/li&gt;&lt;li&gt;push 用のブランチをベースブランチにリセットする&lt;/li&gt;&lt;li&gt;思いのままに積み上げたコミットを丁寧に cherry pick し、公開するに適切なコミット粒度・コミットログへ書き換える&lt;/li&gt;&lt;li&gt;タグを打った元の状態と差分がないことを確認した後でめでたく push&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;重要なのは 3、ここでコミットの順番を入れ替えたりまとめたり分割したりという操作をするが、Tortoise Git 以外ではこういうことができないように見える。流行り？の GitKraken でさえこの有様 → &lt;a href="https://feedback.gitkraken.com/suggestions/191932/add-support-for-splitting-an-existing-commit"&gt;Add support for splitting an existing commit - GitKraken&lt;/a&gt;
え、分割できへんの！？的な。&lt;/p&gt;&lt;p&gt;最近見た限りだと、GitLens や Git Graph では reset したコミット以降の変更を 1 コミットにまとめるとかはできるっぽかった。でもそういうのがしたいわけじゃない。もっと派手にやりたいんじゃ！&lt;/p&gt;&lt;p&gt;1 で思いのままにコミットを積み上げる等言語道断という意見もあろうが、都度〃やった内容をペコペココミットするリズム感がほしいので結局こうやってしまう。みんないちいちコミットの粒度を頭に入れた上で、アソコを直してココを直して...とかやってるのだろうか。多分やってないでしょう。&lt;/p&gt;&lt;p&gt;より良い歴史改竄体験を求めて別のツールを探してみたいが、ググった感じだと派手な歴史改竄機能がみられず、あんまりみんなやらないっぽいのではと思っている。みんな素直に &lt;code&gt;git rebase --interactive&lt;/code&gt;(Interactive Rebasing) してるんだろうきっと。&lt;/p&gt;&lt;p&gt;あーあとひとつ重要な機能を忘れていた。 &lt;a href="https://github.com/dahlbyk/posh-git"&gt;dahlbyk/posh-git&lt;/a&gt; を使っていると &lt;a href="https://github.com/dahlbyk/posh-git/wiki/Posh--Git-Module-Functions"&gt;&lt;code&gt;tgit&lt;/code&gt;&lt;/a&gt; という素敵な関数が提供されることでより一層 Tortoise Git から離れにくくなる。 &lt;code&gt;tgit&lt;/code&gt; は Tortoise Git の任意の機能を召喚する魔法の関数なのだ。
この珍妙な関数を使うせいで、ペアプロ時に「あ！コマンド間違ってますよ！」と言われたこともあるが、便利なんだから仕方がない。勿論 Tab 補完もついている。&lt;/p&gt;&lt;p&gt;もうここまで沼に飲まれていると使い続ければ良いのでは...という気もしないではないが、より良いツールが出てきたらぜひ乗り換えたい。あるいは全部 CLI に寄せるか。
未来の自分に託した。&lt;/p&gt;</description><pubDate>Sat, 19 Feb 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-02-12-publish-to-powershell-gallery-etc</guid><link>https://krymtkts.github.io/posts/2022-02-12-publish-to-powershell-gallery-etc</link><title>PoweShell Gallery へ公開するためのステップ覚書</title><description>&lt;p&gt;タイトルの通り。これは未来の自分へのバトンだ。&lt;/p&gt;&lt;p&gt;毎回 PoweShell Gallery への公開方法を忘れたりする。 &lt;a href="/tags/powershellgallery"&gt;弊ブログの&lt;code&gt;powershellgallery&lt;/code&gt;タグ&lt;/a&gt;を参照すればどれだけ同じミスを繰り返してるかアホさがわかる。
加えて &lt;a href="https://github.com/microsoft/PowerShellForGitHub"&gt;microsoft/PowerShellForGitHub&lt;/a&gt; で repo を作るのもしょっちゅう忘れる。
こちらに関してはもうそろそろ &lt;a href="https://github.com/cli/cli"&gt;&lt;code&gt;gh&lt;/code&gt;&lt;/a&gt;に乗り換えた方がいいのかも知れん。(けど、そうすると PowerShell の旨味であるオブジェクトでゴニョゴニョやりやすい世界がなくなってしまうのは困る)&lt;/p&gt;&lt;p&gt;なのでこれらを定型化して &lt;code&gt;psake&lt;/code&gt; タスクに落とし込む等したいな～と考えている(今度はその&lt;code&gt;psake&lt;/code&gt;タスクが秘伝のソース化するかも知れんがそれはそれ)。
そのためにいつも何をやっているかを以下にリストアップする。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;前提。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;PSMFAttendance&lt;/code&gt; の作成時にやったことを踏まえている&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/x-motemen/ghq"&gt;ghq&lt;/a&gt; を使っている前提&lt;/li&gt;&lt;li&gt;MS 公式文書はこちら &lt;a href="https://docs.microsoft.com/en-us/powershell/scripting/gallery/concepts/publishing-guidelines?view=powershell-7.2"&gt;PowerShell Gallery Publishing Guidelines and Best Practices - PowerShell | Microsoft Docs&lt;/a&gt;&lt;ul&gt;&lt;li&gt;残念ながら過去のメモ(&lt;a href="https://github.com/krymtkts/Get-GzipContent"&gt;krymtkts/Get-GzipContent&lt;/a&gt;を公開したとき)からは URL が変わっていた。今回はどうかな。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="step-1-repo-とモジュールマニフェストの作成"&gt;Step 1. repo とモジュールマニフェストの作成&lt;/h3&gt;&lt;p&gt;まず最初のステップはモジュールの雛形作成。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# create repo.
$owner = 'krymtkts'
$module = 'PSMFAttendance'
New-GitHubRepository -RepositoryName $module -Private -LicenseTemplate MIT
ghq get -p (Get-GitHubRepository -OwnerName krymtkts -RepositoryName $module | Select-Object -ExpandProperty ssh_url)
cd "$(ghq root)/$(ghq list $module)"

# create module manifest.
mkdir $module
$author = 'Takatoshi Kuriyama'
New-ModuleManifest -Path "./$module/$module.psd1" -ModuleVersion 1.0 -Author $author -Copyright "(c) $((get-date).Year) $author. All rights reserved."
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;PowerShell Gallery への公開コマンド &lt;a href="https://docs.microsoft.com/en-us/powershell/module/powershellget/publish-module?view=powershell-7.2"&gt;&lt;code&gt;Publish-Module&lt;/code&gt; (PowerShellGet)&lt;/a&gt; は、指定したディレクトリの中身を全部 PowerShell Gallery にぶち上げるため、モジュール以外のファイルを配置していても全て雲の上に持っていかれてしまう(除外設定がないのだ)。
そういう事故を起こさないためにも、モジュールリリース用のディレクトリを作成することをおすすめする。
そこでモジュールを開発するか、リリース対象のコードをそこにコピーした上で公開する、というのに限るのではないだろうか。わたしはコピーしたあとの掃除とか考えるのが面倒なので前者。&lt;/p&gt;&lt;p&gt;先にモジュールマニフェストを作るのは、動作確認なんかで関数がエクスポートできているか見るのに使うからだ。&lt;/p&gt;&lt;h3 id="step-2-モジュールマニフェストの更新"&gt;Step 2. モジュールマニフェストの更新&lt;/h3&gt;&lt;p&gt;次は実装して、マニフェストの更新。
マニフェストに記すべき内容については公式のドキュメントを読むのが良い。&lt;/p&gt;&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/powershell/scripting/gallery/how-to/publishing-packages/publishing-a-package?view=powershell-7.2#required-metadata-for-items-published-to-the-powershell-gallery"&gt;Creating and publishing an item - PowerShell | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;とはいえわたしは大したモジュールを作らないのもあり、いつも更新するのは限られたフィールドだけだ。主に以下。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;Description&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;PowerShellVersion&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;*ToExport&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;PrivateData.PSData.Tags&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;PrivateData.PSData.LicenseUri&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;PrivateData.PSData.ProjectUri&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;この中でわかりにくいのが、互換性のあるプラットフォームの指定。これは &lt;code&gt;Tags&lt;/code&gt; で表す。
&lt;a href="https://docs.microsoft.com/en-us/powershell/scripting/gallery/concepts/publishing-guidelines?view=powershell-7.2#tag-your-package-with-the-compatible-pseditions-and-platforms"&gt;PowerShell Gallery Publishing Guidelines and Best Practices - PowerShell | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;マニフェストの更新は手で書いてもよいが、&lt;code&gt;Update-ModuleManifest&lt;/code&gt; も使える。
ただし &lt;code&gt;New-ModuleManifest&lt;/code&gt; と &lt;code&gt;Update-ModuleManifest&lt;/code&gt; で出力結果のフォーマットが異なる(後者はインデントされない)のがイライラするので、手でやることが多いか。
ただ自動化していくとすれば、ここは &lt;code&gt;Update-ModuleManifest&lt;/code&gt; に従うところか(こいつインデントしてくれへんのだが)。&lt;/p&gt;&lt;h3 id="last-step-powershell-gallery-公開"&gt;Last Step. PowerShell Gallery 公開&lt;/h3&gt;&lt;p&gt;最後は PowerShell Gallery への公開だ。&lt;/p&gt;&lt;p&gt;PowerShell Gallery への公開を実施する前に、API キーの期限が切れていないか必ずチェックしておく。
キーの有効期限が切れている場合のエラーが非常にわかりにくいので、無駄にトラシューに時間を費やさずに済ますためにも公開前にチェック兼ねて毎回キーを更新するのが妥当では？
API キーの有効期限は最長 1 年しかないので、しょっちゅう切らしている。むしろ公開前に更新するフローであれば、期限も最短にできるのでよりセキュアかも知れない。&lt;/p&gt;&lt;p&gt;API キー はモジュール名に対して &lt;a href="https://en.wikipedia.org/wiki/Glob_(programming)"&gt;glob パターン&lt;/a&gt;でスコープを切れる。過去には面倒を回避するために&lt;code&gt;*&lt;/code&gt;パターンを使ったりしていたが、今はパッケージ名の完全一致を利用していて、パッケージ毎に API キーを分けるようにしている。&lt;/p&gt;&lt;p&gt;公開の手順は &lt;a href="https://github.com/krymtkts/Get-GzipContent"&gt;krymtkts/Get-GzipContent&lt;/a&gt;を公開したときスクリプトを使う。&lt;/p&gt;&lt;p&gt;このスクリプトでは &lt;code&gt;PSScriptAnalyzer&lt;/code&gt; を使ったチェックが成功した後に公開する。
また、&lt;code&gt;WhatIf&lt;/code&gt; は Dry Run として置き換えた上で使うようにしていた。
&lt;code&gt;WhatIf&lt;/code&gt; を使わないことで覚えることが増えて面倒な気もするが、とにかく間違って公開すると面倒なので、初期値を Dry Run にしたいという意図だった(多分)。この辺は &lt;a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-shouldprocess?view=powershell-7.2"&gt;&lt;code&gt;ShouldProcess&lt;/code&gt;&lt;/a&gt; の勉強をしたらより良い案があるかも知れん。&lt;/p&gt;&lt;p&gt;PowerShell Gallery でのバージョニングは基本的に Semantic Versioning なので、何かしらミスったらモジュールの非公開はできるけど、同じバージョンへの更新はできない。パッチバージョンを上げて再公開とかしかできない。これはミスったら恥ずかしいしやり直しがきかないから、 Dry Run しまくる。この「何かしらミスったら」を Pester とかで事前チェックできると良いのだろうけど。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Param (
    [String]$ApiKey,
    [ValidateSet('Publish', 'DryRun')]$Mode = 'DryRun'
)

$ModuleName = Get-ChildItem -File -Path ./ -Recurse -Name '*.psd1' | Split-Path -Parent
$ArtifactPath = ".\$ModuleName\"
Write-Host "Check modules under $ArtifactPath."

$report = Invoke-ScriptAnalyzer -Path "$ArtifactPath" -Recurse -Settings PSGallery
if ($report) {
    Write-Host "Violation found."
    $report
    exit
}
Write-Host "Check passed."

switch ($Mode) {
    'Publish' {
        Write-Host "Publishing module: $ModuleName"
        Publish-Module -Path $ArtifactPath -NugetAPIKey $ApiKey -Verbose
    }
    'DryRun' {
        Write-Host "[DRY-RUN]Publishing module: $ModuleName"
        Publish-Module -Path $ArtifactPath -NugetAPIKey $ApiKey -Verbose -WhatIf
    }
}
if ($?) {
    Write-Host 'Successfully published.'
}
else {
    Write-Error 'Failed to publish.'
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;今改めて見るとこのスクリプト、API キーは Credential に変更した方がマトモだ。ぜひ対応したい。&lt;/p&gt;&lt;p&gt;このように使う。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;.\publish.ps1 -Mode DryRun -ApiKey xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

.\publish.ps1 -Mode Publish -ApiKey xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;公開後は最終チェック、自端末へモジュールをインストールして一通り使えるか見ている。何しかちゃんと出来てるか不安。&lt;/p&gt;&lt;p&gt;公開できたら、 repo の&lt;code&gt;README.md&lt;/code&gt; に以下を加筆する。これは流石に自動化無理なのでいいや。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;PowerShell Gallery からのインストール方法&lt;/li&gt;&lt;li&gt;&lt;a href="https://shields.io/category/downloads"&gt;Shields.io&lt;/a&gt; の PowerShell Gallery のダウンロード&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;終。&lt;/p&gt;&lt;hr /&gt;&lt;h3 id="おわりに"&gt;おわりに&lt;/h3&gt;&lt;p&gt;手順起こしてみてあれやけど、これもうすぐにでも &lt;code&gt;psake&lt;/code&gt; タスク化できそう。単にサボってただけだったか...&lt;/p&gt;</description><pubDate>Sat, 12 Feb 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-02-06-back-to-old-context-menu-in-win-11-pwsh</guid><link>https://krymtkts.github.io/posts/2022-02-06-back-to-old-context-menu-in-win-11-pwsh</link><title>Windows11 のコンテキストメニューを前のんに戻す(PowerShell で)</title><description>&lt;p&gt;Windows11 にてコンテキストメニューの UI が変わった。
しかし自身は普段コンテキストメニューを使わないのであまり気にならなかった。&lt;/p&gt;&lt;p&gt;のだが、たまたま 7z 圧縮されたファイルを渡されたことで、右クリックで 7zip で開けないのクソめんどい...と気になり始めた。
なので前のコンテキストメニューに戻す。PowerShell で。&lt;/p&gt;&lt;p&gt;レジストリを編集する必要があるらしい。情報元 ↓
&lt;a href="https://www.tomshardware.com/how-to/windows-11-classic-context-menus"&gt;How to Get Full Context Menus in Windows 11 | Tom's Hardware&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$path = 'HKCU:\Software\Classes\CLSID\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\InprocServer32'
New-Item -Path $path -Force
Split-Path $path -Parent | Get-ChildItem
Set-ItemProperty -Path $path -Name '(Default)' -Value ''
Get-ItemProperty $path

Stop-Process -Name explorer -Force
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Gist → &lt;a href="https://gist.github.com/krymtkts/30af31454d510ce0c34cfeb2fefec072"&gt;Return to the previous context menu in Windows 11.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;↓ キーの名前は case insensitive なのかーい！&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; Get-ItemProperty $path

(default)    :
PSPath       : Microsoft.PowerShell.Core\Registry::HKEY_CURRENT_USER\Software\Classes\CLSID\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\In
               procServer32
PSParentPath : Microsoft.PowerShell.Core\Registry::HKEY_CURRENT_USER\Software\Classes\CLSID\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}
PSChildName  : InprocServer32
PSDrive      : HKCU
PSProvider   : Microsoft.PowerShell.Core\Registry
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;終わり。&lt;/p&gt;</description><pubDate>Sun, 06 Feb 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-02-05-build-pwsh-2022</guid><link>https://krymtkts.github.io/posts/2022-02-05-build-pwsh-2022</link><title>2022-02 版 PowerShell のビルド</title><description>&lt;p&gt;PowerShell のパラメータバインディングについて調べていてコードに潜る時に、やっぱりローカルでビルドしたいよな！と思ったので、試してみた。
結果、副産物的に PowerShell 自体のコードをいじれる環境ができた。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;PC は Razer Blade Stealth 2018、Windows 11 Home 21H2 22000.469 だ。&lt;/p&gt;&lt;p&gt;まず ビルドの方法を探す。&lt;/p&gt;&lt;p&gt;&lt;code&gt;README.md&lt;/code&gt;から辿って&lt;a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/windows-core.md"&gt;Build PowerShell on Windows for .NET Core&lt;/a&gt;に辿り着いた。
わたしは &lt;code&gt;dotnet&lt;/code&gt; を使った CLI ビルドがしたいので &lt;a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/windows-core.md#net-cli"&gt;.NET CLI&lt;/a&gt; のやり方を使う。
ゆーても惚れ惚れするくらい簡単。以下だけ。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Import-Module ./build.psm1
Start-PSBootstrap
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ビルドに使うのは &lt;code&gt;Start-PSBuild&lt;/code&gt; らしい。&lt;code&gt;build.psm1&lt;/code&gt; を見たらわかるが、多くの関数が定義されてる。今回使うのはそのうちの 3 つだけだ。
これらの関数が何を行うためのものかのコメントがあまりないので、それぞれドキュメントからタグルなり使いみちを調べるのも一興か。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;&amp;gt; Get-Command -ListImported | Where-Object -Property Source -eq build

CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Function        Clear-PSRepo                                       0.0        build
# ︙
Function        Start-PSBootstrap                                  0.0        build
Function        Start-PSBuild                                      0.0        build
# ︙
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;PC にインストール済みの &lt;code&gt;dotnet&lt;/code&gt; が &lt;code&gt;6.0.101&lt;/code&gt; だったので、試しに &lt;code&gt;6.0.101&lt;/code&gt; でビルドする。
&lt;code&gt;global.json&lt;/code&gt;内の&lt;code&gt;sdk.version&lt;/code&gt;という属性がある。このときは&lt;code&gt;6.0.100&lt;/code&gt;がデフォルト値になってたので、使いたいバージョンに変える。&lt;/p&gt;&lt;pre&gt;&lt;code class="diff"&gt;PS&amp;gt; git diff
diff --git a/global.json b/global.json
index 047020849..e52d340bc 100644
--- a/global.json
+++ b/global.json
@@ -1,5 +1,5 @@
 {
   "sdk": {
-    "version": "6.0.100"
+    "version": "6.0.101"
   }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Start-PSBuild&lt;/code&gt; を実行することでビルドできる。
Razer Blade Stealth 2018 だとビルドに 2 分近くかかった。
ビルド物はドキュメントに記載の通り &lt;code&gt;./src/powershell-win-core/bin/Debug/net6.0/win7-x64/publish/pwsh.exe&lt;/code&gt; に出力された。
普通に起動すると実行時エラーで死んだけど、プロファイル読み込みを外せば起動した。ﾔｯﾀﾈ！&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; ./src/powershell-win-core/bin/Debug/net6.0/win7-x64/publish/pwsh.exe # 死
PowerShell 7.2.0-preview.10-222-g0ef30e54c70b9d5d69a35d1aeecdf2820cc1ab3b
Process terminated. Assertion failed.
No locals tuple should have been created yet.
   at System.Management.Automation.Diagnostics.Assert(Boolean condition, String whyThisShouldNeverHappen, String detailMessage) in C:\Users\takatoshi\dev\github.com\PowerShell\PowerShell\src\System.Management.Automation\utils\assert.cs:line 202
   at System.Management.Automation.Diagnostics.Assert(Boolean condition, String whyThisShouldNeverHappen) in C:\Users\takatoshi\dev\github.com\PowerShell\PowerShell\src\System.Management.Automation\utils\assert.cs:line 134
# ... スタックトレースは続く

PS&amp;gt; ./src/powershell-win-core/bin/Debug/net6.0/win7-x64/publish/pwsh.exe -NoProfile # Good!
PowerShell 7.2.0-preview.10-222-g0ef30e54c70b9d5d69a35d1aeecdf2820cc1ab3b
PS C:\Users\takatoshi\dev\github.com\PowerShell\PowerShell\src\powershell-win-core\bin\Debug\net6.0\win7-x64\publish&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最後にビルド生成物などを掃除するには &lt;code&gt;Clear-PSRepo&lt;/code&gt; を実行すれば良い。&lt;/p&gt;&lt;p&gt;終。&lt;/p&gt;</description><pubDate>Sat, 05 Feb 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-01-30-pwsh-parameter-binding-parse-datetime</guid><link>https://krymtkts.github.io/posts/2022-01-30-pwsh-parameter-binding-parse-datetime</link><title>PowerShell のパラメータバインディングは "3 時" を Datetime 型にパースする</title><description>&lt;h3 id="いきなりまとめ"&gt;いきなりまとめ&lt;/h3&gt;&lt;p&gt;PowerShell の関数なりコマンドレットがパラメータを受け取る場合、パラメータバインディングの仕組みで型ごとの変換処理をしており、日付型のパラメータでは&lt;code&gt;DateTime.Parse&lt;/code&gt; しているのがわかった。&lt;/p&gt;&lt;hr /&gt;&lt;h3 id="経緯"&gt;経緯&lt;/h3&gt;&lt;p&gt;先日 &lt;a href="/posts/2022-01-23-scheduled-task-in-powershell"&gt;ScheduledTask を設定した&lt;/a&gt;くだりで初めて知った。&lt;/p&gt;&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/powershell/module/scheduledtasks/new-scheduledtasktrigger?view=windowsserver2022-ps#example-1--register-a-scheduled-task-that-starts-a-task-once"&gt;New-ScheduledTaskTrigger (ScheduledTasks) | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;を見ていて、 &lt;code&gt;-At 3pm&lt;/code&gt; て何これ？と思って日本語も試した。
使い所がわかりかねるが、以下のようなジャパナイズされた入力でも OK!
ただし漢数字、曜日や午前/午後は &lt;code&gt;Parse&lt;/code&gt; できないので無理な。&lt;/p&gt;&lt;p&gt;参照: &lt;a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/parsing-datetime"&gt;Convert strings to DateTime | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; Get-Date 15時

Wednesday, January 16, 2022 03:00:00

PS&amp;gt; Get-Date 6年6月6日

Monday, June 6, 2006 00:00:00

PS&amp;gt; Get-Date 3じ
Get-Date: Cannot bind parameter 'Date'. Cannot convert value "3じ" to type "System.DateTime". Error: "The string '3じ' was not recognized as a valid DateTime. There is an unknown word starting at index '1'."
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;どういう仕組や。&lt;/p&gt;&lt;h4 id="大まかな予測"&gt;大まかな予測&lt;/h4&gt;&lt;p&gt;コマンドレットや関数に渡す前、引数の型 &lt;code&gt;DateTime&lt;/code&gt; の時点で捏ねくっている様子。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function hiduke() {
  param(
    [datetime]
    $d
  )
  $d
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; hiduke -d 3時

Wednesday, January 16, 2022 03:00:00
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;キャストとパースの違いを見る。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; [DateTime]::Parse('3時')

Wednesday, January 16, 2022 03:00:00

PS&amp;gt; [DateTime]::Parse('3じ')
MethodInvocationException: Exception calling "Parse" with "1" argument(s): "The string '3じ' was not recognized as a valid DateTime. There is an unknown word starting at index '1'."

PS&amp;gt; [DateTime]'3時'

Wednesday, January 16, 2022 03:00:00

PS&amp;gt; [DateTime]'3じ'
InvalidArgument: Cannot convert value "3じ" to type "System.DateTime". Error: "The string '3じ' was not recognized as a valid DateTime. There is an unknown word starting at index '1'."
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同じエラーメッセージ出てるので、 PowerShell が指定の型に評価するのに &lt;code&gt;DateTime.Parse&lt;/code&gt; を呼んでる。
真面目に考えたことなかったが、PowerShell 自体の機能でパラメーターバインディングというらしい。
&lt;a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_parameters?view=powershell-7.2"&gt;about Parameters - PowerShell | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;(今更ながら)また一つ学んでしまったようだな...&lt;/p&gt;&lt;p&gt;パラメーターバインディングの処理内容を知るには &lt;code&gt;Trace-Command&lt;/code&gt; が使える。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; Trace-Command -PSHost -Name ParameterBinding {Get-Date 3じ}
DEBUG: 2022-01-30 14:47:05.5488 ParameterBinding Information: 0 : BIND NAMED cmd line args [Get-Date]
DEBUG: 2022-01-30 14:47:05.5491 ParameterBinding Information: 0 : BIND POSITIONAL cmd line args [Get-Date]
DEBUG: 2022-01-30 14:47:05.5493 ParameterBinding Information: 0 :     BIND arg [3じ] to parameter [Date]
DEBUG: 2022-01-30 14:47:05.5495 ParameterBinding Information: 0 :         BIND arg [3じ] to param [Date] SKIPPED
DEBUG: 2022-01-30 14:47:05.5496 ParameterBinding Information: 0 :     BIND arg [3じ] to parameter [Date]
DEBUG: 2022-01-30 14:47:05.5497 ParameterBinding Information: 0 :         BIND arg [3じ] to param [Date] SKIPPED
DEBUG: 2022-01-30 14:47:05.5499 ParameterBinding Information: 0 :     BIND arg [3じ] to parameter [Date]
DEBUG: 2022-01-30 14:47:05.5501 ParameterBinding Information: 0 :         BIND arg [3じ] to param [Date] SKIPPED
DEBUG: 2022-01-30 14:47:05.5503 ParameterBinding Information: 0 :     BIND arg [3じ] to parameter [Date]
DEBUG: 2022-01-30 14:47:05.5504 ParameterBinding Information: 0 :         COERCE arg to [System.DateTime]
DEBUG: 2022-01-30 14:47:05.5506 ParameterBinding Information: 0 :             Trying to convert argument value from System.String to System.DateTime
DEBUG: 2022-01-30 14:47:05.5509 ParameterBinding Information: 0 :             CONVERT arg type to param type using LanguagePrimitives.ConvertTo
DEBUG: 2022-01-30 14:47:05.5519 ParameterBinding Information: 0 :             ERROR: ERROR: COERCE FAILED: arg [3じ] could not be converted to the parameter type [System.DateTime]
(...端折る...)
Get-Date: Cannot bind parameter 'Date'. Cannot convert value "3じ" to type "System.DateTime". Error: "The string '3じ' was not recognized as a valid DateTime. There is an unknown word starting at index '1'."
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;パラメータバインディング時によしなにしてるのがわかってきたところで、力尽きた。
PowerShell のパラメータバインディングの仕組みに関しては宿題やな。気長に見ていくしかない。&lt;/p&gt;&lt;h4 id="潜る"&gt;潜る&lt;/h4&gt;&lt;p&gt;ここまで来れたので、次は PowerShell のパラメータバインディングのコードに潜り込む。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Trace-Command&lt;/code&gt; の ParameterBinding Information に出てた&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;"COERCE FAILED: arg .+ could not be converted to the parameter type "&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;"CONVERT arg type to param type using LanguagePrimitives.ConvertTo"&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;から、 &lt;a href="https://github.com/PowerShell/PowerShell/blob/master/src/System.Management.Automation/engine/ParameterBinderBase.cs#L1262"&gt;&lt;code&gt;ParameterBinderBase.cs&lt;/code&gt;&lt;/a&gt;にたどり着いた。&lt;/p&gt;&lt;p&gt;例外がスローされたのがどこか &lt;code&gt;LanguagePrimitives.ConvertTo&lt;/code&gt; から先を探るのにはちょっと情報が足りなかったので、&lt;code&gt;Trace-Command&lt;/code&gt; に TypeConversion を足して出力した。&lt;/p&gt;&lt;p&gt;TypeConversion が有用なのがわかったのは、&lt;a href="https://github.com/PowerShell/PowerShell/blob/0ef30e54c70b9d5d69a35d1aeecdf2820cc1ab3b/src/System.Management.Automation/engine/LanguagePrimitives.cs#L4837"&gt;&lt;code&gt;LanguagePrimitives.cs&lt;/code&gt; 内の &lt;code&gt;ConvertTo&lt;/code&gt;&lt;/a&gt;を追ってたらトレース情報にまんまその名前が出てきたから。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; Trace-Command -PSHost -Name ParameterBinding,TypeConversion {Get-Date 3じ}
DEBUG: 2022-01-30 15:36:52.2304 ParameterBinding Information: 0 : BIND NAMED cmd line args [Get-Date]
DEBUG: 2022-01-30 15:36:52.2309 ParameterBinding Information: 0 : BIND POSITIONAL cmd line args [Get-Date]
DEBUG: 2022-01-30 15:36:52.2312 ParameterBinding Information: 0 :     BIND arg [3じ] to parameter [Date]
DEBUG: 2022-01-30 15:36:52.2314 ParameterBinding Information: 0 :         BIND arg [3じ] to param [Date] SKIPPED
DEBUG: 2022-01-30 15:36:52.2315 ParameterBinding Information: 0 :     BIND arg [3じ] to parameter [Date]
DEBUG: 2022-01-30 15:36:52.2318 ParameterBinding Information: 0 :         BIND arg [3じ] to param [Date] SKIPPED
DEBUG: 2022-01-30 15:36:52.2320 ParameterBinding Information: 0 :     BIND arg [3じ] to parameter [Date]
DEBUG: 2022-01-30 15:36:52.2322 ParameterBinding Information: 0 :         BIND arg [3じ] to param [Date] SKIPPED
DEBUG: 2022-01-30 15:36:52.2325 ParameterBinding Information: 0 :     BIND arg [3じ] to parameter [Date]
DEBUG: 2022-01-30 15:36:52.2326 ParameterBinding Information: 0 :         COERCE arg to [System.DateTime]
DEBUG: 2022-01-30 15:36:52.2329 ParameterBinding Information: 0 :             Trying to convert argument value from System.String to System.DateTime
DEBUG: 2022-01-30 15:36:52.2331 ParameterBinding Information: 0 :             CONVERT arg type to param type using LanguagePrimitives.ConvertTo
DEBUG: 2022-01-30 15:36:52.2336 TypeConversion Information: 0 :             Converting "3じ" to "System.DateTime".
DEBUG: 2022-01-30 15:36:52.2346 TypeConversion Information: 0 :                 Exception calling Parse method with CultureInfo: "The string '3じ' was not recognized as a valid DateTime. There is an unknown word starting at index '1'.".
DEBUG: 2022-01-30 15:36:52.2350 ParameterBinding Information: 0 :             ERROR: ERROR: COERCE FAILED: arg [3じ] could not be converted to the parameter type [System.DateTime]
(...端折る...)
Get-Date: Cannot bind parameter 'Date'. Cannot convert value "3じ" to type "System.DateTime". Error: "The string '3じ' was not recognized as a valid DateTime. There is an unknown word starting at index '1'."
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ParameterBinding Information のエラー出力までに TypeConversion Information が足されたのがわかる。いい感じじゃないか。&lt;/p&gt;&lt;p&gt;このキーワードを元にコードを探ると、&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/PowerShell/PowerShell/blob/0ef30e54c70b9d5d69a35d1aeecdf2820cc1ab3b/src/System.Management.Automation/engine/LanguagePrimitives.cs#L5226-L5287"&gt;&lt;code&gt;LanguagePrimitives.cs&lt;/code&gt; 内の &lt;code&gt;FigureParseConversion&lt;/code&gt;&lt;/a&gt; でパースに使うメソッドをリフレクションで取得している&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/PowerShell/PowerShell/blob/0ef30e54c70b9d5d69a35d1aeecdf2820cc1ab3b/src/System.Management.Automation/engine/LanguagePrimitives.cs#L3747-L3780"&gt;&lt;code&gt;LanguagePrimitives.cs&lt;/code&gt; 内の &lt;code&gt;ConvertViaParseMethod&lt;/code&gt;&lt;/a&gt; で取得したメソッドを使ったパースが行われてる&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;というのがわかった。&lt;/p&gt;&lt;p&gt;やっぱり &lt;code&gt;Datetime.Parse&lt;/code&gt; を使ってたんや。あー、スッキリした！&lt;/p&gt;&lt;p&gt;というか PowerShell 使ってる割にちゃんと勉強してないから、せなあかんな。&lt;/p&gt;</description><pubDate>Sun, 30 Jan 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-01-23-scheduled-task-in-powershell</guid><link>https://krymtkts.github.io/posts/2022-01-23-scheduled-task-in-powershell</link><title>Windows のタスクを操作する(PowerShell で)</title><description>&lt;p&gt;決まった時間までにやらなければいけないことがあるとする。それを人間力でカバーするのは、それなりに資源の浪費になるので自動化したいとする。
最近の Windows ならタスクスケジューラで直に書いてもいいけど、操作めんどすぎるので普通に考えたらスクリプトにするでしょう。
これを Windows 11 と PowerShell 7.2.1 でやる。&lt;/p&gt;&lt;p&gt;それでは &lt;a href="https://docs.microsoft.com/en-us/powershell/module/scheduledtasks/?view=windowsserver2019-ps"&gt;ScheduledTasks Module&lt;/a&gt; を使う。
このモジュールは Window なら以下のシステムフォルダにひっそりと存在する。令和のこの時代になんつー古い(v1)話なんや、とは思う。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Get-Module -Name ScheduledTasks -ListAvailable

    Directory: C:\WINDOWS\system32\WindowsPowerShell\v1.0\Modules

ModuleType Version    PreRelease Name                                PSEdition ExportedCommands
---------- -------    ---------- ----                                --------- ----------------
Manifest   1.0.0.0               ScheduledTasks                      Core,Desk {Get-ScheduledTask, Set-ScheduledTask, Register-Sche…
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;WindowsPowerShell(v5.1)なら &lt;a href="https://docs.microsoft.com/en-us/powershell/module/psscheduledjob/?view=powershell-5.1"&gt;PSScheduledJob Module&lt;/a&gt; が使えるが、 PowerShell 7 では使えない(&lt;code&gt;Import-Module&lt;/code&gt; もできない)ので、 &lt;code&gt;ScheduledTask&lt;/code&gt; 一択かと。&lt;/p&gt;&lt;p&gt;ではいくつかのレシピを以下に記す。&lt;/p&gt;&lt;h3 id="日次で指定時間に実行人間味のあるズレを添えて"&gt;日次で指定時間に実行(人間味のあるズレを添えて)&lt;/h3&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$pwsh = (get-command pwsh).Source
$action = New-ScheduledTaskAction -Execute $pwsh -Argument '-NonInteractive -Command "Invoke-MyCommand"'
$trigger = New-ScheduledTaskTrigger -Daily -At 7:46 -RandomDelay 00:10
$task = New-ScheduledTask -Action $action -Trigger $trigger
Register-ScheduledTask -InputObject $task -TaskName 'morning-action'
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="指定時間に起動して実行待ちするタスク--実行許諾の通知的なもの"&gt;指定時間に起動して実行待ちするタスク ≒ 実行許諾の通知的なもの&lt;/h3&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$pwsh = (get-command pwsh).Source
$action = New-ScheduledTaskAction -Execute $pwsh -Argument '-Command "{Read-Host `"press key`" | Out-Null; Invoke-MyCommand}.Invoke()"'
$trigger = New-ScheduledTaskTrigger -Daily -At 17:00
$task = New-ScheduledTask -Action $action -Trigger $trigger
Register-ScheduledTask -InputObject $task -TaskName 'evening-action'
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="単発で指定時間に実行人間味のあるズレを添えて"&gt;単発で指定時間に実行(人間味のあるズレを添えて)&lt;/h3&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$pwsh = (get-command pwsh).Source
$action = New-ScheduledTaskAction -Execute $pwsh -Argument '-NonInteractive -Command "Invoke-MyCommand"'
$jitter = (Get-Random -Minimum 30 -Maximum (60*5))
$timing = (Get-Date '2022-01-30 17:05').AddSeconds($jitter)
$trigger = New-ScheduledTaskTrigger -At $timing -Once
$setting = New-ScheduledTaskSettingsSet -DeleteExpiredTaskAfter 00:00:10
$task = New-ScheduledTask -Action $action -Trigger $trigger -Settings $setting | `
    %{ $_.Triggers[0].EndBoundary = $timing.AddMinutes(1).ToString('s'); $_}
Register-ScheduledTask -InputObject $task -TaskName 'single-action'
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;このレシピではズレの算出は自前で行っている。&lt;code&gt;New-ScheduledTaskTrigger&lt;/code&gt; に &lt;code&gt;-RandomDelay&lt;/code&gt; を指定しておくのもアリだが、単発であるし具体的にいつ実行されるかがわかる方が好ましいかと考えた。&lt;/p&gt;&lt;p&gt;単発タスクなので、実行後にタスクを廃棄したいとする。その場合は例のように &lt;code&gt;-Settings&lt;/code&gt; で自動削除の設定を有効にする必要がある。
同時に、タスクの期限切れの日時も指定する必要があるが、これはコマンドレットのオプションでは設定できない。直接オブジェクトに代入することで設定する(各 &lt;code&gt;Triggers&lt;/code&gt; で &lt;code&gt;EndBoundary&lt;/code&gt; を設定)。&lt;/p&gt;&lt;p&gt;参照: &lt;a href="https://stackoverflow.com/questions/29337135/powershell-v4-create-remote-task-scheduler-task-set-to-expire-and-delete/35777432#35777432"&gt;Powershell v4. Create remote task scheduler task set to expire and delete - Stack Overflow&lt;/a&gt;&lt;/p&gt;&lt;h3 id="注意"&gt;注意&lt;/h3&gt;&lt;p&gt;いくつかの注意点がある。&lt;/p&gt;&lt;h4 id="実行ファイルは絶対パス指定"&gt;実行ファイルは絶対パス指定&lt;/h4&gt;&lt;p&gt;実行ファイルは絶パス(絶対パスのわかりにくい略称)指定じゃないといけない。コマンドプロンプトでパスを通していたとしても、 &lt;code&gt;pwsh&lt;/code&gt; とかだとタスクスケジューラちゃんは実行ファイルを見つけられない。&lt;/p&gt;&lt;h4 id="pwsh-の引数-command-はダブルクォートで書く"&gt;&lt;code&gt;pwsh&lt;/code&gt; の引数 &lt;code&gt;Command&lt;/code&gt; はダブルクォートで書く&lt;/h4&gt;&lt;p&gt;&lt;code&gt;New-ScheduledTaskAction&lt;/code&gt; の引数 &lt;code&gt;Argument&lt;/code&gt; に、 &lt;code&gt;pwsh&lt;/code&gt; に渡す引数を定義する。
この時、引数 &lt;code&gt;Command&lt;/code&gt; に渡す文字列はダブルクォートで書くこと。
コマンドプロンプトで試せばわかるが、ダブルクォートはコマンドプロンプトで文字列として解釈され &lt;code&gt;pwsh&lt;/code&gt; に渡るのに対し、シングルクォートは文字列と解釈されないそのままが渡されている様子。&lt;/p&gt;&lt;pre&gt;&lt;code class="cmd"&gt;C:\Windows\system32&amp;gt;pwsh -NonInteractive -Command "Write-Host 123"
123

C:\Windows\system32&amp;gt;pwsh -NonInteractive -Command 'Write-Host 123'
Write-Host 123
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;この挙動のソースはコレ ↓ くらいしか見つからんかった。オフィシャルな情報はないのかな。あったら是非引用したい。(コマンドプロンプト界の常識過ぎるテーマなのか？)&lt;/p&gt;&lt;p&gt;&lt;a href="https://stackoverflow.com/questions/24173825/what-does-single-quoting-do-in-windows-batch-files/24181667#24181667"&gt;cmd - What does single-quoting do in Windows batch files? - Stack Overflow&lt;/a&gt;&lt;/p&gt;&lt;h3 id="read-host-するからにゃぁ-interactive-で-pwsh-を起動しろよな"&gt;&lt;code&gt;Read-Host&lt;/code&gt; するからにゃぁ Interactive で &lt;code&gt;pwsh&lt;/code&gt; を起動しろよな&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Read-Host&lt;/code&gt; する例なのに、間違って &lt;code&gt;-NoInteractive&lt;/code&gt; をつけてしまうと、このようにおもしろエラーを頂戴するのでご注意。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;C:\Windows\system32&amp;gt;pwsh -NonInteractive -Command "{Read-Host `"press key`" | Out-Null; Invoke-MyCommand}.Invoke()"
MethodInvocationException: Exception calling "Invoke" with "0" argument(s): "PowerShell is in NonInteractive mode. Read and Prompt functionality is not available."
&lt;/code&gt;&lt;/pre&gt;</description><pubDate>Sun, 23 Jan 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-01-15-move-taskbar-to-the-top-in-win11-pwsh</guid><link>https://krymtkts.github.io/posts/2022-01-15-move-taskbar-to-the-top-in-win11-pwsh</link><title>Windows 11 のタスクバーを天に(PowerShell で)</title><description>&lt;p&gt;Windows11 ではメニューからタスクバーを天に持ち上げれなくなったので、みんなレジストリを操作して実現している。手順はどこでも手に入るが、以下のページを参照した。&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.tomshardware.com/how-to/windows-11-taskbar-move-to-top"&gt;How to Move the Taskbar to the Top in Windows 11 | Tom's Hardware&lt;/a&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;regedit&lt;/code&gt; を開く&lt;/li&gt;&lt;li&gt;&lt;code&gt;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\StuckRects3&lt;/code&gt; を開く&lt;/li&gt;&lt;li&gt;&lt;code&gt;Settings&lt;/code&gt; を編集し保存する
&lt;ul&gt;&lt;li&gt;2 行目を &lt;code&gt;7A F4 00 00 03 00 00 00&lt;/code&gt; -&amp;gt; &lt;code&gt;7A F4 00 00 01 00 00 00&lt;/code&gt;にする
&lt;ul&gt;&lt;li&gt;デフォルトの&lt;code&gt;03&lt;/code&gt;が下、&lt;code&gt;01&lt;/code&gt;が上というわけ&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;explorer&lt;/code&gt; を再起動する
&lt;ul&gt;&lt;li&gt;コマンドプロンプトで
&lt;ol&gt;&lt;li&gt;&lt;code&gt;taskkill /f /im explorer.exe&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;start explorer.exe&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;これが PC 変わる度にやるのクソめんどいので、PowerShell でスクリプト化した。
そんなに機会はないけど一々覚えてないので先程のページを見にったりと、とにかくめんどい。&lt;/p&gt;&lt;p&gt;PowerShell 7.2.1 でやった。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ShowHex = {param ([array]$arr) ($arr | %{[System.Convert]::ToHexString($_)}) -join ' '}
$path = 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\StuckRects3'
$key = 'Settings'
$org = Get-ItemProperty $path | Select-Object -ExpandProperty $key
$ShowHex.Invoke((,$org))

$new = @() + $org
$new[12] = 0x01
$ShowHex.Invoke((,$new))
Compare-Object $org $new

Set-ItemProperty $path -name $key -Value $new

Stop-Process -Name explorer -Force
## if explorer doesn't restart, start explorer manually.
# Start-Process -Name explorer
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;万が一失敗してたら &lt;code&gt;$org&lt;/code&gt; で &lt;code&gt;Set-ItemProperty&lt;/code&gt; して戻す必要があるので、成功(≒ 天にタスクバー)を確認するまで窓を閉じない方が良かろう。
ちゃんと期待の更新ができているか確認するために、レジストリの値を 16 進数に変換して標準出力までしちゃう。&lt;/p&gt;&lt;p&gt;&lt;a href="https://gist.github.com/krymtkts/ba83a0612bba84b5e8229d64e9d8681a"&gt;Gist はこちら&lt;/a&gt;。&lt;/p&gt;&lt;h3 id="おまけ"&gt;おまけ&lt;/h3&gt;&lt;p&gt;&lt;code&gt;taskkill&lt;/code&gt; は PowerShell で言うところの何か調べたときのページ ↓&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.pdq.com/blog/what-is-the-powershell-equivalent-of-taskkill/"&gt;What Is The PowerShell Equivalent Of Taskkill | PDQ.com&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Okay, I'll be the first to admit it; the name is a little lackluster. Especially when compared to &lt;strong&gt;TASKKILL!!!!!!&lt;/strong&gt; &lt;strong&gt;Stop-Process&lt;/strong&gt; just doesn't carry the same hostile undertones Thankfully, Microsoft at least gave us &lt;strong&gt;kill&lt;/strong&gt; as an alias, so we've got that going for us. Regardless, let's see if it still packs the same task-killing punch.&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;さて、最初に断っておきますが、このネーミングは少し物足りないですね。特に&lt;strong&gt;TASKKILL!!!!!!&lt;strong&gt;と比較するとね。 ありがたいことに、Microsoft は少なくとも&lt;/strong&gt;kill&lt;/strong&gt;という別名をつけてくれました。 ともかく、同じようにタスクを殺すパンチをパックしているかどうか見てみましょう。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;こんなん笑うわｗ&lt;/p&gt;</description><pubDate>Sat, 15 Jan 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-01-09-planning</guid><link>https://krymtkts.github.io/posts/2022-01-09-planning</link><title>2022</title><description>&lt;p&gt;できたら or できなかったらどうなるというのがないが、例年通り目標をたてる。&lt;/p&gt;&lt;h4 id="テーマ-自分の人生は自分で決める"&gt;テーマ: 自分の人生は自分で決める&lt;/h4&gt;&lt;p&gt;これは自分の中でずっと言い聞かせていることなのだけど、去年一昨年は外的要因によって見失いがちだった。改めて見つめ直したいテーマにした。&lt;/p&gt;&lt;p&gt;単になんでもかんでも自分で決めたいわけじゃなくて、意見を持ってこうなのだと考えているところに、決断の資源を割く様にする。&lt;/p&gt;&lt;h3 id="2021-年の目標"&gt;2021 年の目標&lt;/h3&gt;&lt;p&gt;継続する目標。前年未達だった目標は基本継続としたいが、OSS への貢献については保留とする。&lt;/p&gt;&lt;p&gt;なんでかというとわたし自身が積極的でなくて「バグ見っけたら起票しよう」くらいのアクションしか例年やってないから、個別に項を設けて書いても意味がない。
AWS Tools for PowerShell のくだりで実感したが、やるんだったら Pull Request をマージしてくらいまでドライブしないと、如何なる小規模プロジェクトでもメンテナの負荷になり得る。結局コードで殴りつけてあげないと誰のためにもならない。とはいえ貢献したいプロジェクトを探して～とかやるのはなんか違う。
自作ツールの更新周りで既存のツールを色々見ていくだろうから、その流れで貢献することがあればできたらいいかなくらいにする。なんか無責任な感じもするけど、わたしの資源はわたしが思った(というか期待した)ほど多くなくて、やりたいことができないってのが常なので。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;住みたい場所を決める
&lt;ul&gt;&lt;li&gt;わたしは田舎に住み(薪ストーブやり)たいが、妻は車でなくても生活圏内を移動できることを重視してるので、落とし所を探す。なんか良い選択肢ないかなー&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;積ん読の消化 1 冊/月
&lt;ul&gt;&lt;li&gt;前年からペースを上げて、読書習慣を改善する&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;自作ツールの更新
&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/PSMFAttendance"&gt;PSMFAttendance&lt;/a&gt;&lt;ul&gt;&lt;li&gt;はよ Gallery に登録しろ&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/mccall-bot"&gt;mccall-bot&lt;/a&gt;&lt;ul&gt;&lt;li&gt;現職は Slack 文化がないため使い所が自分のチャンネルしかなく持て余している。放置したままだとマッコールさんにも申し訳ないので、なんか行く末を決めて差し上げたほうが良いのかもと考えている&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;ギター練習を 30 分/毎日
&lt;ul&gt;&lt;li&gt;たまにはバンド練習やりたいけど、世情を見つつ判断する&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://krymtkts.github.io/"&gt;このブログ&lt;/a&gt;&lt;ul&gt;&lt;li&gt;毎月の更新リズムを維持する&lt;/li&gt;&lt;li&gt;&lt;code&gt;todo.txt&lt;/code&gt; に放置テーマが結構溜まってきていることも鑑み、粛々と消化したい&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;追加する目標。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;深酒で怪我をしない
&lt;ul&gt;&lt;li&gt;寄る年波もあり怪我の治りが遅いので超重要課題&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;知らない言語を学ぶ F#
&lt;ul&gt;&lt;li&gt;PowerShell で面倒なスクリプトを書くとき、代わりに F#で書こうという気になったので今勉強している&lt;/li&gt;&lt;li&gt;なんかツールを書いたらゴールとしよう&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</description><pubDate>Sun, 09 Jan 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-12-31-retrospective2021</guid><link>https://krymtkts.github.io/posts/2021-12-31-retrospective2021</link><title>振り返り 2021 年</title><description>&lt;p&gt;2021 年を振り返る。&lt;/p&gt;&lt;p&gt;2021 年のテーマは「自分を大事に」だった。肉体・精神共に大事にできてへんのちゃうん？という上半期から、大事にするための判断に絡んだ下半期。&lt;/p&gt;&lt;p&gt;決して悪い方向には向かっていないが、2021 年は迷いの多い年だった。判断としては信念に沿ったモノだったはずなのだが、外的要因や体力不足による判断低下から自分自身の判断とその結果に相当の迷いがあった。&lt;/p&gt;&lt;p&gt;大きな出来事は 2 個だけか。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;働きすぎた&lt;/li&gt;&lt;li&gt;転職&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="働きすぎた"&gt;働きすぎた&lt;/h3&gt;&lt;p&gt;2020 年末から 2021 年始は殆ど休みもなく「2020 年秋の新機能開発」に奔走していた。冬やけどな。
これはチーム総力戦の鬼の休日出勤によってなんとか本番へリリースされたのだけど敗戦処理は 2021 年 2 月頃まであったような感じやったな～、もはや懐かしい景色。&lt;/p&gt;&lt;p&gt;その新機能開発によって圧迫されてしまった機能もちょいちょいバグはあれど重大な問題なく本番へリリースできた(奇跡的に)。またリリース後の残作業に 1 年目の若手とおよそ 2week のスクラムもどきで敗戦処理をできたのはよかった。前職の若手教育は OJT が主なのだが、リスキーな案件ばかりで開発やらせてあげられないので、こういった場を設けられるのはやはりリードエンジニアたる所以だったなと感じる(これは自画自賛)。
この辺はまだ限界突破してなかったが、休日出勤を繰り返したことで感覚がおかしくなって、3 月以降徐々に稼働時間がかさんでいった。&lt;/p&gt;&lt;p&gt;3 月頃から入ったプロジェクトは、開発も始めていないのに締切だけあり、割り振られたリソースではどうあがいても足りないくらいだった。外向けのコミットメントもされてたせいで誰も止められない暴走列車と化したプロジェクト。今思い出してもドキドキするな～。プログラマなら感覚的に WBS とか見て「あ、やばいな」という肌感触があると思うが、まさにあれだった。打開策ないかスケジュール見直し頼んでみたりとか人足し依頼してみたような記憶もあるけど抜本的な解決に至らず。&lt;/p&gt;&lt;p&gt;どうにもできなかったので、人身御供的にリードエンジニアが全てを背負うしかあるまいなとわたしも暴走し、 SES やってた時以来の過重労働で 36 協定の制限突破する勢い出してた。万が一法律に触れそうなら会社も動くやろ的な。いやーほんまに良くない判断ね。まさにアドレナリンジャンキーと化していた。
結局スケジュールに決定的に間に合わないと判断してもらえたことで、わたしからいくつかのしごとが引き剥がしてもらい、エンジニアがドカドカ投入されてメチャクチャ綱渡り的に開発・リリースしていった形だったような気がする。
正直なところ肉体・精神共に不調だったので、細かく覚えてない。これも日記見ながら書いたくらいや。ある種、燃え尽き症候群的な状態に陥ってたのだろう。&lt;/p&gt;&lt;h3 id="転職"&gt;転職&lt;/h3&gt;&lt;p&gt;そしてこの過重労働の間に、ヘッドハンター()からオファーをもらって、転職することにした。&lt;/p&gt;&lt;p&gt;当時の判断は&lt;a href="/posts/2021-09-28-jobchange-2021"&gt;過去の日記&lt;/a&gt;に書いてあるが、この振り返りの文脈でいうとまた思うところがある。プロジェクトの悪いところ全部盛りみたいな状況から「こんなに苦しいならもうチーム開発などいらぬ！」みたいな聖帝的感覚に陥ってただろうなと改めて感じる(現職はほぼ一人ひとり働く感じ)。わたしの中では前職の元同僚達と働くのは楽しいことだったので転職するのに相当の迷いがあった。一緒に飲んだらかなりの確率でわたしが酔っ払って負傷するので危険な仲間。&lt;/p&gt;&lt;p&gt;この転職、入社前から諸々のトラブルはあったものの、辛うじてまだ生き残ってる。直前にヘッドハンター()に手のひら返されたり、ヘッド(略)が先に入れた社員が即辞めてたり、1 ヶ月パイセンが左遷(とわたしは表現している)されたりして、あんま精神衛生の環境は良くない。&lt;/p&gt;&lt;p&gt;ただ悪いことばかりではない。リモート慣れしていない会社にフルリモートで参画しても、関係者と意見交換しつつ一人で仕事を進められる自信ができた。また最近仕事で深く踏み込んでなかったフロントエンド開発(TypeScript + React.js で Atomic Components する)をやってフロントエンド戦国時代を肌で感じたりできたのは良。
入社前からやりたかったところは未だやれてない状況なので煮え切らないが、これまた期待値だけで報酬は上がったりしてるので、筋は悪くないのかなと。&lt;/p&gt;&lt;p&gt;やっぱどこでもそれなりに動けるな、という自信が確たるもんになった。&lt;/p&gt;&lt;h3 id="2021-年目標と成果"&gt;2021 年目標と成果&lt;/h3&gt;&lt;p&gt;年初に以下の目標を設定した。50%超えたしぼちぼちということにする。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;❌ 住みたい場所を決める
&lt;ul&gt;&lt;li&gt;意見のすり合わせが進んでいない&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;⭕️ 仕事上の掃除
&lt;ul&gt;&lt;li&gt;掃除の仕方が転職って形になったが、引き継ぎも最低限やったので良しとしてくれ...&lt;/li&gt;&lt;li&gt;のちの調査によると、引き継いだ仕事の 33% だけがわたしのシナリオ通り進めて、他は放置されているらしい。ショッキングな結果やがそこは残された者共や前職が決めるとこやからな、何も言うまい&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;⭕️ 昇給
&lt;ul&gt;&lt;li&gt;前職の昇給は満足じゃなかったが、転職して上がった&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;🔺 積ん読の消化
&lt;ul&gt;&lt;li&gt;技術書以外含めて 1 冊/2 ヵ月&lt;/li&gt;&lt;li&gt;ライフハックや書評とかのライトな本から再開し、今は技術書も読めるようになってきた。転職後少しずつ習慣を取り戻せている&lt;/li&gt;&lt;li&gt;やはり読書のためには疲労感の改善が重要やな&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;❌ OSS へのコントリビューション
&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/aws/aws-tools-for-powershell/issues/225"&gt;&lt;code&gt;aws/aws-tools-for-powershell&lt;/code&gt; のバグレポート&lt;/a&gt;しただけ
&lt;ul&gt;&lt;li&gt;なんか忙しそうで進展ないし、修正試みた方が良かったな&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;あとは自作のツールか。まだ PSGallery に登録してないけど。 &lt;a href="https://github.com/krymtkts/PSMFAttendance"&gt;krymtkts/PSMFAttendance&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;🔺 自作ツールの更新
&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/Get-GzipContent"&gt;krymtkts/Get-GzipContent: Get-Content for gzip files.&lt;/a&gt;&lt;ul&gt;&lt;li&gt;ちょっとだけやった&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/mccall-bot"&gt;mccall-bot&lt;/a&gt;&lt;ul&gt;&lt;li&gt;やってない&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;⭕️ ギター練習を 30 分/週 3 回
&lt;ul&gt;&lt;li&gt;割と出来てる。耳コピ少し/songsterr で曲覚えたり&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;⭕️ &lt;a href="https://krymtkts.github.io/"&gt;このブログ&lt;/a&gt;を毎月更新する
&lt;ul&gt;&lt;li&gt;6 月ズルしたけどコンスタントにかけるようになったかな&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;⭕️ 日頃使ってるスニペット的なのを Gist に登録していく
&lt;ul&gt;&lt;li&gt;&lt;a href="https://gist.github.com/krymtkts"&gt;krymtkts’s gists&lt;/a&gt; みたら月 1 個くらいで数少ないけどぼちぼちやっとるな&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;やっぱ転職の判断した頃から制御を自分に戻せてるのか、自分向けの目標は簡単なところからできるようになったんじゃないかな。
ここから大きく変化を～とか欲張らず、ちまちま積み重ねれたらいいな。&lt;/p&gt;&lt;p&gt;おわり。&lt;/p&gt;</description><pubDate>Fri, 31 Dec 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-12-26-fnm-tips-with-ccleaner</guid><link>https://krymtkts.github.io/posts/2021-12-26-fnm-tips-with-ccleaner</link><title>fnm でインストールした処理系は Temp フォルダからシンボリックリンクされるので ccleaner で消える話(当然)</title><description>&lt;p&gt;最近、 Node.js 処理系のバージョン管理に fnm を使っている。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/Schniz/fnm"&gt;Schniz/fnm: 🚀 Fast and simple Node.js version manager, built in Rust&lt;/a&gt;&lt;/p&gt;&lt;p&gt;お仕事 PC(Windows) では Yarn を使うのだが、 それまで使っていた Nodist だとどうにも Yarn が内部的に参照する npx が新しいバージョンに変わらなくてエラーが解消できなかった。&lt;/p&gt;&lt;p&gt;これが fnm なら何の問題もなくサクサク動く。&lt;a href="https://community.chocolatey.org/packages/fnm"&gt;chocolatey&lt;/a&gt; でインストールできるし、&lt;code&gt;.node-version&lt;/code&gt;, &lt;code&gt;.nvmrc&lt;/code&gt; をうまく使える点でも良、重宝している。&lt;/p&gt;&lt;p&gt;&lt;code&gt;fnm env&lt;/code&gt; で使う処理系を指定した環境変数を生成＆利用したいツールに反映させる必要があるため、 VS Code なんかは terminal 経由で起動する必要があるのだけど(それしか方法を知らん)、これは元々わたしの作業スタイルだったので特に問題ない。&lt;/p&gt;&lt;h3 id="事件は突然に"&gt;事件は突然に&lt;/h3&gt;&lt;p&gt;ある日、怪現象に悩まされた。&lt;/p&gt;&lt;p&gt;何気なく VS Code を立ち上げると、 &lt;code&gt;textlint&lt;/code&gt; が見つからないというエラーが出力されていた。&lt;code&gt;textlint&lt;/code&gt; だけでなく、 &lt;code&gt;npm&lt;/code&gt; も &lt;code&gt;node&lt;/code&gt; も消え去っていたのだ。その時はさっさと作業を始めたかったので、処理系やモジュールを再インストールすることで現状復帰した。これが最も手っ取り早い。&lt;/p&gt;&lt;p&gt;この原因は後でからわかったのだが非常に単純な話であって、Temp フォルダの中身を再帰的に消したことで fnm がインストールした処理系全ても無に帰したのだ。&lt;/p&gt;&lt;p&gt;わたしは Temp フォルダやその他のゴミ掃除目的に ccleaner を長らく使っている。ccleaner は Temp フォルダの中身を一覧して消す。&lt;/p&gt;&lt;p&gt;&lt;code&gt;fnm&lt;/code&gt; がインストールした処理系自体は &lt;code&gt;$env:FNM_DIR&lt;/code&gt; に配置される。
&lt;code&gt;fnm env&lt;/code&gt; を実行すると、Temp フォルダ内に &lt;code&gt;$env:FNM_DIR&lt;/code&gt; 配下の特定バージョンへ向けたシンボリックリンクを作成する。そのシンボリックリンクのパスは &lt;code&gt;$env:FNM_MULTICHELL_PATH&lt;/code&gt; に格納されている。&lt;/p&gt;&lt;p&gt;おわかりいただけただろうか。&lt;/p&gt;&lt;p&gt;ccleaner のように Temp フォルダを探索的に掃除するなら、以下のコマンドで事前に削除されるファイルが何処のものか知ると良い。こんなの事故るまで頭が回らんわ。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Get-ChildItem $env:FNM_MULTISHELL_PATH/../ | Select-Object -Property LinkTarget
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="対策"&gt;対策&lt;/h3&gt;&lt;p&gt;現状、ccleaner 等の Temp フォルダを掃除するアプリで、 &lt;code&gt;fnm&lt;/code&gt; のフォルダを除外するしかないか。
しかしそうなると、使われなくなった &lt;code&gt;$env:FNM_MULTISHELL_PATH&lt;/code&gt; の掃除を自力でする必要が出てくる。
&lt;code&gt;fnm env&lt;/code&gt; の度に処理系へのシンボリックリンクが作成されるので、掃除はこまめに行う必要がある(だからこそ Temp フォルダに作成しているのだろうけど)。&lt;/p&gt;&lt;p&gt;&lt;code&gt;fnm&lt;/code&gt; 自体には手動でこのシンボリックリンクを消すコマンドもないみたいなので、とりあえずは PowerShell の Profile で古いやつを消す様にするのが妥当なラインかな。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# てきとーにこんなのを想像
Get-ChildItem $env:FNM_MULTISHELL_PATH/../ | Where-Object -Property CreationTime -LE (Get-Date).AddDays(-1) | Remove-Item
&lt;/code&gt;&lt;/pre&gt;</description><pubDate>Sun, 26 Dec 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-12-04-pyenv-win</guid><link>https://krymtkts.github.io/posts/2021-12-04-pyenv-win</link><title>pyenv-win</title><description>&lt;p&gt;Python の処理系をローカルに直で入れることに抵抗はなかったのだが、chocolatey で Python3 を入れていると pin でもしない限りバージョンが進んでいって処理系が乱雑に配置されるので、Python 自体のバージョン管理をすることにした。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/pyenv-win/pyenv-win"&gt;pyenv-win/pyenv-win: pyenv for Windows. pyenv is a simple python version management tool. It lets you easily switch between multiple versions of Python. It's simple, unobtrusive, and follows the UNIX tradition of single-purpose tools that do one thing well.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;事前に Windows が Microsoft Store アプリの Python を使わないようにしておく必要がある。これがクソめんどい。以下は &lt;code&gt;README.md&lt;/code&gt; からの引用。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;NOTE: If you are running Windows 10 1905 or newer, you might need to disable the built-in Python launcher via Start &amp;gt; "Manage App Execution Aliases" and turning off the "App Installer" aliases for Python&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Win キーを押下して "Manage App Execution Aliases" をタイプするのが現状の最速と思うが、できたら &lt;code&gt;ms-settings&lt;/code&gt; スキームで一発で飛べたら良いのに(&lt;code&gt;ms-settings:appsfeatures&lt;/code&gt;で手前まで行くのが精一杯)。&lt;/p&gt;&lt;p&gt;わたしは chocolatey ユーザなので、 chocolatey でこの pyenv をインストールした。この場合環境変数の設定が chocolatey により行われるので幾分サボれる。&lt;/p&gt;&lt;p&gt;&lt;a href="https://community.chocolatey.org/packages/pyenv-win#psdsc"&gt;Chocolatey Software | pyenv-win 2.64.11&lt;/a&gt;&lt;/p&gt;&lt;p&gt;わたしの場合は chocolatey 操作とゴミを消すのだけ管理者権限が必要なようにしてるのでそうしたが、それ以外は普通で行った。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;(pip freeze | ConvertFrom-StringData).Keys | Set-Content requirements.txt # モジュールを控える

choco uninstall python3 -y
rm C:/Python* -recurse -force # ゴミを消す
choco install pyenv-win -y

pyenv install 3.9.6 # まだ 3.10.0 がリリースキャンディデートしかなかったので
pyenv global 3.9.6
pyenv rehash # バージョン切り替え後に必要

pip --version # 確認
python -m pip install --upgrade pip # 更新してって出たので更新
pip install -r requirements.txt # モジュール復元
# done.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="バージョン移行時の-requirementstxt"&gt;バージョン移行時の &lt;code&gt;requirements.txt&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;バージョン乗り換え時の &lt;code&gt;requirements.txt&lt;/code&gt; の作成だが、単純に &lt;code&gt;pip freeze&lt;/code&gt; の出力を使うとバージョン不整合で取り込めないことがある。
なのでわたしの場合は雑にモジュール名だけにフィルタリングしたものを使う。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;(pip freeze | ConvertFrom-StringData).Keys | Set-Content requirements.txt
&lt;/code&gt;&lt;/pre&gt;</description><pubDate>Sat, 04 Dec 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-11-27-psmfattendance</guid><link>https://krymtkts.github.io/posts/2021-11-27-psmfattendance</link><title>PowerShell で Money Forward クラウド勤怠を操作する</title><description>&lt;p&gt;現職について 2 ヶ月が経とうとしているが、まだ爆殺されてない。ので馴染んできているのかも知れない。コミュニケーションが少なくても(定例を除き、最少 DM1 通/週とか)何とかやっていけるものだなという気づきを得た。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;現職では勤怠の管理に Money Forward クラウド勤怠を利用している(時間管理なのだ)。
始めに書いておくと、勤怠管理システムはなんでか知らんがそれぞれに特色があって、どのツールを使っても一癖あるモノだというのがわたしの見解。その中でも Money Forward クラウド勤怠は悪くない印象だ。&lt;/p&gt;&lt;p&gt;しかし、わたしという人間がどうにもこうにも打刻という行為が大の苦手で、非常に億劫だ(労務管理の上で必要なんはわかるけど仕事の前後で打刻しないといけないとかワシら機械か、人間のやることじゃないと。某筋肉番組のショットガンタッチならいざ知らず)。&lt;/p&gt;&lt;p&gt;プログラマというのは怠惰なので、ブラウザで一々アクセスして打刻ボタンを押すのも苦痛なのであって、即ち半自動化に至るのは自然なことだ。
自動化じゃなく半自動化なのがポイント。自動化したら勤務してないのに勤務してるみたいなやばいことになりかねへん。自動化できるケーパビリティを持ちつつも半自動で使うのが職業プログラマの倫理？&lt;/p&gt;&lt;p&gt;そこでまず自分で作りたくないので誰かが書いたツールを探すと、&lt;a href="https://github.com/puhitaku/mfpy"&gt;puhitaku/mfpy: MoneyForward クラウド勤怠といい感じに通信していい感じに打刻するやつ&lt;/a&gt; が見つかった。良さそう。&lt;/p&gt;&lt;p&gt;でも PowerShell でどうしてもやりたかった。なので PowerShell で作った ↓&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/PSMFAttendance"&gt;krymtkts/PSMFAttendance&lt;/a&gt;&lt;/p&gt;&lt;p&gt;今は出退勤のリアルタイム打刻しかできない。今後、わたしがグータラできる水準まで高めるには次の機能が必要かなーと考えている。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;二重打刻防止
&lt;ul&gt;&lt;li&gt;なんと出勤や退勤が無限多重打刻できる仕様なので、これを防止したい
&lt;ul&gt;&lt;li&gt;そのためには勤怠実績の一覧を取得する機能が必要になる&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;打刻のリマインド機能
&lt;ul&gt;&lt;li&gt;これは &lt;code&gt;*-ScheduledTask&lt;/code&gt; でなんとかでけへんかなと考えているが...やったことない
&lt;ul&gt;&lt;li&gt;過去にタスクスケジューラでスケジュール実行をしてたけど PowerShell でやりたいし&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;勤務実績の入力
&lt;ul&gt;&lt;li&gt;打刻忘れの場合この作業が必要なので&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;あと、PowerShell Gallery の登録まだなのでしないと。アレのやり方毎回忘れるし簡単な方法ないんかというのも悩みどころ。あの工程を&lt;code&gt;psake&lt;/code&gt; のタスクにまとめるのはなんかで見たことあるけど、初回は手でやるか。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;因みに自動化について利用規約に触れないか気になったのだが、見た感じ問題なさそうだった。
&lt;a href="https://biz.moneyforward.com/agreement/"&gt;利用規約 | 会計ソフト マネーフォワード クラウド&lt;/a&gt;&lt;/p&gt;</description><pubDate>Sat, 27 Nov 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-10-30-toolchain-of-powershell</guid><link>https://krymtkts.github.io/posts/2021-10-30-toolchain-of-powershell</link><title>PowerShell のツールチェーン</title><description>&lt;p&gt;今更読んだ ↓&lt;/p&gt;&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/powershell/powershellget-3-0-preview-11-release/#features-to-expect-in-coming-preview-releases"&gt;PowerShellGet 3.0 Preview 11 Release - PowerShell Team&lt;/a&gt;&lt;/p&gt;&lt;p&gt;モジュールの依存性管理がくるっぽ。&lt;/p&gt;&lt;p&gt;これを機に NuGet のバージョンレンジ記法を学ばないといけないかな。PowerShell 使うけど NuGet と直接的な縁ないので触れずに来た。
&lt;a href="https://docs.microsoft.com/en-us/nuget/concepts/package-versioning#version-ranges-and-wildcards"&gt;NuGet Package Version Reference | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;それはさておき、先述の PowerShellGet のネタはまだ正式なものでもなく、プレビュー機能が来てるわけでもない。だから今はまだ従来の術を使うのが良いだろうと考えている。
真面目に PowerShell 開発したことがないので、その辺の知ってるモジュールを棚卸しし、調べ直した。&lt;/p&gt;&lt;p&gt;ここに書いたあるような内容は、PowerShell で書かれているアプリの GitHub repo を見たらだいたい出てくるのじゃないだろうか。
わたしの場合は、&lt;a href="https://github.com/jasonmarcher/poco"&gt;jasonmarcher/poco&lt;/a&gt;で初めて&lt;code&gt;psakefile.ps1&lt;/code&gt;を見つけてそこから世界へ踏み入れた感じ。&lt;/p&gt;&lt;p&gt;そして、この記事をまとめているときに「ああそういえば Awesome 〇〇ってあったなー」と思いググると、PowerShell 版も見つかったので置いておく。この記事に書いたツールチェーンは全部 Awesome の方に載ってた...&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/janikvonrotz/awesome-powershell"&gt;janikvonrotz/awesome-powershell: A curated list of delightful PowerShell modules and resources&lt;/a&gt;&lt;/p&gt;&lt;hr /&gt;&lt;h3 id="ビルド"&gt;ビルド&lt;/h3&gt;&lt;p&gt;PowerShell はスクリプトなのでコンパイルはないが、静的解析・テスト・パッケージング等のことをひっくるめて、ここではビルドと呼ぶことにする。&lt;/p&gt;&lt;p&gt;やはり&lt;a href="https://github.com/psake"&gt;psake&lt;/a&gt; が有名でしょう。&lt;sup id="fnref-1"&gt;&lt;a class="footnote-ref" href="#fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/psake/psake"&gt;psake/psake&lt;/a&gt; は基盤のようなもので、汎用的なビルドタスクなんかは&lt;a href="https://github.com/psake/PowerShellBuild"&gt;psake/PowerShellBuild&lt;/a&gt;に定義されている。
肝心の&lt;a href="https://github.com/psake/psake"&gt;psake/psake&lt;/a&gt;のビルドには自身ではなく&lt;a href="https://github.com/RamblingCookieMonster/BuildHelpers"&gt;RamblingCookieMonster/BuildHelpers&lt;/a&gt;が使われているというのがこれまたややこしい。
&lt;a href="https://github.com/RamblingCookieMonster/BuildHelpers"&gt;RamblingCookieMonster/BuildHelpers&lt;/a&gt;それ自身は、CI/CD シナリオで使えるヘルパーだぜ？と自称しているだけあり、その用途(GitHub Actions)で使われている&lt;/p&gt;&lt;p&gt;因みに&lt;a href="https://github.com/nightroman/Invoke-Build"&gt;Invoke-Build&lt;/a&gt;なんていうのもいて、これは使ったことない。GitHub のグラフはこちらの方が比較的アクティブかな。
README.md 見る限り&lt;a href="https://github.com/psake/psake"&gt;psake&lt;/a&gt;よりも使いやすいぜ！って書いてあるので、何か大変なことでもあったのかなと勘ぐってしまう。
わたしはまだ真面目に使い込めていないこともあり、&lt;a href="https://github.com/psake/psake"&gt;psake&lt;/a&gt;の闇を知らないだけかも知れない。&lt;/p&gt;&lt;h3 id="依存性管理"&gt;依存性管理&lt;/h3&gt;&lt;p&gt;モジュールあるところに依存性管理あり。PowerShell も例に漏れずある。
&lt;a href="https://github.com/RamblingCookieMonster/PSDepend"&gt;RamblingCookieMonster/PSDepend&lt;/a&gt;&lt;/p&gt;&lt;p&gt;話は変わるが、&lt;a href="https://github.com/RamblingCookieMonster"&gt;RamblingCookieMonster (Warren Frame)&lt;/a&gt;さんは他にも PowerShell のツールを色々書かれている。
&lt;a href="https://github.com/RamblingCookieMonster/PSDeploy"&gt;RamblingCookieMonster/PSDeploy&lt;/a&gt;だったり、わたしも最近所用で使った&lt;a href="https://github.com/RamblingCookieMonster/PSSlack"&gt;RamblingCookieMonster/PSSlack&lt;/a&gt;だったり(最新の API に対応してないけど)。&lt;/p&gt;&lt;h3 id="テスト静的解析"&gt;テスト/静的解析&lt;/h3&gt;&lt;p&gt;&lt;a href="https://github.com/pester/Pester"&gt;pester/Pester&lt;/a&gt; しか知らん。BDD スタイルでクールよね。
&lt;a href="https://github.com/PowerShell/PSScriptAnalyzer"&gt;PowerShell/PSScriptAnalyzer&lt;/a&gt; しか知らん。
いずれも開発もアクティブだし唯一無二か？&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;Awesome ~ を見つけたことだし、他にも色々見てみるか。&lt;/p&gt;&lt;div class="footnotes"&gt;&lt;hr /&gt;&lt;ol&gt;&lt;li id="fn-1"&gt;&lt;p&gt;と書いたがどう考えても有名じゃない。わたしも知ったの 2,3 年くらい前。最近は repo のグラフもほとんど息してなく見える。「枯れてる」のかも知れんけど。&lt;/p&gt;&lt;a href="#fnref-1" class="footnote-backref"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description><pubDate>Sat, 30 Oct 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-09-28-jobchange-2021</guid><link>https://krymtkts.github.io/posts/2021-09-28-jobchange-2021</link><title>転職する</title><description>&lt;p&gt;転職する。2021-10-01 から新しい会社だ。&lt;/p&gt;&lt;p&gt;前職(まだ退職日を迎えていないが便宜上こう呼ぶ)に決定的な不満があったわけではなく、諸々の条件で現状を上回るオファーをもらったのが大きい。
以下に判断時の Good/Bad を一覧す。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Good
&lt;ul&gt;&lt;li&gt;いま GCP、そのうち Azure を加えてマルチクラウド&lt;/li&gt;&lt;li&gt;GitHub&lt;/li&gt;&lt;li&gt;少人数チームでの開発&lt;/li&gt;&lt;li&gt;額面年収 3 桁万 UP&lt;/li&gt;&lt;li&gt;みなし残業の上限が下がる&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Bad
&lt;ul&gt;&lt;li&gt;確定拠出年金がない&lt;/li&gt;&lt;li&gt;超成果主義&lt;/li&gt;&lt;li&gt;レッドオーシャン？&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;お話を伺った限り、自分が貢献できそうなテーマも色々ある感じだったし、「やってみたいこと」のような挑戦に対する Welcome な姿勢がとても印象的だった。
正直なところ選考らしい選考された覚えなく、「一緒に働いてみないとわからない」という CTO の観点のもと採用判断されている。そのため入ってからパフォ出せなかったら多分盛大に爆死するんだろうなと。そこだけは不安なのだが、それこそ「働いてみないとわからない」。
とはいえ、自分も地べた這いずる中の下のエンジニアとはいえ 15 年以上の経験があるので、貢献できることがあるだろうという前向きな姿勢ではある。
(全く手も足も出せずに爆殺されるかも知れんけど。)&lt;/p&gt;&lt;p&gt;やるのは久しぶりの通信系アプリ。dotnet も仕事で使うのは 10 年ぶりか。
なんでもやりたいマンなので、入社後じわじわ守備範囲を広めていくイメージをしている。&lt;/p&gt;&lt;p&gt;今回で 4 回目の転職だが、えんじにゃー転職はリモートワークの普及で大きく景色を変えたような印象があった。どこも DX()で人手がほしいことも重なってか。事実今回の転職は大阪の人材を買い叩く流れで採用いただいたわけである。&lt;/p&gt;&lt;p&gt;心残りがなかったわけではない。前職の辞め方、個人的には引き継ぎは最低限やったけど、あまりいい辞め方ではなかったなと思っている。自分がやり始めてとっちらかっていることが多い状態で、今やめるのもなーと考えていた。
とはいえ自分の人生をより良くできるのは自分自身だ。そのためには今いる環境に変化をもたらすか、あるいは環境を別の環境に変えてしまうかしかない。
2 年ちょっとの在籍期間は前者の行動をしてたが、今回は後者を選択したと。&lt;/p&gt;&lt;p&gt;この日記は、入社半年とか 1 年後、または爆死時とかの区切りで読み返そうと思う。
わたし自身も、このうねり狂う変化の波を乗りこなせるかのチャレンジ一年生なのである。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;休みの間に、積んでた HADES をやり始めた。死にゲーで最高。時間が溶ける...&lt;/p&gt;</description><pubDate>Tue, 28 Sep 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-08-30-patch-to-vscode-extension</guid><link>https://krymtkts.github.io/posts/2021-08-30-patch-to-vscode-extension</link><title>VS Code の拡張機能に ローカル patch する</title><description>&lt;p&gt;VS Code の拡張機能にバグがある場合、メンテナが Marketplace に修正版を公開するのを待つ以外にも、自力で修正する方法がある。
ちょうどよく使っている&lt;a href="https://github.com/michalyao/evermonkey"&gt;michalyao/evermonkey&lt;/a&gt;が、壊れてしまってから 3 週間程経っても一向に対応されないので、その方法で一時的に回避した。&lt;/p&gt;&lt;p&gt;Issue は以下の通り。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/michalyao/evermonkey/issues/161"&gt;Evernote Error: 11 - Illegal to contain comments in ENML · Issue #161 · michalyao/evermonkey&lt;/a&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;エラーの原因は&lt;a href="https://dev.evernote.com/doc/articles/enml.php"&gt;ENML&lt;/a&gt;が HTML コメントを許容しなくなったことで、 これにより upload できなくなってしまった。コメントを許容しないって記述は一見なさそうだが、Upload 時のエラーになってる。&lt;/p&gt;&lt;p&gt;この&lt;a href="https://dev.evernote.com/doc/articles/enml.php"&gt;ENML&lt;/a&gt;の変更に対する Pull Request は&lt;a href="https://github.com/michalyao/evermonkey/pull/162"&gt;ある&lt;/a&gt;のだが、どうでもいいところでコンフリクトしていたり、メンテナが忙しいのかチェックされていない状態にある。
すぐに修正を適用するには、この PR の patch を自分の VS Code に適用すればいい。&lt;/p&gt;&lt;p&gt;VS Code の拡張機能は &lt;code&gt;~/.vscode/extensions&lt;/code&gt; にある&lt;sup id="fnref-1"&gt;&lt;a class="footnote-ref" href="#fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt;。今回の対象となるファイルは&lt;code&gt;converterplus.js&lt;/code&gt;。
PowerShell には&lt;code&gt;patch&lt;/code&gt;コマンドが無いので今回は手で patch した。
元は TypeScript で記述されているが、&lt;a href="https://github.com/cancastilho/evermonkey/commit/70991c155f08101d14a4ab4c64ad36d66f9850a3?branch=70991c155f08101d14a4ab4c64ad36d66f9850a3&amp;amp;diff=split"&gt;変更内容&lt;/a&gt;は素の JavaScript と同じなのでそのままコピペできる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;code $(Get-ChildItem ~\.vscode\extensions\michalyao.evermonkey-2.4.5\out\src\converterplus.js).FullName
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;↑ クソどうでもいいコードスニペット。
でも知らなかった点として、&lt;code&gt;~&lt;/code&gt;は PowerShell がユーザーディレクトリに評価するのでそのままだと VS Code に渡せなかった、というのがわかった記念に。&lt;/p&gt;&lt;p&gt;変更が終わったら、 VS Code で&lt;code&gt;Developer: Reload Windows&lt;/code&gt;すれば拡張機能に施した変更が VS Code に取り込まれる。
因みにここでは&lt;code&gt;Developer: Restart Extension Host&lt;/code&gt;で良いはずだが、割と Extension Host を起動できない Notification が表示される。
それが面倒なので&lt;code&gt;Developer: Reload Windows&lt;/code&gt;で丸ごと再起動している。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;これで無事に Evernote を利用できる状況まで戻った。でもこのままメンテナが音信不通だとこの拡張機能を VS Code で使い続けることも難しくなりそう。こりゃ参ったね。&lt;/p&gt;&lt;div class="footnotes"&gt;&lt;hr /&gt;&lt;ol&gt;&lt;li id="fn-1"&gt;&lt;p&gt;&lt;a href="https://vscode-docs.readthedocs.io/en/stable/extensions/install-extension/"&gt;Install extension - vscode-docs&lt;/a&gt;&lt;/p&gt;&lt;a href="#fnref-1" class="footnote-backref"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description><pubDate>Mon, 30 Aug 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-07-18-psake-completion</guid><link>https://krymtkts.github.io/posts/2021-07-18-psake-completion</link><title>psake の Task 名を自動補完する</title><description>&lt;p&gt;ほぼ趣味レベルなのだが、所謂タスクランナーとして&lt;a href="https://github.com/psake/psake"&gt;psake&lt;/a&gt;を使っている。趣味レベルなのは、Go とか Python とかでは &lt;code&gt;make&lt;/code&gt; を使うので &lt;code&gt;psake&lt;/code&gt; を製品コードでは使ったことなくて、自分の細々とした面倒な処理をスクリプト化してまとめるのに &lt;code&gt;psake&lt;/code&gt; を使ってるからだ。&lt;/p&gt;&lt;p&gt;そんな訳で利用頻度も高くなかったのだが、なんか最近は AWS のリソースを操作するニッチなスクリプト(例えば開発環境とかステージング環境だけに使うようなやつ)が大量にあって、それをまとめるのに使い出した。
その御蔭で利用頻度が高まり、いやーよくできたツールやな～などと改めて思っていたが、今まで不満に感じなかった自動補完がないことがストレスになってきた。タスクが増え過ぎて名前が覚えられないのだ。&lt;/p&gt;&lt;p&gt;ｷﾞｯﾊﾌﾞの repo を確認すると、古の&lt;code&gt;TabExpansion&lt;/code&gt;版はあれど、今どきの&lt;code&gt;Register-ArgumentCompleter&lt;/code&gt;版がない。
&lt;a href="https://github.com/psake/psake/blob/master/tabexpansion/PsakeTabExpansion.ps1"&gt;psake/PsakeTabExpansion.ps1 at master · psake/psake&lt;/a&gt;&lt;/p&gt;&lt;p&gt;今更&lt;code&gt;TabExpansion&lt;/code&gt;使いたくないので、&lt;code&gt;Register-ArgumentCompleter&lt;/code&gt;用に合わせてこしらえた。&lt;/p&gt;&lt;p&gt;&lt;a href="https://gist.github.com/krymtkts/b2e6742691fdca6ca09567ca146063df"&gt;This is Register-ArgumentCompleter version of https://github.com/psake/psake/blob/master/tabexpansion/PsakeTabExpansion.ps1.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;使ってみていまんとこ良さそうな感じ。問題なさそうなら本家に PRO ぶん投げてみてもいいかもね。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;以下は&lt;code&gt;Register-ArgumentCompleter&lt;/code&gt;のスクリプトブロックをデバッグするときの個人的メモ。&lt;/p&gt;&lt;p&gt;その時の入力でトリガーされたスクリプトブロックの引数を確認するのに &lt;code&gt;Write-Host&lt;/code&gt; とか使うと厄介だと思うので、ログファイル的なものをこしらえておき、別窓で&lt;code&gt;tail&lt;/code&gt;してあげると見易くなる(と思っている)。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Register-ArgumentCompleter -CommandName Invoke-Psake -ParameterName taskList -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
    "$commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters" &amp;gt;&amp;gt; test.log
    if ($commandAst -match '(?&amp;lt;file&amp;gt;[^\.]*\.ps1)') {
        $file = $Matches.file
        "YEAH" &amp;gt;&amp;gt; test.log
    }
    else {
        $file = 'psakefile.ps1'
        "DEFAULT" &amp;gt;&amp;gt; test.log
    }
    &amp;amp; $commandName -buildFile $file -docs -nologo | Out-String -Stream | ForEach-Object { if ($_ -match "^[^ ]*") { $matches[0] } } | `
        Where-Object { $_ -notin ('Name', '----', '') } | Where-Object { !$wordToComplete -or $_ -like "$wordToComplete*" }
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Get-Content .\test.log -Wait -Tail 10
# Invoke-psake, taskList, I, invoke-psake -buildFile .\psakefile.ps1 -taskList I, System.Collections.Hashtable
# Invoke-psake, taskList, In, invoke-psake -taskList In, System.Collections.Hashtable
# DEFAULT
# Invoke-psake, taskList, I, invoke-psake -buildFile .\psakefile.ps1 -taskList I, System.Collections.Hashtable
# YEAH
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;どーでもいーけどこの日記の deploy をｷﾞｯﾊﾌﾞｱｸｼｮﾝ化したい。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;追記。&lt;/p&gt;&lt;p&gt;デバッグ中に気づいたのだが、プロファイル内で &lt;code&gt;$psake&lt;/code&gt; という変数を作ると &lt;code&gt;Invoke-psake&lt;/code&gt; が壊れるという事に気づいた。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;🤖 takatoshi  invoke-psake -nologo
Test-Path: C:\Program Files\PowerShell\Modules\psake\4.9.0\private\Get-DefaultBuildFile.ps1:9
Line |
   9 |      if (test-path $psake.config_default.buildFileName -pathType Leaf) …
     |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     | Value cannot be null. (Parameter 'The provided Path argument was null or an empty collection.')

Test-Path: C:\Program Files\PowerShell\Modules\psake\4.9.0\private\Get-DefaultBuildFile.ps1:11
Line |
  11 |  …   } elseif (test-path $psake.config_default.legacyBuildFileName -path …
     |                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     | Value cannot be null. (Parameter 'The provided Path argument was null or an empty collection.')

InvalidOperation: C:\Program Files\PowerShell\Modules\psake\4.9.0\public\Invoke-psake.ps1:327
Line |
 327 |          $psake.build_success = $false
     |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     | The property 'build_success' cannot be found on this object. Verify that the property exists and can be set.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;罠すぎる...&lt;/p&gt;</description><pubDate>Sun, 18 Jul 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-07-11-my-terminal-icons</guid><link>https://krymtkts.github.io/posts/2021-07-11-my-terminal-icons</link><title>Terminal-Icons のアイコングリフのコードポイントを変えたい</title><description>&lt;p&gt;先日、&lt;a href="/posts/2021-07-01-i-want-to-change-codepoint"&gt;わたしの改造 Migu で Terminal-Icons の見栄えが悪い話&lt;/a&gt;を書いた。
あの後、チマチマ作業を行い、ある程度納得の行くものが出来上がったのでまとめておく。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;まず、先日の記事に書いていた豆腐は、ありゃー Material Design Icons を改造 Migu に組み込んでいないからであった。無知蒙昧。
あと Weather Icons もいらねーだろと思ってたしてなかったが、この際なので打ち込んじまえ！と意気込み処置を行うた。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/fontmerger/commit/81681e6de10149ed34dda60e9b6b806374efa472"&gt;Add fonts. · krymtkts/fontmerger@81681e6&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/fontmerger/commit/44c72fc3cc6cbabb44d25c3268d4191f81c78fed"&gt;Update font settings. · krymtkts/fontmerger@44c72fc&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Weather Icons は、なんか知らんがサイズを調整してパッチすると結構縦長になってしまってた。
が、ちょっと前に足しといた縦比/横比だけ調整するパラメータがいい感じに使え、我ながら先見の明を感じた(何&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/fontmerger/commit/7653e06d1f106b8dbcc01f30dc9ea25c175a3916"&gt;Split scale option to x and y scale. Add force_narrow option that for… · krymtkts/fontmerger@7653e06&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;こうしてまたさらにイイカンジの Migu になったところで、Terminal-Icons の&lt;code&gt;glyphs.ps1&lt;/code&gt;を上書きするモンをこしらえて完成とした。
ブツは Gist に上げた → &lt;a href="https://gist.github.com/krymtkts/4457a23124b2db860a6b32eba6490b03"&gt;my Terminal-Icons glyphs.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Material Design Icons はコードポイントがわかりやすくずれるだけなので機械的にずらすだけで OK だった。
Weather Icons と Octicons あたりは Nerd Fonts ではよくわからん順番に組み替えてるようだった。
コード読むのめんどかったので、モウ泥臭くヒューマンマニピュレーションにて処置...気が遠くなるかと思いきや割とすぐできた感じではある。
あと&lt;code&gt;glyphs.ps1&lt;/code&gt;を直接上書きするパワースタイルなので、なんか後から差し込めるようにしたい気はする。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2021-07-11-terminal/icons.png" alt="きれいなアイコンたち" /&gt;&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;全く関係ないが最近マイ Iris がやたらとチャタリングするようになてムカつくぜぇぇぇ...
ホコリが接点に侵入してるんやと思うんやけど、掃除しても掃除しても数日で再発する。
でもファミコンのカートリッジスタイルでフーッ！！すると割と改善する...そんな日々。&lt;/p&gt;</description><pubDate>Sun, 11 Jul 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-07-01-i-want-to-change-codepoint</guid><link>https://krymtkts.github.io/posts/2021-07-01-i-want-to-change-codepoint</link><title>Terminal-Icons のアイコングリフのコードポイントを変えたい</title><description>&lt;p&gt;2021 年 5 月から、法律による上限スレスレの時間外＆休日労働だったため、すっかりブログを認めるのを忘れていた。
なのでこの記事は 6 月分のつもりで書いている(言い訳)。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;さて、先月に現時点自分史上最高の Migu フォントを生み出したわけだが、実用において完全に気になるポイントがないわけではない。
その実、前から抱えていた幾つかの課題がそれなのだけど。&lt;/p&gt;&lt;p&gt;fontmerger を使って日本語フォントにパッチする場合、漢字が割り当てられているコードポイントにアイコングリフが割り当てられないように、コードポイントをずらす機能がついている。
当然の如く、わたしの Migu を作るためのパッチでもコードポイントをずらしている。&lt;/p&gt;&lt;p&gt;するとですね、&lt;a href="https://github.com/devblackops/Terminal-Icons/"&gt;devblackops/Terminal-Icons&lt;/a&gt;は &lt;a href="https://github.com/devblackops/Terminal-Icons/blob/eeb5ce85d4a1882b5155bd6f06859a4b6f4b44d8/psakeFile.ps1#L28"&gt;https://www.nerdfonts.com/cheat-sheet から自動生成した標準のコードポイント&lt;/a&gt; で以てフィアルやディレクトリのアイコンを表示するので...わたしの Migu だと豆腐になるアイコンがちらほらいるわけですね。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2021-07-01-terminal/icon-tofu.png" alt="豆腐アイコン" /&gt;&lt;/p&gt;&lt;p&gt;偶然にも、「栗」がアイコンに割り当てられてしまっているところもあったり。この動機づけはシンクロニシティやろ！&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2021-07-01-terminal/stop-is-chestnut.png" alt="停止は栗" /&gt;&lt;/p&gt;&lt;p&gt;前まではアイコンがぶっ壊れ気味の Migu を使っていたので、割れ窓理論的に気にならなかった豆腐が、最近妙に気になってきたわけだ。&lt;/p&gt;&lt;p&gt;Terminal-Icons のドキュメントやコードを見ても、先述の自動生成したコードポイント表(&lt;a href="https://github.com/devblackops/Terminal-Icons/blob/main/Terminal-Icons/Data/glyphs.ps1"&gt;Terminal-Icons/glyphs.ps1&lt;/a&gt;)を差し替えたりできるような仕組みはないようなので、一旦はこのスクリプト自体にパッチを当てる方向で考えよかなと考え中。&lt;/p&gt;&lt;p&gt;4000 行近くあるとはいえ、その中から普段使うアイコンに絞れば数は少ないと思うから、とりま手でﾎﾟﾘﾎﾟﾘコードポイントを変えようかなと(さっきのキャプチャだけでも 3 つ豆腐並んでてヒット率高すぎ感はあるが)。&lt;/p&gt;&lt;p&gt;とはいえ英語圏じゃない人のフォントはわたしと同じ問題を抱えてるかもしれないので、なんかグリフのコードポイント変えさせてくれや～、という機能をプルリしてもいいかもしれない。&lt;/p&gt;</description><pubDate>Thu, 01 Jul 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-05-30-maybe-completed-refining-migu-nerd-font</guid><link>https://krymtkts.github.io/posts/2021-05-30-maybe-completed-refining-migu-nerd-font</link><title>Migu Nerd Font の改善が完了したっぽい</title><description>&lt;p&gt;(2021-05-16 に書いたまま投稿するのを忘れていた)&lt;/p&gt;&lt;p&gt;&lt;a href="/posts/2021-05-07-i-want-to-resize-migu-icon"&gt;以前&lt;/a&gt;の続き。まだやってる。&lt;/p&gt;&lt;p&gt;横も縦も微妙にサイズが合わないのであれば、強制的に矯正するしかない！ということでまた fontmerger に機能追加した。&lt;a href="https://fontforge.org/docs/scripting/python/fontforge.html#fontforge.contour.boundingBox"&gt;contour.boundingBox&lt;/a&gt;は結局やめた。今のコードでもフォント設定を分ければ実現が容易だったからだ。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;フォントごとの &lt;code&gt;scale&lt;/code&gt; オプションを x,y 軸で 2 つのオプション(&lt;code&gt;scale_x&lt;/code&gt;, &lt;code&gt;scale_y&lt;/code&gt;)に分割&lt;/li&gt;&lt;li&gt;narrow 幅に矯正する &lt;code&gt;force_narrow&lt;/code&gt; オプションを追加&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/fontmerger/commit/690830d0842a21445d7ca4e3aa367e1bbf859c31"&gt;Split scale option to x and y scale. Add force_narrow option that for… · krymtkts/fontmerger@690830d&lt;/a&gt;&lt;/p&gt;&lt;p&gt;コードは愚直に書いただけで Cognitive Complexy が 16 を突破してしまったが、期待の通りのフォント変換ができた模様。
これにより残念だった Powerline の隙間・見切れ問題が解決したものと思う。これで現時点では完璧や...という Migu になったので当分は使用を確かめてみようと思う。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2021-05-16-terminal/mypowerline.png" alt="現在のpowerline" /&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;[x] お亡くなりになられた fontmerger を Python3 化して動かす&lt;/li&gt;&lt;li&gt;[x] 最新の Migu に対して fontmerger で Nerd font patch する&lt;/li&gt;&lt;li&gt;[x] &lt;code&gt;0xE0B0&lt;/code&gt; を始めとした Cascadia でだけうまく表示されるグリフを Migu に移植する
&lt;ul&gt;&lt;li&gt;そして効果なし！&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;[x] Nerd Fonts の font-patcher で Migu にパッチしてみる
&lt;ul&gt;&lt;li&gt;フォントが使い物にならなくなった&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;[x] Migu のチャーミングな部分を M+に移植
&lt;ul&gt;&lt;li&gt;縦横比の違いから縦長に...&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;[x] font-merger がパッチするグリフのみ narrow 幅にしてみる
&lt;ul&gt;&lt;li&gt;おしい！右よりフォントが残念&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;[x] font-merger の scale オプションを x,y で分割、強制 narrow 幅オプション追加&lt;/li&gt;&lt;li&gt;[x] 完璧な Migu の完成！&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;完&lt;/p&gt;</description><pubDate>Sun, 30 May 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-05-07-i-want-to-resize-migu-icon</guid><link>https://krymtkts.github.io/posts/2021-05-07-i-want-to-resize-migu-icon</link><title>Migu Nerd Font のアイコンフォントを narrow にしたい</title><description>&lt;p&gt;&lt;a href="/posts/2021-04-11-consideration-of-difference-between-cascadia-and-migu"&gt;以前&lt;/a&gt;、Nerd Fonts の&lt;code&gt;font-patcher&lt;/code&gt;で Migu に Narrow サイズの Symbol グリフぶちこみゃええやんけ、まで来てた。
その後を記す。&lt;/p&gt;&lt;h3 id="nerd-fonts"&gt;Nerd Fonts&lt;/h3&gt;&lt;p&gt;Nerd Font の font-patcher を試す。事前にパッチ済みの M+を見ると完璧なので期待に胸が高ぶる。実行してみると Python モジュールに Windows のライブラリが含まれていたので WSL2 内の Ubuntu では実行できなかった。Windows で実行する。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;fontforge -script font-patcher migu-1m-regular.ttf -s -l -w -c --careful --progressbars -out patched
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;結果、全然アカン... &lt;code&gt;-s, --mono, --use-single-width-glyphs&lt;/code&gt;オプションを有効にすると全グリフが single-width になってしまい日本語フォントとして使いものにならなくなる。&lt;/p&gt;&lt;p&gt;逆にこの完璧な M+が惚れ惚れする出来なので、こちらに半濁音を移植するだけでいい気がしてきた。&lt;/p&gt;&lt;h2 id="font-merger-再び"&gt;font-merger 再び&lt;/h2&gt;&lt;p&gt;コードポイントがわからないので、取得するための関数を PowerShell で作る。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function UC {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true,
            Position = 0,
            ValueFromPipeline = $true,
            ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNullOrEmpty()]
        [String[]]$s
    )
    process {
        foreach ($c in $s) {
            [Convert]::ToInt32($c -as [char]).ToString("x")
        }
    }
}

('がぎぐげござじずぜぞだぢづでどばぱびぴぶぷべぺぼぽゔ'+''+''+'ゞガギグゲゴザジズゼゾダヂヅデドバパビピブプベペボポヴヷヸヹヺ').ToCharArray() | UC
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これで置き換えたい文字(Migu のチャーミングな濁音半濁音たち)のコードポイントを取れるよにした。
特定のコードポイントの移植といえば font-merger 使えるやん！というところではあるが、ほしいコードポイントは連続せず細切れになっているので、これを 1 個ずつ設定に書くのはめんどい...
ということで font-merger の改造をした。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/fontmerger/commit/33c775ef4f1fd47f90b6359f5ae74529552a87a6"&gt;Add codepoint option to copy glyph from specific code points. · krymtkts/fontmerger@33c775e&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;/usr/bin/fontforge -script fontmerger/__init__.py -x migu-1m-regular -o patched --suffix=migu -- ./source/M+1mNerdFontCompleteWindowsCompatible.ttf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;コードポイントを個別に指定できるようにしまして実行したところ、なんかそれっぽく半濁点が反映されてる。
いや待てよ...微妙に縦長になってしまった...これは M+と Migu でフォントの縦横比が異なるせいやろな。&lt;/p&gt;&lt;p&gt;もう FontForge のスクリプティング真面目にやってくしか残された将来はない気がしてきた。😰&lt;/p&gt;&lt;h2 id="font-merger-再び-再び"&gt;font-merger 再び 再び&lt;/h2&gt;&lt;p&gt;Nerd Fonts の font-patcher を読んでいるときに気づいたのが、&lt;code&gt;--mono&lt;/code&gt; オプションを有効にしている場合すべての glyph に narrow 幅を設定するようになっていたこと。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/ryanoasis/nerd-fonts/blob/master/font-patcher#L71-L74"&gt;nerd-fonts/font-patcher at master · ryanoasis/nerd-fonts · GitHub&lt;/a&gt;&lt;/p&gt;&lt;p&gt;日本語フォントの場合 wide 幅を書き換えてしまうから先述の通り Nerf Fonts はえらいことになってしまっていたので、これをパッチするグリフにのみ適用すれば良いという力技に気づく。
ということで更に font-merger を改造した。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/fontmerger/commit/25ed2b1dfd547d6599417793fb679ea9fdbe4548"&gt;Adds mono command line option that forces glyph to be single width. · krymtkts/fontmerger@25ed2b1&lt;/a&gt;&lt;/p&gt;&lt;h2 id="現状"&gt;現状&lt;/h2&gt;&lt;p&gt;これにより全ての追加したアイコングリフが narrow 幅になることで、漸く Windows Terminal でもﾐﾆﾐﾆアイコンフォントにならずに表示できるようになった。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2021-05-07-terminal/mypowerline.png" alt="現在のpowerline。左向き三角が残念" /&gt;&lt;/p&gt;&lt;p&gt;しかしご覧の通り、右に寄るべきフォントの見た目が非常に残念なので、今後もちょいちょいいじらねばならない。完成はいつになるのか...😪
(幅 500 以上になってるためずれる)&lt;/p&gt;&lt;p&gt;なんとなく、次は Powerline グリフの narrow 幅を大きく超過するものを左右の align をつけて変形しないといけない気がしている。
この辺の頂点の xmax, ymax からどないか計算できんかな →
&lt;a href="https://fontforge.org/docs/scripting/python/fontforge.html#fontforge.contour.boundingBox"&gt;fontforge — FontForge 20201107 documentation&lt;/a&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;[x] お亡くなりになられた fontmerger を Python3 化して動かす&lt;/li&gt;&lt;li&gt;[x] 最新の Migu に対して fontmerger で Nerd font patch する&lt;/li&gt;&lt;li&gt;[x] &lt;code&gt;0xE0B0&lt;/code&gt; を始めとした Cascadia でだけうまく表示されるグリフを Migu に移植する
&lt;ul&gt;&lt;li&gt;そして効果なし！&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;[x] Nerd Fonts の font-patcher で Migu にパッチしてみる
&lt;ul&gt;&lt;li&gt;フォントが使い物にならなくなった&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;[x] Migu のチャーミングな部分を M+に移植
&lt;ul&gt;&lt;li&gt;縦横比の違いから縦長に...&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;[x] font-merger がパッチするグリフのみ narrow 幅にしてみる
&lt;ul&gt;&lt;li&gt;おしい！右よりフォントが残念&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;[ ] 完璧な Migu の完成！
&lt;ul&gt;&lt;li&gt;To Be Continued...&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</description><pubDate>Fri, 07 May 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-05-06-simple-way-to-update-pwsh-special-module</guid><link>https://krymtkts.github.io/posts/2021-05-06-simple-way-to-update-pwsh-special-module</link><title>PowerShell の特殊なモジュールを更新する方法</title><description>&lt;p&gt;&lt;code&gt;PSReadLine&lt;/code&gt; のような特殊な PowerShell モジュールを更新する術として、以下の方法を使うようにしている。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;管理者権限で起動したコマンドプロンプトから&lt;/li&gt;&lt;li&gt;非対話モードで&lt;/li&gt;&lt;li&gt;PSReadline を読み込んでるプロファイルを読み込まずに&lt;/li&gt;&lt;li&gt;プレリリース許可＆全ユーザ＆サイドバイサイド でインストール&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class="bat"&gt;REM 、かつ、-NonInteractive でPowerShell Coreを実行
pwsh -NonInteractive -NoProfile -Command "Install-Module PSReadLine -AllowPrerelease -Scope AllUsers -Force"
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Remove-Module&lt;/code&gt; さえちゃんとできてたら更新できると思うんやけど、プロファイルとの組み合わせで意図せず&lt;code&gt;Import-Module&lt;/code&gt;してしまい、しょっちゅうエラーしてしまうので上記手順が楽。
ほんとは pwsh 内からいい感じに処理できればよいのだけどトラシューの時間をこんなとこに割きたくない関係で、更新の都度初手一発でうまくいく手順をやりがち。&lt;/p&gt;&lt;p&gt;エラーになりがちな奴ら。ワイの profile が依存してる関係でエラーになりがち。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;PSReadLine&lt;/li&gt;&lt;li&gt;PowerShellGet&lt;/li&gt;&lt;li&gt;posh-git&lt;/li&gt;&lt;li&gt;Pester&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href="https://docs.microsoft.com/ja-jp/powershell/module/microsoft.powershell.core/about/about_pwsh?view=powershell-7.1"&gt;about_Pwsh - PowerShell | Microsoft Docs&lt;/a&gt;&lt;/p&gt;</description><pubDate>Thu, 06 May 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-04-11-consideration-of-difference-between-cascadia-and-migu</guid><link>https://krymtkts.github.io/posts/2021-04-11-consideration-of-difference-between-cascadia-and-migu</link><title>Cascadia Code PL と Migu Nerd Font の違い</title><description>&lt;p&gt;注意: アイコンフォントのコピペを多用しているので、対応していないフォントを使われている豆腐が見えます。&lt;/p&gt;&lt;h3 id="tldr"&gt;TL;DR&lt;/h3&gt;&lt;p&gt;これはズブのフォント素人による try&amp;amp;error なので大いに間違っている可能性もある。&lt;/p&gt;&lt;p&gt;結論から言うとまだ納得の行く改造版 Migu の作成には至っていない。&lt;/p&gt;&lt;p&gt;Cascadia も Hack も Narrow な Powerline グリフが埋め込まれているっぽい。
ここに来て Migu に直接 Narrow な Powerline グリフを埋め込んだらええやんけ、という Nerd Fonts 回帰案が浮上した(うまく行った試しないのだけど)。&lt;/p&gt;&lt;p&gt;To be Continued...&lt;/p&gt;&lt;h3 id="経緯"&gt;経緯&lt;/h3&gt;&lt;p&gt;長年 Migu を愛用している。&lt;/p&gt;&lt;p&gt;Migu の良さはそのスリムでシンプルな見栄えだけでなく、Proportional と Monospace で同じ字体を使えることだ。
しかし最近の開発環境で使うにはアイコンフォントが同梱されないことで不便を感じることが多い。特に Powerline を使っているとアイコンフォントは必須。
ということで 5 年ほど前から &lt;a href="https://github.com/iij/fontmerger"&gt;iij/fontmerger&lt;/a&gt; を使って Nerd fonts などを追加した自作フォントを使っている。&lt;/p&gt;&lt;p&gt;しかしこれがここ 1,2 年くらいで Windows Terminal を使い始めたことで納得いかない点が出てきた。
"Ambiguous"なフォントについては全部 Narrow サイズになる ≒ Certain なフォントについてはサイズが適用される？だと？&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/microsoft/terminal/pull/2928/commits"&gt;TermControl: force all ambiguous glyphs to be narrow by DHowett-MSFT · Pull Request #2928 · microsoft/terminal&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Windows Terminal とともに提供される &lt;a href="https://github.com/microsoft/cascadia-code"&gt;Cascadia&lt;/a&gt; に関してはどうもこの問題が発生しない。&lt;strong&gt;Powerline グリフに関しては完璧なのだ&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;フォント素人のわたしはこの時こう考えた。&lt;/p&gt;&lt;p&gt;改造 Migu と Cascadia でコードポイントは同じだけどフォントを切り替えるだけで表示サイズが異なってくる。
→ つまり Cascadia フォントでは、コードポイント&lt;code&gt;0xE0B0&lt;/code&gt;とかになんかの情報を入れ込んでるのではないか？と...！&lt;/p&gt;&lt;p&gt;グリフのサイズを目視確認するための一覧用コード。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# Helper function to show Unicode character
function U {
    param
    (
        [int] $Code
    )

    if ((0 -le $Code) -and ($Code -le 0xFFFF)) {
        return [char] $Code
    }

    if ((0x10000 -le $Code) -and ($Code -le 0x10FFFF)) {
        return [char]::ConvertFromUtf32($Code)
    }

    throw "Invalid character code $Code"
}

# 数値は[Convert]::ToInt32('0xE080', 16)でHEX変換する
((170..61278) | %{U $_}) -join ''
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;全然わからない...クソむずすぎる。でも特定のグリフを移植するだけなら、元々改造 Migu を作るのに使っていた fontmerger が利用できる。とおもてたら DEPRECATED になっておった、そら Python2 やからな...&lt;/p&gt;&lt;p&gt;とりあえず最終目標までの段階的目標を立てた。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;お亡くなりになられた fontmerger を Python3 化して動かす&lt;/li&gt;&lt;li&gt;最新の Migu に対して fontmerger で Nerd font patch する&lt;/li&gt;&lt;li&gt;&lt;code&gt;0xE0B0&lt;/code&gt; を始めとした Cascadia でだけうまく表示されるグリフを Migu に移植する&lt;/li&gt;&lt;li&gt;完璧な Migu の完成！&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="2021-03-13"&gt;2021-03-13&lt;/h3&gt;&lt;p&gt;Cascadia を CLI で簡単に落としてくる方法はないものか？&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Invoke-WebRequest -Uri https://github.com/microsoft/cascadia-code/releases/download/v2102.25/CascadiaCode-2102.25.zip -OutFile CascadiaCode-2102.25.zip
Expand-Archive -Path .\CascadiaCode-2102.25.zip -DestinationPath CascadiaCode-2102.25
cd .\CascadiaCode-2102.25\
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="powershell"&gt;                                                                                                                   2021-03-13 15:27
 takatoshi  ~\.\CascadiaCode-2102.25  ll

        Directory: C:\Users\takatoshi\desktop\CascadiaCode-2102.25


Mode                LastWriteTime         Length Name
----                -------------         ------ ----
la---        2021-03-13     15:24                  otf
la---        2021-03-13     15:24                  ttf
la---        2021-03-13     15:24                  woff2

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;フォントの拡張子がわからなくなったのでおさらい。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;otf ... Open Type Font
&lt;ul&gt;&lt;li&gt;Adobe と MS で作った。MS 商標。今や一般的。リガチャ使うならこっちしか無理&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;ttf ... True Type Font
&lt;ul&gt;&lt;li&gt;Apple 作った。プラットフォーム互換がない&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;woff ... Web Open Font Format 2
&lt;ul&gt;&lt;li&gt;Web&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class="powershell"&gt; takatoshi  ~\.\CascadiaCode-2102.25  ll .\otf\static\

        Directory: C:\Users\takatoshi\desktop\CascadiaCode-2102.25\otf\static


Mode                LastWriteTime         Length Name
----                -------------         ------ ----
la---        2021-02-25     20:32         161908   CascadiaCode-Bold.otf
la---        2021-02-25     20:32         150456   CascadiaCode-ExtraLight.otf
la---        2021-02-25     20:32         158652   CascadiaCode-Light.otf
la---        2021-02-25     20:32         158244   CascadiaCode-Regular.otf
la---        2021-02-25     20:32         161960   CascadiaCode-SemiBold.otf
la---        2021-02-25     20:32         159372   CascadiaCode-SemiLight.otf
la---        2021-02-25     20:32         185320   CascadiaCodePL-Bold.otf
la---        2021-02-25     20:32         175352   CascadiaCodePL-ExtraLight.otf
la---        2021-02-25     20:32         181752   CascadiaCodePL-Light.otf
la---        2021-02-25     20:32         181376   CascadiaCodePL-Regular.otf
la---        2021-02-25     20:32         185540   CascadiaCodePL-SemiBold.otf
la---        2021-02-25     20:32         182740   CascadiaCodePL-SemiLight.otf
la---        2021-02-25     20:32         145316   CascadiaMono-Bold.otf
la---        2021-02-25     20:32         133864   CascadiaMono-ExtraLight.otf
la---        2021-02-25     20:32         142060   CascadiaMono-Light.otf
la---        2021-02-25     20:32         141652   CascadiaMono-Regular.otf
la---        2021-02-25     20:32         145368   CascadiaMono-SemiBold.otf
la---        2021-02-25     20:32         142780   CascadiaMono-SemiLight.otf
la---        2021-02-25     20:32         168588   CascadiaMonoPL-Bold.otf
la---        2021-02-25     20:32         158620   CascadiaMonoPL-ExtraLight.otf
la---        2021-02-25     20:32         165020   CascadiaMonoPL-Light.otf
la---        2021-02-25     20:32         164644   CascadiaMonoPL-Regular.otf
la---        2021-02-25     20:32         168808   CascadiaMonoPL-SemiBold.otf
la---        2021-02-25     20:32         166008   CascadiaMonoPL-SemiLight.otf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ここで対象になるのは MonoPL(monospace の PowerLine 版)。まだリガチャを受け入れるだけの心のゆとりができていない。&lt;/p&gt;&lt;p&gt;次に [Migu][https://mix-mplus-ipa.osdn.jp/migu/] を落とす。OSDN のリダイレクトかまされ迂回方法がわからないので手で落とした。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt; takatoshi  ~\desktop  cd .\migu-1m-20200307\
 takatoshi  ~\.\migu-1m-20200307  ll .\migu-1m-20200307\

        Directory: C:\Users\takatoshi\desktop\migu-1m-20200307\migu-1m-20200307


Mode                LastWriteTime         Length Name
----                -------------         ------ ----
la---        2021-03-13     15:39                  ipag00303
la---        2021-03-13     15:39                  mplus-TESTFLIGHT-063a
la---        2020-03-07     22:14        3401580   migu-1m-bold.ttf
la---        2020-03-07     22:12        3144556   migu-1m-regular.ttf
la---        2020-03-08     16:00           2344   migu-README.txt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;fontmerger のスクリプトがちょっと Windows では使いにくそうに見えたので、一旦 Ubuntu(WSL2)でやる。&lt;/p&gt;&lt;p&gt;でも Ubuntu16LTS の fontforge は 2019 年までのやつで古かったので、一旦 WSL2 の Ubuntu を更新することにする。&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;sudo apt update
sudo apt upgrade
sudo do-release-upgrade
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;途中で sshd_config が編集されとんぞ！？と言われて新しいのとローカルのどっち使うか選ばねばいけなかった。ここは新しい方を有効化。この流れで Ubuntu20LTS まで上げた。
Ubuntu20 では fontforge はデフォルトのパッケージではなくなったので、パッケージソースを追加する必要がある。&lt;/p&gt;&lt;p&gt;&lt;a href="https://packages.ubuntu.com/focal/x11/fontforge"&gt;Ubuntu – Details of package fontforge in focal&lt;/a&gt;&lt;/p&gt;&lt;p&gt;universe にあるのがわかったので追加。&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;sudo apt-add-repository universe
sudo apt update
sudo apt install fontforge
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="sh"&gt;mkdir ./patched
./bin/fontmerger --all -o patched --suffix=with-icons -- migu-1m-regular.ttf migu-1m-bold.ttf migu-1c-regular.ttf migu-1c-bold.ttf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;結果、無反応。&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;krymtkts@krymtkts-stealth:/mnt/c/Users/takatoshi/dev/github.com/krymtkts/fontmerger$ /usr/bin/fontforge -script fontmerger/__init__.py
 --all -o patched --suffix=with-icons -- migu-1m-regular.ttf migu-1m-bold.ttf migu-1c-regular.ttf migu-1c-bold.ttf
Copyright (c) 2000-2020. See AUTHORS for Contributors.
 License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
 with many parts BSD &amp;lt;http://fontforge.org/license.html&amp;gt;. Please read LICENSE.
 Version: 20190801
 Based on sources from 03:10 UTC  6-Mar-2020-ML-D-GDK3.
  File "fontmerger/__init__.py", line 103
    except Exception, e:
                    ^
SyntaxError: invalid syntax
Error in sys.excepthook:
Traceback (most recent call last):
  File "/usr/lib/python3.8/subprocess.py", line 64, in &amp;lt;module&amp;gt;
    import msvcrt
ModuleNotFoundError: No module named 'msvcrt'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/usr/lib/python3/dist-packages/apport_python_hook.py", line 72, in apport_excepthook
    from apport.fileutils import likely_packaged, get_recent_crashes
  File "/usr/lib/python3/dist-packages/apport/__init__.py", line 5, in &amp;lt;module&amp;gt;
    from apport.report import Report
  File "/usr/lib/python3/dist-packages/apport/report.py", line 12, in &amp;lt;module&amp;gt;
    import subprocess, tempfile, os.path, re, pwd, grp, os, time, io
  File "/usr/lib/python3.8/subprocess.py", line 69, in &amp;lt;module&amp;gt;
    import _posixsubprocess
ModuleNotFoundError: No module named '_posixsubprocess'

Original exception was:
  File "fontmerger/__init__.py", line 103
    except Exception, e:
                    ^
SyntaxError: invalid syntax
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;あー、Python2 の構文によるエラーね。解消して再実行してみる。引数も間違ってたし。&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;krymtkts@krymtkts-stealth:/mnt/c/Users/takatoshi/dev/github.com/krymtkts/fontmerger$ /usr/bin/fontforge -script fontmerger/__init__.py --all -o patched --suffix=with-icons -- ./source/migu-1m-regular.ttf ./source/migu-1m-bold.ttf ./source/migu-1c-regular.ttf ./source/migu-1c-bold.ttf
Copyright (c) 2000-2020. See AUTHORS for Contributors.
 License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
 with many parts BSD &amp;lt;http://fontforge.org/license.html&amp;gt;. Please read LICENSE.
 Version: 20190801
 Based on sources from 03:10 UTC  6-Mar-2020-ML-D-GDK3.
The following table(s) in the font have been ignored by FontForge
  Ignoring 'EPAR'
The glyph named asterisk is mapped to U+F069.
  But its name indicates it should be mapped to U+002A.
The glyph named plus is mapped to U+F067.
  But its name indicates it should be mapped to U+002B.
The glyph named question is mapped to U+F128.
  But its name indicates it should be mapped to U+003F.
The glyph named minus is mapped to U+F068.
  But its name indicates it should be mapped to U+2212.
The glyph named heart is mapped to U+F004.
  But its name indicates it should be mapped to U+2665.
The glyph named home is mapped to U+F015.
  But its name indicates it should be mapped to U+21B8.
The glyph named check is mapped to U+F046.
  But its name indicates it should be mapped to U+2713.
The glyph named bell is mapped to U+F0A2.
  But its name indicates it should be mapped to U+2407.
The glyph named lessequal is mapped to U+F500.
  But its name indicates it should be mapped to U+2264.
The glyph named circle is mapped to U+F111.
  But its name indicates it should be mapped to U+25CB.
The glyph named smile is mapped to U+F118.
  But its name indicates it should be mapped to U+263A.
The glyph named frown is mapped to U+F119.
  But its name indicates it should be mapped to U+2322.
The glyph named bullseye is mapped to U+F140.
  But its name indicates it should be mapped to U+25CE.
The glyph named compass is mapped to U+F14E.
  But its name indicates it should be mapped to U+263C.
The glyph named female is mapped to U+F182.
  But its name indicates it should be mapped to U+2640.
The glyph named male is mapped to U+F183.
  But its name indicates it should be mapped to U+2642.
The glyph named sun is mapped to U+F185.
  But its name indicates it should be mapped to U+263C.
The glyph named venus is mapped to U+F221.
  But its name indicates it should be mapped to U+2640.
The glyph named slash is mapped to U+E016.
  But its name indicates it should be mapped to U+002F.
The glyph named pi is mapped to U+E02C.
  But its name indicates it should be mapped to U+03C0.
The glyph named ring is mapped to U+E03D.
  But its name indicates it should be mapped to U+02DA.
The glyph named infinity is mapped to U+E055.
  But its name indicates it should be mapped to U+221E.
The glyph named equal is mapped to U+E079.
  But its name indicates it should be mapped to U+003D.
The glyph named question is mapped to U+F02C.
  But its name indicates it should be mapped to U+003F.
The glyph named check is mapped to U+F03A.
  But its name indicates it should be mapped to U+2713.
The glyph named plus is mapped to U+F05D.
  But its name indicates it should be mapped to U+002B.
The glyph named x is mapped to U+F081.
  But its name indicates it should be mapped to U+0078.
The glyph named home is mapped to U+F08D.
  But its name indicates it should be mapped to U+21B8.
The glyph named ellipsis is mapped to U+F09A.
  But its name indicates it should be mapped to U+2026.
The glyph named bell is mapped to U+F0DE.
  But its name indicates it should be mapped to U+2407.
The following table(s) in the font have been ignored by FontForge
  Ignoring 'EPAR'
The glyph named asterisk is mapped to U+F069.
  But its name indicates it should be mapped to U+002A.
The glyph named plus is mapped to U+F067.
  But its name indicates it should be mapped to U+002B.
The glyph named question is mapped to U+F128.
  But its name indicates it should be mapped to U+003F.
The glyph named minus is mapped to U+F068.
  But its name indicates it should be mapped to U+2212.
The glyph named heart is mapped to U+F004.
  But its name indicates it should be mapped to U+2665.
The glyph named home is mapped to U+F015.
  But its name indicates it should be mapped to U+21B8.
The glyph named check is mapped to U+F046.
  But its name indicates it should be mapped to U+2713.
The glyph named bell is mapped to U+F0A2.
  But its name indicates it should be mapped to U+2407.
The glyph named lessequal is mapped to U+F500.
  But its name indicates it should be mapped to U+2264.
The glyph named circle is mapped to U+F111.
  But its name indicates it should be mapped to U+25CB.
The glyph named smile is mapped to U+F118.
  But its name indicates it should be mapped to U+263A.
The glyph named frown is mapped to U+F119.
  But its name indicates it should be mapped to U+2322.
The glyph named bullseye is mapped to U+F140.
  But its name indicates it should be mapped to U+25CE.
The glyph named compass is mapped to U+F14E.
  But its name indicates it should be mapped to U+263C.
The glyph named female is mapped to U+F182.
  But its name indicates it should be mapped to U+2640.
The glyph named male is mapped to U+F183.
  But its name indicates it should be mapped to U+2642.
The glyph named sun is mapped to U+F185.
  But its name indicates it should be mapped to U+263C.
The glyph named venus is mapped to U+F221.
  But its name indicates it should be mapped to U+2640.
The glyph named slash is mapped to U+E016.
  But its name indicates it should be mapped to U+002F.
The glyph named pi is mapped to U+E02C.
  But its name indicates it should be mapped to U+03C0.
The glyph named ring is mapped to U+E03D.
  But its name indicates it should be mapped to U+02DA.
The glyph named infinity is mapped to U+E055.
  But its name indicates it should be mapped to U+221E.
The glyph named equal is mapped to U+E079.
  But its name indicates it should be mapped to U+003D.
The glyph named question is mapped to U+F02C.
  But its name indicates it should be mapped to U+003F.
The glyph named check is mapped to U+F03A.
  But its name indicates it should be mapped to U+2713.
The glyph named plus is mapped to U+F05D.
  But its name indicates it should be mapped to U+002B.
The glyph named x is mapped to U+F081.
  But its name indicates it should be mapped to U+0078.
The glyph named home is mapped to U+F08D.
  But its name indicates it should be mapped to U+21B8.
The glyph named ellipsis is mapped to U+F09A.
  But its name indicates it should be mapped to U+2026.
The glyph named bell is mapped to U+F0DE.
  But its name indicates it should be mapped to U+2407.
The following table(s) in the font have been ignored by FontForge
  Ignoring 'EPAR'
The glyph named asterisk is mapped to U+F069.
  But its name indicates it should be mapped to U+002A.
The glyph named plus is mapped to U+F067.
  But its name indicates it should be mapped to U+002B.
The glyph named question is mapped to U+F128.
  But its name indicates it should be mapped to U+003F.
The glyph named minus is mapped to U+F068.
  But its name indicates it should be mapped to U+2212.
The glyph named heart is mapped to U+F004.
  But its name indicates it should be mapped to U+2665.
The glyph named home is mapped to U+F015.
  But its name indicates it should be mapped to U+21B8.
The glyph named check is mapped to U+F046.
  But its name indicates it should be mapped to U+2713.
The glyph named bell is mapped to U+F0A2.
  But its name indicates it should be mapped to U+2407.
The glyph named lessequal is mapped to U+F500.
  But its name indicates it should be mapped to U+2264.
The glyph named circle is mapped to U+F111.
  But its name indicates it should be mapped to U+25CB.
The glyph named smile is mapped to U+F118.
  But its name indicates it should be mapped to U+263A.
The glyph named frown is mapped to U+F119.
  But its name indicates it should be mapped to U+2322.
The glyph named bullseye is mapped to U+F140.
  But its name indicates it should be mapped to U+25CE.
The glyph named compass is mapped to U+F14E.
  But its name indicates it should be mapped to U+263C.
The glyph named female is mapped to U+F182.
  But its name indicates it should be mapped to U+2640.
The glyph named male is mapped to U+F183.
  But its name indicates it should be mapped to U+2642.
The glyph named sun is mapped to U+F185.
  But its name indicates it should be mapped to U+263C.
The glyph named venus is mapped to U+F221.
  But its name indicates it should be mapped to U+2640.
The glyph named slash is mapped to U+E016.
  But its name indicates it should be mapped to U+002F.
The glyph named pi is mapped to U+E02C.
  But its name indicates it should be mapped to U+03C0.
The glyph named ring is mapped to U+E03D.
  But its name indicates it should be mapped to U+02DA.
The glyph named infinity is mapped to U+E055.
  But its name indicates it should be mapped to U+221E.
The glyph named equal is mapped to U+E079.
  But its name indicates it should be mapped to U+003D.
The glyph named question is mapped to U+F02C.
  But its name indicates it should be mapped to U+003F.
The glyph named check is mapped to U+F03A.
  But its name indicates it should be mapped to U+2713.
The glyph named plus is mapped to U+F05D.
  But its name indicates it should be mapped to U+002B.
The glyph named x is mapped to U+F081.
  But its name indicates it should be mapped to U+0078.
The glyph named home is mapped to U+F08D.
  But its name indicates it should be mapped to U+21B8.
The glyph named ellipsis is mapped to U+F09A.
  But its name indicates it should be mapped to U+2026.
The glyph named bell is mapped to U+F0DE.
  But its name indicates it should be mapped to U+2407.
The following table(s) in the font have been ignored by FontForge
  Ignoring 'EPAR'
The glyph named asterisk is mapped to U+F069.
  But its name indicates it should be mapped to U+002A.
The glyph named plus is mapped to U+F067.
  But its name indicates it should be mapped to U+002B.
The glyph named question is mapped to U+F128.
  But its name indicates it should be mapped to U+003F.
The glyph named minus is mapped to U+F068.
  But its name indicates it should be mapped to U+2212.
The glyph named heart is mapped to U+F004.
  But its name indicates it should be mapped to U+2665.
The glyph named home is mapped to U+F015.
  But its name indicates it should be mapped to U+21B8.
The glyph named check is mapped to U+F046.
  But its name indicates it should be mapped to U+2713.
The glyph named bell is mapped to U+F0A2.
  But its name indicates it should be mapped to U+2407.
The glyph named lessequal is mapped to U+F500.
  But its name indicates it should be mapped to U+2264.
The glyph named circle is mapped to U+F111.
  But its name indicates it should be mapped to U+25CB.
The glyph named smile is mapped to U+F118.
  But its name indicates it should be mapped to U+263A.
The glyph named frown is mapped to U+F119.
  But its name indicates it should be mapped to U+2322.
The glyph named bullseye is mapped to U+F140.
  But its name indicates it should be mapped to U+25CE.
The glyph named compass is mapped to U+F14E.
  But its name indicates it should be mapped to U+263C.
The glyph named female is mapped to U+F182.
  But its name indicates it should be mapped to U+2640.
The glyph named male is mapped to U+F183.
  But its name indicates it should be mapped to U+2642.
The glyph named sun is mapped to U+F185.
  But its name indicates it should be mapped to U+263C.
The glyph named venus is mapped to U+F221.
  But its name indicates it should be mapped to U+2640.
The glyph named slash is mapped to U+E016.
  But its name indicates it should be mapped to U+002F.
The glyph named pi is mapped to U+E02C.
  But its name indicates it should be mapped to U+03C0.
The glyph named ring is mapped to U+E03D.
  But its name indicates it should be mapped to U+02DA.
The glyph named infinity is mapped to U+E055.
  But its name indicates it should be mapped to U+221E.
The glyph named equal is mapped to U+E079.
  But its name indicates it should be mapped to U+003D.
The glyph named question is mapped to U+F02C.
  But its name indicates it should be mapped to U+003F.
The glyph named check is mapped to U+F03A.
  But its name indicates it should be mapped to U+2713.
The glyph named plus is mapped to U+F05D.
  But its name indicates it should be mapped to U+002B.
The glyph named x is mapped to U+F081.
  But its name indicates it should be mapped to U+0078.
The glyph named home is mapped to U+F08D.
  But its name indicates it should be mapped to U+21B8.
The glyph named ellipsis is mapped to U+F09A.
  But its name indicates it should be mapped to U+2026.
The glyph named bell is mapped to U+F0DE.
  But its name indicates it should be mapped to U+2407.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;警告出るがフォントの生成完了。開いてみるも、いやフォントが壊れてるわ...なんでや？&lt;/p&gt;&lt;p&gt;理由がわかった。fontmerger の実行後に出力先フォルダからフォントを移動するとプレビューできる。出力先フォルダに fontforge の謎のハンドルが残っている様子。&lt;/p&gt;&lt;p&gt;fontmerger の Python3 化が完了した。&lt;a href="https://github.com/krymtkts/fontmerger"&gt;GitHub - krymtkts/fontmerger: FontForge script for to merge any fonts&lt;/a&gt;&lt;/p&gt;&lt;h3 id="2021-04-10"&gt;2021-04-10&lt;/h3&gt;&lt;p&gt;Cascadia からコピる範囲を決める。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt; takatoshi  ~\.\.\.\fontmerger   master ≣ +1 ~2 -6 !  [Convert]::ToInt32('0xE0A0', 16)
57504
 takatoshi  ~\.\.\.\fontmerger   master ≣ +1 ~2 -6 !  [Convert]::ToInt32('0xE0D4', 16)
57556                                                                                                             2021-04-10 15:17
 takatoshi  ~\.\.\.\fontmerger   master ≣ +1 ~2 -6 !  ((57504..57556) | %{U $_}) -join ''

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Cascadia には Powerline の拡張グリフくらいしか入っていないので Powerline の部分を抜き出して Migu にコピーする。&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;/usr/bin/fontforge -script fontmerger/__init__.py --all -o patched --suffix=cascadia -- ./source/migu-1m-regular.ttf ./source/migu-1m-bold.ttf ./source/migu-1c-regular.ttf ./source/migu-1c-bold.ttf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;結果は Cascadia からコピーした領域は以前 Ambiguous なままだった...なんでだろう。以下が追加の Cascadia からコピる設定。&lt;/p&gt;&lt;pre&gt;&lt;code class="json"&gt;{
    "id": "cascadia-powerline",
    "name": "Cascadia Powerline Symbols",
    "description": "Powerline symbols copied from Cascadia Code. https://github.com/microsoft/cascadia-code",
    "filename": "./fonts/cascadia/CascadiaCodePL-Regular.otf",
    "unicode_range": [
      "E0A0",
      "E0D4"
    ]
  },
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;コピっても解消しないのか...と思ってた矢先、フォカのフォントを参考に調べていて &lt;a href="https://github.com/yuru7/HackGen"&gt;GitHub - yuru7/HackGen: HackGen is Japanese programming font which is a composed of Hack and GenJyuu-Gothic.&lt;/a&gt; なるフォントを見つけた。&lt;/p&gt;&lt;p&gt;あれ、このフォント Powerline グリフが Windows Terminal でも崩れないし、見た目も結構好みでこれちょっとよいかも...と浮気しそうになるも、やはり字幅の広さが気に入らず Migu に返り咲くワイ。&lt;/p&gt;&lt;p&gt;それはそうと Powerline グリフが崩れないのはなんでか？と思ってみてたところ、これ Symbol フォントが Narrow スペースなのね。Cascadia もそう。つまり問題なのはフォント幅じゃね？と気づく。
更に々々、Nerd Fonts から提供されている Hack を使うと、PowerShell モジュールの Terminal Icons で表示されるファイルアイコンすらも小さくならずに表示できるではないかい！これやろ答え。&lt;/p&gt;&lt;p&gt;数年前に試してうまくいったことがないのが心配のタネだが、ここは原点回帰して Nerd Fonts の font-patcher で Migu に Narrow スペースでパッチしてみるか～という気持ちになった。&lt;/p&gt;&lt;h3 id="現状"&gt;現状&lt;/h3&gt;&lt;p&gt;ただ単に Migu の最新版にパッチしただけの状態になっているのだが、途中経過をまとめておかないと着手する時加齢に忘れてて辛いので一旦状況をまとめた。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;[x] お亡くなりになられた fontmerger を Python3 化して動かす&lt;/li&gt;&lt;li&gt;[x] 最新の Migu に対して fontmerger で Nerd font patch する&lt;/li&gt;&lt;li&gt;[x] &lt;code&gt;0xE0B0&lt;/code&gt; を始めとした Cascadia でだけうまく表示されるグリフを Migu に移植する
&lt;ul&gt;&lt;li&gt;そして効果なし！&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;[ ] Nerd Fonts の font-patcher で Migu にパッチしてみる &amp;lt;- &lt;strong&gt;NEW!!!&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;[ ] 完璧な Migu の完成！&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;俺たちの戦いはこれからだ！😭😭😭&lt;/p&gt;</description><pubDate>Sun, 11 Apr 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-03-06-fix-publish-failure-to-powershell-gallery</guid><link>https://krymtkts.github.io/posts/2021-03-06-fix-publish-failure-to-powershell-gallery</link><title>PSGallery への公開つまづき 2021</title><description>&lt;p&gt;今年のはじめに&lt;a href="https://github.com/krymtkts/Get-GzipContent"&gt;krymtkts/Get-GzipContent: Get-Content for gzip files.&lt;/a&gt;の更新を行った際に、PoweShell Gallery への公開で手間取った。その 2 ヶ月遅れの記録である。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/PowerShell/PowerShellGetv2/issues/303#issuecomment-433139506"&gt;Publish-Module throws error "Failed to generate the compressed file for module 'Microsoft (R) Build Engine version 15.7.179.6572 for .NET Core'" · Issue #303 · PowerShell/PowerShellGetv2&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Invoke-WebRequest -Uri https://dist.nuget.org/win-x86-commandline/latest/nuget.exe -OutFile "$env:LOCALAPPDATA\Microsoft\Windows\PowerShell\PowerShellGet\NuGet.exe"
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;いやまあこれで直ったんやけど、わからなさすぎてこの記事も見た。&lt;/p&gt;&lt;p&gt;&lt;a href="https://sqldbawithabeard.com/2019/11/26/fixing-the-failed-to-generate-the-compressed-file-for-module-cprogram-filesdotnetdotnet-exe-error-when-deploying-to-the-powershell-gallery-using-azure-devops/"&gt;Fixing the ‘Failed to generate the compressed file for module ‘C:\Program Files\dotnet\dotnet.exe’ error when deploying to the PowerShell Gallery using Azure DevOps | SQL DBA with A Beard&lt;/a&gt;&lt;/p&gt;&lt;p&gt;これは一時しのぎなので最終的に目指すのは配置している&lt;code&gt;nuget.exe&lt;/code&gt;を消し去っても動くようになることだ。とはいえまた次公開するときまで使うときがないので試すのめんどくせええ＆次試そうと思っても忘れる...ということで一旦 Chocolatey で NuGet を入れておいて保険とした。でもこれ自体も本来バイナリ不要で動いてたことからしたら蛇足のはずやねんけどな、Issue に進捗なく Close されてるからわからん。まあ日記にも書いたからエラーしたときにきっと振り返れる、未来のワイ。&lt;/p&gt;&lt;p&gt;あと年に数回しか PowerShell Gallery に公開しないとやり方とか色々忘れるのだけど、一番忘れるのが API キーの寿命が短く設定してあって切れてるということ。今回期限切れの API キーを再有効化できるってのを知ったので、それはそれで良。&lt;/p&gt;&lt;p&gt;&lt;a href="https://docs.microsoft.com/ja-jp/powershell/scripting/gallery/how-to/managing-profile/creating-apikeys?view=powershell-7.1#editing-and-deleting-existing-api-keys"&gt;API キーの管理 - PowerShell | Microsoft Docs&lt;/a&gt;&lt;/p&gt;</description><pubDate>Sat, 06 Mar 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-02-12-various-stories-about-starting-to-use-nodist</guid><link>https://krymtkts.github.io/posts/2021-02-12-various-stories-about-starting-to-use-nodist</link><title>色々あって Nodist を使い始めた話</title><description>&lt;p&gt;重い腰を上げて、&lt;a href="https://github.com/krymtkts/mccall-bot"&gt;Slackbot のマッコールさん&lt;/a&gt;の Typo を直す気になった。
タイポの修正と追加のセンテンスを登録して、いざ deploy しようとしたら、Serverless Framework がエラーを吐くようになっていた。↓ らしい。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/serverless/serverless/issues/8794"&gt;Unable to deploy to Serverless due to 'empty zip' · Issue #8794 · serverless/serverless&lt;/a&gt;&lt;/p&gt;&lt;p&gt;aws-cdk の方も同様のバグがあるらしいけど、あっちは直してくれてるみたい。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/aws/aws-cdk/issues/12536"&gt;lambda: corrupt zip archive asset produced when using node v15.6 · Issue #12536 · aws/aws-cdk&lt;/a&gt;&lt;/p&gt;&lt;p&gt;残念ながら Serverless Framework の方は直してないっぽなので、Node.js のバージョンを 15 から 14 に落とす必要が出てきた。この時リアルタイムで友人に &lt;a href="https://github.com/nullivex/nodist"&gt;nodist&lt;/a&gt; を教えてもらったので、これを使って複数の系を利用できるようにした。&lt;/p&gt;&lt;p&gt;&lt;del&gt;(というか Chocolatey で Node.js の v15 を uninstall して v14 入れようとしてもなんかエラーになって、ログ見たら「新しい版いるから失敗するね！」てあって「はぁ!?」と調べたら&lt;code&gt;choco uninstall nodejs&lt;/code&gt;は仕事してくれへんらしい。古き良き Chocolatey 流儀はやめろ。で日頃使ってた node modules も全部吹っ飛んで災難やで...)&lt;/del&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;choco install nodist -y
# RapidEE で PATH に `C:\Program Files (x86)\Nodist\bin` を追加した

# nodist と一緒に install される系は古い
nodist list
  (x64)
&amp;gt; 11.13.0
# 15 系と 14 系の最新を入れる
nodist add 15.8.0
nodist add 14.15.5
# 14 系を選択
nodist 14.15.5
# npm も古い
nodist npm list
&amp;gt; 6.9.0
# 選択中の node と合わせる
nodist npm match
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href="https://nodejs.org/ja/download/releases/"&gt;Node.js のリリース一覧&lt;/a&gt;から node と npm の対応を見て選んでってやってもいいけど、そんなんめんどすぎるので &lt;code&gt;nodist npm match&lt;/code&gt; の一度ではないかと考える。
もし、厳密に指定のバージョン使いたいとかあったら加初環境をコンテナに構築したりすればいいし、そもそも nodist を使ってローカル PC のグローバル node をこねくったりしてないはず。&lt;/p&gt;&lt;p&gt;ちょっとおもしろいのが、node/npm の version を変えても install した node_modules は同じものを使えるところ。 v14.15.5 で入れたモジュールが v15.8.0 でも見れた。何度も同じモジュールをインストールしなくていいのは楽やけど、バージョン互換性の厳しいモジュールは使うのが難しいのでは。&lt;/p&gt;&lt;p&gt;node、npm、モジュールの実態はそれぞれ、&lt;code&gt;$env:NODIST_PREFIX/v-x64&lt;/code&gt;(32bit が&lt;code&gt;$env:NODIST_PREFIX/v&lt;/code&gt;?) &lt;code&gt;$env:NODIST_PREFIX/npmv&lt;/code&gt; &lt;code&gt;$env:NODIST_PREFIX/bin/node_modules&lt;/code&gt; 配下にインストールされる様子。&lt;/p&gt;&lt;p&gt;nodist、どうも 2019 年を最後にメンテが止まっている様子(単にマジで変更がないのかも知れん)。現時点でこいつが最後 &lt;a href="https://github.com/nullivex/nodist/commit/bb099ba3723027469bf46e3159f51171b5dd4b59"&gt;Fix deprecated use of Tar.Extract in npm.js, release 0.9.1 · nullivex/nodist@bb099ba&lt;/a&gt;&lt;/p&gt;&lt;p&gt;とはいえ便利なので不都合ない限り利用してみるつもり。&lt;/p&gt;&lt;p&gt;と色々やったことでようやくマッコールさん Bot の最新版を deploy できるようになったとさ。めでたし x2。&lt;/p&gt;</description><pubDate>Fri, 12 Feb 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-02-01-go-map-key-tips</guid><link>https://krymtkts.github.io/posts/2021-02-01-go-map-key-tips</link><title>go の map のキーの Tips</title><description>&lt;ul&gt;&lt;li&gt;知ってた
&lt;ul&gt;&lt;li&gt;&lt;code&gt;map&lt;/code&gt;のキーには&lt;code&gt;struct&lt;/code&gt;が使える&lt;/li&gt;&lt;li&gt;キーがポインタやポインタを含む&lt;code&gt;struct&lt;/code&gt;の場合、ポインタの指す値が同じでもポインタ値自体が比較されるため異なるキーとなる&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;知らなかった
&lt;ul&gt;&lt;li&gt;&lt;code&gt;interface&lt;/code&gt;もキーにできる
&lt;ul&gt;&lt;li&gt;キーを追加するときにポインタを使ってないこと&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;time.Time&lt;/code&gt;はキーにつこたらあかん
&lt;ul&gt;&lt;li&gt;&lt;a href="https://go.googlesource.com/go/+/go1.15.6/src/time/time.go#147"&gt;src/time/time.go - go - Git at Google&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://pkg.go.dev/time#Time"&gt;time · pkg.go.dev&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;blockquote&gt;&lt;p&gt;Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. Therefore, Time values should not be used as map or database keys without first guaranteeing that the identical Location has been set for all values, which can be achieved through use of the UTC or Local method, and that the monotonic clock reading has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u) to t == u, since t.Equal uses the most accurate comparison available and correctly handles the case when only one of its arguments has a monotonic clock reading.&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;UT では一致しちゃいバグを見つけられなかった...😥&lt;/li&gt;&lt;li&gt;まだわかってないのが、&lt;code&gt;Location&lt;/code&gt;が必ず同じになるようにしてた＆年月日だけの情報しか持ってなかったのにずれとんのかい！？というところ&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href="https://play.golang.org/p/Rd5OJ2S37AT"&gt;コード&lt;/a&gt;。このコードでは&lt;code&gt;time.Time&lt;/code&gt;のキーのズレは再現しないけど。&lt;/p&gt;&lt;pre&gt;&lt;code class="go"&gt;package main

import (
	"fmt"
	"time"
)

type Key interface {
}

type KeyA struct {
	s string
}

type KeyB struct {
	s string
	i int
}

type KeyC struct {
	t time.Time
}

type KeyD struct {
	a *KeyA
}

func checkInterfaceKey() {
	m := map[Key]int{}
	m[KeyA{
		s: "A1",
	}] = 1
	m[KeyA{
		s: "A1",
	}] = 2
	m[KeyA{
		s: "A2",
	}] = 3
	m[KeyB{
		s: "B1",
		i: 1,
	}] = 4
	m[KeyB{
		s: "B1",
		i: 1,
	}] = 5
	m[KeyB{
		s: "B1",
		i: 2,
	}] = 6
	fmt.Printf("%v\n", m)
}

func init() {
	location := "Asia/Tokyo"
	loc, err := time.LoadLocation(location)
	if err != nil {
		loc = time.FixedZone(location, 9*60*60)
	}
	time.Local = loc
	fmt.Printf("%v\n", loc)
}

func checkPointerIncludedKey() {
	m := map[Key]int{}
	m[KeyC{
		t: time.Date(2021, 2, 1, 0, 0, 0, 0, time.Local),
	}] = 1
	m[KeyC{
		t: time.Date(2021, 2, 1, 0, 0, 0, 0, time.Local),
	}] = 2
	m[KeyD{
		a: &amp;amp;KeyA{
			s: "D1",
		},
	}] = 3
	m[KeyD{
		a: &amp;amp;KeyA{
			s: "D1",
		},
	}] = 4
	fmt.Printf("%v\n", m)
}

func main() {
	checkInterfaceKey()
	checkPointerIncludedKey()
}

&lt;/code&gt;&lt;/pre&gt;</description><pubDate>Mon, 01 Feb 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-01-30-beware-to-update-aws-tools</guid><link>https://krymtkts.github.io/posts/2021-01-30-beware-to-update-aws-tools</link><title>AWS.Tools.Installer で入れたモジュールの更新は気をつけろよ</title><description>&lt;pre&gt;&lt;code class="powershell"&gt;Install-Package: C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\PowerShellGet\2.2.5\PSModule.psm1:13069
 Line |
13069 |  …           $sid = PackageManagement\Install-Package @PSBoundParameters
      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      | Unable to find repository 'C:\Users\takatoshi\AppData\Local\Temp\xeqcnbnp.pgl'. Use Get-PSRepository to see all available repositories.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;普段 PowerShell Module を一括更新しているのだけど、変なエラーが出るよになった。&lt;/p&gt;&lt;p&gt;一括更新は、 &lt;code&gt;Get-InstalledModule | Update-Module -AllowPrerelease&lt;/code&gt; で。&lt;/p&gt;&lt;p&gt;ちょうど最近、 &lt;a href="https://github.com/PowerShell/PowerShellGetv2/issues/303"&gt;Publish-Module うまくいかない問題&lt;/a&gt; を解消したり Win10 の更新したりしてたので、そのへんかなーと思い NuGet の Provider の登録し直しとか色々やっても直らず 😥&lt;/p&gt;&lt;p&gt;初心に帰って、↑ のログを見てみたら「何やねんこの謎 repo」というのに気づき、 改めて&lt;code&gt;Get-InstalledModule&lt;/code&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code class="PowerShell"&gt; ⚡ takatoshi  ~  Get-InstalledModule

Version              Name                                Repository           Description
-------              ----                                ----------           -----------
4.1.7.0              AWS.Tools.Amplify                   C:\Users\takatoshi\… The Amplify module of AWS Tools for PowerShell lets developers and administrators manage AWS Amplify from the PowerShell scripting environment. In order to manage each AWS service, install th…
4.1.7.0              AWS.Tools.CloudFormation            C:\Users\takatoshi\… The CloudFormation module of AWS Tools for PowerShell lets developers and administrators manage AWS CloudFormation from the PowerShell scripting environment. In order to manage each AWS servi…
4.1.7.0              AWS.Tools.Common                    C:\Users\takatoshi\… The AWS Tools for PowerShell lets developers and administrators manage their AWS services from the PowerShell scripting environment. In order to manage each AWS service, install the correspon…
4.1.7.0              AWS.Tools.EC2                       C:\Users\takatoshi\… The EC2 module of AWS Tools for PowerShell lets developers and administrators manage Amazon Elastic Compute Cloud (EC2) from the PowerShell scripting environment. In order to manage each AWS …
4.1.7.0              AWS.Tools.IdentityManagement        C:\Users\takatoshi\… The IdentityManagement module of AWS Tools for PowerShell lets developers and administrators manage AWS Identity and Access Management from the PowerShell scripting environment. In order to m…
1.0.2.0              AWS.Tools.Installer                 PSGallery            The AWS.Tools.Installer module makes it easier to install, update and uninstall other AWS.Tools modules (see https://www.powershellgallery.com/packages/AWS.Tools.Common/).…
4.1.7.0              AWS.Tools.Lambda                    C:\Users\takatoshi\… The Lambda module of AWS Tools for PowerShell lets developers and administrators manage AWS Lambda from the PowerShell scripting environment. In order to manage each AWS service, install the …
4.1.7.0              AWS.Tools.S3                        C:\Users\takatoshi\… The S3 module of AWS Tools for PowerShell lets developers and administrators manage Amazon Simple Storage Service (S3) from the PowerShell scripting environment. In order to manage each AWS s…
4.1.7.0              AWS.Tools.SecretsManager            C:\Users\takatoshi\… The SecretsManager module of AWS Tools for PowerShell lets developers and administrators manage AWS Secrets Manager from the PowerShell scripting environment. In order to manage each AWS serv…
0.1.8                ClipboardText                       PSGallery            Support for text-based clipboard operations for PowerShell Core (cross-platform) and older versions of Windows PowerShell
1.3.1                Configuration                       PSGallery            A module for storing and reading configuration values, with full PS Data serialization, automatic configuration for modules and scripts, etc.
1.2010.0.201211      DockerCompletion                    PSGallery            Docker command completion for PowerShell.
1.27.0.200908        DockerComposeCompletion             PSGallery            Docker Compose command completion for PowerShell.
0.16.2.190903        DockerMachineCompletion             PSGallery            Docker Machine command completion for PowerShell.
0.2                  MavenAutoCompletion                 PSGallery            Maven Auto Completion provides a simple auto completion of Maven 3 to PowerShell.
3.75.0-beta          oh-my-posh                          PSGallery            A prompt theme engine for any shell
1.4.7                PackageManagement                   PSGallery            PackageManagement (a.k.a. OneGet) is a new way to discover and install software packages from around the web.…
5.1.0-rc1            Pester                              PSGallery            Pester provides a framework for running BDD style Tests to execute and validate PowerShell commands inside of PowerShell and offers a powerful set of Mocking Functions that allow tests to mim…
1.1.0                poco                                PSGallery            Interactive filtering command based on peco
1.0.0-beta3          posh-git                            PSGallery            Provides prompt with Git status summary information and tab completion for Git commands, parameters, remotes and branch names.
0.16.0               PowerShellForGitHub                 PSGallery            PowerShell wrapper for GitHub API
3.0.0-beta10         PowerShellGet                       PSGallery            PowerShell module with commands for discovering, installing, updating and publishing the PowerShell artifacts like Modules, DSC Resources, Role Capabilities and Scripts.
4.9.0                psake                               PSGallery            psake is a build automation tool written in PowerShell.
2.2.0-beta1          PSReadLine                          PSGallery            Great command line editing in the PowerShell console host
1.19.1               PSScriptAnalyzer                    PSGallery            PSScriptAnalyzer provides script analysis and checks for potential code defects in the scripts by applying a group of built-in or customized rules on the scripts being analyzed.
0.2.2                Terminal-Icons                      PSGallery            PowerShell module to add file icons to terminal based on file extension
2.2.0                Get-ChildItemColor                  PSGallery            Get-ChildItemColor provides colored versions of Get-ChildItem Cmdlet and Get-ChildItem | Format-Wide (ls equivalent)
0.1.2                Get-GzipContent                     PSGallery            Gets the content of the gzip archive at the specified location.
1.0.1.10             GoogleCloud                         PSGallery            PowerShell cmdlets for the Google Cloud Platform.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ﾌｷﾞｬｰ、AWS.Tools.Installer で入れたモジュールは全て repo が一時ファイルになっとるやんけ！😇&lt;/p&gt;&lt;p&gt;これは事案ですね。ということでとりま暫定対処として Repository が PSGallery のやつだけにした。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Get-InstalledModule | Where-Object -Property Repository -eq 'PSGallery' | Update-Module -AllowPrerelease
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href="https://github.com/aws/aws-tools-for-powershell/issues?q=is%3Aissue+is%3Aopen+unable+to+find+repository"&gt;AWS Tools の GitHub&lt;/a&gt; を見てみても誰も同じような話はしてないし、みんな真面目に&lt;code&gt;Update-AWSToolsModule&lt;/code&gt;と&lt;code&gt;Update-Module&lt;/code&gt;使い分けれてんねな～エライ！というのに気づいた一日であった。&lt;/p&gt;&lt;p&gt;ﾁｬﾝﾁｬﾝ。&lt;/p&gt;</description><pubDate>Sat, 30 Jan 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-01-04-planning</guid><link>https://krymtkts.github.io/posts/2021-01-04-planning</link><title>2021</title><description>&lt;p&gt;年始めに抱負を明文化しておくのと年末振り返りしやすいから例年通りやっとく。
なんか定量的なやつと定性的なやつがごっちゃになっとるけど、ええんや。&lt;/p&gt;&lt;h4 id="テーマ-自分を大事に"&gt;テーマ: 自分を大事に&lt;/h4&gt;&lt;p&gt;これは仕事と自己学習の両方でだ。&lt;/p&gt;&lt;p&gt;仕事の方は、年末年始ずっと働き詰めだった。土日以外で完全な休みは今日 2020-01-04 となってしまった。もちろん家族への負担も大きかったし、年末年始でやろうと思っていた勉強だったり久しぶりにゲームやっちゃうかな？といった Fun な部分も全て蔑ろにしてしまった。
何でもかんでも「ワイがやらなあかんねや」と意気込むのは良いのだが、そこで得られるものとは如何に？刮目せなあかん。
数年前にエッセンシャル思考を読んだあと、立ち振舞を改めたときの状況に似ている。同じ轍を踏んでもーたわけでみっともない話や。&lt;/p&gt;&lt;p&gt;わたしが働くのは、楽しくプログラムを書いて自分を高め、かつ日銭を稼ぐことのできる都合が良い仕事だからだ。自身の人生を蔑ろにしたいわけではない。ここを改めて強調していきたい。&lt;/p&gt;&lt;p&gt;自己学習においても同様、WFH 歴もあと数ヶ月で 1 年となるけど、家のことをやる時間だけが増殖して、本を読む機会を失ってしまった。このように自分の考えを文章にまとめる機会すら少なくなっていた。これはよろしくない。
新しい技術などは極力仕事で取り組めるように取りなしているが、そこから溢れるものは私生活で掬うしかない。
学習習慣を日常生活に浸透させることでこの状況を打破したい。&lt;/p&gt;&lt;h3 id="2021-年の目標"&gt;2021 年の目標&lt;/h3&gt;&lt;p&gt;継続するテーマと新しい奴ら。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;NEW!&lt;/strong&gt; 住みたい場所を決める
&lt;ul&gt;&lt;li&gt;長年田舎に住みたいと思っているのだけど、昨年色々あって目当てだったところは住むのが難しそうになった。とりあえず今年はふんわりとでも候補地を固めるのが目標。&lt;/li&gt;&lt;li&gt;現職は WFH やからいいけどもし転職したら...とか考えると成約ばかりにで嫌気がさすが、そこは縛りゲーばりに割り切ってフルリモートの仕事しか選ばん所存。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;NEW!&lt;/strong&gt; 仕事上の掃除
&lt;ul&gt;&lt;li&gt;&lt;code&gt;組織とビジネスは潰す、ひとつずつ、一ドルずつ、一人ずつ - ロバート・マッコール&lt;/code&gt;&lt;/li&gt;&lt;li&gt;壊れたままの〇〇
&lt;ul&gt;&lt;li&gt;CI パイプライン直す&lt;/li&gt;&lt;li&gt;テスト直す&lt;/li&gt;&lt;li&gt;チーム直す&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;これはまず家を建てる前に土台を固めるのと同じことなので、この障害を取り除かんとアプリをもりもり書くのも難しい&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;昇給
&lt;ul&gt;&lt;li&gt;やってることが間違っていなけれ場評価は勝手についてくるのだが、金額はついてこないので、ここは要相談やな&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;積ん読の消化
&lt;ul&gt;&lt;li&gt;月に 1 冊を消化する&lt;/li&gt;&lt;li&gt;いま SNS 殆どやってないけど、Chrome のサジェストや RSS のフィードを読む時間増えてるので、そこを読書に置き換える&lt;/li&gt;&lt;li&gt;手の届くとこに読んでる本数冊を置くとか？&lt;/li&gt;&lt;li&gt;いま昼飯時間も仕事してるからそれを単純に読書に置き換えるのも良い&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;OSS へのコントリビューション
&lt;ul&gt;&lt;li&gt;気が向いたら。とりあえず今は身の回りのこと優先なので低く。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;自作ツールの更新
&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/Get-GzipContent"&gt;krymtkts/Get-GzipContent: Get-Content for gzip files.&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;*&lt;/code&gt; ファイルに対応させる(最近できてへんのに気づいた)&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/mccall-bot"&gt;mccall-bot&lt;/a&gt;&lt;ul&gt;&lt;li&gt;Typo 修正、マルチチャンネル対応したい...&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;ギター練習を 30 分/週 3 回
&lt;ul&gt;&lt;li&gt;&lt;a href="https://aristidesinstruments.com/guitar/h-08"&gt;真に求めていたスペックのギター&lt;/a&gt;が現れたのだけど、スキルのほうが劣化しすぎて...一から出直すため&lt;/li&gt;&lt;li&gt;バンド練習は COVID19 のこともあるし当面無理かな&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://krymtkts.github.io/"&gt;このブログ&lt;/a&gt;を毎月更新する
&lt;ul&gt;&lt;li&gt;いつも未達なので&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;NEW!&lt;/strong&gt; 日頃使ってるスニペット的なのを Gist に登録していく
&lt;ul&gt;&lt;li&gt;Evernote に書いたりローカルに残してるよりも、こっちのほうが良さそうやから&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</description><pubDate>Mon, 04 Jan 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2020-12-27-ns-record-of-route53-hosted-zone</guid><link>https://krymtkts.github.io/posts/2020-12-27-ns-record-of-route53-hosted-zone</link><title>Rote53 ホストゾーンの NS レコード</title><description>&lt;p&gt;これで 12 月だいぶ躓いたので書いとくわ。思い出じゃ。&lt;/p&gt;&lt;p&gt;NS レコードは Simple Routing しかサポートしてへん。まずそれは AWS Management Console でわかる。
これを AWSPowerShell のパラメータでどうやんのかがわからんかった。ワタシが阿呆やからに違いない。&lt;/p&gt;&lt;script src="https://gist.github.com/krymtkts/7774bb65f2f0351697a47383aefe9ec9.js"&gt;&lt;/script&gt;&lt;p&gt;はまったところ。&lt;/p&gt;&lt;p&gt;&lt;a href="https://docs.aws.amazon.com/cli/latest/reference/route53/change-resource-record-sets.html"&gt;change-resource-record-sets — AWS CLI 1.18.203 Command Reference&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;SetIdentifier -&amp;gt; (string)&lt;/p&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;p&gt;Resource record sets that have a routing policy other than simple: An identifier that differentiates among multiple resource record sets that have the same combination of name and type, such as multiple weighted resource record sets named acme.example.com that have a type of A. In a group of resource record sets that have the same name and type, the value of SetIdentifier must be unique for each resource record set.&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;For information about routing policies, see Choosing a Routing Policy in the Amazon Route 53 Developer Guide .&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;p&gt;Alias レコードのパラメータからコピペしてたので&lt;code&gt;SetIdentifier&lt;/code&gt;を残したままにしてしまっていた。NS レコードは Simple Routing のみを許可するのでエラーになるのね。↓&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;  52 |  Edit-R53ResourceRecordSet -HostedZoneId $ParentHostedZone.Id -ChangeB …
     |  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     | Invalid request: Expected exactly one of [Weight, Region, Failover, GeoLocation, or MultiValueAnswer], but found none in Change with [Action=CREATE, Name=test.testtest.com, Type=NS, SetIdentifier=nandeyanen]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;わかりにくぅ！&lt;/p&gt;&lt;p&gt;おわり 😭&lt;/p&gt;</description><pubDate>Sun, 27 Dec 2020 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2020-12-26-retrospective2020</guid><link>https://krymtkts.github.io/posts/2020-12-26-retrospective2020</link><title>振り返り 2020 年</title><description>&lt;p&gt;2020 年を振り返る。&lt;/p&gt;&lt;p&gt;2020 年は自分の人生の中でも全く予想のつかない年であったと同時に、停滞感を感ずる年でもあった。以下ダイジェスト。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一人でサブシステム&lt;/li&gt;&lt;li&gt;COVID-19 流行からのフルリモートワーク&lt;/li&gt;&lt;li&gt;チームメンバのクビ&lt;/li&gt;&lt;li&gt;フラストレーションの多い下半期&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="一人でサブシステム"&gt;一人でサブシステム&lt;/h3&gt;&lt;p&gt;ほとんど偶然の流れでサーバーレスな ETL を一人で作る機会を得た。&lt;/p&gt;&lt;p&gt;すぐに作って初夏までにリリース的な感じのやつでやった。サービスの見込みが「ほんまにそんなにユーザとれんのか？おお？」的なきな臭い感じだったので極力維持費をかけないようにサーバーレスに。そしたら案の定、年末までほとんど利用されることなかったんでこの選択は我ながら良いとおもた。サブシステム単体の原価が 1 日 40 円程度とめちゃくちゃ安い、ものすごく利益率がいいので、使ってもらえれば儲かる。
結果的に Go on AWS Step Functions &amp;amp; AWS Lambda を組み合わせて作った。その際に Aurora Serverless やら Cognito やら使ったことないサービスを利用でけたこと、IaC 大前提でイチから権限の設計だったりできたのはかなりいい経験になったなーとおもとる。
というか今年のハイライトはここちゃうか...という気もしなくない。裁量という面においては。&lt;/p&gt;&lt;p&gt;もちろんヘマこいたところもいっぱいあるんやけど、それすら次に活かそうという気持ちになれるやつらでヒジョーにポジティブに考えれていた時期。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;運用用途で 1 日のデータ量の集計を Aurora Serverless に保持するようにしたが、これは結果的に要らなかった
&lt;ul&gt;&lt;li&gt;DynamoDB にエントリを作っといて、後でからスクリプトなり最近増えた SQL のサポートで良かったんじゃないか、的な。そうすれば維持費ももっと抑えれた&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Cognito むずすぎ
&lt;ul&gt;&lt;li&gt;S3 へのアクセス制御を Cognito で行った。結果的にバケツへアクセスする一時クリデンシャルを作成する形にしたが、これはどうも OAuth2 仕様だと機器間認証を使うべきだったらしい。わからん&lt;/li&gt;&lt;li&gt;こんなの？&lt;a href="https://medium.com/faun/setting-up-a-machine-to-machine-authentication-system-with-amazon-cognito-4c8e2de41c2e"&gt;Machine-to-machine authentication with Amazon Cognito | FAUN&lt;/a&gt;&lt;/li&gt;&lt;li&gt;あと秒間の initiate auth 上限がしょぼくて同時ログイン多いと使えない。AWS SA の方にも Auth0 にしとけって言われてしまう始末。とはいえ料金的にこっちのが安くて選んだ&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Go の熟れてなかった感
&lt;ul&gt;&lt;li&gt;複数エンドポイント作るのにオレオレディレクトリ構造で作ったのでややこしい形に
&lt;ul&gt;&lt;li&gt;すぐ良くないのがわかったので次の Go 経験で&lt;a href="https://github.com/golang-standards/project-layout"&gt;golang-standards/project-layout: Standard Go Project Layout&lt;/a&gt; を速攻取り込んで改善した&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;JSON＆ファイルストリーム操作がいまいち
&lt;ul&gt;&lt;li&gt;aws-go-sdk で S3 から gzip された JSON 取り込むのにパイプを使ってうまく空間計算量を減らしたが、まだちょっとイケてない部分が残ってて極端にファイルサイズが大きいと死にうる。これをもっとうまくできたろうと思う&lt;/li&gt;&lt;li&gt;JSON のパースエラーを親切にする方法はこわかったので、次の経験で活かした&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;channel や独自の型は相性が良かったのか難なく。後のデスマーチプロジェクトでもそれが活きた&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Aurora Serverless Data API の使いこなし
&lt;ul&gt;&lt;li&gt;接続時に最大 1 分くらい応答がないけど Data API ではタイムアウト時間を延ばせず(標準 50 秒くらい)、そのエラーハンドリングが下手くそだった。結果的にリリース後相当経ってからの対応になったが error 型でリトライ可能エラーとか切り分けた&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="covid-19-流行からのフルリモートワーク"&gt;COVID-19 流行からのフルリモートワーク&lt;/h3&gt;&lt;p&gt;これは IT 系ならどこもそうだろうと思うが、ついにフルリモートワークになった。もともと子守で週に数回在宅勤務時間を設けていたが、フルリモートとなるとその労働体験は全く異なる。&lt;/p&gt;&lt;p&gt;通勤時間 2 時間がまるっとなくなった分かなり楽になったが、逆に駆けつけ 3 杯だったり、思考しながら歩いたりといった息抜きのタイミングがなくなった。家庭へのサポートの負担がより増えたことで読書や自習の時間も確保しにくく、それこそ自身の学びのスタイルを再構築する程度には追い詰められたのかなと思う。もちろん自走できるエンジニアにとしては労働体験は向上したのだけど。&lt;/p&gt;&lt;p&gt;半年以上フルリモートワークなのだけど、この状況に合わせた最良の方法は、まだ模索中。&lt;/p&gt;&lt;p&gt;少しずつ習慣化していたワークアウトは、こういった状況だと有無の効果がわかりやすかった(メンタル面の安定において)。でも引っ越し後機会を取れていなくバランスを崩している。&lt;/p&gt;&lt;h3 id="チームメンバのクビ"&gt;チームメンバのクビ&lt;/h3&gt;&lt;p&gt;これは自身の労働体験では一番悪い出来事だった。1 年半ほどずっと同じチームメンバとして働いてきて、コンテキストの共有もできていたし、ようやくチーム開発が回りだすなという状況だったが、いなくなってしまった。優秀な方で、鼓を打てば響くがごとく(個人的には)よいチームワークやと感じていただけに非常に残念だったし、前職チームリーダ時代にメンバのおじさまエンジニアの年俸 150 万をふっとばしてしまった経験と同列くらいで、自分の至らなさを悔やみ続ける事件になった。
チーム開発がしたかったけど、これは当面できなくなってしまった。これが結局フラストレーションを溜め始める 1 要素になったのは間違いない。
その後を埋める形で？優秀なメンバを得れたのだけど、自律性といった意味では前任者が天才的だったのと、1 年半の間の積み重ねが灰燼に帰したこともあって傷心チックな状態は今も続いている。&lt;/p&gt;&lt;p&gt;その中で唯一救われたのは、件の方がエンジニアとしてのキャリアを見定めて次の活動をすでに始めている点。これだけは本当に良かった。幸多からんことを。&lt;/p&gt;&lt;h3 id="フラストレーションの多い下半期"&gt;フラストレーションの多い下半期&lt;/h3&gt;&lt;p&gt;チーム開発 ≒ わたしのなかではコラボレーションができない仕事というのは、自分の出力以上のものが期待できないのと同時に学びや気づきも自発的なもの以外にないという面白くない状態でであって、これが半年間の間続いたことで相当に気分が参ってしまった。この下半期の間続いていたデスマーチ的な案件も、参加メンバは多いのに情報連携の齟齬がこれでもかというくらいにあって、まあ色々疲れてしまった。件の方もこのプロジェクトに参加中にいなくなったにもかかわらず、開発者は補充されなかったのでけっきょくワイ一人で開発してたよーな気分。
この間にでかい会社のリクルータが面談の話を持ってきたので挑んでみたが、これまた全然だめだった。知識もメンタルも準備大事。&lt;/p&gt;&lt;p&gt;苛々する時期だったが、年の瀬には曲りなりにもアプリケーションは本番稼働し、面談で感じた自分の至らなさから改めて自身のエッセンシャルな選択肢を掘り起こす事ができたので、プラスマイナス 0 くらいの経験になったのではないか？とは思っている。
今振り返ると、ETL の失敗経験からこのデスマーチに取り組んだ改善点は相当数あって、そういった進歩を楽しめていなかった点でもわたし自身気分が落ちてたんやろなーというのが明らかや。&lt;/p&gt;&lt;p&gt;このデスマーチの裏では別の Fury Road が残ってて、年末年始も働くのだ。でも全然気持ちのしんどさが違う。&lt;/p&gt;&lt;p&gt;※デスマーチゝいうてるけど肉体的な労働負荷は全然大したことない。偏に 8 時間と少ししか働けない自身の限られた時間内でやるべきでないしょうもないことに時間を浪費してしまっていたり、そういったところがデスなマーチなのだ。アドレナリンジャンキーになれていたらもっと追い込んで働けたろうに。リモートワークではそこまで中毒できないんちゃうかな？&lt;/p&gt;&lt;h3 id="2020-年目標と成果"&gt;2020 年目標と成果&lt;/h3&gt;&lt;p&gt;年初に以下の目標を羅列した。その結果は次の通り。惨憺たる結果。まず目標が多い、多すぎるわ。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;家庭
&lt;ul&gt;&lt;li&gt;⭕️ 引越
&lt;ul&gt;&lt;li&gt;時期はかなりずれ込んだが完了&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;🔺 親族
&lt;ul&gt;&lt;li&gt;半分完了的な形。およそ 5 年後に延期&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;仕事
&lt;ul&gt;&lt;li&gt;⭕️ リモートワーク
&lt;ul&gt;&lt;li&gt;意図せずフルリモート化した&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;🔺 昇給
&lt;ul&gt;&lt;li&gt;源泉がまだだが年間 40~50 万 UP 程度で期待のとおりでなかった&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;⭕️ リード的な活動
&lt;ul&gt;&lt;li&gt;できていたが、件のメンバ離脱でちょっと空回り気味&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;自分のこと
&lt;ul&gt;&lt;li&gt;❌ 積ん読の消化
&lt;ul&gt;&lt;li&gt;無理すぎた&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;🔺 OSS へのコントリビューション
&lt;ul&gt;&lt;li&gt;おしい
&lt;ul&gt;&lt;li&gt;ドキュメント修正やフォーマットだけの PR で 3 回だけ&lt;/li&gt;&lt;li&gt;Terminal Icons の Issue にコメントして助けたのが 1 回&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;❌ 自作ツールの更新
&lt;ul&gt;&lt;li&gt;ほぼなしか。TODO はあるけど&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;❌ 音楽活動
&lt;ul&gt;&lt;li&gt;これも全然できず。というか COVID-19 で無理んなった&lt;/li&gt;&lt;li&gt;下期は忙しくて死ぬほどギターが下手くそになった&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;❌ &lt;a href="https://krymtkts.github.io/"&gt;このブログ&lt;/a&gt;を毎月更新する
&lt;ul&gt;&lt;li&gt;途中から落とした...&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;自分のことが後回しになるのは年を経るとよくあることやと思うけど、ちょっとひどい。
今年溜め込んだ知識というか、使い回せるスクリプトもあるので、年末年始の落ち着いた時期にそういう宝物を Gist にガンガン登録していこう。&lt;/p&gt;&lt;p&gt;おわり。&lt;/p&gt;</description><pubDate>Sat, 26 Dec 2020 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2020-11-01-terminal-icons-not-work-case</guid><link>https://krymtkts.github.io/posts/2020-11-01-terminal-icons-not-work-case</link><title>Terminal Icons が動かなくなるケース</title><description>&lt;p&gt;9 月&amp;amp;10 月と文字起こしするのをサボった 😪&lt;/p&gt;&lt;p&gt;肉親の不幸やトラブルがあったりで気乗りしなかったのもあるが、お仕事の方で WFH になって以降最高潮に忙しさのピークを迎えていたというのもある。この辺はチームビルディングぽい要素大いにあったのでまたなんかまとめたい所存 🤔&lt;/p&gt;&lt;p&gt;この間、OSS 活動も特に何のアクションもなく過ごしたが、ただ無為に過ごしたわけではない(と言い聞かせたい)のでなんか貢献したぽいことをネタに記事に残そうと思う。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;先日&lt;a href="https://devblogs.microsoft.com/commandline/windows-terminal-tips-and-tricks/"&gt;Windows Terminal Tips and Tricks | Windows Command Line&lt;/a&gt;を見てたら、愛すべき oh my posh の紹介の後に &lt;a href="https://github.com/devblackops/Terminal-Icons"&gt;Terminal-Icons: A PowerShell module to show file and folder icons in the terminal&lt;/a&gt; が紹介されていた。
なんじゃこりゃー即導入せねばなるまいな、という感じで導入してみたのだが、初回は&lt;code&gt;Get-ChildItem&lt;/code&gt;の結果に可愛らしいアイコンフォントが付与されるのに、2 回目以降は普通の見た目に戻ってしまい、なんでや...とトラシューしてみた。&lt;/p&gt;&lt;p&gt;わかったのは、一緒に使っていた &lt;a href="https://github.com/joonro/Get-ChildItemColor"&gt;Get-ChildItemColor: Add coloring to the output of Get-ChildItem Cmdlet of PowerShell.&lt;/a&gt; の実行後に、Terminal Icons のアイコンフォントが反映されなくなること。
試しに &lt;code&gt;Remove-Module Get-ChildItemColor&lt;/code&gt; すればあ～ら不思議、アイコンが復活するのである。&lt;/p&gt;&lt;p&gt;Terminal Icons では&lt;code&gt;format.ps1xml&lt;/code&gt; で表示内容の改変を行っているのだけど、&lt;code&gt;Get-ChildItemColor&lt;/code&gt;も色の改変をしてるし、競合してるのだろう。詳しくは追っていくのがめんどくて競合できないという結論だけだした。↓ の Issue で同じく困ってる人がいたので共有してあげた。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/devblackops/Terminal-Icons/issues/12"&gt;No icons after installation. · Issue #12 · devblackops/Terminal-Icons · GitHub&lt;/a&gt;&lt;/p&gt;</description><pubDate>Sun, 01 Nov 2020 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2020-08-31-how-do-i-manage-todos</guid><link>https://krymtkts.github.io/posts/2020-08-31-how-do-i-manage-todos</link><title>TODO の管理どないしてまっか？</title><description>&lt;p&gt;最近、TODO 管理のやり方を変えたので記しておく。&lt;/p&gt;&lt;p&gt;いろんなタスク管理術がある。昔は Remember the Milk 使ってみたり、Evernote に TODO リスト書いたり。最近では Google Tasks 使ってみたり。へーしゃ内では Getting Things Done が優勢なんかな。
とはいえ結局の所いずれの手段もわたしにはうまく使いこなせず、結局日報的なものに落ちつていた、もう 7 年以上？日報のようなお仕事日記をつけている。&lt;/p&gt;&lt;p&gt;ところが、そのスタイルに狂いが生じだしたのが、COVID-19 流行による出社自粛 →WFH を始めてからだ。&lt;/p&gt;&lt;p&gt;WFH になってかなり仕事とプライベートの距離感が急接近。結果どういうわけか仕事と私生活の両方において、タスクの消化をそれまでの様にできない状態になりつつあった。7,8 割くらいのパフォが出たらいい感じ。実際はもっと悪い。&lt;/p&gt;&lt;p&gt;思うに、往復 2 時間の通勤時間でコンテキストスイッチを緩やかに行っていたり、処理すべきタスクの組み換えとかを行っていたのだろう。歩く時間も 30 分はあったし。
スキマ時間がなくなったことで、ギアが上がりきらないままタスク消化を急いで空回りでもしてたのだろうか。
もともと仕事の日記にはプライベートのタスクを書かずに続けていたのだけど、とりあえずコンテキストスイッチを抑えるために、仕事と私生活のタスクを一括管理しようと考えた。とはいえお仕事日記は自身の振り返りのためにも使っていて、あまり私生活のノイジー？な内容を書いていくのもどうかなと。
そんな時ちょうど Chrome のサジェスト記事で &lt;a href="https://marketplace.visualstudio.com/items?itemName=davraamides.todotxt-mode"&gt;todotxt-mode - Visual Studio Marketplace&lt;/a&gt; の存在を知ったので、&lt;a href="https://github.com/todotxt/todo.txt"&gt;todo.txt&lt;/a&gt; で、単純にタスクの管理だけを一括管理することにした。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/todotxt/todo.txt"&gt;todo.txt&lt;/a&gt;はシンプルにフォーマットが決まっているのがありがたい。また詳細を note に切り出せるのでタスク自体をシンプルに保てるのが気に入っている。&lt;/p&gt;&lt;p&gt;複数の端末でこの「TODO を記したプレーンテキスト」を同期する必要があるが、これについては現状 &lt;a href="https://marketplace.visualstudio.com/items?itemName=GustavoASC.google-drive-vscode"&gt;Google Drive™ for VSCode - Visual Studio Marketplace&lt;/a&gt; を使っている。
Upload したファイルが上書きじゃなく、都度新しいファイルになるのがかなり気に食わないけど、生のテキストファイルが使えることを優先してのチョイスだ。&lt;/p&gt;&lt;p&gt;今の所はゆるく todo.txt のフォーマットの一部(priority, context, due ぐらいしか使えてない)だけ運用している。
数年来のタスク管理を変える機会なので慣れないことも多いが、折角の変化の機会なので楽しんで模索してみたい。&lt;/p&gt;</description><pubDate>Mon, 31 Aug 2020 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2020-07-31-partial-decode-uniqid</guid><link>https://krymtkts.github.io/posts/2020-07-31-partial-decode-uniqid</link><title>PHP の uniqid をデコードする</title><description>&lt;p&gt;なんか一意っぽい値を PHP で生成する場合の楽な手段として、 &lt;code&gt;uniqid&lt;/code&gt; がある。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/php/php-src/blob/91fbd12d5736b3cc9fc6bc2545e877dd65be1f6c/ext/standard/uniqid.c"&gt;php-src/uniqid.c at 91fbd12d5736b3cc9fc6bc2545e877dd65be1f6c · php/php-src&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;prefix を除いた先頭 8 桁が unixtime を 16 進数で出してるだけっぽいので、こいつが何時生成されたのかを知りたい時に、以下の手順が踏める。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://www.php.net/manual/ja/function.uniqid.php#95001"&gt;PHP: uniqid - Manual&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;ここのコメントのまま使える。&lt;code&gt;more_entropy&lt;/code&gt;が有効な値で試す。&lt;/p&gt;&lt;pre&gt;&lt;code class="php"&gt;// &amp;lt;?php
$s = "5ef4f46e0e40f9.59913527";
$d = date("r",hexdec(substr($s,0,8)));
echo($d . PHP_EOL);
// Thu, 25 Jun 2020 19:01:02 +0000
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;しかし手前は PHP をインストールしてなくて repl を持ってない(↑ の Repl.it でやった)ので、これを PowerShell でやる！(ついでに JST)&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/10781697/convert-unix-time-with-powershell"&gt;epoch - Convert Unix time with PowerShell - Stack Overflow&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$s = "5ef4f46e0e40f9.59913527";
(Get-Date '1970-1-1').AddSeconds([System.Convert]::ToInt32($s.Substring(0, 8), 16)).ToLocalTime()
# 2020年6月26日 04:01:02
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ちょっとした小技が必要だったので覚書しておく。
無駄に PHP のコードを読んでしまった...😂&lt;/p&gt;</description><pubDate>Fri, 31 Jul 2020 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2020-06-29-contextual-sfn-example</guid><link>https://krymtkts.github.io/posts/2020-06-29-contextual-sfn-example</link><title>Step Functions のステートをまたいでパラメータを伝播するパターン</title><description>&lt;p&gt;&lt;a href="2020-04-30-context-like-sfn"&gt;前の記事&lt;/a&gt;で記したアイデアの実装例を残しておいた。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/contextual-sfn"&gt;krymtkts/contextual-sfn: Example for passing parameters across states.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;現時点で実際にお仕事で使っているパターンなのだけど、前述の通りペイロードが大幅に大きくなると問題になり得るので、より良くするすべはないものかと考え中。&lt;/p&gt;&lt;h3 id="おさらい"&gt;おさらい&lt;/h3&gt;&lt;p&gt;StateMachine の構成。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Task&lt;/li&gt;&lt;li&gt;Map&lt;/li&gt;&lt;li&gt;Reduce&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;のステートがあるとする。Task は文字列、配列 A、配列 B を Output する。これらのデータについては以下の通りとする。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;文字列(&lt;code&gt;t&lt;/code&gt;)は、フロー全体に渡って使用したいデータ。&lt;/li&gt;&lt;li&gt;配列 A(&lt;code&gt;ia&lt;/code&gt;) は、1 つ目の Map タスクで分散したいデータ。&lt;/li&gt;&lt;li&gt;配列 B(&lt;code&gt;sa&lt;/code&gt;) は、2 つ目の Map タスクで分散したいデータ。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;このパターンを実装した背景としては以下の通り。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Map と Reduce で使いたいデータを Aurora Serverless から取得する必要がある&lt;/li&gt;&lt;li&gt;普段停止しているクラスタは結構起動に時間がかかる&lt;/li&gt;&lt;li&gt;Map では Reduce のパラメータも利用したい&lt;/li&gt;&lt;li&gt;フローの最初に全部取ってしまおう！&lt;/li&gt;&lt;/ul&gt;&lt;h4 id="1-task"&gt;1. Task&lt;/h4&gt;&lt;p&gt;Lambda からの出力がこんなのだとする。&lt;/p&gt;&lt;pre&gt;&lt;code class="json"&gt;{
  "t": "nanigashi",
  "ia": [1, 2, 4, 8, 16, 32, 64],
  "sa": ["A", "B", "C", "D", "E"]
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;ResultPath&lt;/code&gt;を&lt;code&gt;$.data&lt;/code&gt;にしておくと Task1 ステートの出力は ↓ になる。&lt;/p&gt;&lt;pre&gt;&lt;code class="json"&gt;{
  "data": {
    "t": "nanigashi",
    "ia": [1, 2, 4, 8, 16, 32, 64],
    "sa": ["A", "B", "C", "D", "E"]
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;YAML はこう。&lt;/p&gt;&lt;pre&gt;&lt;code class="yml"&gt;Entrypoint:
  Type: Task
  Resource:
    Fn::GetAtt: [task, Arn]
  ResultPath: $.data
  Next: Map
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id="2-map"&gt;2. Map&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;ItemsPath&lt;/code&gt; に &lt;code&gt;$.data.ia&lt;/code&gt; を指定し、配列 A でイテレーションする&lt;/li&gt;&lt;li&gt;&lt;code&gt;Parameters&lt;/code&gt; に Lambda へ渡したいパラメータを指定する。以下の通り
&lt;ul&gt;&lt;li&gt;マッピングの各要素は&lt;code&gt;$$.Map.Item.Value&lt;/code&gt;&lt;/li&gt;&lt;li&gt;追加で渡したいパラメータを &lt;code&gt;$.data.t&lt;/code&gt;, &lt;code&gt;$.data.sa&lt;/code&gt;&lt;/li&gt;&lt;li&gt;パラメータ名末尾の&lt;code&gt;.$&lt;/code&gt;忘れがち&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;OutputPath&lt;/code&gt; に前のタスクの出力 &lt;code&gt;$.data&lt;/code&gt; を指定すれば、同じパラメータを次のステートに回せる&lt;/li&gt;&lt;li&gt;ここではマッピングの出力は無視するとして、&lt;code&gt;ResultPath&lt;/code&gt;に&lt;code&gt;$.null&lt;/code&gt;など&lt;code&gt;OutputPath&lt;/code&gt;に含まれないパスを指定する&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class="yml"&gt;Map:
  Type: Map
  MaxConcurrency: 10
  Parameters:
    k.$: $$.Map.Item.Value
    t.$: $.data.t
    a.$: $.data.sa
  ItemsPath: $.data.ia
  ResultPath: $.null
  OutputPath: $.data
  Iterator:
    StartAt: MapTask
    States:
      MapTask:
        Type: Task
        Resource: !GetAtt [map, Arn]
        End: true
  Next: Reduce
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id="3-reduce"&gt;3. Reduce&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;ItemsPath&lt;/code&gt; に &lt;code&gt;$.sa&lt;/code&gt; を指定し、配列 B でイテレーションする&lt;/li&gt;&lt;li&gt;&lt;code&gt;Parameters&lt;/code&gt; に Lambda へ渡したいパラメータを指定する。以下の通り
&lt;ul&gt;&lt;li&gt;マッピングの各要素は&lt;code&gt;$$.Map.Item.Value&lt;/code&gt;&lt;/li&gt;&lt;li&gt;追加で渡したいパラメータを &lt;code&gt;$.data.t&lt;/code&gt;&lt;/li&gt;&lt;li&gt;パラメータ名末尾の&lt;code&gt;.$&lt;/code&gt;忘れがち(2 回目)&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;出力を制御したい場合は、Map 同様に&lt;code&gt;OutputPath&lt;/code&gt;、&lt;code&gt;ResultPath&lt;/code&gt;を指定仕分ける&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class="yml"&gt;Reduce:
  Type: Map
  Parameters:
    k.$: $$.Map.Item.Value
    t.$: $.t
  ItemsPath: $.sa
  ResultPath: $.null
  OutputPath: $.t
  Iterator:
    StartAt: ReduceTask
    States:
      ReduceTask:
        Type: Task
        Resource: !GetAtt [reduce, Arn]
        End: true
  End: true
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="まとめ"&gt;まとめ&lt;/h3&gt;&lt;p&gt;こういう例、ググっても見つからずあまり使われないパターンかも知れない。
必要だった＆実現できたので制限を理解した上で、容量用法守って使えれば良いかな。&lt;/p&gt;</description><pubDate>Mon, 29 Jun 2020 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2020-05-09-try-to-elm-handson</guid><link>https://krymtkts.github.io/posts/2020-05-09-try-to-elm-handson</link><title>Elm のハンズオンを試した</title><description>&lt;p&gt;会社の勉強会で Elm のハンズオンをしてみた。それだけ。&lt;/p&gt;&lt;h3 id="elm-とわたし"&gt;Elm とわたし&lt;/h3&gt;&lt;p&gt;いつ頃 Elm を知ったのだろう。なんか前職ですごい H 本の輪読会をした 2015 年らへんか、2016 年とかそのあたりに知ったような気がする。&lt;/p&gt;&lt;p&gt;爆発炎上中の新製品開発(Backbone.js なのに誰も使えてなくてやばい製品だった)のヘルプに入ってちょっとした頃。フロントエンドを全然知らなかったので一通り新しめの情報をさらってて、その中に Elm を見つけたような気がしている。&lt;/p&gt;&lt;p&gt;最近までずっと Elm と付き合うことなく来た&lt;sup id="fnref-1"&gt;&lt;a class="footnote-ref" href="#fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt;が、ちょうどへーしゃにてフロントエンド刷新の機運があると聞き、Elm 一択ですね！と押し込むためにも開催してみた。今思えばこいつ何様やねん 🤔&lt;/p&gt;&lt;h3 id="勉強会について"&gt;勉強会について&lt;/h3&gt;&lt;p&gt;&lt;a href="https://github.com/mather/elm-handson"&gt;mather/elm-handson: ハンズオン資料&lt;/a&gt; を流用させていただいた。めちゃくちゃやりやすかったですありがとうございました。&lt;/p&gt;&lt;p&gt;カンペ用にわたしは回答例みたいなのを fork して添えさせていただいた。&lt;a href="https://github.com/krymtkts/elm-handson"&gt;krymtkts/elm-handson: ハンズオン資料&lt;/a&gt;&lt;/p&gt;&lt;p&gt;元々はデータストアがあって、CRUD 操作ができて、みたいなバックエンドも含めたやつをやろうとしてた。
のだけど、わたしに Elm でハンズオンを作りきるパワーもなく、「う、めんどくせえ！」となり、またインターネッツで探してみるもめぼしいものを見つけられなかった。&lt;/p&gt;&lt;p&gt;やはり導入部ということもあり、もっとシンプルにできるものはないか－と探していたところ、前述のハンズオンにたどり着いたのだ。&lt;/p&gt;&lt;h3 id="やってみた感想"&gt;やってみた感想&lt;/h3&gt;&lt;p&gt;へーしゃのフロントエンドに Elm を採用するのには至らなそうだけど、他のエンジニアに興味を持ってもらえり静的型付け＆関数型言語のパワーを知ってもらったのは良かった。Message を足したり型変えたらめちゃくちゃ親切なコンパイルエラーになるやでー、が結構ウケた印象。
現行が複雑怪奇な PHP(Smarty)や jQuery でメンテも苦痛なところに、Elm が爽やかな風を送り込んでくれたのだから、そりゃエンジニアの認識が変わるのも必然やで。&lt;/p&gt;&lt;p&gt;最終的に CRUD ある画面のハンズオンを目指す。遊び用 AWS 垢が支給されてるし、Amplify で Sample 探すか。
まだ何回か企画してるので、刺激を与えていきたい所存。&lt;/p&gt;&lt;div class="footnotes"&gt;&lt;hr /&gt;&lt;ol&gt;&lt;li id="fn-1"&gt;&lt;p&gt;&lt;a href="https://www.amazon.co.jp/dp/4863542224/"&gt;基礎からわかる Elm&lt;/a&gt;はもちろん読んでるで。ポチってからかなり待ったけど、無事出版され、読むことができてホッとした。&lt;/p&gt;&lt;a href="#fnref-1" class="footnote-backref"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description><pubDate>Sat, 09 May 2020 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2020-04-30-context-like-sfn</guid><link>https://krymtkts.github.io/posts/2020-04-30-context-like-sfn</link><title>Step Functions のステートをまたいでパラメータを伝播する</title><description>&lt;p&gt;仕事でシンプルなバッチを組む必要があり、ちょうどワークフローみたいな感じだったので Step Functions で Lambda をつないで作っている。&lt;/p&gt;&lt;p&gt;3 つ Lambda が登場するのだけど、1 つ目の Lambda の Output を 2 つ目 3 つ目で使いたい。
でも、こいつらが Map ステートなのもあり Output でつなぐのはちょっと違う。
代わりに &lt;code&gt;ResultPath&lt;/code&gt;, &lt;code&gt;OutputPath&lt;/code&gt;, &lt;code&gt;ItemPath&lt;/code&gt;, &lt;code&gt;Parameters&lt;/code&gt; の組み合わせれば、Lambda の Output にない後続のステートにつなげるのがわかったのでメモしておく。&lt;/p&gt;&lt;h3 id="参考資料"&gt;参考資料&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://docs.aws.amazon.com/ja_jp/step-functions/latest/dg/input-output-example.html"&gt;InputPath、ResultPath、および OutputPath 例 - AWS Step Functions&lt;/a&gt;&lt;ul&gt;&lt;li&gt;これは読んでもナンノコッチャよくわからんかった&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://dev.classmethod.jp/articles/step-functions-parameters/"&gt;Step Functions の入出力処理の制御パラメータ（InputPath、 Parameters、ResultPath および OutputPath）を理解するために参照したドキュメント | Developers.IO&lt;/a&gt;&lt;ul&gt;&lt;li&gt;流石のクラスメソッドさん、わかりやすかった&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="構成"&gt;構成&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;Task&lt;/li&gt;&lt;li&gt;Map&lt;/li&gt;&lt;li&gt;Map&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;のステートがあるとする。Task は文字列、配列 A、配列 B を Output する。これらのデータについては以下の通りとする。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;文字列は、StateMachine 全体に渡って使用したいデータ。&lt;/li&gt;&lt;li&gt;配列 A は、1 つ目の Map タスクで分散したいデータ。&lt;/li&gt;&lt;li&gt;配列 B は、2 つ目の Map タスクで分散したいデータ。&lt;/li&gt;&lt;/ul&gt;&lt;h4 id="1-task1"&gt;1. Task1&lt;/h4&gt;&lt;p&gt;Lambda からの出力がこんなのだとする。&lt;/p&gt;&lt;pre&gt;&lt;code class="json"&gt;{
  "string": "nanigashi",
  "arrayA": [
      0, 1, 2, 3, 4, 5, 6
  ],
  "arrayB": {
      "A", "B", "C", "D", "E"
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;ResultPath&lt;/code&gt;を&lt;code&gt;$.key&lt;/code&gt;にしておくと Task1 ステートの出力は ↓ になる。&lt;/p&gt;&lt;pre&gt;&lt;code class="json"&gt;{
  "key": {
    "string": "nanigashi",
    "arrayA": [
        0, 1, 2, 3, 4, 5, 6
    ],
    "arrayB": {
        "A", "B", "C", "D", "E"
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id="2-map1"&gt;2. Map1&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;ItemPath&lt;/code&gt; に &lt;code&gt;$.key.arrayA&lt;/code&gt; を指定し、配列 A でイテレーションする&lt;/li&gt;&lt;li&gt;&lt;code&gt;Parameters&lt;/code&gt; に Lambda へ渡したいパラメータを指定する。以下の通り
&lt;ul&gt;&lt;li&gt;マッピングの各要素は&lt;code&gt;$$.Map.Item.Value&lt;/code&gt;&lt;/li&gt;&lt;li&gt;追加で渡したいパラメータを &lt;code&gt;$.key.string&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;OutputPath&lt;/code&gt; に前のタスクの出力 &lt;code&gt;$.key&lt;/code&gt; を指定する&lt;/li&gt;&lt;li&gt;マッピング処理の出力は無視したいので、&lt;code&gt;ResultPath&lt;/code&gt;に&lt;code&gt;$.null&lt;/code&gt;など&lt;code&gt;OutputPath&lt;/code&gt;に含まれないパスを指定する&lt;/li&gt;&lt;/ul&gt;&lt;h4 id="3-map2"&gt;3. Map2&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;ItemPath&lt;/code&gt; に &lt;code&gt;$.arrayB&lt;/code&gt; を指定し、配列 B でイテレーションする&lt;/li&gt;&lt;li&gt;&lt;code&gt;Parameters&lt;/code&gt; に Lambda へ渡したいパラメータを指定する。以下の通り
&lt;ul&gt;&lt;li&gt;マッピングの各要素は&lt;code&gt;$$.Map.Item.Value&lt;/code&gt;&lt;/li&gt;&lt;li&gt;追加で渡したいパラメータを &lt;code&gt;$.key.string&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;出力を制御したい場合は、Map1 同様に&lt;code&gt;OutputPath&lt;/code&gt;、&lt;code&gt;ResultPath&lt;/code&gt;を指定仕分ける&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;これで Task1 の出力を Map1 をまたいで Map2 で利用できる。&lt;/p&gt;&lt;h3 id="まとめ"&gt;まとめ&lt;/h3&gt;&lt;p&gt;これで最初の Lambda の Output を加工せずそのまま後ろ 2 つの Lambda まで伝播できた。やったね 😂
文章だけじゃわからなさすぎる気がしてきた...今度サンプルコードを起こすことにする。&lt;/p&gt;&lt;p&gt;ただし懸念点として以下の気になる 2 点も備えており、どうしたもんかなと言う感じでもある 🤔&lt;/p&gt;&lt;ol&gt;&lt;li&gt;伝播したい回数だけ階層化しないといけないのではないか
&lt;ul&gt;&lt;li&gt;出力を無視するためにはセクションを切り分けないといけなくなってるから&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;可変長のパラメータを伝播する場合、ペイロードの上限値に注意しないといけない
&lt;ul&gt;&lt;li&gt;ダブルクォートは&lt;code&gt;\&lt;/code&gt;エスケープされるようだし計算が大変&lt;/li&gt;&lt;li&gt;だからセクションを切り分けるしかなくなってる&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;出力無視することさえできたら階層化いらんなー 🤔&lt;/p&gt;</description><pubDate>Thu, 30 Apr 2020 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2020-03-31_oh-my-posh-theme</guid><link>https://krymtkts.github.io/posts/2020-03-31_oh-my-posh-theme</link><title>My own oh-my-posh theme</title><description>&lt;p&gt;oh-my-posh の話。
ご存じない？ &lt;a href="https://github.com/JanDeDobbeleer/oh-my-posh"&gt;JanDeDobbeleer/oh-my-posh: A prompt theming engine for Powershell&lt;/a&gt;&lt;/p&gt;&lt;p&gt;元々、Agnoster のシンボルを変えるだけで使ってた。&lt;/p&gt;&lt;p&gt;が、最近になって諸々の不満点 ↓ を解決したくなって、自分用のテーマを作ろうと思ったのがきっかけ。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;コマンドを打った時間を出したくなった
&lt;ul&gt;&lt;li&gt;分割して Terminal を使うことが多いので仕事で CLI を使ったときにどこがいちばん最後に使ったかわかりやすくしたい&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;階層が深いディレクトリで仕事することが多く working directory の短縮表示をもっと短くしたかった
&lt;ul&gt;&lt;li&gt;デフォルトの&lt;code&gt;..&lt;/code&gt;を&lt;code&gt;.&lt;/code&gt;にする(ほんとは頭文字にしたいが)&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Windows10 のいつの Version からか忘れたが一部の絵文字の表示が化ける(管理者権限には 💪 を使ってた)
&lt;ul&gt;&lt;li&gt;⚡ に戻す&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;作ったのはこれ。&lt;a href="https://gist.github.com/krymtkts/6f7e365fd1683d6edeb7e531f725d280"&gt;My own oh-my-posh theme.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;oh-my-posh のテーマを作るのはかんたん。その作り方を以下に記す。&lt;/p&gt;&lt;h2 id="how-to-make-it"&gt;How to make it&lt;/h2&gt;&lt;p&gt;テンプレを生成してくれる機能とかはない。そのため theme の PS モジュールは手で配置することになる。ちなみに export されている function たちは以下の通りである。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/JanDeDobbeleer/oh-my-posh/blob/master/oh-my-posh.psd1#L48"&gt;oh-my-posh/oh-my-posh.psd1 at master · JanDeDobbeleer/oh-my-posh&lt;/a&gt;&lt;/p&gt;&lt;p&gt;ユーザ定義のテーマは &lt;code&gt;$ThemeSettings.MyThemesLocation&lt;/code&gt; に配置する(&lt;code&gt;Get-ThemesLocation&lt;/code&gt;でも同じ様子)。フォルダがなければ合わせて作成する。&lt;/p&gt;&lt;p&gt;元ファイルはいまあるテーマからコピって作るのが手っ取り早い。わたしは&lt;a href="https://github.com/JanDeDobbeleer/oh-my-posh/blob/master/Themes/Agnoster.psm1"&gt;Agnoster.psm1&lt;/a&gt;から作成した。
今あるテーマの配置フォルダを知るには&lt;code&gt;Get-Theme&lt;/code&gt;を実行すれば良い。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; Get-Theme

Name                  Type     Location
----                  ----     --------
krymtkts              User     C:\Users\takatoshi\OneDrive\Documents\PowerShell\PoshThemes\krymtkts.psm1
Agnoster              Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\Agnoster.psm1
Avit                  Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\Avit.psm1
Darkblood             Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\Darkblood.psm1
Fish                  Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\Fish.psm1
Honukai               Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\Honukai.psm1
Paradox               Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\Paradox.psm1
Powerlevel10k-Classic Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\Powerlevel10k-Classic.psm1
Powerlevel10k-Lean    Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\Powerlevel10k-Lean.psm1
PowerLine             Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\PowerLine.psm1
pure                  Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\pure.psm1
robbyrussell          Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\robbyrussell.psm1
Sorin                 Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\Sorin.psm1
tehrob                Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\tehrob.psm1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Agnoster とわたしのテーマの差分は次の通り。&lt;code&gt;Compare-Object&lt;/code&gt;だと差分が見にくいことこの上なし！誰得 😂 なので wsl の bash から diff した。PowerSheller 失格だね(&lt;code&gt;Compare-Object&lt;/code&gt;がひどいのよ)。&lt;/p&gt;&lt;p&gt;Unified diff でみたらこの通り。&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;$ diff ./Modules/oh-my-posh/2.0.399/Themes/Agnoster.psm1 ./PoshThemes/krymtkts.psm1 -u
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="diff"&gt;--- ./Modules/oh-my-posh/2.0.399/Themes/Agnoster.psm1   2020-03-13 13:22:52.000000000 +0900
+++ ./PoshThemes/krymtkts.psm1  2020-02-24 16:03:51.912063800 +0900
@@ -11,12 +11,27 @@

     $lastColor = $sl.Colors.PromptBackgroundColor

-    $prompt = Write-Prompt -Object $sl.PromptSymbols.StartSymbol -ForegroundColor $sl.Colors.SessionInfoForegroundColor -BackgroundColor $sl.Colors.SessionInfoBackgroundColor
-
+    $now = Get-Date -UFormat '%Y-%m-%d %R'
+    $backwardSymbol = "$($sl.PromptSymbols.SegmentBackwardSymbol)"
     #check the last command state and indicate if failed
     If ($lastCommandFailed) {
-        $prompt += Write-Prompt -Object "$($sl.PromptSymbols.FailedCommandSymbol) " -ForegroundColor $sl.Colors.CommandFailedIconForegroundColor -BackgroundColor $sl.Colors.SessionInfoBackgroundColor
+        $rightText = " $($sl.PromptSymbols.FailedCommandSymbol) $now "
+        $rightLength = $rightText.Length + $backwardSymbol.Length + 1 # care the symbol size blur.
+        $foregroundColor = $ThemeSettings.Colors.CommandFailedIconForegroundColor
     }
+    else {
+        $rightText = " $now "
+        $rightLength = $rightText.Length + $backwardSymbol.Length
+        $foregroundColor = $ThemeSettings.Colors.PromptForegroundColor
+    }
+    $prompt += Set-CursorUp -lines 1
+    $prompt += Set-CursorForRightBlockWrite -textLength $rightLength
+    $prompt += Write-Prompt $backwardSymbol -ForegroundColor $sl.Colors.PromptBackgroundColor -BackgroundColor $sl.Colors.SessionInfoBackgroundColor
+    $prompt += Write-Prompt $rightText -ForegroundColor $foregroundColor -BackgroundColor $sl.Colors.PromptBackgroundColor
+
+    # Write the prompt
+    $prompt += Set-Newline
+    $prompt += Write-Prompt -Object $sl.PromptSymbols.StartSymbol -ForegroundColor $sl.Colors.SessionInfoForegroundColor -BackgroundColor $sl.Colors.SessionInfoBackgroundColor

     #check for elevated prompt
     If (Test-Administrator) {
@@ -24,9 +39,8 @@
     }

     $user = $sl.CurrentUser
-    $computer = $sl.CurrentHostname
     if (Test-NotDefaultUser($user)) {
-        $prompt += Write-Prompt -Object "$user@$computer " -ForegroundColor $sl.Colors.SessionInfoForegroundColor -BackgroundColor $sl.Colors.SessionInfoBackgroundColor
+        $prompt += Write-Prompt -Object "$user " -ForegroundColor $sl.Colors.SessionInfoForegroundColor -BackgroundColor $sl.Colors.SessionInfoBackgroundColor
     }

     if (Test-VirtualEnv) {
@@ -63,7 +77,11 @@
 }

 $sl = $global:ThemeSettings #local settings
+$sl.PromptSymbols.ElevatedSymbol = [char]::ConvertFromUtf32(0x26A1)
+$sl.PromptSymbols.FailedCommandSymbol = [char]::ConvertFromUtf32(0x274C)
 $sl.PromptSymbols.SegmentForwardSymbol = [char]::ConvertFromUtf32(0xE0B0)
+$sl.PromptSymbols.SegmentBackwardSymbol = [char]::ConvertFromUtf32(0xe0b2)
+$sl.PromptSymbols.TruncatedFolderSymbol = '.'
 $sl.Colors.PromptForegroundColor = [ConsoleColor]::White
 $sl.Colors.PromptSymbolColor = [ConsoleColor]::White
 $sl.Colors.PromptHighlightColor = [ConsoleColor]::DarkBlue
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ちょっと実行時間のあたりが Cmder で出した場合にずれてしまうことがあって、微妙に余白をとってたりする。
でもこれでだいたい Cmder で見ても Windows Terminal でみても美しく出力される様になっている。
Windows Terminal ではシンボルフォントがめちゃくちゃ小さくなってしまうバグが有るのでまだ 100%最高とはいけないけど(&lt;a href="https://github.com/microsoft/terminal/issues/900"&gt;Certain "emoji" are still half-sized · Issue #900 · microsoft/terminal&lt;/a&gt;)&lt;/p&gt;&lt;p&gt;余談だが、こんかい自作テーマの作成にあたり、既存テーマの PS モジュールにフォーマットの崩れを見つけたので PR 送ったら受け入れてもらえた。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/JanDeDobbeleer/oh-my-posh/pull/211"&gt;Format some themes. by krymtkts · Pull Request #211 · JanDeDobbeleer/oh-my-posh&lt;/a&gt;&lt;/p&gt;&lt;p&gt;自分の気に入っている OSS に PR を受けれてもらえるのはちょっとした感動があるな 😚&lt;/p&gt;</description><pubDate>Tue, 31 Mar 2020 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2020-02-22-maven-auto-completion-0.2</guid><link>https://krymtkts.github.io/posts/2020-02-22-maven-auto-completion-0.2</link><title>MavenAutoCompletion v0.2</title><description>&lt;p&gt;およそ 1 年の時を経て、MavenAutoCompletion を更新した。とても小さな更新だ。&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.powershellgallery.com/packages/MavenAutoCompletion/0.2"&gt;PowerShell Gallery | MavenAutoCompletion 0.2&lt;/a&gt;&lt;/p&gt;&lt;p&gt;この 3 連休はひとりで暇なので、しょうもない更新をするのも億劫でない。&lt;/p&gt;&lt;p&gt;&lt;a href="/posts/2019-04-02-pubslish-first-module-to-powershell-gallery"&gt;前回&lt;/a&gt;やった PSGallery への公開でのミスは、スクリプトを作成していたおかげもあり、1 年ぶりでもミスらなかった。&lt;/p&gt;&lt;p&gt;ただ...色々イケてないところも見つかっている。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;このモジュール、公開するものをサブディレクトリへコピペして公開しているのだけど、これってもともとそのディレクトリで開発してたらいい話&lt;/li&gt;&lt;li&gt;補完の定義が大量なので 1 ファイルの見通しが悪くなってる
&lt;ul&gt;&lt;li&gt;更に非推奨にしたい補完候補の説明を追加できない構造&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;対応するの忘れてる非推奨タグ残したままになってる
&lt;ul&gt;&lt;li&gt;&lt;code&gt;�x��: &amp;lt;licenseUrl&amp;gt; element will be deprecated, please consider switching to specifying the license in the package. Learn more: https://aka.ms/deprecateLicenseUrl.&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;とりあえず Issue を作っといて、忘れていても暇なときに課題を解消していけるように準備しておくかあ 😅&lt;/p&gt;</description><pubDate>Sat, 22 Feb 2020 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2020-01-29-plannning</guid><link>https://krymtkts.github.io/posts/2020-01-29-plannning</link><title>2020</title><description>&lt;p&gt;書こう書こうと思って書けていなかった。
明文化する必要もないのかもしれんが、改めて書くことによって再認識したい、というのがこのポストの目的。&lt;/p&gt;&lt;h3 id="2020-年の目標"&gt;2020 年の目標&lt;/h3&gt;&lt;p&gt;大きく分けて 3 つ。家庭、仕事、自分のことだ。&lt;/p&gt;&lt;h4 id="家庭"&gt;家庭&lt;/h4&gt;&lt;ol&gt;&lt;li&gt;引越
&lt;ul&gt;&lt;li&gt;候補地の選定は終えている&lt;/li&gt;&lt;li&gt;永続的に住む場所ではないので次の候補も頭に浮かべておく&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;親族
&lt;ul&gt;&lt;li&gt;10 年来の、シンプルにいってくだらないが制御不可能な、問題があるため今年上半期に対応を決める&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 id="仕事"&gt;仕事&lt;/h4&gt;&lt;ol&gt;&lt;li&gt;リモートワーク
&lt;ul&gt;&lt;li&gt;現状 5 営業日中、固定の曜日で 2 時間だけ&lt;/li&gt;&lt;li&gt;子供の送り迎えの関係もあり、春から毎日 4 時間は事務所、残りはリモートにする&lt;/li&gt;&lt;li&gt;比較的コントローラブルな部分なので必ず達成する&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;昇給
&lt;ul&gt;&lt;li&gt;職位はないが Job Rank みたいな給与の等級はあって、それは前年上がったので、今年は金額的な上昇に注力する
&lt;ul&gt;&lt;li&gt;金額に注力するのは、ランクアップ時の昇給額が大したことなく、今のランクで継続的に(相対的に)良い評価を刻み続けることで上がるらしいため(へーしゃの場合)&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;リード的な活動
&lt;ul&gt;&lt;li&gt;主に CI/CD といった DevOps プラクティス, Serverless Architecture 面で貢献したい。ここに書く内容でもないが意思表明として&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 id="自分のこと"&gt;自分のこと&lt;/h4&gt;&lt;p&gt;これが一番ないがしろになりがち、継続的にケアする方法も同時進行で考えたい。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;積ん読の消化
&lt;ul&gt;&lt;li&gt;月に 1 冊を消化する
&lt;ul&gt;&lt;li&gt;積ん読はもう何冊あるかわからないが、減らしていく習慣を今年確立する&lt;/li&gt;&lt;li&gt;とりあえず 1 月は、witcher① で攻略済み&lt;/li&gt;&lt;li&gt;これは自身の可能性を広げるためなので、最も優先する&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;OSS へのコントリビューション
&lt;ul&gt;&lt;li&gt;今年 5 回は PR や Issue でコントリビューションしたい&lt;/li&gt;&lt;li&gt;1 回目は AWS Docs への PR で攻略済み&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;自作ツールの更新
&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/MavenAutoCompletion"&gt;MavenAutoCompletion&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/mccall-bot"&gt;mccall-bot&lt;/a&gt;&lt;/li&gt;&lt;li&gt;他、気が向いたら&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;音楽活動
&lt;ul&gt;&lt;li&gt;ギター練習を 30 分/週 3 回&lt;/li&gt;&lt;li&gt;バンド練習を年 4 回&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://krymtkts.github.io/"&gt;このブログ&lt;/a&gt;を毎月更新する&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;4 は他より優先度が低く、かつ制御不可能な部分が多いためハードルが下がりがち。なのでかならず達成したいところ。&lt;/p&gt;&lt;p&gt;5 は去年落とした目標なので今年こそは(それでもこのポスト時点でギリギリ 😂)&lt;/p&gt;&lt;p&gt;救いのない社会だが、自分・家族の人生にいい影響をもたらそう。エッセンシャル思考とマッコーリズムの実践だ。&lt;/p&gt;</description><pubDate>Wed, 29 Jan 2020 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-12-29-retrospective2019</guid><link>https://krymtkts.github.io/posts/2019-12-29-retrospective2019</link><title>振り返り 2019 年</title><description>&lt;p&gt;ことし 2019 年も残すところあと僅か。2019 年の自身の成長などを振り返ろう。&lt;/p&gt;&lt;p&gt;短くまとめると、2019 年は新しいことを始めた年になった。&lt;/p&gt;&lt;p&gt;転職し、未体験の事業領域の企業で働き始めた。
会社の後押しもあって積極的に未経験の技術を取り入れ、部分的ではあるが在宅ワークもしてみた。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;前職は、実にチョロいかいしゃだったので、6 年ほどの在職中に入社前の 8 割ほど昇給できたのはこの会社のおかげ(前々職がリーマンのあおりもあって給料安すぎたのだけど)。
しかしながら、従業員に対する評価や報酬については不誠実極まりなかったし、自分の思い描くエンジニア像に必要な経験を積めなくなったのは一番痛かった。
やる気と実力を以て希望さえすれば挑戦させてくれる、入社時にあったような腕を磨ける環境が失われていくのは、1 度ならずこの会社を最後の会社にできそうだと心に思った自分には辛いものがあった。これは過去の話だけど。&lt;/p&gt;&lt;p&gt;転職して今の会社に入れたのもよかった。適切な判断を下すのにインフラ、クラウドの知識を求められ、わたしの技術スタックのうすーいところを絶妙に攻め立ててくれる。
おかげで徐々にではあるが弱いところを克服できている。
また強みである積極性と吸収スピードの高さが上手く活かせて、CI/CD の補填、未体験だったのにサーバーレスアーキテクチャや Python を選ばせてくれたり。
カンファレンスに積極的に参加して、社内に情報を持ち帰ったり、やりたかったことが色々でき始めた。
会社での評価も今のところは順調で、現場での自身の成長スピードを増幅できていると感じる。&lt;/p&gt;&lt;p&gt;心配事があるとしたら、前職の 1 年目年末もこんなのだったので、同じ轍を踏みたくないなというところか 😅&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;自分でも御しきれていなかったのは、在宅ワークの部分。
今は子供の面倒を見る機会を平日は週に 1 回設けて、その日を早く帰って在宅ワークの日としている。
在宅中の仕事の進め方と家族との関わり方の両立が難しくて、まだ納得の行く形になっていない。そりゃ家族からしたら、家にいるのだから色々やってほしいことができてしまうし、このままだと単純に自身の過重労働だなあと思っている。
こういった我が家のパターンだと、在宅ワークよりもちょっとカフェとかで仕事するとかがよいのか。
通勤時間を削る＆家族とも連絡を断つ、という手段がいるのかも、ただしそれは元々わたしの考えていた在宅ワークの動機と違うけど。
この辺は来年 2020 年になってからも、また別の手段を検討していきたい。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;最後に今年密かに目標としていた、1 年間毎月投稿を書く、について。
どこにも宣言してなかったけどブログを継続するという習慣づくりのためにこの目標を据えた。
結果は未達。11 月が現職の障害対応で気持ちに余裕がなかったため。まあ投稿の数は平均月 2 のペースになってたので、この点は目をつぶろう 🙈&lt;/p&gt;&lt;p&gt;来年も目標をゆるくだが設定して邁進したく。もっと情報に触れて、コードを書いて、という生活に昇華しよう。&lt;/p&gt;&lt;p&gt;(きょうの投稿には 1 文字もコードがなかったけど、特例日 😆)&lt;/p&gt;</description><pubDate>Sun, 29 Dec 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-10-14-how-to-handle-waiter-of-boto3</guid><link>https://krymtkts.github.io/posts/2019-10-14-how-to-handle-waiter-of-boto3</link><title>boto3 の Waiter さんとの戯れ</title><description>&lt;p&gt;こないだの仕事。AWS Certificate Manager で証明書をごにょごにょするアプリを書いた。&lt;/p&gt;&lt;p&gt;Python で書いたので AWS のリソースを操作するのに &lt;a href="https://boto3.amazonaws.com/v1/documentation/api/latest/index.html"&gt;Boto3&lt;/a&gt; というライブラリを利用した。証明書を発行したあと検証済みになるまでの待受処理が&lt;code&gt;Waiter&lt;/code&gt;という機能で提供されていたり、非常に便利で大変お世話になっている。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/acm.html#ACM.Waiter.CertificateValidated"&gt;ACM.Waiter.CertificateValidated — Boto 3 Docs 1.9.248 documentation&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;ただ、一つバグらせてしまったところがあった。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Waiter&lt;/code&gt;さんは AWS のリソースを操作する API をラップしているだけ&lt;sup id="fnref-1"&gt;&lt;a class="footnote-ref" href="#fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt;なので、API がエラーを発生させた場合と待受処理がタイムアウトした場合のどちらとも、&lt;code&gt;WaiterError&lt;/code&gt;を発生させる。つまり単純にキャッチするだけの例外処理では違いに気づけないのだ 😱&lt;/p&gt;&lt;p&gt;どのようにハンドリングするか？&lt;code&gt;WaiterError&lt;/code&gt;さんの属性を調べてあげれば良い。&lt;/p&gt;&lt;p&gt;&lt;code&gt;dir&lt;/code&gt;したら&lt;code&gt;last_response&lt;/code&gt;なる属性があったのでそいつを見たら、もとのエラーが何だったのかは分かる形にはなってた。&lt;/p&gt;&lt;p&gt;エラーの場合、&lt;code&gt;WaiterError.last_response['Error']&lt;/code&gt;にエラー情報が格納される。&lt;code&gt;Waiter&lt;/code&gt;さんがリトライ回数の上限に達して&lt;code&gt;WaiterError&lt;/code&gt;をぶん投げてきた場合は、&lt;code&gt;last_response&lt;/code&gt;には&lt;code&gt;Waiter&lt;/code&gt;さんが内包する API の戻り値が架空されるので、それをもとにエラー処理すれば良いのがわかった。以下イメージ。&lt;/p&gt;&lt;pre&gt;&lt;code class="python"&gt;{'Error': {'Message': 'Could not find certificate arn:aws:acm:ap-northeast-1:xxxxxxxxxxxx:certificate/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx in account xxxxxxxxxxxx.', 'Code': 'ResourceNotFoundException'}, 'ResponseMetadata': {'RequestId': 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx', 'HTTPStatusCode': 400, 'HTTPHeaders': {'x-amzn-requestid': 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx', 'content-type': 'application/x-amz-json-1.1', 'content-length': '191', 'date': 'Fri, 11 Oct 2019 03:51:10 GMT', 'connection': 'close'}, 'RetryAttempts': 0}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;👍&lt;/p&gt;&lt;div class="footnotes"&gt;&lt;hr /&gt;&lt;ol&gt;&lt;li id="fn-1"&gt;&lt;p&gt;証明書の検証済みを待つ&lt;code&gt;ACM.Waiter.CertificateValidated&lt;/code&gt;の場合は&lt;code&gt;ACM.Client.describe_certificate()&lt;/code&gt;をラップしている。&lt;/p&gt;&lt;a href="#fnref-1" class="footnote-backref"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description><pubDate>Mon, 14 Oct 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-10-13-docker-toolbox-with-powershell</guid><link>https://krymtkts.github.io/posts/2019-10-13-docker-toolbox-with-powershell</link><title>PowerShell で Docker Toolbox を使う</title><description>&lt;p&gt;へーしゃはちょっといけてなくて、秘伝の古い VM をコンテナ化しない&lt;del&gt;できない&lt;/del&gt;まま使っている。&lt;/p&gt;&lt;p&gt;加えて社内は Windows ユーザと Mac ユーザがごちゃまぜなので VM が VirtualBox のため、Windows ユーザであるわたしは Docker on Windows を使えず。&lt;/p&gt;&lt;p&gt;Docker Toolbox を日常使いしているのだが、&lt;code&gt;docker&lt;/code&gt;に&lt;code&gt;docker-compose&lt;/code&gt;に&lt;code&gt;docker-machine&lt;/code&gt;まで現れたらコマンドやオプションが覚えきれないのが現状である 😭&lt;/p&gt;&lt;p&gt;これらを PowerShell で楽ちんに使おう。いますぐ以下のモジュールを PSGallery からゲットしよう。これらを発見したときは狂喜乱舞した。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://www.powershellgallery.com/packages/DockerCompletion/1.1903.0.190723"&gt;PowerShell Gallery | DockerCompletion 1.1903.0.190723&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://www.powershellgallery.com/packages/DockerComposeCompletion/1.24.0.190329"&gt;PowerShell Gallery | DockerComposeCompletion 1.24.0.190329&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://www.powershellgallery.com/packages/DockerMachineCompletion/0.16.2.190903"&gt;PowerShell Gallery | DockerMachineCompletion 0.16.2.190903&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以下、雑なインストール例。もちろん PowerShell Guys(勝手にそう呼んでいる)なら自前の Profile に追記しよう。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Install-Module -Name DockerCompletion,DockerComposeCompletion,DockerMachineCompletion
Import-Module -Name DockerCompletion,DockerComposeCompletion,DockerMachineCompletion
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これで&lt;code&gt;docker-machine start&lt;/code&gt;に始まり&lt;code&gt;docker&lt;/code&gt;やら&lt;code&gt;docker-compose&lt;/code&gt;でのイメージ・コンテナの名前補完とか諸々できるようになる。世の中、すごいモジュールを作る方がいるもんやねえ 🤔&lt;/p&gt;</description><pubDate>Sun, 13 Oct 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-09-22-limitaion-of-remove-certificates</guid><link>https://krymtkts.github.io/posts/2019-09-22-limitaion-of-remove-certificates</link><title>ALBのListenerから証明書を削除するときの制限</title><description>&lt;p&gt;タイトルの通り。&lt;/p&gt;&lt;p&gt;仕事中にわかっただけで2つある。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;ALBのListenerに登録された証明書を一度にまとめて消せる上限は10件ぽい&lt;/li&gt;&lt;li&gt;ALBのListenerから証明書を消したあと、証明書に関連づいたリソースが消えるまで待たないといけない&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;上記はPython(boto3)からAWSのリソースを操作した際のもの。boto3はpipでインストールできる最新のv1.9.233。&lt;/p&gt;&lt;h3 id="1-albのlistenerに登録された証明書を一度にまとめて消せる上限は10件ぽい"&gt;1. ALBのListenerに登録された証明書を一度にまとめて消せる上限は10件ぽい&lt;/h3&gt;&lt;p&gt;ドキュメントには書かれてない気がする。少なくとも&lt;a href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/elbv2.html#ElasticLoadBalancingv2.Client.remove_listener_certificates"&gt;boto3&lt;/a&gt;と&lt;a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_RemoveListenerCertificates.html"&gt;ELBのAPIリファレンス&lt;/a&gt;のどちらにも記載がない。&lt;/p&gt;&lt;p&gt;問い合わせして聞いてないねんけど、書いてあったら教えてほしい🤔&lt;/p&gt;&lt;p&gt;以下はListener Certificatesの上限25件全部を一気に消そうとしたときのログ。センシティブな部分は削ってある。&lt;/p&gt;&lt;pre&gt;&lt;code class="log"&gt;Traceback (most recent call last):
  File "C:\workspace\alb-batch\albbatch\elbapi.py", line 102, in remove_cerificates
    Certificates=params)
  File "C:\Users\takatoshi_kuriyama\.virtualenvs\alb-batch-J4EQQ8Xf\lib\site-packages\botocore\client.py", line 357, in _api_call
    return self._make_api_call(operation_name, kwargs)
  File "C:\Users\takatoshi_kuriyama\.virtualenvs\alb-batch-J4EQQ8Xf\lib\site-packages\botocore\client.py", line 661, in _make_api_call
    raise error_class(parsed_response, operation_name)
botocore.exceptions.ClientError: An error occurred (ValidationError) when calling the RemoveListenerCertificates operation: Up to '10' certificate ARNs can be specified, but '25' were specified
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="2-albのlistenerから証明書を消したあと証明書に関連づいたリソースが消えるまで待たないといけない"&gt;2. ALBのListenerから証明書を消したあと、証明書に関連づいたリソースが消えるまで待たないといけない&lt;/h3&gt;&lt;p&gt;ACMで証明書を削除する場合、その証明書が他のAWSリソースに関連付けられていると&lt;code&gt;ResourceInUseException&lt;/code&gt;(boto3では&lt;code&gt;ClientError&lt;/code&gt;)で削除できない。&lt;/p&gt;&lt;p&gt;&lt;a href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/acm.html#ACM.Client.delete_certificate"&gt;ACM.Client.delete_certificate&lt;/a&gt; から抜粋。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;You cannot delete an ACM certificate that is being used by another AWS service. To delete a certificate that is in use, the certificate association must first be removed.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;なのでまず関連付けられたLoad BalancerのListenerなどから証明書を取り除いた後、かつ証明書の情報からもその関連付けが取り除かれたことを確認しないと安全に削除できない😱&lt;/p&gt;&lt;p&gt;どうすればよいかというと、ACMの&lt;code&gt;DescribeCertificate&lt;/code&gt;のレスポンスに含まれる&lt;code&gt;InUseBy&lt;/code&gt;リストの中が空になってたら、それらの関連付けが取り除かれた状態なので安全に削除できる。&lt;/p&gt;&lt;p&gt;ACMで提供されてる&lt;code&gt;Waiter&lt;/code&gt;は検証待ちのみで、それ用にはないみたいなので、以下のように手動で待ち合わせする...🤔&lt;/p&gt;&lt;pre&gt;&lt;code class="python"&gt;def wait_until_certificate_unused(self, arn: str):
    cert = self.acm_client.describe_certificate(CertificateArn=arn)
    while len(cert['InUseBy']) &amp;gt; 0:
        time.sleep(1)
        cert = self.acm_client.describe_certificate(CertificateArn=arn)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;めんどくせえええええ、こんなsnipetレベルのモノは&lt;code&gt;Waiter&lt;/code&gt;作って欲しいわ😭&lt;/p&gt;</description><pubDate>Sun, 22 Sep 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-09-01-aws-lambda-cloud-front-and-serverless</guid><link>https://krymtkts.github.io/posts/2019-09-01-aws-lambda-cloud-front-and-serverless</link><title>Serverless FrameworkでAWS LambdaとCloudFront</title><description>&lt;p&gt;AWS Lambdaって書くのはホント簡単。&lt;/p&gt;&lt;p&gt;でも手動でデプロイするのはほんまに勘弁してほしいわ...って感じだったのでAWS強メンの同僚に相談してみたところ、&lt;a href="https://serverless.com/framework/"&gt;Serverless Framework&lt;/a&gt;ってのがいい具合に抽象化してくれてるので試しに使ってみては？と助言いただけた。&lt;/p&gt;&lt;h3 id="使ってみた"&gt;使ってみた&lt;/h3&gt;&lt;p&gt;事前にNodeが必要なことくらい。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# global install
$ npm install -g serverless

# installed version
$ serverless --version
Framework Core: 1.51.0
Plugin: 1.3.10
SDK: 2.1.0

# generate boilerplate
$ serverless create --template aws-python3
Serverless: Generating boilerplate...
 _______                             __
|   _   .-----.----.--.--.-----.----|  .-----.-----.-----.
|   |___|  -__|   _|  |  |  -__|   _|  |  -__|__ --|__ --|
|____   |_____|__|  \___/|_____|__| |__|_____|_____|_____|
|   |   |             The Serverless Application Framework
|       |                           serverless.com, v1.51.0
 -------'

Serverless: Successfully generated boilerplate for template: "aws-python3"
Serverless: NOTE: Please update the "service" property in serverless.yml with your service name
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これで生成された関数に処理を書くだけ。あ～らかんたん😁&lt;/p&gt;&lt;p&gt;デプロイも超簡単なので、これならCDに組み込むのも楽そう。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# deploy
serverless deploy -v

# deploy to specific stage
serverless deploy -v --stage dev
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="cloudfrontを添えて"&gt;CloudFrontを添えて&lt;/h3&gt;&lt;p&gt;今回の仕事ではちょっと特殊な事情でCloudFrontを経由してLambdaのエンドポイントURLへリクエストする必要があった。&lt;/p&gt;&lt;p&gt;プラグインを使えばかんたんに記述することもできる。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/Droplr/serverless-api-cloudfront"&gt;Droplr/serverless-api-cloudfront: Serverless Plugin - CloudFront distribution in front of your API Gateway&lt;/a&gt;&lt;/p&gt;&lt;p&gt;が、かんたんに記述できる＝かんたんな内容しかいじれない、のため片手落ちな点が多かった。諸々のパラメータの指定ができなくて細かな指定をする場合は結局&lt;code&gt;resources&lt;/code&gt;セクションに自力でCloudFormationを書くことになった。&lt;/p&gt;&lt;p&gt;以下はresourceセクションのサンプル。&lt;code&gt;DomainName&lt;/code&gt;の解決は以下のStackoverflowからヒントを得た。&lt;/p&gt;&lt;p&gt;&lt;a href="https://stackoverflow.com/questions/50931730/deploying-lambda-api-gateway-cloudfront-through-serverless-framework-at-a-ti"&gt;amazon web services - Deploying Lambda + API-gateway + CloudFront through serverless framework at a time - Stack Overflow&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="yaml"&gt;resources:
  Resources:
    LambdaDistribution:
      Type: AWS::CloudFront::Distribution
      Properties:
        DistributionConfig:
          Enabled: true
          Comment: "managed by serverless framewrok"
          HttpVersion: http2
          PriceClass: PriceClass_All
          Origins:
            - Id: ApiGateway
              DomainName: !Join
                - "."
                - - !Ref ApiGatewayRestApi
                  - execute-api
                  - !Ref AWS::Region
                  - amazonaws.com
              OriginPath: /
              CustomOriginConfig:
                HTTPPort: 80
                HTTPSPort: 443
                OriginProtocolPolicy: https-only
                OriginReadTimeout: 10
                OriginSSLProtocols:
                  - "SSLv3"
                  - "TLSv1"
                  - "TLSv1.1"
                  - "TLSv1.2"
          DefaultCacheBehavior:
            AllowedMethods:
              - HEAD
              - DELETE
              - POST
              - GET
              - OPTIONS
              - PUT
              - PATCH
            Compress: false
            DefaultTTL: 0
            MaxTTL: 0
            MinTTL: 0
            ForwardedValues:
              Cookies:
                Forward: none
              Headers:
                - x-api-key
              QueryString: false
            TargetOriginId: ApiGateway
            ViewerProtocolPolicy: redirect-to-https
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ちなみにLambda@Edgeにはまだ対応していないみたいでプラグインの利用が必須となっている様子。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/serverless/serverless/issues/3944"&gt;Support for Lambda@Edge · Issue #3944 · serverless/serverless&lt;/a&gt;&lt;/p&gt;&lt;h3 id="感想"&gt;感想&lt;/h3&gt;&lt;p&gt;AWSだけにベンダーロックインせずServeless Computingの開発ができるよーな抽象化層を提供するようなCLIのイメージ。&lt;/p&gt;&lt;p&gt;誕生は数年前でまだまだ新し目のため、web上には新旧の情報が玉石混交の状態であるからして、細かなYAMLの記述内容の確認なんかは&lt;a href="https://serverless.com/framework/docs/"&gt;Serverless Framework Documentation&lt;/a&gt;を参考にし、大まかな書き方はそのへんのブログなどから引っこ抜いてくるのが良いと思われる。&lt;/p&gt;&lt;p&gt;まだ1プロダクトでしか使ってないけど、いい感触を得た。YAMLの記述内容は、AWSの場合でいうとresourcesはまんまCloudFormationなので、そのへんの知識があれば使いこなせそう。SaaSのやつはまだ使ってないので感触なし。&lt;/p&gt;&lt;h3 id="おまけ-slsというコマンド名"&gt;おまけ: &lt;code&gt;sls&lt;/code&gt;というコマンド名&lt;/h3&gt;&lt;p&gt;ばかみたいな話なんやけど、Serverless Frameworkの短縮形コマンド&lt;code&gt;sls&lt;/code&gt;はPowerShellで言うところの&lt;code&gt;Select-String&lt;/code&gt;コマンドレットにエイリアスされてるので使えねえｗ&lt;/p&gt;&lt;p&gt;ではアデュー😘&lt;/p&gt;</description><pubDate>Sun, 01 Sep 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-08-11-test-lambda-with-pwsh</guid><link>https://krymtkts.github.io/posts/2019-08-11-test-lambda-with-pwsh</link><title>AWS LambdaをPowershellでテスト実行する</title><description>&lt;p&gt;へーしゃの支援によりGoogle Cloud Next Tokyo 2019へ参加できた。&lt;/p&gt;&lt;p&gt;とても有意義な時間を過ごせたのでブログをしたためたかったのだけど、日が経つにつれ仕事もメモもとっ散らかってしまい清書もできず、現時点でのブログへのまとめは断念中😫&lt;/p&gt;&lt;p&gt;代わりに小ネタを投稿する。&lt;/p&gt;&lt;h3 id="curlの代わりのpowershell"&gt;curlの代わりのPowershell&lt;/h3&gt;&lt;p&gt;最近仕事でAWS Lambdaを使う機会を得た。へーしゃはAWSもGCPもどっちでもアリだが、現状はAWS優勢。わたしはGCPがいいけど。
元々最初にCloud WatchとAWS Lambdaで作った方が良いのでは？という提案をしていたのだが、大した理由もなく却下。その後追加された機能がLambdaじゃないと実行環境を準備するのが難しいというのが判明して、棚からぼた餅なチャンス到来。&lt;/p&gt;&lt;p&gt;本題に入ろう。今回作ったLambdaはAPI Gatewayと組み合わせてWeb APIとして利用する。&lt;/p&gt;&lt;p&gt;そのためAPI Key(&lt;code&gt;x-api-key&lt;/code&gt;)をRequest Headerに付与してリクエストされる想定でいる(現時点で)。&lt;/p&gt;&lt;p&gt;なのでブラウザなんかでテスト実行出来ないので、大抵のやつはcurlなんかでURLを叩く。しかしここはPowershellでやってみよう。&lt;/p&gt;&lt;p&gt;Web-APIを叩くのなら&lt;code&gt;Invoke-WebRequest&lt;/code&gt;がよかろう。追加のヘッダーは&lt;code&gt;-Headers&lt;/code&gt;にhashtableとして渡せるのだ。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Invoke-WebRequest -Uri https://omae-no-api-endpoint/helloworld -Headers @{'x-api-key' = 'omae-no-api-key!!!'}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;こうなる。そんだけ😉&lt;/p&gt;</description><pubDate>Sun, 11 Aug 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-07-28-have-a-good-day-with-poco</guid><link>https://krymtkts.github.io/posts/2019-07-28-have-a-good-day-with-poco</link><title>pocoで捗る日常生活</title><description>&lt;p&gt;&lt;a href="/posts/2019-06-23-poco"&gt;以前ちょっとだけ触れたpoco&lt;/a&gt;を使いだしてから、よく使うディレクトリへの移動とか、&lt;code&gt;PSReadline&lt;/code&gt;のHistoryからよく使うコマンドを引っ張り出すとかの、インタラクティブなコマンドが作りやすくとて捗っている。&lt;/p&gt;&lt;p&gt;&lt;a href="https://gist.github.com/krymtkts/f8af667c32b16fc28a815243b316c5be"&gt;Gistにあげたプロファイル&lt;/a&gt;にまるっと書いているのだけど、ココではコメントも添えて書いておく。&lt;/p&gt;&lt;h3 id="psreadlineのhistoryを見る実行する"&gt;&lt;code&gt;PSReadline&lt;/code&gt;のhistoryを見る/実行する&lt;/h3&gt;&lt;p&gt;作った関数は以下の通り。似たようなモジュールはPSGalleryに何個かあるけど、pocoで書きたかったので自作した次第。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function Show-ReadLineHistory() {
    Get-Content -Path (Get-PSReadlineOption).HistorySavePath | Select-Object -Unique | Select-Poco -CaseSensitive
}
Set-Alias pghy Show-ReadLineHistory -Option AllScope

function Invoke-ReadLineHistory() {
    Show-ReadLineHistory | Select-Object -First 1 | Invoke-Expression
}
Set-Alias pihy Invoke-ReadLineHistory -Option AllScope
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;途中で&lt;code&gt;Select-Object -Unique&lt;/code&gt;を挟んでいるのは、わたしがやたら同じコマンドを繰り返すので重複を省くため😅&lt;/p&gt;&lt;p&gt;&lt;code&gt;Select-Object -First 1&lt;/code&gt;はpoco自体の機能不足(選択機能がない)のを補うためである😭&lt;/p&gt;&lt;p&gt;ちなみにPowerShellのHistoryが謎な件についてはソースはこの辺。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://qiita.com/yuta0801/items/ad0cf608144fb1546e54"&gt;PowerShellの完全な履歴を取得する - Qiita&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/44104043/how-can-i-see-the-command-history-across-all-powershell-sessions-in-windows-serv"&gt;How can I see the command history across all PowerShell sessions in Windows Server 2016? - Stack Overflow&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;code&gt;Get-History&lt;/code&gt;は現在のセッションの情報しか取らない。でも実は&lt;code&gt;(Get-PSREeadlineOption).HistorySavePath&lt;/code&gt;に保存されている、という話🤔&lt;/p&gt;&lt;p&gt;&lt;code&gt;~\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt&lt;/code&gt;な感じでテキストファイルに保存されている。&lt;/p&gt;&lt;p&gt;ちなみに本来の&lt;code&gt;Get-History&lt;/code&gt;実行結果のような履歴ごとにIDを振るのはやってない。&lt;/p&gt;&lt;h3 id="お気に入りのディレクトリへ移動する"&gt;お気に入りのディレクトリへ移動する&lt;/h3&gt;&lt;p&gt;これはパクリ。仕事で使うリポジトリはghqを使わないで決められたディレクトリへcloneすることを期待されてたりするので、そのときにこういう任意のディレクトリへの移動ができるやつが重宝してる。&lt;/p&gt;&lt;p&gt;&lt;a href="https://mattn.kaoriya.net/software/peco.htm"&gt;Big Sky :: Windows のコマンドプロンプトを10倍便利にするコマンド「peco」&lt;/a&gt;&lt;/p&gt;&lt;p&gt;あと編集機能は未実装。わたしの用途では編集よりも削除機能のほうが良いかなと思ったりしてるところ🤔&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function Set-SelectedLocation {
    param(
        [ValidateSet("Add", "Move", "Edit")]$Mode = "Move",
        [string]$Location
    )
    switch ($Mode) {
        "Add" {
            if ($Location) {
                Write-Output "$Location" | Out-File -Append -Encoding UTF8 "~/.poco-cd"
                break
            }
        }
        "Move" {
            Get-Content -Path "~/.poco-cd" | Select-Poco -CaseSensitive | Select-Object -First 1 | Set-Location
            break
        }
        "Edit" {
            break
        }
    }
}
Set-Alias pcd Set-SelectedLocation -Option AllScope
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="雑なまとめ"&gt;雑なまとめ&lt;/h3&gt;&lt;p&gt;これらのツールをpocoの補完ツールとしてもうちと洗練してもいいかもしれんなあと思ったりしてる🤔&lt;/p&gt;</description><pubDate>Sun, 28 Jul 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-07-07-cement-the-cli-framework</guid><link>https://krymtkts.github.io/posts/2019-07-07-cement-the-cli-framework</link><title>CementというCLIフレームワーク</title><description>&lt;p&gt;仕事で、なんかDBに通信しながらAWSのAPIをぶん殴ってゴニョゴニョするバックエンド処理を書く必要があって、Pythonで書くことになった。&lt;/p&gt;&lt;p&gt;&lt;a href="https://python-guideja.readthedocs.io/ja/latest/index.html"&gt;Python ヒッチハイク・ガイド — The Hitchhiker's Guide to Python&lt;/a&gt;を参考にCLIのフレームワークを見ていって、サンプル的に作ってみた感じや継続的にメンテされてることとかで&lt;a href="https://builtoncement.com/"&gt;Cement Framework&lt;/a&gt;を採用することにした。&lt;/p&gt;&lt;p&gt;簡潔に説明すると、CLIアプリケーション作成を容易にするためのフレームワーク。なんとAWS Elastic Beanstalkに使われてるらしい。&lt;/p&gt;&lt;p&gt;数少ない日本語の資料。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://qiita.com/ma2saka/items/9aacc46e20b9886ec156"&gt;自分が必要とする最低限の Cement の情報 - Qiita&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;ほんとに少ないのでなんか自分用にメモを取ろうとこの記事をしたためた次第である。&lt;/p&gt;&lt;p&gt;ボイラープレートでCLIのベースはできてしまうので、あとはその中身を書いていくだけ。ちょっとAPIドキュメントがわかりにくい気もするが、YAMLの設定ファイル読み込みやロギングなども拡張機能としてある。今の所はとてもよくできた使いやすいFWだと思っている。こんどコードの生成らへんの簡単な手順をまとめてみたい。&lt;/p&gt;&lt;p&gt;すでに途中までCementをベースに開発しているのだけど、少し困った点がある。&lt;/p&gt;&lt;h3 id="困った点"&gt;困った点&lt;/h3&gt;&lt;p&gt;&lt;a href="https://github.com/datafolklabs/cement/issues/549"&gt;Cement not compatible with pipenv · Issue #549 · datafolklabs/cement&lt;/a&gt;&lt;/p&gt;&lt;p&gt;バグでpipenvは&lt;code&gt;setup.py&lt;/code&gt;をインストール出来ないのでエラーで死ぬのだ😭わたしが考えた対策としてはイカのトーリである。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;開発環境
&lt;ul&gt;&lt;li&gt;&lt;code&gt;pipenv install -r requirement.txt&lt;/code&gt;などを使いつつ開発&lt;/li&gt;&lt;li&gt;実行時には作業ディレクトリでスクリプト実行する感じ&lt;code&gt;python -m myapp.main&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;製品環境
&lt;ul&gt;&lt;li&gt;&lt;code&gt;pip&lt;/code&gt;を使ったインストール及び&lt;code&gt;setup.py&lt;/code&gt;でモジュールをインストール&lt;/li&gt;&lt;li&gt;モジュール実行を行うのでどこでもok(なはず)&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;まだ開発途上なので、製品環境の想定がそのままうまくいくかはビミョーなところ🤔また試行錯誤しなくては。&lt;/p&gt;&lt;p&gt;最近は[Poetry(https://cocoatomo.github.io/poetry-ja/index.html)のほうがイケてると聞くし、はじめからPipenvを使わないようにしてたら良かった感はしなくはない😭&lt;/p&gt;</description><pubDate>Sun, 07 Jul 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-06-29-season-of-openssh-error</guid><link>https://krymtkts.github.io/posts/2019-06-29-season-of-openssh-error</link><title>またOpenSSHが動かなくなる季節がやってきた</title><description>&lt;p&gt;アップデートの度に何かあるので、もはや風物詩と化したOpenSSHのエラー。&lt;/p&gt;&lt;p&gt;&lt;a href="/posts/2019-03-31-win-openssh-is-gone"&gt;前回のエラー&lt;/a&gt;&lt;/p&gt;&lt;p&gt;きょうChocolateyでパッケージ更新したらWindowsのOpenSSHがアップデートされた様子。&lt;a href="https://github.com/PowerShell/Win32-OpenSSH/releases/tag/v8.0.0.0p1-Beta"&gt;Release v8.0.0.0p1-Beta · PowerShell/Win32-OpenSSH&lt;/a&gt;かな？&lt;/p&gt;&lt;p&gt;それに伴い&lt;code&gt;ssh-agent&lt;/code&gt;サービスが消え去ってしまった。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ Get-Service -Name 'ssh-agent'
Get-Service : Cannot find any service with service name 'ssh-agent'.
At line:1 char:1
+ Get-Service -Name 'ssh-agent'
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ CategoryInfo          : ObjectNotFound: (ssh-agent:String) [Get-Service], ServiceCommandException
+ FullyQualifiedErrorId : NoServiceFoundForGivenName,Microsoft.PowerShell.Commands.GetServiceCommand
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;単純に再インストールしても自動でサービス登録はされなかったのだけど、同梱されているファイルを見てみたところそれらしいスクリプト&lt;code&gt;install-sshd.ps1&lt;/code&gt;を発見した。Wikiにも記載がある。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/PowerShell/Win32-OpenSSH/wiki/Install-Win32-OpenSSH#install-win32-openssh-test-release"&gt;Install Win32 OpenSSH · PowerShell/Win32-OpenSSH Wiki&lt;/a&gt;&lt;/p&gt;&lt;p&gt;実行してみたところ無事にサービスが作成されたので一安心。サービス自動起動の設定をしておいて完了した。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ .\install-sshd.ps1
[SC] SetServiceObjectSecurity SUCCESS
[SC] ChangeServiceConfig2 SUCCESS
[SC] ChangeServiceConfig2 SUCCESS
sshd and ssh-agent services successfully installed
$ Get-Service 'ssh-agent'

Status   Name               DisplayName
------   ----               -----------
Stopped  ssh-agent          OpenSSH Authentication Agent

$ Set-Service -name "ssh-agent" -startuptype "automatic"
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ふう🙃&lt;/p&gt;</description><pubDate>Sat, 29 Jun 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-06-23-poco</guid><link>https://krymtkts.github.io/posts/2019-06-23-poco</link><title>Poco</title><description>&lt;p&gt;5月以降outputのリズムが崩れております🤔&lt;/p&gt;&lt;p&gt;時間の使い方の改善を目論み、ポモドーロを導入するなど。まだ効果の程は見えていないので今日はPowerShell版pecoのpocoを紹介する。&lt;/p&gt;&lt;h3 id="peco"&gt;peco&lt;/h3&gt;&lt;p&gt;まずpecoってなんじゃこらって感じでもあるのだが、linuxなどで使えるインクリメンタルなフィルタリングコマンドらしい。&lt;/p&gt;&lt;p&gt;&lt;a href="http://tm.root-n.com/unix:command:peco"&gt;Unix :: コマンド / peco [Tipsというかメモ]&lt;/a&gt;&lt;/p&gt;&lt;p&gt;こんなに便利な機能なので、もちろんWindowsでも使えるようになってある &lt;a href="https://github.com/peco/peco"&gt;peco/peco: Simplistic interactive filtering tool&lt;/a&gt;&lt;/p&gt;&lt;p&gt;ただ日常使いのシェルをPowerShellにしている身としては、単純なテキストの絞り込みじゃなくてオブジェクトを扱えるやつが望ましいわけで...&lt;/p&gt;&lt;h3 id="poco"&gt;poco&lt;/h3&gt;&lt;p&gt;というふうに思ってたら普通にPowerShell Galleryにあったわ😲&lt;/p&gt;&lt;p&gt;PowerShellの場合は&lt;a href="https://gist.github.com/yumura/8df37c22ae1b7942dec7"&gt;powershell peco&lt;/a&gt;というのがあって、それを使ったPSModuleがPSGalleryに上がっている...!!!これは使わない手はないぞよ🤔&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://www.powershellgallery.com/packages/poco/1.1.0"&gt;PowerShell Gallery | poco 1.1.0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/jasonmarcher/poco"&gt;jasonmarcher/poco: Interactive pipeline filtering in PowerShell (a port of peco).&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;ただしこのモジュール、&lt;a href="https://gist.github.com/yumura/8df37c22ae1b7942dec7"&gt;powershell peco&lt;/a&gt;のコードをそのまま使ってるのが現状みたいで、作者の方が書かれている改善点そのまま残ってるくさい😭&lt;/p&gt;&lt;p&gt;&lt;a href="https://qiita.com/yumura_s/items/a068329769c6338471dd"&gt;PowerShell で peco (インタラクティブ・フィルタリングツール)っぽいものを作った - Qiita&lt;/a&gt;&lt;/p&gt;&lt;p&gt;という具合に不完全なできであるのは確かなんやが、雰囲気でCLIにPowerShellを使っているようなワイには非常に便利なツールなのである。&lt;/p&gt;&lt;h3 id="pocoを使ってなにか書こう"&gt;pocoを使ってなにか書こう&lt;/h3&gt;&lt;p&gt;例えば、PowerShellではCLIの完全な入力履歴を取ろうとしたら&lt;code&gt;PSReadLine&lt;/code&gt;に頼ることになるのだが、こいつをインタラクティブにフィルタリングするコマンドをぺぺっと書いてしまうこともできる↓&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function Show-ReadLineHistory() {
    Get-Content -Path (Get-PSReadlineOption).HistorySavePath | poco
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;こんな風な単純なやつは正直なところpecoで十分なのだけど...&lt;/p&gt;&lt;p&gt;あと、検索結果の1行を選んで即実行なんしたいのだけど、pocoの機能不足でリストアップされた検索結果をarrow keyで選んだりとかできないので、今のところかなり癖のある使い方になってる😅&lt;/p&gt;&lt;p&gt;そんな感じPowerShellにも育てたい？ツールがあって使っていくモチベーションみたいなもんが湧いてきますな？🤔現状至らないところ多いからなんかコントリビュートしたい。
でもまず時間を作らなあかんな🤔&lt;/p&gt;</description><pubDate>Sun, 23 Jun 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-06-02_install-shfmt-to-win-using-cli</guid><link>https://krymtkts.github.io/posts/2019-06-02_install-shfmt-to-win-using-cli</link><title>シェルスクリプトのフォーマッタをCLIでインストールする</title><description>&lt;p&gt;小ネタ。&lt;/p&gt;&lt;p&gt;へーしゃの仕事では、Bashで書かれたスクリプトの出番がめちゃくちゃ多い。&lt;/p&gt;&lt;p&gt;Bashが得意じゃないマンのわたしにとっては、そういったスクリプトを読み書きに慣れてないこともあり、結構疲れる仕事である。&lt;/p&gt;&lt;p&gt;そこでせめて書くのだけは少しでも楽したいと思って、フォーマッタを導入しようと思った。&lt;/p&gt;&lt;h3 id="ツールを導入する"&gt;ツールを導入する&lt;/h3&gt;&lt;p&gt;shfmtというgolang製のツールがあるので、それを採択。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/mvdan/sh"&gt;mvdan/sh: A shell parser, formatter, and interpreter (POSIX/Bash/mksh)&lt;/a&gt;&lt;/p&gt;&lt;p&gt;しかし悲しいかな、Windows用に提供されてるパッケージはScoopのみ(リンク切れてるけど)でChocolateyにない様子🤔(筆者はChocolateyユーザである)。&lt;/p&gt;&lt;p&gt;代わりにCLIでのインストールを使うことにする。&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;cd $(mktemp -d); go mod init tmp; go get mvdan.cc/sh/v3/cmd/shfmt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;でも&lt;code&gt;mktemp&lt;/code&gt;コマンドはPowerShellにはないし...そこは&lt;code&gt;mkdir&lt;/code&gt;で茶を濁す。あとtmpフォルダの後始末もする。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;cd $(mkdir tmp); go mod init tmp; go get mvdan.cc/sh/v3/cmd/shfmt; cd ../; rm -r tmp
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ええがな。&lt;/p&gt;&lt;h3 id="雑記"&gt;雑記&lt;/h3&gt;&lt;p&gt;5月後半はうまく波に乗れずブログを書けなかった。まだアウトプットが習慣化していないようなので、きちんと積み重ねしていきたいもんやで🤔&lt;/p&gt;</description><pubDate>Sun, 02 Jun 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-05-11-pipenv-skeleton</guid><link>https://krymtkts.github.io/posts/2019-05-11-pipenv-skeleton</link><title>Pipenvのテンプレを作った</title><description>&lt;p&gt;&lt;a href="/posts/2019-04-29-bias-amp-2issue"&gt;前回&lt;/a&gt;の最後に触れた、仕事で経験を得た2019年のイケてそうなPython開発環境構築について。&lt;/p&gt;&lt;p&gt;この度新し目と思われるPythonのプロジェクト構築について学んだので、次回Pythonを触ることがあったとしてもぱぱっと始められるようにテンプレートを作ろうと思った次第である。&lt;/p&gt;&lt;p&gt;過去のeasy_installとかpipまでで知識が止まってたが、新たにpipenvを知ってかなり便利に使えるいい感じの印象を得たのもあって、動機付けされた感じ。&lt;/p&gt;&lt;p&gt;なので、勉強がてらGW中のお楽しみにちょろっと作った。&lt;/p&gt;&lt;h3 id="作ったもの"&gt;作ったもの&lt;/h3&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/pipenv-skeleton"&gt;krymtkts/pipenv-skeleton&lt;/a&gt;&lt;/p&gt;&lt;p&gt;いろいろとググって、pipとかvirtualenvの時代は過ぎ去っており、いまはpienvがイケていると直感を得た。
なのでpipenvについて以下の記事などを参考にこのテンプレを作った。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://pipenv-ja.readthedocs.io/ja/translate-ja/"&gt;Pipenv: 人間のためのPython開発ワークフロー — pipenv 2018.11.27.dev0 ドキュメント&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://www.natsukium.com/blog/2019-02-18/python/"&gt;Python環境構築ベストプラクティス2019 - ばいおいんふぉっぽいの！&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://qiita.com/youkidkk/items/b6a6e39ee3a109001c75"&gt;Windows + Python 3.6 + PipEnv + Visual Studio Code でPython開発環境 - Qiita&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://qiita.com/tonluqclml/items/b09f4a5ed04ebcbd0af1"&gt;既存プロジェクトに pipenv を導入した方法 - Qiita&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;予めLinterやらFormatterやらをdevPackageとして用意している。LinterにはPylintを用意したが、エラーの自動修正がないようなのでautopep8も用意した。&lt;/p&gt;&lt;p&gt;あと静的型付けに守られた世界で仕事できるように、MyPyも用意している。Better Bashとして使うときは大げさかもしれないけど、その時は単にMyPyを使わなかったらいいだけ。&lt;/p&gt;&lt;p&gt;このプロジェクトをコピペして、moduleのところをこねこねして使うイメージ。&lt;/p&gt;&lt;p&gt;Pythonのモジュールシステムについてはまだ理解が浅い。以下を参考にドキュメントをあたって、&lt;code&gt;__init.py__&lt;/code&gt;,&lt;code&gt;__main.py__&lt;/code&gt;のらへんを定型化した感じ。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/448271/what-is-init-py-for"&gt;python - What is &lt;strong&gt;init&lt;/strong&gt;.py for? - Stack Overflow&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/4042905/what-is-main-py"&gt;python - What is &lt;strong&gt;main&lt;/strong&gt;.py? - Stack Overflow&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;ただ、&lt;code&gt;__init.py__&lt;/code&gt;は名前空間パッケージではなくていいようだし、よりモダンな方法に寄せたいので再検討するかな。単に今はわたしの知識がそこまで及んでない😭Pythonの言語仕様もちゃんと勉強したいのう。&lt;/p&gt;&lt;p&gt;いろいろ足りない点があるが、それらは今後改善できれば良いかな。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;moduleの名前をいろいろ変えないといけないのが面倒なので、なんか改善ができれば良。&lt;/li&gt;&lt;li&gt;テストがないので足したい。&lt;/li&gt;&lt;li&gt;なんかバッジ足したい。ビルドとか...&lt;/li&gt;&lt;li&gt;mypyで&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="まとめ"&gt;まとめ&lt;/h3&gt;&lt;p&gt;Python3たのしい。&lt;/p&gt;&lt;p&gt;せっかくテンプレを作ったので、なんかゴミスクリプトでも良いのでちまちま書いていきたい所存🤔&lt;/p&gt;&lt;p&gt;mypyについてもメモためていこ。&lt;/p&gt;</description><pubDate>Sat, 11 May 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-04-29-bias-amp-2issue</guid><link>https://krymtkts.github.io/posts/2019-04-29-bias-amp-2issue</link><title>BIAS Amp 2で保存したアンプが消える問題</title><description>&lt;p&gt;小ネタ。&lt;/p&gt;&lt;p&gt;個人的に、2019年からPositive Grid社のBIAS Amp miniを導入した。&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.positivegrid.com/bias-mini-guitar/"&gt;BIAS MINI Guitar - Positive Grid&lt;/a&gt;&lt;/p&gt;&lt;p&gt;平たく言うと、ギターアンプの部品をいじくり回すことでサウンドメイクする、というアイデアのデジタルアンプ。そのサウンドメイクの幅の広さ、自分好みのサウンドを手探りする面白さから、とても気に入っている。&lt;/p&gt;&lt;p&gt;ただちょっと、バグが多いように思う。現時点で2つのバグらしい挙動を見つけている。&lt;/p&gt;&lt;h3 id="1line-outが出力されない問題"&gt;1.Line OUTが出力されない問題&lt;/h3&gt;&lt;p&gt;見出しの通りである。出る場合と出ない場合があるのか、パターンを絞り出せていない。&lt;/p&gt;&lt;p&gt;Line OUTはスタジオで試したときに気づいたので、まだすべての状況において出力がないのかは調べ尽くしていない。&lt;/p&gt;&lt;h3 id="2保存したアンプが消える問題"&gt;2.保存したアンプが消える問題&lt;/h3&gt;&lt;p&gt;購入したBIAS Amp miniには、同社のモデリングソフトウェアBIAS Amp 2が付属し、それで作ったアンプモデルをBIAS Amp miniに書き込むことができる。&lt;/p&gt;&lt;p&gt;今確認している範囲では、以下のパターンで書き込んだアンプが、消失する時がある。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;BIAS Amp 2でキャプチャしたアンプ(AMP MATCH)をTone Cloudで入手する&lt;/li&gt;&lt;li&gt;入手したアンプのパラメータを変える&lt;/li&gt;&lt;li&gt;BIAS Amp miniをdesconnect後にスキンを変更する&lt;/li&gt;&lt;li&gt;再度BIAS Amp miniを接続し、変更したアンプを書き込む&lt;/li&gt;&lt;li&gt;電源OFFから数時間後に消失&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;ただ、このパターンで2回消えたのだが、3回目の再現ができていないので別の変数が関与してそう🤔ややこしい。&lt;/p&gt;&lt;h3 id="まとめ"&gt;まとめ&lt;/h3&gt;&lt;p&gt;いずれも割とまじで困る系の障害なので、ちゃんと条件を調べた上でサポートに問い合わせしたいところだけど、まだ全然出来てない状態...&lt;/p&gt;&lt;p&gt;2の保存したアンプが消える問題は一応着手中。ライブ本番とかにモデルが消えてたらほんま笑い事じゃないからな...&lt;/p&gt;&lt;p&gt;しょうもないネタを書き記すことが増えてきたので、次回は仕事で経験を得た、2019年のイケてそうなPython開発環境構築について書きたい所存🤔&lt;/p&gt;</description><pubDate>Mon, 29 Apr 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-04-20_disable-touch-screen</guid><link>https://krymtkts.github.io/posts/2019-04-20_disable-touch-screen</link><title>Windows10でタッチスクリーンを無効化する</title><description>&lt;p&gt;小ネタ。&lt;/p&gt;&lt;p&gt;自機は、Razer Blade Stealth 2018のタッチスクリーン対応のやつだ。&lt;/p&gt;&lt;p&gt;ディスプレイを閉じた状態から再度開いたときに、たま～に謎に画面が連続タップされまくって制御不能になるポルターガイスト現象(偽)が起こることがあった。&lt;/p&gt;&lt;p&gt;それ以来タッチスクリーンの無効化をしているんやが、これがWindowsの大規模アップデートがあると設定が無効になって、都度再設定が必要になってる感じ🤔&lt;/p&gt;&lt;p&gt;最近ver1803が降りてきたことで再度必要になったので覚書。&lt;/p&gt;&lt;h3 id="手順"&gt;手順&lt;/h3&gt;&lt;p&gt;&lt;a href="https://support.microsoft.com/ja-jp/help/4028019/windows-enable-and-disable-your-touchscreen-in-windows-10"&gt;Windows 10 でタッチスクリーンを有効/無効にする&lt;/a&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;デバイスマネージャを開く&lt;/li&gt;&lt;li&gt;HID準拠タッチスクリーンのデバイスを無効化する&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;THE END&lt;/p&gt;</description><pubDate>Sat, 20 Apr 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-04-14-add-a-badge</guid><link>https://krymtkts.github.io/posts/2019-04-14-add-a-badge</link><title>プロジェクトにバッジを貼ろう</title><description>&lt;p&gt;&lt;a href="https://www.powershellgallery.com/packages/MavenAutoCompletion/0.1"&gt;先日PowerShell Galleryにモジュールを公開した&lt;/a&gt;ついでに、プロジェクトのGitHubにバッジを貼ってみた。&lt;/p&gt;&lt;p&gt;のでその覚書。&lt;/p&gt;&lt;h3 id="バッジを貼ろう"&gt;バッジを貼ろう&lt;/h3&gt;&lt;p&gt;なんかいろいろサービスがあるようだけど、わたしは&lt;a href="https://shields.io/"&gt;Shields.io: Quality metadata badges for open source projects&lt;/a&gt;にしてみた。&lt;/p&gt;&lt;p&gt;いろんなバッジが提供されてるみたいやし、利用するためのハードルが低い(とにかく楽な)のが良い。&lt;/p&gt;&lt;p&gt;PowerShell GalleryのDownload数を表示するバッチがあったので、それを利用してみた。&lt;/p&gt;&lt;p&gt;&lt;a href="https://shields.io/category/downloads"&gt;Shields.io: Quality metadata badges for open source projects&lt;/a&gt;&lt;/p&gt;&lt;p&gt;利用は簡単でURLを貼るだけ。なんかよそのOSSとか見ててたらもっと簡単な方法がありそうだが、普通のMarkdownで書いた。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/MavenAutoCompletion/blob/master/README.md"&gt;MavenAutoCompletion/README.md at master · krymtkts/MavenAutoCompletion&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="md"&gt;[![PowerShell Gallery](https://img.shields.io/powershellgallery/dt/MavenAutoCompletion.svg?style=flat-square)](https://www.powershellgallery.com/packages/MavenAutoCompletion)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;コレがこうなる↓&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2019-04-14-badge/badge.png" alt="バッジ" /&gt;&lt;/p&gt;&lt;p&gt;いいね～😚&lt;/p&gt;&lt;p&gt;つかDLすっくねえ！！！&lt;/p&gt;&lt;p&gt;まあ自分のDLは、家、家リトライ、職場の3回だけで、残りの7回は世界のどこかで使われてるということがわかった。
ので良しとしよう🤔&lt;/p&gt;&lt;p&gt;こうなるともっとバッジをペタペタ貼りたくなりますな～。&lt;/p&gt;</description><pubDate>Sun, 14 Apr 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-04-07-lint-my-statement</guid><link>https://krymtkts.github.io/posts/2019-04-07-lint-my-statement</link><title>下手な文章を Lint する</title><description>&lt;p&gt;転職してから 2 ヶ月の間、海外労働者の同僚から、日本語のドキュメントも英語のドキュメントもレビューコメントをいただいていてつらい。&lt;/p&gt;&lt;p&gt;英語だけならまだしろ、わしゃ日本語もろくに扱えん日本人なんかと思うと涙ちょちょぎれる次第であります。&lt;/p&gt;&lt;p&gt;なので自分の文章に Lint をかけようと思った。&lt;/p&gt;&lt;h3 id="textlint"&gt;textlint&lt;/h3&gt;&lt;p&gt;いつだったか文章の Linter についてググってたら、以下のようなものを見つけた。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/textlint/textlint"&gt;GitHub - textlint/textlint&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://qiita.com/azu/items/2c565a38df5ed4c9f4e1"&gt;Qiita - VS Code で textlint を使って文章をチェックする&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/textlint-ja/textlint-rule-preset-ja-technical-writing"&gt;textlint-ja/textlint-rule-preset-ja-technical-writing: 技術文書向けの textlint ルールプリセット&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;...すげえな！近い内に使えるようにしよう。と思ってから数ヶ月後、実務でまともな文章を書く能力が必要になるとわ...😭
というか vscode-textlint ってホイル焼きで有名な方の作品なのですね。敬意を払うべきプロダクトだ。&lt;/p&gt;&lt;p&gt;以下にわたしのセットアップ手順を記す(実行は PowerShell だよ)。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;VSCode で vscode-textlin を入れる&lt;/li&gt;&lt;li&gt;&lt;code&gt;npm i -g textlint textlint-rule-preset-ja-technical-writing&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;cd ~&lt;/code&gt;で&lt;code&gt;textlint --init&lt;/code&gt;してルールを書き込み&lt;/li&gt;&lt;li&gt;VSCode では設定ファイルを絶対パスで利用するからどうしたものか...(複数端末で Sync してる関係で)
&lt;ol&gt;&lt;li&gt;&lt;code&gt;~/,textlint&lt;/code&gt;にしたらユーザ名とか考えなくていいから、なんかいい 😁&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;ついかパッケージ &lt;code&gt;npm i -g textlint-rule-date-weekday-mismatch textlint-rule-terminology textlint-rule-ginger&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;これで簡単な typo は減らせるんじゃないかな。&lt;/p&gt;&lt;p&gt;お気に入りのルールは&lt;code&gt;textlint-rule-date-weekday-mismatch&lt;/code&gt;。これからのオレが曜日を間違うことはないぜええええ？(フラグ&lt;/p&gt;</description><pubDate>Sun, 07 Apr 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-04-02-pubslish-first-module-to-powershell-gallery</guid><link>https://krymtkts.github.io/posts/2019-04-02-pubslish-first-module-to-powershell-gallery</link><title>はじめてのPowerShell Galleryへの公開</title><description>&lt;p&gt;先日、自前のモジュールをPowerShell Galleryに公開したので、その時のメモを記す。&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.powershellgallery.com/packages/MavenAutoCompletion/0.1"&gt;PowerShell Gallery | MavenAutoCompletion 0.1&lt;/a&gt;&lt;/p&gt;&lt;p&gt;PowerShell Galleryのアカウントを作るだとか、モジュールのAnalysisだとかはまた別で書こう。ここではモジュールの公開の部分だけ。&lt;/p&gt;&lt;h3 id="tldr"&gt;TL;DR&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Poblish-Module&lt;/code&gt;は除外ファイル設定とかないから公開時には注意しましょう😭&lt;/p&gt;&lt;h3 id="モジュールの公開"&gt;モジュールの公開&lt;/h3&gt;&lt;p&gt;以下の手順に従う。&lt;/p&gt;&lt;p&gt;&lt;a href="https://docs.microsoft.com/ja-jp/powershell/gallery/how-to/publishing-packages/publishing-a-package"&gt;アイテムの作成と公開 | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;事前にチェックしろよな！！！と書いてるのでそれに従い以下のコマンドを実行する&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Publish-Module -Path ".\MavenAutoCompletion" -NugetAPIKey "キーは見せられないよ" -WhatIf -Verbose
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;途中で最新のNuGet入れるかい？と聞かれるのでそれはYesで。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ Publish-Module -Path ".\MavenAutoCompletion" -NugetAPIKey "キーは見せられないよ" -WhatIf -Verbose
VERBOSE: Acquiring providers for assembly: C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\PackageManagement\1.3.1\coreclr\netstandard2.0\Microsoft.PackageManagement.NuGetProvider.dll
VERBOSE: Acquiring providers for assembly: C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\PackageManagement\1.3.1\coreclr\netstandard2.0\Microsoft.PackageManagement.MetaProvider.PowerShell.dll
VERBOSE: Acquiring providers for assembly: C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\PackageManagement\1.3.1\coreclr\netstandard2.0\Microsoft.PackageManagement.ArchiverProviders.dll
VERBOSE: Acquiring providers for assembly: C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\PackageManagement\1.3.1\coreclr\netstandard2.0\Microsoft.PackageManagement.CoreProviders.dll

NuGet.exe is required to continue
This version of PowerShellGet requires minimum version '4.1.0' of NuGet.exe to publish an item to the
NuGet-based repositories. NuGet.exe must be available in
'C:\ProgramData\Microsoft\Windows\PowerShell\PowerShellGet\' or
'C:\Users\takatoshi\AppData\Local\Microsoft\Windows\PowerShell\PowerShellGet\', or under one of the
paths specified in PATH environment variable value. NuGet.exe can be downloaded from
https://aka.ms/psget-nugetexe. For more information, see https://aka.ms/installing-powershellget . Do
you want PowerShellGet to install the latest version of NuGet.exe now?
[Y] Yes  [N] No  [S] Suspend  [?] Help (default is "Y"): y
VERBOSE: Installing NuGet.exe.
VERBOSE: GET https://aka.ms/psget-nugetexe with 0-byte payload
VERBOSE: received 5690456-byte response of content type application/x-msdownload
VERBOSE: Repository details, Name = 'PSGallery', Location = 'https://www.powershellgallery.com/api/v2/'; IsTrusted = 'True'; IsRegistered = 'True'.
VERBOSE: Repository details, Name = 'PSGallery', Location = 'https://www.powershellgallery.com/api/v2/'; IsTrusted = 'True'; IsRegistered = 'True'.
VERBOSE: Publish Location:'https://www.powershellgallery.com/api/v2/package/'.
VERBOSE: Module 'MavenAutoCompletion' was found in 'C:\Users\takatoshi\dev\powershell\MavenAutoCompletion'.
VERBOSE: Repository details, Name = 'PSGallery', Location = 'https://www.powershellgallery.com/api/v2/'; IsTrusted = 'True'; IsRegistered = 'True'.
VERBOSE: Using the provider 'PowerShellGet' for searching packages.
VERBOSE: Using the specified source names : 'PSGallery'.
VERBOSE: Getting the provider object for the PackageManagement Provider 'NuGet'.
VERBOSE: The specified Location is 'https://www.powershellgallery.com/api/v2/items/psscript/' and PackageManagementProvider is 'NuGet'.
VERBOSE: Searching repository 'https://www.powershellgallery.com/api/v2/items/psscript/FindPackagesById()?id='MavenAutoCompletion'' for ''.
VERBOSE: Total package yield:'0' for the specified package 'MavenAutoCompletion'.
VERBOSE: Repository details, Name = 'PSGallery', Location = 'https://www.powershellgallery.com/api/v2/'; IsTrusted = 'True'; IsRegistered = 'True'.
VERBOSE: Using the provider 'PowerShellGet' for searching packages.
VERBOSE: Using the specified source names : 'PSGallery'.
VERBOSE: Getting the provider object for the PackageManagement Provider 'NuGet'.
VERBOSE: The specified Location is 'https://www.powershellgallery.com/api/v2/' and PackageManagementProvider is 'NuGet'.
VERBOSE: Searching repository 'https://www.powershellgallery.com/api/v2/FindPackagesById()?id='MavenAutoCompletion'' for ''.
VERBOSE: Total package yield:'0' for the specified package 'MavenAutoCompletion'.
What if: Performing the operation "Publish-Module" on target "Version '0.0.1' of module 'MavenAutoCompletion'".
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;それらしいエラーも警告も出ないので、実行に移す。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ Publish-Module -Path ".\MavenAutoCompletion" -NugetAPIKey "キーは見せられないよ" -Verbose
VERBOSE: Repository details, Name = 'PSGallery', Location = 'https://www.powershellgallery.com/api/v2/'; IsTrusted = 'True'; IsRegistered = 'True'.
VERBOSE: Repository details, Name = 'PSGallery', Location = 'https://www.powershellgallery.com/api/v2/'; IsTrusted = 'True'; IsRegistered = 'True'.
VERBOSE: Publish Location:'https://www.powershellgallery.com/api/v2/package/'.
VERBOSE: Module 'MavenAutoCompletion' was found in 'C:\Users\takatoshi\dev\powershell\MavenAutoCompletion'.
VERBOSE: Repository details, Name = 'PSGallery', Location = 'https://www.powershellgallery.com/api/v2/'; IsTrusted = 'True'; IsRegistered = 'True'.
VERBOSE: Using the provider 'PowerShellGet' for searching packages.
VERBOSE: Using the specified source names : 'PSGallery'.
VERBOSE: Getting the provider object for the PackageManagement Provider 'NuGet'.
VERBOSE: The specified Location is 'https://www.powershellgallery.com/api/v2/items/psscript/' and PackageManagementProvider is 'NuGet'.
VERBOSE: Searching repository 'https://www.powershellgallery.com/api/v2/items/psscript/FindPackagesById()?id='MavenAutoCompletion'' for ''.
VERBOSE: Total package yield:'0' for the specified package 'MavenAutoCompletion'.
VERBOSE: Repository details, Name = 'PSGallery', Location = 'https://www.powershellgallery.com/api/v2/'; IsTrusted = 'True'; IsRegistered = 'True'.
VERBOSE: Using the provider 'PowerShellGet' for searching packages.
VERBOSE: Using the specified source names : 'PSGallery'.
VERBOSE: Getting the provider object for the PackageManagement Provider 'NuGet'.
VERBOSE: The specified Location is 'https://www.powershellgallery.com/api/v2/' and PackageManagementProvider is 'NuGet'.
VERBOSE: Searching repository 'https://www.powershellgallery.com/api/v2/FindPackagesById()?id='MavenAutoCompletion'' for ''.
VERBOSE: Total package yield:'0' for the specified package 'MavenAutoCompletion'.
VERBOSE: Performing the operation "Publish-Module" on target "Version '0.0.1' of module 'MavenAutoCompletion'".
VERBOSE: Pushing MavenAutoCompletion.0.0.1.nupkg to 'https://www.powershellgallery.com/api/v2/package/'...
  PUT https://www.powershellgallery.com/api/v2/package/
�x��: &amp;lt;licenseUrl&amp;gt; element will be deprecated, please consider switching to specifying the license in
the package. Learn more: https://aka.ms/deprecateLicenseUrl.
  Created https://www.powershellgallery.com/api/v2/package/ 3489ms
Your package was pushed.

VERBOSE: Successfully published module 'MavenAutoCompletion' to the module publish location 'https://www.powershellgallery.com/api/v2/package/'. Please allow few minutes for 'MavenAutoCompletion' to show up in the search results.
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;�x��: &lt;licenseUrl&gt; element will be deprecated, please consider switching to specifying the license in
the package. Learn more: https://aka.ms/deprecateLicenseUrl.&lt;/licenseUrl&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;う、モジュールのマニフェストでdeprecatedな属性があるが...いけたっぽい。この文字化けはemojiかな(Win10 1809ではterminalでemoji化けがあるのは既知)&lt;/p&gt;&lt;h3 id="いけてない"&gt;いけて...ない！&lt;/h3&gt;&lt;p&gt;困ったことにイケてなかった...gitのオブジェクトとかそういうのまで全部publishedなかんじでまじで笑えねえ...とりあえずPowerShell Gallery上でリスト表示しないリクエストを出しておいたが笑えねえ😭&lt;/p&gt;&lt;p&gt;どうもこれはPowerShell Getの既知の問題？みたい...事前調査が足りてなかったぜえ...😭&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/PowerShell/PowerShellGet/issues/191"&gt;Ignore files when using &lt;code&gt;Publish-Module&lt;/code&gt; · Issue #191 · PowerShell/PowerShellGet&lt;/a&gt;&lt;/p&gt;&lt;p&gt;現状できることとしては、別にモジュールと同名のフォルダを作って、その中にpublishしたいファイルをコピーし、&lt;code&gt;Publish-Module&lt;/code&gt;を実行するしかないのではないかなと思う🤔&lt;/p&gt;&lt;p&gt;この際なので↑の取りなしでvr0.1として公開することにする。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ Publish-Module -Path ".\MavenAutoCompletion" -NugetAPIKey "キーは見せられないよ" -Verbose
VERBOSE: Repository details, Name = 'PSGallery', Location = 'https://www.powershellgallery.com/api/v2/'; IsTrusted = 'True'; IsRegistered = 'True'.
VERBOSE: Repository details, Name = 'PSGallery', Location = 'https://www.powershellgallery.com/api/v2/'; IsTrusted = 'True'; IsRegistered = 'True'.
VERBOSE: Publish Location:'https://www.powershellgallery.com/api/v2/package/'.
VERBOSE: Module 'MavenAutoCompletion' was found in 'C:\Users\takatoshi\dev\powershell\MavenAutoCompletion\publish\MavenAutoCompletion'.
VERBOSE: Repository details, Name = 'PSGallery', Location = 'https://www.powershellgallery.com/api/v2/'; IsTrusted = 'True'; IsRegistered = 'True'.
VERBOSE: Using the provider 'PowerShellGet' for searching packages.
VERBOSE: Using the specified source names : 'PSGallery'.
VERBOSE: Getting the provider object for the PackageManagement Provider 'NuGet'.
VERBOSE: The specified Location is 'https://www.powershellgallery.com/api/v2/items/psscript/' and PackageManagementProvider is 'NuGet'.
VERBOSE: Searching repository 'https://www.powershellgallery.com/api/v2/items/psscript/FindPackagesById()?id='MavenAutoCompletion'' for ''.
VERBOSE: Total package yield:'0' for the specified package 'MavenAutoCompletion'.
VERBOSE: Repository details, Name = 'PSGallery', Location = 'https://www.powershellgallery.com/api/v2/'; IsTrusted = 'True'; IsRegistered = 'True'.
VERBOSE: Using the provider 'PowerShellGet' for searching packages.
VERBOSE: Using the specified source names : 'PSGallery'.
VERBOSE: Getting the provider object for the PackageManagement Provider 'NuGet'.
VERBOSE: The specified Location is 'https://www.powershellgallery.com/api/v2/' and PackageManagementProvider is 'NuGet'.
VERBOSE: Searching repository 'https://www.powershellgallery.com/api/v2/FindPackagesById()?id='MavenAutoCompletion'' for ''.
VERBOSE: Total package yield:'1' for the specified package 'MavenAutoCompletion'.
VERBOSE: Performing the operation "Publish-Module" on target "Version '0.1' of module 'MavenAutoCompletion'".
VERBOSE: Pushing MavenAutoCompletion.0.1.0.nupkg to 'https://www.powershellgallery.com/api/v2/package/'...
  PUT https://www.powershellgallery.com/api/v2/package/
�x��: &amp;lt;licenseUrl&amp;gt; element will be deprecated, please consider switching to specifying the license in
the package. Learn more: https://aka.ms/deprecateLicenseUrl.
  Created https://www.powershellgallery.com/api/v2/package/ 4558ms
Your package was pushed.

VERBOSE: Successfully published module 'MavenAutoCompletion' to the module publish location 'https://www.powershellgallery.com/api/v2/package/'. Please allow few minutes for 'MavenAutoCompletion' to show up in the search results.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これによって一応無事にPowerShell Getでの公開はできたし、一旦コレでええか😅&lt;/p&gt;&lt;p&gt;今度非推奨になってる&lt;code&gt;&amp;lt;licenseUrl&amp;gt;&lt;/code&gt;を変えなあかんな。&lt;/p&gt;&lt;p&gt;ファイルコピって公開するためのスクリプトを起こしたので、次回はそれでやろうと思う。&lt;/p&gt;</description><pubDate>Tue, 02 Apr 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-03-31-win-openssh-is-gone</guid><link>https://krymtkts.github.io/posts/2019-03-31-win-openssh-is-gone</link><title>Windows10の更新でOpenSSHが逝った</title><description>&lt;p&gt;今更ながら、Raser Blade Stealth 2018にもWindows10 ver1809の更新が来てたようだった。&lt;/p&gt;&lt;p&gt;何の気なしに更新してみたところ、更新自体はすぐに終わってあっさりいったなと思っていたのだが、terminalを立ち上げると...&lt;/p&gt;&lt;h3 id="tldr"&gt;TL;DR&lt;/h3&gt;&lt;p&gt;Windows10 ver1809のOpenSSHは既知のバグがあるのでOpenSSH Portableを入れ直そう。&lt;/p&gt;&lt;h3 id="まずssh-agentのサービスが無効になってた"&gt;まずSSH Agentのサービスが無効になってた&lt;/h3&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Get-Process : Cannot find a process with the name "ssh-agent". Verify the process name and call the cmdlet again.
At C:\Users\takatoshi\OneDrive\Documents\PowerShell\Microsoft.PowerShell_profile.ps1:40 char:8
+ if (! (Get-Process -Name 'ssh-agent')) {
+        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ CategoryInfo          : ObjectNotFound: (ssh-agent:String) [Get-Process], ProcessCommandException
+ FullyQualifiedErrorId : NoProcessFoundForGivenName,Microsoft.PowerShell.Commands.GetProcessCommand
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;PowerShellのprofileで&lt;code&gt;ssh-agent&lt;/code&gt;のプロセスの存在を確認するようにしてたのだけど、Windowsの更新でサービスの自動実行が無効になってたようなのでこのエラーが...とりあえず今回は手動で自動実行するように変えて終わった。&lt;/p&gt;&lt;p&gt;あとどういうわけかわからないが、PC起動時のサービスの立ち上がりがめちゃくちゃ遅くなった気がする(体感)。PC起動後にすぐterminalを立ち上げると同じエラーがまだ出るから。根治させるにはprofileをいじらないといけないかな🤔&lt;/p&gt;&lt;p&gt;後述の問題に比べれば、こちらは楽しいアクシデント程度のものだ。&lt;/p&gt;&lt;h3 id="win10備え付けのopensshに既知のバグが有るとか云々"&gt;Win10備え付けのOpenSSHに既知のバグが有るとか云々&lt;/h3&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ git remote show origin
warning: agent returned different signature type ssh-rsa (expected rsa-sha2-512)
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;↑この警告が常時出るようになった。むかつく💢&lt;/p&gt;&lt;p&gt;直さな...😭と思ってググってみると...&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/PowerShell/Win32-OpenSSH/issues/1263"&gt;ssh-agent: agent returned different signature type · Issue #1263 · PowerShell/Win32-OpenSSH&lt;/a&gt;&lt;/p&gt;&lt;p&gt;これの様子🤔&lt;/p&gt;&lt;p&gt;更に調べると、これマジIssueやなと思わざるを得ない... -&amp;gt; &lt;a href="https://github.com/PowerShell/openssh-portable/pull/366"&gt;Fixes to ssh-agent issues by manojampalam · Pull Request #366 · PowerShell/openssh-portable&lt;/a&gt;&lt;/p&gt;&lt;p&gt;つまりはバグが直ったOpenSSH-Portbale入れないと解決しないってんでFAかな...キレそう❤&lt;/p&gt;&lt;p&gt;&lt;a href="https://blog.frankfu.com.au/2019/03/21/moving-from-windows-1809s-openssh-to-openssh-portable/"&gt;Moving from Windows 1809's OpenSSH to OpenSSH Portable&lt;/a&gt;&lt;/p&gt;&lt;p&gt;幸いにも同じ障害を解消したブログがあったので助かる🙏&lt;/p&gt;&lt;h4 id="処置する"&gt;処置する&lt;/h4&gt;&lt;p&gt;&lt;a href="https://blog.frankfu.com.au/2019/03/21/moving-from-windows-1809s-openssh-to-openssh-portable/"&gt;Moving from Windows 1809's OpenSSH to OpenSSH Portable&lt;/a&gt;&lt;/p&gt;&lt;p&gt;この記事にそのまま従えばいける。&lt;/p&gt;&lt;p&gt;Windowsに関わる操作はPowerShell Coreではできないので、PowerShell CoreとWindowsPowerShellを使い分けた(WindowsPowerShellで全部やればいいものを...😅)&lt;/p&gt;&lt;p&gt;Coreでできる範囲から始める。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ Get-Service -Name ssh-agent | Stop-Service
$ sc.exe delete ssh-agent
[SC] DeleteService SUCCESS
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;WindowsPowerShellでしかできない範囲&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ Remove-WindowsCapability -Online -Name "OpenSSH.Client~~~~0.0.1.0"


Path          :
Online        : True
RestartNeeded : False



$  Remove-WindowsCapability -Online -Name "OpenSSH.Server~~~~0.0.1.0"


Path          :
Online        : True
RestartNeeded : False
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Coreで続きをやる&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ choco install openssh --package-parameters="/SSHAgentFeature"
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;Chocolatey v0.10.13
2 validations performed. 1 success(es), 1 warning(s), and 0 error(s).

Validation Warnings:
 - A pending system reboot request has been detected, however, this is
   being ignored due to the current Chocolatey configuration.  If you
   want to halt when this occurs, then either set the global feature
   using:
     choco feature enable -name=exitOnRebootDetected
   or pass the option --exit-when-reboot-detected.

Installing the following packages:
openssh
By installing you accept licenses for the packages.
Progress: Downloading openssh 7.9.0.1... 100%

openssh v7.9.0.1 [Approved]
openssh package files install completed. Performing other installation steps.
The package openssh wants to run 'chocolateyinstall.ps1'.
Note: If you don't run this script, the installation will fail.
Note: To confirm automatically next time, use '-y' or consider:
choco feature enable -n allowGlobalConfirmation
Do you want to run the script?([Y]es/[N]o/[P]rint): y

Running on: Windows 10 Home, (Core)
Windows Version: 10.0.17763

************************************************************************************
************************************************************************************
This package is a Universal Installer and can ALSO install Win32-OpenSSH on
Nano, Server Core, Docker Containers and more WITHOUT using Chocolatey.

See the following for more details:
https://github.com/DarwinJS/ChocoPackages/blob/master/openssh/readme.md
************************************************************************************
************************************************************************************

/SSHAgentFeature was used, including SSH Agent Service.
Extracting C:\ProgramData\chocolatey\lib\openssh\tools\OpenSSH-Win64.zip to C:\Users\takatoshi\AppData\Local\Temp\chocolatey\OpenSSHTemp...
C:\Users\takatoshi\AppData\Local\Temp\chocolatey\OpenSSHTemp
Source files are internal to the package, checksums are not required nor checked.
C:\Program Files\OpenSSH-Win64
C:\Program Files\OpenSSH-Win64\FixHostFilePermissions.ps1
C:\Program Files\OpenSSH-Win64\FixUserFilePermissions.ps1
C:\Program Files\OpenSSH-Win64\install-sshd.ps1
C:\Program Files\OpenSSH-Win64\libcrypto.dll
C:\Program Files\OpenSSH-Win64\openssh-events.man
C:\Program Files\OpenSSH-Win64\OpenSSHUtils.psd1
C:\Program Files\OpenSSH-Win64\OpenSSHUtils.psm1
C:\Program Files\OpenSSH-Win64\scp.exe
C:\Program Files\OpenSSH-Win64\sftp-server.exe
C:\Program Files\OpenSSH-Win64\sftp.exe
C:\Program Files\OpenSSH-Win64\ssh-add.exe
C:\Program Files\OpenSSH-Win64\ssh-agent.exe
C:\Program Files\OpenSSH-Win64\ssh-keygen.exe
C:\Program Files\OpenSSH-Win64\ssh-keyscan.exe
C:\Program Files\OpenSSH-Win64\ssh-shellhost.exe
C:\Program Files\OpenSSH-Win64\ssh.exe
C:\Program Files\OpenSSH-Win64\sshd.exe
C:\Program Files\OpenSSH-Win64\sshd_config_default
C:\Program Files\OpenSSH-Win64\uninstall-sshd.ps1
C:\Program Files\OpenSSH-Win64\Set-SSHDefaultShell.ps1
PATH environment variable does not have C:\Program Files\OpenSSH-Win64 in it. Adding...
Updating machine environment variable TERM from "" to ""
[SC] SetServiceObjectSecurity SUCCESS
Starting SSH-Agent...

NEW VERSIONS OF SSH EXES:

FileName                                         FileVersion
--------                                         -----------
C:\Program Files\OpenSSH-Win64\scp.exe           7.9.0.0
C:\Program Files\OpenSSH-Win64\sftp-server.exe   7.9.0.0
C:\Program Files\OpenSSH-Win64\sftp.exe          7.9.0.0
C:\Program Files\OpenSSH-Win64\ssh-add.exe       7.9.0.0
C:\Program Files\OpenSSH-Win64\ssh-agent.exe     7.9.0.0
C:\Program Files\OpenSSH-Win64\ssh-keygen.exe    7.9.0.0
C:\Program Files\OpenSSH-Win64\ssh-keyscan.exe   7.9.0.0
C:\Program Files\OpenSSH-Win64\ssh-shellhost.exe 7.9.0.0
C:\Program Files\OpenSSH-Win64\ssh.exe           7.9.0.0
C:\Program Files\OpenSSH-Win64\sshd.exe          7.9.0.0




WARNING: You must start a new prompt, or use the command 'refreshenv' (provided by your chocolatey install) to re-read the environment for the tools to be available in this shell session.
Environment Vars (like PATH) have changed. Close/reopen your shell to
 see the changes (or in powershell/cmd.exe just type `refreshenv`).
 The install of openssh was successful.
  Software installed to 'C:\Users\takatoshi\AppData\Local\Temp\chocolatey\OpenSSHTemp'

Chocolatey installed 1/1 packages.
 See the log for details (C:\ProgramData\chocolatey\logs\chocolatey.log).
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ Get-Service ssh-agent

Status   Name               DisplayName
------   ----               -----------
Running  ssh-agent          ssh-agent
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ git config --global core.sshCommand "'C:\Program Files\OpenSSH-Win64\ssh.exe'"
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;環境変数PATHを反映させてから、terminalでwariningが消えたのを確認&lt;/p&gt;&lt;h3 id="振り返り"&gt;振り返り&lt;/h3&gt;&lt;p&gt;Windowsのでかい更新の際はちゃんと注意して取り組まなあかんな🤔(めんどい)&lt;/p&gt;&lt;p&gt;あとこれまた既知の別件なのだけど、ver1809だとterminalのemojiの表示が中点とかに化けるので、これもなんとかしたいわ...&lt;/p&gt;&lt;p&gt;Cmder/ConEmuじゃなくてWindows自体の問題みたい。&lt;/p&gt;</description><pubDate>Sun, 31 Mar 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-03-24_coverage-of-qunt-puppeteer</guid><link>https://krymtkts.github.io/posts/2019-03-24_coverage-of-qunt-puppeteer</link><title>QUnit で CI したい その 2</title><description>&lt;p&gt;&lt;a href="./2019-03-21_want-to-run-qunit-in-cli.md"&gt;前回&lt;/a&gt;、QUnit のユニットテストを puppeteer で CLI 実行できるようにした&lt;/p&gt;&lt;p&gt;今回は code coverage を計測できるようにする。&lt;/p&gt;&lt;h3 id="前回のおさらい"&gt;前回のおさらい&lt;/h3&gt;&lt;p&gt;puppeteer で JavaScript のカバレッジを計測することができる(&lt;a href="https://developers.google.com/web/updates/2017/04/devtools-release-notes"&gt;What's New In DevTools (Chrome 59)  |  Web  |  Google Developers&lt;/a&gt;)のだが、現状利用している&lt;a href="https://www.npmjs.com/package/node-qunit-puppeteer"&gt;node-qunit-puppeteer&lt;/a&gt;だと、puppeteer の部分をモジュール外部から触れないので利用できなくて困った、ということろまで書いた。&lt;/p&gt;&lt;p&gt;理想ではユニットテストの実施と同時にカバレッジを計測したいところなのだが、一旦は簡単のために別々に、つまりユニットテストの実行後さらにカバレッジ取得のためにユニットテスを再実行する、というかたちで楽しようと考えた。ユニットテストの実行が軽いうちは 2 度実行したところで大した負荷にならないというのもあり。&lt;/p&gt;&lt;h3 id="やったこと"&gt;やったこと&lt;/h3&gt;&lt;p&gt;これ ↓&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/istanbuljs/puppeteer-to-istanbul"&gt;istanbuljs/puppeteer-to-istanbul: given coverage information output by puppeteer's API output a format consumable by Istanbul reports&lt;/a&gt;&lt;/p&gt;&lt;p&gt;puppeteer で計測したカバレッジを istanbul(nyc)で利用できる形に書き出すモジュールを使う。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/qunit-trial/blob/master/test/run.js"&gt;すでにある node-qunit-puppeteer のテストランナー&lt;/a&gt;と一緒には使えないので、カバレッジ計測のためのスクリプトも新たに書く(無駄)。&lt;/p&gt;&lt;pre&gt;&lt;code class="js"&gt;const pti = require("puppeteer-to-istanbul");
const puppeteer = require("puppeteer");
const path = require("path");

(async () =&amp;gt; {
  try {
    const browser = await puppeteer.launch();
    const page = await browser.newPage();

    await page.coverage.startJSCoverage();
    await page.goto(`file://${path.join(__dirname, "/index.html")}`);
    const jsCoverage = await page.coverage.stopJSCoverage();

    pti.write(jsCoverage);
    await browser.close();
  } catch (error) {
    console.error(error);
  }
})();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これもほぼサンプルママで使えた。読み込ませるページのパスだけ工夫が必要ってだけ。&lt;/p&gt;&lt;p&gt;あとはカバレッジ計測に成功したら nyc のレポート作成を実行するだけでおｋ。これを npm のタスクにする。&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;node test/coverage.js &amp;amp;&amp;amp; nyc report --reporter=html
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これでページを開いたときに読み込まれる JS のカバレッジを計測できた。ただしこのままだと、QUnit やユニットテスト自体のカバレッジも含まれてしまうので、仕事の CI で使う場合なんかには特定のファイルのカバレッジだけを見るか、あるいは除外設定があればいいのだけど。&lt;/p&gt;&lt;h3 id="まとめ"&gt;まとめ&lt;/h3&gt;&lt;p&gt;また今回試した内容は以下の repo に反映してある&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/qunit-trial"&gt;krymtkts/qunit-trial: sandbox to enhance legacy QUnit test.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;2 回ユニットテストを実行していて無駄感があるので、node-qunit-puppeteer に手を入れることも検討していいかも 🤔&lt;/p&gt;&lt;p&gt;続く&lt;/p&gt;</description><pubDate>Sun, 24 Mar 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-03-21_want-to-run-qunit-in-cli</guid><link>https://krymtkts.github.io/posts/2019-03-21_want-to-run-qunit-in-cli</link><title>QUnit で CI したい その 1</title><description>&lt;p&gt;2 月に転職した。&lt;/p&gt;&lt;p&gt;へーしゃでの初めての仕事はフロントエンド、と言ってもトラッキングに関わる部分である。&lt;/p&gt;&lt;p&gt;生の ES5 で書かれてて&lt;a href="https://github.com/google/closure-compiler"&gt;Google Closure Compiler&lt;/a&gt;で minify されてるようなのだけど、困ったことにユニットテストがない様子？
どこそこのチームで作ってたことがあったらしいという情報は得たので、それを CI に組み込めたらいいかなと思っていた。&lt;/p&gt;&lt;p&gt;蓋を開けてみると、2 年間ほどメンテされていない死んだユニットテストで、最新のコードベースに対するテストでなかった(テストコードと同ディレクトリにテスト対象のコードがコピられてて)🤔&lt;/p&gt;&lt;p&gt;CI に組み込まれないテストは陳腐化すると云うが、まさかそれを身をもって実感することになろうとは思わなんだ。&lt;/p&gt;&lt;p&gt;&lt;del&gt;仕方ないので&lt;/del&gt;既存の資産を活かすためにも、テスティングフレームワークなど既存のものを利用して少なくとも CI に組み込めるところまでは持っていこうと考えた。CI に組み込まれればビルド失敗の通知を恐れてみんなユニットテストを書くのをサボらなくなる。&lt;/p&gt;&lt;p&gt;というわけで、許可を取り付けた上で仕事の合間を縫ってユニットテストの整備を行うことにした。&lt;/p&gt;&lt;h3 id="現状把握と展望"&gt;現状把握と展望&lt;/h3&gt;&lt;p&gt;ユニットテストは&lt;a href="https://qunitjs.com/"&gt;QUnit&lt;/a&gt;で書かれていて、モッキングフレームワークには&lt;a href="https://sinonjs.org/"&gt;Sinon.JS&lt;/a&gt;が使われていた。&lt;/p&gt;&lt;p&gt;linter は&lt;a href="https://eslint.org/"&gt;ESLint - Pluggable JavaScript linter&lt;/a&gt;を用意してあるようなのだけどどうも長らく利用されてなかったようで、試しに実行すると 41 件の autofix 可能なエラーが...😅&lt;/p&gt;&lt;p&gt;ブラウザで&lt;code&gt;index.html&lt;/code&gt;を開くことでテストが実行されるタイプのやつで、CLI での実行は用意されてなかった。
プロダクトコードが&lt;code&gt;window&lt;/code&gt;オブジェクトに依存してることもあって、QUnit のテストをヘッドレスブラウザで実行するのが良さげかな。&lt;/p&gt;&lt;p&gt;ここにカバレッジ計測も追加して、最終的にはプルリクをトリガーにした自動テストが CI に組み込まれるのが良さげかなと思う。&lt;/p&gt;&lt;h3 id="やったことやらなかったこと"&gt;やったこと＆やらなかったこと&lt;/h3&gt;&lt;p&gt;とりあえずカバレッジは置いといて今ある QUnit の CLI 実行を優先した。&lt;/p&gt;&lt;p&gt;node でのカバレッジ計測に関しては知らないことが多かったので軽く下調べだけした。
istabul というやつが node 界隈で強かったみたいだが、こいつは 2 年ほどメンテされてなくて、後続の&lt;a href="https://www.npmjs.com/package/nyc"&gt;nyc - npm&lt;/a&gt;と言うやつがみつかる 👀
puppeteer もそれ単体でカバレッジが測れるようす ↓&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://www.philkrie.me/2018/07/04/extracting-coverage.html"&gt;Using Puppeteer to Extract Code Coverage Data from Chrome Dev Tools&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/istanbuljs/puppeteer-to-istanbul"&gt;istanbuljs/puppeteer-to-istanbul: given coverage information output by puppeteer's API output a format consumable by Istanbul reports&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 id="やったこと"&gt;やったこと&lt;/h4&gt;&lt;p&gt;まず元々ある QUnit もそのまま使えないとブラウザで見つつの開発の利便性も下がっちゃうので、そこは担保したかった。
(&lt;code&gt;window&lt;/code&gt;オブジェクトがないので CommonJS は死ぬ)&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.npmjs.com/package/qunit-puppeteer"&gt;qunit-puppeteer - npm&lt;/a&gt;は簡単にテスト実行できて楽だったのだけど、テストの url を絶対パスで指定しないといけず＆自分で URL をこねくり回せなくて却下。&lt;/p&gt;&lt;p&gt;なのでそのへん柔軟な&lt;a href="https://www.npmjs.com/package/node-qunit-puppeteer"&gt;node-qunit-puppeteer - npm&lt;/a&gt;しか選択肢が残らなかったわけだ。&lt;/p&gt;&lt;p&gt;とりま&lt;code&gt;eslint&lt;/code&gt;だけあるからソイツはそのままに、QUnit を headless browser 実行するための module だけ足す。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;npm install --save-dev node-qunit-puppeteer
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;package.json&lt;/code&gt;は以下のような感じにした&lt;/p&gt;&lt;pre&gt;&lt;code class="json"&gt;  "scripts": {
    "lint": "eslint --fix ./",
    "test": "node test/run.js"
  },
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;lint&lt;/code&gt;はメンテされてなかった関係で 40 件くらいの error があるけど、最終的には実行できるようになる(ハズな)ので用意しておく。&lt;/p&gt;&lt;p&gt;&lt;code&gt;test/run.js&lt;/code&gt;は以下の通りで、&lt;a href="https://github.com/ameshkov/node-qunit-puppeteer"&gt;ameshkov/node-qunit-puppeteer: A simple node module for running qunit tests with headless Chromium&lt;/a&gt;の Example とほぼ同じで行ける便利さ。しびれる。&lt;/p&gt;&lt;pre&gt;&lt;code class="js"&gt;#! /usr/bin/env node
// almost the same as the sample code :-p
// https://github.com/ameshkov/node-qunit-puppeteer

const path = require("path");
const { runQunitPuppeteer, printOutput } = require("node-qunit-puppeteer");

const qunitArgs = {
  targetUrl: `file://${path.join(__dirname, "/index.html")}`,
  redirectConsole: true,
};

runQunitPuppeteer(qunitArgs)
  .then((result) =&amp;gt; {
    // Print the test result to the output
    printOutput(result, console);
    if (result.stats.failed &amp;gt; 0) {
      // Handle the failed test run
      // currently notghing to do.
    }
  })
  .catch((ex) =&amp;gt; {
    console.error(ex);
  });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;実行結果は以下のような感じで出る。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ npm run test

&amp;gt; qunit@1.0.0 test C:\Users\takatoshi\dev\javascript\qunit
&amp;gt; node test/run.js

Module: hello module
  hello test
    Status: success
    Passed assertions: 2 of 2
    Elapsed: 1ms

Test run result: success
Total tests: 1
  Assertions: 2
  Passed assertions: 2
  Failed assertions: 0
  Elapsed: 8ms
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;と、ここまで書いた内容を会社のコードに組み込んだのだけど、会社で作ったものは外に出せないので模倣したゴミプロジェクトを作った ↓&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/qunit-trial"&gt;krymtkts/qunit-trial: sandbox to enhance legacy QUnit test.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;今後いじくり回すときの砂場としても使おうかな。&lt;/p&gt;&lt;h4 id="あとやりたいこと"&gt;あとやりたいこと&lt;/h4&gt;&lt;p&gt;ユニットテストだけあってカバレッジ計測がないのはちょっとアレなので早々に追加したい所存 🤔&lt;/p&gt;&lt;p&gt;そもそもユニットテスト書くにしてもどの経路通ったとかわからないのでテスト品質を保証しづらく、コード網羅率 Level C1 を 100%にしたいマンなのもありカバレッジ必須。&lt;/p&gt;&lt;p&gt;でも事前に調べてた nyc や puppeteer での方法だと、現状の node-qunit-puppeteer を使ったテストのカバレッジ計測できなさそう...&lt;/p&gt;&lt;p&gt;もう少し調べる必要がありそう 😳&lt;/p&gt;&lt;p&gt;続く&lt;/p&gt;</description><pubDate>Thu, 21 Mar 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-02-24_lein-ring-server-error</guid><link>https://krymtkts.github.io/posts/2019-02-24_lein-ring-server-error</link><title>lein ringでエラーが発生した</title><description>&lt;p&gt;&lt;a href="./2019-02-20-instead-of-ping.md"&gt;前回&lt;/a&gt;以下のコメントを残した&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;この記事をしたためておるときに&lt;code&gt;lein ring server&lt;/code&gt;でエラーが出るようになってたのを解消したので、メモがてら次回に記す。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;どのような状況だったかを以下に記すと&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;lein ring server
clojure.lang.Compiler$CompilerException: Syntax error macroexpanding clojure.core/fn at (clojure/core/unify.clj:83:18).
#:clojure.error{:phase :macro-syntax-check, :line 83, :column 18, :source "clojure/core/unify.clj", :symbol clojure.core/fn}
 at clojure.lang.Compiler.checkSpecs (Compiler.java:6971)
    clojure.lang.Compiler.macroexpand1 (Compiler.java:6987)
    clojure.lang.Compiler.analyzeSeq (Compiler.java:7092)
    clojure.lang.Compiler.analyze (Compiler.java:6789)
    clojure.lang.Compiler.analyzeSeq (Compiler.java:7094)
    clojure.lang.Compiler.analyze (Compiler.java:6789)
    clojure.lang.Compiler.access$300 (Compiler.java:38)
    clojure.lang.Compiler$DefExpr$Parser.parse (Compiler.java:596)
    clojure.lang.Compiler.analyzeSeq (Compiler.java:7106)
    clojure.lang.Compiler.analyze (Compiler.java:6789)
    clojure.lang.Compiler.analyze (Compiler.java:6745)
    clojure.lang.Compiler.eval (Compiler.java:7180)
    clojure.lang.Compiler.load (Compiler.java:7635)
    clojure.lang.RT.loadResourceScript (RT.java:381)
    clojure.lang.RT.loadResourceScript (RT.java:372)
    clojure.lang.RT.load (RT.java:463)
    clojure.lang.RT.load (RT.java:428)
    clojure.core$load$fn__6824.invoke (core.clj:6126)
    clojure.core$load.invokeStatic (core.clj:6125)
    clojure.core$load.doInvoke (core.clj:6109)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    clojure.core$load_one.invokeStatic (core.clj:5908)
    clojure.core$load_one.invoke (core.clj:5903)
    clojure.core$load_lib$fn__6765.invoke (core.clj:5948)
    clojure.core$load_lib.invokeStatic (core.clj:5947)
    clojure.core$load_lib.doInvoke (core.clj:5928)
    clojure.lang.RestFn.applyTo (RestFn.java:142)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$load_libs.invokeStatic (core.clj:5985)
    clojure.core$load_libs.doInvoke (core.clj:5969)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$require.invokeStatic (core.clj:6007)
    clojure.core$require.doInvoke (core.clj:6007)
    clojure.lang.RestFn.invoke (RestFn.java:421)
    clojure.core.contracts.impl.transformers$eval690$loading__6706__auto____691.invoke (transformers.clj:1)
    clojure.core.contracts.impl.transformers$eval690.invokeStatic (transformers.clj:1)
    clojure.core.contracts.impl.transformers$eval690.invoke (transformers.clj:1)
    clojure.lang.Compiler.eval (Compiler.java:7176)
    clojure.lang.Compiler.eval (Compiler.java:7165)
    clojure.lang.Compiler.load (Compiler.java:7635)
    clojure.lang.RT.loadResourceScript (RT.java:381)
    clojure.lang.RT.loadResourceScript (RT.java:372)
    clojure.lang.RT.load (RT.java:463)
    clojure.lang.RT.load (RT.java:428)
    clojure.core$load$fn__6824.invoke (core.clj:6126)
    clojure.core$load.invokeStatic (core.clj:6125)
    clojure.core$load.doInvoke (core.clj:6109)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    clojure.core$load_one.invokeStatic (core.clj:5908)
    clojure.core$load_one.invoke (core.clj:5903)
    clojure.core$load_lib$fn__6765.invoke (core.clj:5948)
    clojure.core$load_lib.invokeStatic (core.clj:5947)
    clojure.core$load_lib.doInvoke (core.clj:5928)
    clojure.lang.RestFn.applyTo (RestFn.java:142)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$load_libs.invokeStatic (core.clj:5985)
    clojure.core$load_libs.doInvoke (core.clj:5969)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$require.invokeStatic (core.clj:6007)
    clojure.core$require.doInvoke (core.clj:6007)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    leinjacker.defconstrainedfn$eval684$loading__6706__auto____685.invoke (defconstrainedfn.clj:1)
    leinjacker.defconstrainedfn$eval684.invokeStatic (defconstrainedfn.clj:1)
    leinjacker.defconstrainedfn$eval684.invoke (defconstrainedfn.clj:1)
    clojure.lang.Compiler.eval (Compiler.java:7176)
    clojure.lang.Compiler.eval (Compiler.java:7165)
    clojure.lang.Compiler.load (Compiler.java:7635)
    clojure.lang.RT.loadResourceScript (RT.java:381)
    clojure.lang.RT.loadResourceScript (RT.java:372)
    clojure.lang.RT.load (RT.java:463)
    clojure.lang.RT.load (RT.java:428)
    clojure.core$load$fn__6824.invoke (core.clj:6126)
    clojure.core$load.invokeStatic (core.clj:6125)
    clojure.core$load.doInvoke (core.clj:6109)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    clojure.core$load_one.invokeStatic (core.clj:5908)
    clojure.core$load_one.invoke (core.clj:5903)
    clojure.core$load_lib$fn__6765.invoke (core.clj:5948)
    clojure.core$load_lib.invokeStatic (core.clj:5947)
    clojure.core$load_lib.doInvoke (core.clj:5928)
    clojure.lang.RestFn.applyTo (RestFn.java:142)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$load_libs.invokeStatic (core.clj:5985)
    clojure.core$load_libs.doInvoke (core.clj:5969)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.core$apply.invokeStatic (core.clj:669)
    clojure.core$use.invokeStatic (core.clj:6093)
    clojure.core$use.doInvoke (core.clj:6093)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    leinjacker.deps$eval676$loading__6706__auto____677.invoke (deps.clj:1)
    leinjacker.deps$eval676.invokeStatic (deps.clj:1)
    leinjacker.deps$eval676.invoke (deps.clj:1)
    clojure.lang.Compiler.eval (Compiler.java:7176)
    clojure.lang.Compiler.eval (Compiler.java:7165)
    clojure.lang.Compiler.load (Compiler.java:7635)
    clojure.lang.RT.loadResourceScript (RT.java:381)
    clojure.lang.RT.loadResourceScript (RT.java:372)
    clojure.lang.RT.load (RT.java:463)
    clojure.lang.RT.load (RT.java:428)
    clojure.core$load$fn__6824.invoke (core.clj:6126)
    clojure.core$load.invokeStatic (core.clj:6125)
    clojure.core$load.doInvoke (core.clj:6109)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    clojure.core$load_one.invokeStatic (core.clj:5908)
    clojure.core$load_one.invoke (core.clj:5903)
    clojure.core$load_lib$fn__6765.invoke (core.clj:5948)
    clojure.core$load_lib.invokeStatic (core.clj:5947)
    clojure.core$load_lib.doInvoke (core.clj:5928)
    clojure.lang.RestFn.applyTo (RestFn.java:142)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$load_libs.invokeStatic (core.clj:5985)
    clojure.core$load_libs.doInvoke (core.clj:5969)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$require.invokeStatic (core.clj:6007)
    clojure.core$require.doInvoke (core.clj:6007)
    clojure.lang.RestFn.invoke (RestFn.java:436)
    leiningen.ring.server$eval668$loading__6706__auto____669.invoke (server.clj:1)
    leiningen.ring.server$eval668.invokeStatic (server.clj:1)
    leiningen.ring.server$eval668.invoke (server.clj:1)
    clojure.lang.Compiler.eval (Compiler.java:7176)
    clojure.lang.Compiler.eval (Compiler.java:7165)
    clojure.lang.Compiler.load (Compiler.java:7635)
    clojure.lang.RT.loadResourceScript (RT.java:381)
    clojure.lang.RT.loadResourceScript (RT.java:372)
    clojure.lang.RT.load (RT.java:463)
    clojure.lang.RT.load (RT.java:428)
    clojure.core$load$fn__6824.invoke (core.clj:6126)
    clojure.core$load.invokeStatic (core.clj:6125)
    clojure.core$load.doInvoke (core.clj:6109)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    clojure.core$load_one.invokeStatic (core.clj:5908)
    clojure.core$load_one.invoke (core.clj:5903)
    clojure.core$load_lib$fn__6765.invoke (core.clj:5948)
    clojure.core$load_lib.invokeStatic (core.clj:5947)
    clojure.core$load_lib.doInvoke (core.clj:5928)
    clojure.lang.RestFn.applyTo (RestFn.java:142)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$load_libs.invokeStatic (core.clj:5985)
    clojure.core$load_libs.doInvoke (core.clj:5969)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.core$apply.invokeStatic (core.clj:669)
    clojure.core$use.invokeStatic (core.clj:6093)
    clojure.core$use.doInvoke (core.clj:6093)
    clojure.lang.RestFn.invoke (RestFn.java:551)
    leiningen.ring$eval662$loading__6706__auto____663.invoke (ring.clj:1)
    leiningen.ring$eval662.invokeStatic (ring.clj:1)
    leiningen.ring$eval662.invoke (ring.clj:1)
    clojure.lang.Compiler.eval (Compiler.java:7176)
    clojure.lang.Compiler.eval (Compiler.java:7165)
    clojure.lang.Compiler.load (Compiler.java:7635)
    clojure.lang.RT.loadResourceScript (RT.java:381)
    clojure.lang.RT.loadResourceScript (RT.java:372)
    clojure.lang.RT.load (RT.java:463)
    clojure.lang.RT.load (RT.java:428)
    clojure.core$load$fn__6824.invoke (core.clj:6126)
    clojure.core$load.invokeStatic (core.clj:6125)
    clojure.core$load.doInvoke (core.clj:6109)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    clojure.core$load_one.invokeStatic (core.clj:5908)
    clojure.core$load_one.invoke (core.clj:5903)
    clojure.core$load_lib$fn__6765.invoke (core.clj:5948)
    clojure.core$load_lib.invokeStatic (core.clj:5947)
    clojure.core$load_lib.doInvoke (core.clj:5928)
    clojure.lang.RestFn.applyTo (RestFn.java:142)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$load_libs.invokeStatic (core.clj:5985)
    clojure.core$load_libs.doInvoke (core.clj:5969)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$require.invokeStatic (core.clj:6007)
    clojure.core$require.doInvoke (core.clj:6007)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    leiningen.core.utils$require_resolve.invokeStatic (utils.clj:102)
    leiningen.core.utils$require_resolve.invoke (utils.clj:95)
    leiningen.core.utils$require_resolve.invokeStatic (utils.clj:105)
    leiningen.core.utils$require_resolve.invoke (utils.clj:95)
    leiningen.core.main$lookup_task_var.invokeStatic (main.clj:69)
    leiningen.core.main$lookup_task_var.invoke (main.clj:65)
    leiningen.core.main$pass_through_help_QMARK_.invokeStatic (main.clj:79)
    leiningen.core.main$pass_through_help_QMARK_.invoke (main.clj:73)
    leiningen.core.main$task_args.invokeStatic (main.clj:82)
    leiningen.core.main$task_args.invoke (main.clj:81)
    leiningen.core.main$resolve_and_apply.invokeStatic (main.clj:339)
    leiningen.core.main$resolve_and_apply.invoke (main.clj:336)
    leiningen.core.main$_main$fn__6771.invoke (main.clj:449)
    leiningen.core.main$_main.invokeStatic (main.clj:439)
    leiningen.core.main$_main.doInvoke (main.clj:436)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.lang.Var.applyTo (Var.java:705)
    clojure.core$apply.invokeStatic (core.clj:665)
    clojure.main$main_opt.invokeStatic (main.clj:491)
    clojure.main$main_opt.invoke (main.clj:487)
    clojure.main$main.invokeStatic (main.clj:598)
    clojure.main$main.doInvoke (main.clj:561)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.lang.Var.applyTo (Var.java:705)
    clojure.main.main (main.java:37)
Caused by: clojure.lang.ExceptionInfo: Call to clojure.core/fn did not conform to spec.
#:clojure.spec.alpha{:problems ({:path [:fn-tail :arity-1 :params], :pred clojure.core/vector?, :val clojure.core.unify/var-unify, :via [:clojure.core.specs.alpha/params+body :clojure.core.specs.alpha/param-list :clojure.core.specs.alpha/param-list], :in [0]} {:path [:fn-tail :arity-n], :pred (clojure.core/fn [%] (clojure.core/or (clojure.core/nil? %) (clojure.core/sequential? %))), :val clojure.core.unify/var-unify, :via [:clojure.core.specs.alpha/params+body :clojure.core.specs.alpha/params+body], :in [0]}),
:spec #object[clojure.spec.alpha$regex_spec_impl$reify__2509 0x4f379769 "clojure.spec.alpha$regex_spec_impl$reify__2509@4f379769"], :value (clojure.core.unify/var-unify [G__800 G__801 G__802 G__803] (clojure.core/if-let [vb__793__auto__ (G__803 G__801)] (clojure.core.unify/garner-unifiers G__800 vb__793__auto__ G__802 G__803) (clojure.core/if-let [vexpr__794__auto__ (clojure.core/and (G__800 G__802) (G__803 G__802))] (clojure.core.unify/garner-unifiers G__800 G__801 vexpr__794__auto__ G__803) (if (clojure.core.unify/occurs? G__800 G__801 G__802 G__803) (throw (java.lang.IllegalStateException. (clojure.core/str "Cycle found in the path " G__802))) (clojure.core.unify/bind-phase G__803 G__801 G__802))))), :args (clojure.core.unify/var-unify [G__800 G__801 G__802 G__803] (clojure.core/if-let [vb__793__auto__ (G__803 G__801)] (clojure.core.unify/garner-unifiers G__800 vb__793__auto__ G__802 G__803) (clojure.core/if-let [vexpr__794__auto__ (clojure.core/and (G__800 G__802) (G__803 G__802))] (clojure.core.unify/garner-unifiers G__800 G__801 vexpr__794__auto__ G__803) (if (clojure.core.unify/occurs? G__800 G__801 G__802 G__803) (throw (java.lang.IllegalStateException. (clojure.core/str "Cycle found in the path " G__802))) (clojure.core.unify/bind-phase G__803 G__801 G__802)))))}
 at clojure.spec.alpha$macroexpand_check.invokeStatic (alpha.clj:705)
    clojure.spec.alpha$macroexpand_check.invoke (alpha.clj:697)
    clojure.lang.AFn.applyToHelper (AFn.java:156)
    clojure.lang.AFn.applyTo (AFn.java:144)
    clojure.lang.Var.applyTo (Var.java:705)
    clojure.lang.Compiler.checkSpecs (Compiler.java:6969)
    clojure.lang.Compiler.macroexpand1 (Compiler.java:6987)
    clojure.lang.Compiler.analyzeSeq (Compiler.java:7092)
    clojure.lang.Compiler.analyze (Compiler.java:6789)
    clojure.lang.Compiler.analyzeSeq (Compiler.java:7094)
    clojure.lang.Compiler.analyze (Compiler.java:6789)
    clojure.lang.Compiler.access$300 (Compiler.java:38)
    clojure.lang.Compiler$DefExpr$Parser.parse (Compiler.java:596)
    clojure.lang.Compiler.analyzeSeq (Compiler.java:7106)
    clojure.lang.Compiler.analyze (Compiler.java:6789)
    clojure.lang.Compiler.analyze (Compiler.java:6745)
    clojure.lang.Compiler.eval (Compiler.java:7180)
    clojure.lang.Compiler.load (Compiler.java:7635)
    clojure.lang.RT.loadResourceScript (RT.java:381)
    clojure.lang.RT.loadResourceScript (RT.java:372)
    clojure.lang.RT.load (RT.java:463)
    clojure.lang.RT.load (RT.java:428)
    clojure.core$load$fn__6824.invoke (core.clj:6126)
    clojure.core$load.invokeStatic (core.clj:6125)
    clojure.core$load.doInvoke (core.clj:6109)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    clojure.core$load_one.invokeStatic (core.clj:5908)
    clojure.core$load_one.invoke (core.clj:5903)
    clojure.core$load_lib$fn__6765.invoke (core.clj:5948)
    clojure.core$load_lib.invokeStatic (core.clj:5947)
    clojure.core$load_lib.doInvoke (core.clj:5928)
    clojure.lang.RestFn.applyTo (RestFn.java:142)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$load_libs.invokeStatic (core.clj:5985)
    clojure.core$load_libs.doInvoke (core.clj:5969)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$require.invokeStatic (core.clj:6007)
    clojure.core$require.doInvoke (core.clj:6007)
    clojure.lang.RestFn.invoke (RestFn.java:421)
    clojure.core.contracts.impl.transformers$eval690$loading__6706__auto____691.invoke (transformers.clj:1)
    clojure.core.contracts.impl.transformers$eval690.invokeStatic (transformers.clj:1)
    clojure.core.contracts.impl.transformers$eval690.invoke (transformers.clj:1)
    clojure.lang.Compiler.eval (Compiler.java:7176)
    clojure.lang.Compiler.eval (Compiler.java:7165)
    clojure.lang.Compiler.load (Compiler.java:7635)
    clojure.lang.RT.loadResourceScript (RT.java:381)
    clojure.lang.RT.loadResourceScript (RT.java:372)
    clojure.lang.RT.load (RT.java:463)
    clojure.lang.RT.load (RT.java:428)
    clojure.core$load$fn__6824.invoke (core.clj:6126)
    clojure.core$load.invokeStatic (core.clj:6125)
    clojure.core$load.doInvoke (core.clj:6109)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    clojure.core$load_one.invokeStatic (core.clj:5908)
    clojure.core$load_one.invoke (core.clj:5903)
    clojure.core$load_lib$fn__6765.invoke (core.clj:5948)
    clojure.core$load_lib.invokeStatic (core.clj:5947)
    clojure.core$load_lib.doInvoke (core.clj:5928)
    clojure.lang.RestFn.applyTo (RestFn.java:142)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$load_libs.invokeStatic (core.clj:5985)
    clojure.core$load_libs.doInvoke (core.clj:5969)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$require.invokeStatic (core.clj:6007)
    clojure.core$require.doInvoke (core.clj:6007)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    leinjacker.defconstrainedfn$eval684$loading__6706__auto____685.invoke (defconstrainedfn.clj:1)
    leinjacker.defconstrainedfn$eval684.invokeStatic (defconstrainedfn.clj:1)
    leinjacker.defconstrainedfn$eval684.invoke (defconstrainedfn.clj:1)
    clojure.lang.Compiler.eval (Compiler.java:7176)
    clojure.lang.Compiler.eval (Compiler.java:7165)
    clojure.lang.Compiler.load (Compiler.java:7635)
    clojure.lang.RT.loadResourceScript (RT.java:381)
    clojure.lang.RT.loadResourceScript (RT.java:372)
    clojure.lang.RT.load (RT.java:463)
    clojure.lang.RT.load (RT.java:428)
    clojure.core$load$fn__6824.invoke (core.clj:6126)
    clojure.core$load.invokeStatic (core.clj:6125)
    clojure.core$load.doInvoke (core.clj:6109)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    clojure.core$load_one.invokeStatic (core.clj:5908)
    clojure.core$load_one.invoke (core.clj:5903)
    clojure.core$load_lib$fn__6765.invoke (core.clj:5948)
    clojure.core$load_lib.invokeStatic (core.clj:5947)
    clojure.core$load_lib.doInvoke (core.clj:5928)
    clojure.lang.RestFn.applyTo (RestFn.java:142)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$load_libs.invokeStatic (core.clj:5985)
    clojure.core$load_libs.doInvoke (core.clj:5969)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.core$apply.invokeStatic (core.clj:669)
    clojure.core$use.invokeStatic (core.clj:6093)
    clojure.core$use.doInvoke (core.clj:6093)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    leinjacker.deps$eval676$loading__6706__auto____677.invoke (deps.clj:1)
    leinjacker.deps$eval676.invokeStatic (deps.clj:1)
    leinjacker.deps$eval676.invoke (deps.clj:1)
    clojure.lang.Compiler.eval (Compiler.java:7176)
    clojure.lang.Compiler.eval (Compiler.java:7165)
    clojure.lang.Compiler.load (Compiler.java:7635)
    clojure.lang.RT.loadResourceScript (RT.java:381)
    clojure.lang.RT.loadResourceScript (RT.java:372)
    clojure.lang.RT.load (RT.java:463)
    clojure.lang.RT.load (RT.java:428)
    clojure.core$load$fn__6824.invoke (core.clj:6126)
    clojure.core$load.invokeStatic (core.clj:6125)
    clojure.core$load.doInvoke (core.clj:6109)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    clojure.core$load_one.invokeStatic (core.clj:5908)
    clojure.core$load_one.invoke (core.clj:5903)
    clojure.core$load_lib$fn__6765.invoke (core.clj:5948)
    clojure.core$load_lib.invokeStatic (core.clj:5947)
    clojure.core$load_lib.doInvoke (core.clj:5928)
    clojure.lang.RestFn.applyTo (RestFn.java:142)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$load_libs.invokeStatic (core.clj:5985)
    clojure.core$load_libs.doInvoke (core.clj:5969)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$require.invokeStatic (core.clj:6007)
    clojure.core$require.doInvoke (core.clj:6007)
    clojure.lang.RestFn.invoke (RestFn.java:436)
    leiningen.ring.server$eval668$loading__6706__auto____669.invoke (server.clj:1)
    leiningen.ring.server$eval668.invokeStatic (server.clj:1)
    leiningen.ring.server$eval668.invoke (server.clj:1)
    clojure.lang.Compiler.eval (Compiler.java:7176)
    clojure.lang.Compiler.eval (Compiler.java:7165)
    clojure.lang.Compiler.load (Compiler.java:7635)
    clojure.lang.RT.loadResourceScript (RT.java:381)
    clojure.lang.RT.loadResourceScript (RT.java:372)
    clojure.lang.RT.load (RT.java:463)
    clojure.lang.RT.load (RT.java:428)
    clojure.core$load$fn__6824.invoke (core.clj:6126)
    clojure.core$load.invokeStatic (core.clj:6125)
    clojure.core$load.doInvoke (core.clj:6109)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    clojure.core$load_one.invokeStatic (core.clj:5908)
    clojure.core$load_one.invoke (core.clj:5903)
    clojure.core$load_lib$fn__6765.invoke (core.clj:5948)
    clojure.core$load_lib.invokeStatic (core.clj:5947)
    clojure.core$load_lib.doInvoke (core.clj:5928)
    clojure.lang.RestFn.applyTo (RestFn.java:142)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$load_libs.invokeStatic (core.clj:5985)
    clojure.core$load_libs.doInvoke (core.clj:5969)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.core$apply.invokeStatic (core.clj:669)
    clojure.core$use.invokeStatic (core.clj:6093)
    clojure.core$use.doInvoke (core.clj:6093)
    clojure.lang.RestFn.invoke (RestFn.java:551)
    leiningen.ring$eval662$loading__6706__auto____663.invoke (ring.clj:1)
    leiningen.ring$eval662.invokeStatic (ring.clj:1)
    leiningen.ring$eval662.invoke (ring.clj:1)
    clojure.lang.Compiler.eval (Compiler.java:7176)
    clojure.lang.Compiler.eval (Compiler.java:7165)
    clojure.lang.Compiler.load (Compiler.java:7635)
    clojure.lang.RT.loadResourceScript (RT.java:381)
    clojure.lang.RT.loadResourceScript (RT.java:372)
    clojure.lang.RT.load (RT.java:463)
    clojure.lang.RT.load (RT.java:428)
    clojure.core$load$fn__6824.invoke (core.clj:6126)
    clojure.core$load.invokeStatic (core.clj:6125)
    clojure.core$load.doInvoke (core.clj:6109)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    clojure.core$load_one.invokeStatic (core.clj:5908)
    clojure.core$load_one.invoke (core.clj:5903)
    clojure.core$load_lib$fn__6765.invoke (core.clj:5948)
    clojure.core$load_lib.invokeStatic (core.clj:5947)
    clojure.core$load_lib.doInvoke (core.clj:5928)
    clojure.lang.RestFn.applyTo (RestFn.java:142)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$load_libs.invokeStatic (core.clj:5985)
    clojure.core$load_libs.doInvoke (core.clj:5969)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$require.invokeStatic (core.clj:6007)
    clojure.core$require.doInvoke (core.clj:6007)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    leiningen.core.utils$require_resolve.invokeStatic (utils.clj:102)
    leiningen.core.utils$require_resolve.invoke (utils.clj:95)
    leiningen.core.utils$require_resolve.invokeStatic (utils.clj:105)
    leiningen.core.utils$require_resolve.invoke (utils.clj:95)
    leiningen.core.main$lookup_task_var.invokeStatic (main.clj:69)
    leiningen.core.main$lookup_task_var.invoke (main.clj:65)
    leiningen.core.main$pass_through_help_QMARK_.invokeStatic (main.clj:79)
    leiningen.core.main$pass_through_help_QMARK_.invoke (main.clj:73)
    leiningen.core.main$task_args.invokeStatic (main.clj:82)
    leiningen.core.main$task_args.invoke (main.clj:81)
    leiningen.core.main$resolve_and_apply.invokeStatic (main.clj:339)
    leiningen.core.main$resolve_and_apply.invoke (main.clj:336)
    leiningen.core.main$_main$fn__6771.invoke (main.clj:449)
    leiningen.core.main$_main.invokeStatic (main.clj:439)
    leiningen.core.main$_main.doInvoke (main.clj:436)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.lang.Var.applyTo (Var.java:705)
    clojure.core$apply.invokeStatic (core.clj:665)
    clojure.main$main_opt.invokeStatic (main.clj:491)
    clojure.main$main_opt.invoke (main.clj:487)
    clojure.main$main.invokeStatic (main.clj:598)
    clojure.main$main.doInvoke (main.clj:561)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.lang.Var.applyTo (Var.java:705)
    clojure.main.main (main.java:37)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;lein ring server&lt;/code&gt;がエラーを吐くようになった。&lt;/p&gt;&lt;p&gt;&lt;code&gt;lein help&lt;/code&gt;で見てみてもringだけエラーが出てる&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;lein help
Leiningen is a tool for working with Clojure projects.

Several tasks are available:
change              Rewrite project.clj with f applied to the value at key-or-path.
check               Check syntax and warn on reflection.
classpath           Write the classpath of the current project to output-file.
clean               Removes all files from paths in clean-targets for a project
compile             Compile Clojure source into .class files.
deploy              Deploy jar and pom to remote repository.
deps                Show details about dependencies.
do                  Higher-order task to perform other tasks in succession.
help                Display a list of tasks or help for a given task or subtask.
install             Install jar and pom to the local repository; typically ~/.m2.
jar                 Package up all the project's files into a jar file.
javac               Compile Java source files.
new                 Generate scaffolding for a new project based on a template.
plugin              DEPRECATED. Please use the :user profile instead.
pom                 Write a pom.xml file to disk for Maven interoperability.
release             Perform release tasks.
repl                Start a repl session either with the current project or standalone.
retest              Run only the test namespaces which failed last time around.
leiningen.ring  Problem loading: Syntax error macroexpanding clojure.core/fn at (clojure/core/unify.clj:83:18).
run                 Run the project's -main function.
search              Search Central and Clojars for published artifacts.
show-profiles       List all available profiles or display one if given an argument.
test                Run the project's tests.
trampoline          Run a task without nesting the project's JVM inside Leiningen's.
uberjar             Package up the project files and all dependencies into a jar file.
update-in           Perform arbitrary transformations on your project map.
upgrade             Upgrade Leiningen to specified version or latest stable.
vcs                 Interact with the version control system.
version             Print version for Leiningen and the current JVM.
with-profile        Apply the given task with the profile(s) specified.

Run `lein help $TASK` for details.

Global Options:
  -o             Run a task offline.
  -U             Run a task after forcing update of snapshots.
  -h, --help     Print this help or help for a specific task.
  -v, --version  Print Leiningen's version.

These aliases are available:
downgrade, expands to upgrade

See also: readme, faq, tutorial, news, sample, profiles, deploying, gpg,
mixed-source, templates, and copying.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;この前後にPCのソフトウェア更新など諸々してたしJDK更新したからか？と云う気もしたが原因はわからず。&lt;/p&gt;&lt;p&gt;ブログを作るだけなら&lt;code&gt;lein run&lt;/code&gt;すりゃいいだけなのでなくてもよいのだが、見れたほうが良いので他のversionだとどうか試してみたところ、
0.12.5以上でならイケることがわかったので、cryogenの&lt;code&gt;project.clj&lt;/code&gt;に記述されてる&lt;code&gt;lein-ring&lt;/code&gt;のversionを上げることで障害を解消した。&lt;/p&gt;&lt;p&gt;ブログを書くための見えない部分の障害なので最も楽な解決方法でいったが、プロダクトでこれが起こってたらもっとエラーの原因を深掘りしたであろうな🤔&lt;/p&gt;</description><pubDate>Sun, 24 Feb 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-02-20-instead-of-ping</guid><link>https://krymtkts.github.io/posts/2019-02-20-instead-of-ping</link><title>`ping`の代わりに`Test-Connection`を使う</title><description>&lt;p&gt;PowerShellには&lt;code&gt;Test-Connection&lt;/code&gt;というやつがあるのを今更ながら知った。&lt;/p&gt;&lt;p&gt;今の仕事では、仮想マシン(dockerでない)を複数立ち上げて作業することが常になってるのだが、結構立ち上げ忘れてたりしてうっかりSSHしたときに繋げないのである😢&lt;/p&gt;&lt;p&gt;疎通確認と合わせてSSHするすべを探してたところ、これを知ったので以下のようなスクリプトを作ってCmderのTaskに登録して使っている。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$waken = Test-Connection -TargetName $ip -Count 1 -Quiet
if (!$waken) {
    Write-Output "target not found. please start up $ip"
    $Host.UI.RawUI.ReadKey() | Out-Null
    exit
}
ssh "admin@$ip"
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href="https://blog.shibata.tech/entry/2016/06/16/231239"&gt;Test-Connectionが遅い理由と対策方法について - しばたテックブログ&lt;/a&gt;&lt;/p&gt;&lt;p&gt;↑このような話もあるようなので目を通しておきたいところ🤔&lt;/p&gt;&lt;h3 id="おまけ"&gt;おまけ&lt;/h3&gt;&lt;p&gt;&lt;a href="https://qiita.com/twinkfrag/items/f3ecf79b68ea09eadec2"&gt;PowerShellでPause - Qiita&lt;/a&gt;&lt;/p&gt;&lt;p&gt;最近のPowerShellには&lt;code&gt;Pause&lt;/code&gt;なるもんがデフォで入ってるが、古来からの方法でEnter以外のキーでも使えるようにしておくのが良いであらうか？&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Write-Output "type key to continue..."
$Host.UI.RawUI.ReadKey() | Out-Null
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;スクリプトの中でコレを呼んだら、なんかのキーを押すまで止まる。&lt;/p&gt;&lt;p&gt;戻り値が標準出力されないようにするために&lt;code&gt;Out-Null&lt;/code&gt;にパイプラインする。&lt;code&gt;$null&lt;/code&gt;に代入でもよいが。&lt;/p&gt;&lt;h3 id="余談"&gt;余談&lt;/h3&gt;&lt;p&gt;この記事をしたためておるときに&lt;code&gt;lein ring server&lt;/code&gt;でエラーが出るようになってたのを解消したので、メモがてら次回に記す。&lt;/p&gt;</description><pubDate>Wed, 20 Feb 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-02-11-Register-ArgumentCompleter2</guid><link>https://krymtkts.github.io/posts/2019-02-11-Register-ArgumentCompleter2</link><title>Register-ArgumentCompleterのScriptBlockの引数</title><description>&lt;p&gt;&lt;a href="./2019-02-04-Register-ArgumentCompleter.md"&gt;前回&lt;/a&gt;の続き。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Register-ArgumentCompleter -Native -CommandName mvn -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;↑こんなんいるやん？&lt;/p&gt;&lt;p&gt;&lt;code&gt;wordToComplete&lt;/code&gt;には入力中の文字列が入ってくる。&lt;/p&gt;&lt;p&gt;&lt;code&gt;$commandAst&lt;/code&gt;にはコマンドラインが全部載ってくる。&lt;/p&gt;&lt;p&gt;でも実際詳しく知らんので、たとえば&lt;code&gt;maven clean install -pl :module1 -&lt;/code&gt;ってとこまで入力してCtrl+Spaceやったときにはどういうパラメータになるかわからんので調べた。&lt;/p&gt;&lt;p&gt;結論から言うと&lt;code&gt;$commandAst&lt;/code&gt;はASTが乗ってくる。&lt;code&gt;mvn clean install --d&lt;/code&gt;でtabしたときのデバッガでの出力は以下の通り(デバッグ実行にはISEを利用した)。 &lt;a href="https://docs.microsoft.com/ja-jp/powershell/scripting/components/ise/exploring-the-windows-powershell-ise?view=powershell-6"&gt;Windows PowerShell ISE の操作 | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS C:\Users\takatoshi\Desktop\maven&amp;gt; mvn clean install --d
ヒット 'C:\Users\takatoshi\dev\powershell\MavenAutoCompletion\MavenAutoCompletion.ps1:152' の行のブレークポイント
[DBG]: PS C:\Users\takatoshi\Desktop\maven&amp;gt;&amp;gt; $commandAst


CommandElements    : {mvn, clean, install, --d}
InvocationOperator : Unknown
DefiningKeyword    :
Redirections       : {}
Extent             : mvn clean install --d
Parent             : mvn clean install --d




[DBG]: PS C:\Users\takatoshi\Desktop\maven&amp;gt;&amp;gt; $wordToComplete
--d
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;mvn clean install --projects :&lt;/code&gt;でtabした場合↓&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;[DBG]: PS C:\Users\takatoshi\Desktop\maven&amp;gt;&amp;gt;
mvn clean install --projects :
ヒット 'C:\Users\takatoshi\dev\powershell\MavenAutoCompletion\MavenAutoCompletion.ps1:152' の行のブレークポイント
[DBG]: PS C:\Users\takatoshi\Desktop\maven&amp;gt;&amp;gt; $commandAst


CommandElements    : {mvn, clean, install, --projects...}
InvocationOperator : Unknown
DefiningKeyword    :
Redirections       : {}
Extent             : mvn clean install --projects :
Parent             : mvn clean install --projects :




[DBG]: PS C:\Users\takatoshi\Desktop\maven&amp;gt;&amp;gt; $commandAst.CommandElements


StringConstantType : BareWord
Value              : mvn
StaticType         : System.String
Extent             : mvn
Parent             : mvn clean install --projects :

StringConstantType : BareWord
Value              : clean
StaticType         : System.String
Extent             : clean
Parent             : mvn clean install --projects :

StringConstantType : BareWord
Value              : install
StaticType         : System.String
Extent             : install
Parent             : mvn clean install --projects :

StringConstantType : BareWord
Value              : --projects
StaticType         : System.String
Extent             : --projects
Parent             : mvn clean install --projects :

StringConstantType : BareWord
Value              : :
StaticType         : System.String
Extent             : :
Parent             : mvn clean install --projects :
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;wordToComplete&lt;/code&gt; こいつはまじでただの文字列。&lt;code&gt;commandAst.CommandElements&lt;/code&gt;の最後の要素の&lt;code&gt;value&lt;/code&gt;が出てる。&lt;/p&gt;&lt;p&gt;という感じだったので、MavenAutoCompletion的には&lt;code&gt;commandAst.CommandElements&lt;/code&gt;の最後から2要素を対象に正規表現してやれば、だいたい望みのことができるのがわかったのであった。&lt;/p&gt;&lt;h3 id="余談"&gt;余談&lt;/h3&gt;&lt;p&gt;PowerShellで配列の任意の連続した要素を抜き出すのに、slice的なんがないんかと調べたところ、以下のようにするようだ。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;&amp;gt; $a = @('mvn', 'clean', 'install', '-pl', ':')
&amp;gt; $a[($a.Length -2)..$a.Length]
-pl
:
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;cool😉&lt;/p&gt;</description><pubDate>Mon, 11 Feb 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-02-04-Register-ArgumentCompleter</guid><link>https://krymtkts.github.io/posts/2019-02-04-Register-ArgumentCompleter</link><title>Register-ArgumentCompleter</title><description>&lt;p&gt;まだoutputが習慣化してなくて随分空いてしまった🤔&lt;/p&gt;&lt;h3 id="register-argumentcompleter"&gt;&lt;a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/register-argumentcompleter?view=powershell-6"&gt;Register-ArgumentCompleter&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;PowerShell5から、従来の&lt;code&gt;TabExpansion&lt;/code&gt;に代わる&lt;code&gt;Register-ArgumentCompleter&lt;/code&gt;なるモノが現れたのは、PowerShellerなら知っているだろう(わたしは去年まで知らんかったのでPowerShellerではないのだ)。&lt;/p&gt;&lt;h3 id="サンプル書いてみた"&gt;サンプル書いてみた&lt;/h3&gt;&lt;p&gt;Mavenのよく使うコマンドでお試し。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Register-ArgumentCompleter -Native -CommandName mvn -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)

    echo -- clean install eclipse:eclipse |
        Where-Object { $_ -like "$wordToComplete*" } |
        Sort-Object |
        ForEach-Object {
            [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;めちゃんこ簡単。&lt;/p&gt;&lt;h3 id="作ったもの"&gt;作ったもの&lt;/h3&gt;&lt;p&gt;当時仕事で巨大なMavenプロジェクトを使っていて、コマンド打つのも億劫だったのでPowerShellで自動補完がほしいなと思っていたのだが、&lt;code&gt;TabExpantion&lt;/code&gt;はちょっと自分には使いこなせなかった。関数のオーバーライドをしたりのおまじないが必要だし。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Register-ArgumentCompleter&lt;/code&gt;なら簡単に作れたので、APIが進化してる感をひしと感じたのであった。以下成果物↓&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/MavenAutoCompletion"&gt;krymtkts/MavenAutoCompletion: MavenAutoCompletion provides a simple auto completion of Maven 3 to PowerShell.&lt;/a&gt;&lt;/p&gt;&lt;h3 id="既知のバグ"&gt;既知のバグ&lt;/h3&gt;&lt;p&gt;PowerShell5だと&lt;code&gt;-Native&lt;/code&gt;オプションありの場合に&lt;code&gt;-&lt;/code&gt;を利用した補完ができないバグがあって、前述の自動補完がうまく使えなくて辛い...&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/PowerShell/PowerShell/issues/2912"&gt;Native ArgumentCompleter not invoked for inputs that begin with hyphen (-) · Issue #2912 · PowerShell/PowerShell&lt;/a&gt;&lt;/p&gt;&lt;p&gt;PowerShell5.xでも使えないものかと試してみたところ、Trickyな回避策として&lt;code&gt;`&lt;/code&gt;で&lt;code&gt;-&lt;/code&gt;をエスケープしたらイケるというのを見つけたが...posh-gitもchocolateyもそれで従来からの&lt;code&gt;TabExpantion&lt;/code&gt;を使ってたのかーという気付きは得られた。&lt;/p&gt;&lt;p&gt;ちなみにわたしはPowerShell6を使ってるのでかんけーないのだ😜&lt;/p&gt;&lt;h3 id="残"&gt;残&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Register-ArgumentCompleter&lt;/code&gt;のScriptBlockの引数をちまちま調べたのがあるけど、長いから別に書こう。&lt;/p&gt;</description><pubDate>Mon, 04 Feb 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-01-17-build-qmk-firmware-of-planck</guid><link>https://krymtkts.github.io/posts/2019-01-17-build-qmk-firmware-of-planck</link><title>Planckのキーマップをビルドする</title><description>&lt;blockquote&gt;&lt;p&gt;当時使ってたPCではプログラミングしなくなったのと、改めてQMK firmwareのdocument見たらbuild toolsんとこの記事が変わってるので、今度環境構築がてら再確認してfirmwareのとこだけ新しく書こうと思う。&lt;/p&gt;&lt;p&gt;わたしのkeymapのrepo(&lt;a href="https://github.com/krymtkts/qmk_firmware"&gt;krymtkts/qmk_firmware&lt;/a&gt;)は「デフォのキーマップをコピった」的なコミットを最後に止まってるので、旧PCに遺物が残されてそう...作り直したほうが早いわ😅&lt;/p&gt;&lt;p&gt;去年はWSLで書き込む方法が確か使えてたはずだけど今は非推奨になってて、MSYS2を使う方法が主流になった？？？謎い🤔&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;a href="./2019-01-14-ortho-linear-keyboard-planck"&gt;前回&lt;/a&gt;のこの辺の続き。&lt;/p&gt;&lt;h3 id="ビルド環境をセットアップする"&gt;ビルド環境をセットアップする&lt;/h3&gt;&lt;p&gt;ドキュメント&lt;a href="https://docs.qmk.fm/#/getting_started_build_tools"&gt;QMK Firmware - Installing Build Tools&lt;/a&gt;に記載のWSLの手順をそのままでOK。ちょっとWSLを使いたかったのでMSYS2でのやつではあえてやらなかった。&lt;/p&gt;&lt;p&gt;WSL用のセットアップは&lt;code&gt;util/wsl_install.sh&lt;/code&gt;で行う。&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ cd ./c/qmk_firmware/
$ ./util/wsl_install.sh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;途中ドライバを全部入れる？と聞かれて、それは流石に...と思ったのでConnectedという接続したドライバだけ入れるやつ&lt;code&gt;C&lt;/code&gt;にした。&lt;/p&gt;&lt;p&gt;Flip入れる？と聞かれたけどつかわないだろうし必要なときに、と思ったので&lt;code&gt;N&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;wsl_install.sh&lt;/code&gt;完了後にPlanckのrev4のdefaultキーマップを試しにコンパイルする。&lt;/p&gt;&lt;p&gt;bashを再起動してサンプルのコマンドを実行する。&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ make planck/rev4:default
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;でバイナリが吐き出されたのでOK。&lt;/p&gt;&lt;h3 id="planckのfirmwareをビルドする"&gt;Planckのfirmwareをビルドする&lt;/h3&gt;&lt;p&gt;わたしのキーマップはこちら→&lt;a href="https://github.com/krymtkts/qmk_firmware/blob/master/keyboards/planck/keymaps/krymtkts/keymap.c"&gt;qmk_firmware/keymap.c at master · krymtkts/qmk_firmware&lt;/a&gt;&lt;/p&gt;&lt;p&gt;2017年末頃にビルドしたころとは&lt;code&gt;keyboards/planck/&lt;/code&gt;配下のコードが結構変わってるようなので、作成済みのキーマップを削除して新しく&lt;code&gt;default&lt;/code&gt;キーマップを作成する。それ用のシェルがあるので使う。&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ ./util/new_keymap.sh planck krymtkts
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これで一旦ビルドする。revisionはわからんけど時期的に5だと思う。[要出典?]&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ make planck/rev5:krymtkts
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;コマンドラインでfirmwareを書き込む。revision5では以下のコマンドが正しい。&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ make planck/rev5:krymtkts:dfu
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;でもエラーになった。なんかエラーが無限に繰り返される。CTRL+Cで中断&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ make planck/rev5:krymtkts:dfu
QMK Firmware 0.6.228
Making planck/rev5 with keymap krymtkts and target dfu

avr-gcc (GCC) 4.9.2
Copyright (C) 2014 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

Size before:
text    data     bss     dec     hex filename
    0   26614       0   26614    67f6 .build/planck_rev5_krymtkts.hex

Compiling: keyboards/planck/keymaps/krymtkts/keymap.c                                               [OK]
Linking: .build/planck_rev5_krymtkts.elf                                                            [OK]
Creating load file for flashing: .build/planck_rev5_krymtkts.hex                                    [OK]
Copying planck_rev5_krymtkts.hex to qmk_firmware folder                                             [OK]
Checking file size of planck_rev5_krymtkts.hex                                                      [OK]
* The firmware size is fine - 26614/28672 (2058 bytes free)
Error: Bootloader not found. Trying again in 5s.
Error: Bootloader not found. Trying again in 5s.
Error: Bootloader not found. Trying again in 5s.
Error: Bootloader not found. Trying again in 5s.
Error: Bootloader not found. Trying again in 5s.
^Ctmk_core/avr.mk:141: recipe for target 'dfu' failed
make[1]: *** [dfu] Interrupt
Makefile:529: recipe for target 'planck/rev5:krymtkts:dfu' failed
make: *** [planck/rev5:krymtkts:dfu] Interrupt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;エラーダイアログで「libusb0.dllがない」というような旨が表示される。WSLでやろうとしたからダメだったのか？&lt;/p&gt;&lt;p&gt;コマンドラインで焼くのを一旦諦めて、&lt;code&gt;qmk_tookbox.exe&lt;/code&gt;を使うことにしたら一発成功、Planckに自分のキーマップを焼くことに成功した。&lt;/p&gt;&lt;p&gt;でもコマンドラインで焼けないのは困るので、PlanckのMakefileの&lt;code&gt;rules.mk&lt;/code&gt;見てみたところ、&lt;/p&gt;&lt;pre&gt;&lt;code class="makefile"&gt;ifeq ($(strip $(KEYBOARD)), planck/rev4)
    BOOTLOADER = atmel-dfu
endif
ifeq ($(strip $(KEYBOARD)), planck/rev5)
    BOOTLOADER = qmk-dfu
endif
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;とあって、rev4と4rev5でbootloaderが変わってることから、あれ？わたしのPlanckもしかしてrev4じゃ？と思って試してみたところ...&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ make planck/rev4:krymtkts:dfu
QMK Firmware 0.6.228
Making planck/rev4 with keymap krymtkts and target dfu

avr-gcc (GCC) 4.9.2
Copyright (C) 2014 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

Compiling: quantum/audio/muse.c                                                                     [OK]
Compiling: keyboards/planck/planck.c                                                                [OK]
Compiling: keyboards/planck/keymaps/krymtkts/keymap.c                                               [OK]
Compiling: quantum/quantum.c                                                                        [OK]
Compiling: quantum/keymap_common.c                                                                  [OK]
Compiling: quantum/keycode_config.c                                                                 [OK]
Compiling: quantum/matrix.c                                                                         [OK]
Compiling: quantum/process_keycode/process_audio.c                                                  [OK]
Compiling: quantum/process_keycode/process_clicky.c                                                 [OK]
Compiling: quantum/audio/audio.c                                                                    [OK]
Compiling: quantum/audio/voices.c                                                                   [OK]
Compiling: quantum/audio/luts.c                                                                     [OK]
Compiling: quantum/process_keycode/process_music.c                                                  [OK]
Compiling: tmk_core/common/host.c                                                                   [OK]
Compiling: tmk_core/common/keyboard.c                                                               [OK]
Compiling: tmk_core/common/action.c                                                                 [OK]
Compiling: tmk_core/common/action_tapping.c                                                         [OK]
Compiling: tmk_core/common/action_macro.c                                                           [OK]
Compiling: tmk_core/common/action_layer.c                                                           [OK]
Compiling: tmk_core/common/action_util.c                                                            [OK]
Compiling: tmk_core/common/print.c                                                                  [OK]
Compiling: tmk_core/common/debug.c                                                                  [OK]
Compiling: tmk_core/common/util.c                                                                   [OK]
Compiling: tmk_core/common/eeconfig.c                                                               [OK]
Compiling: tmk_core/common/report.c                                                                 [OK]
Compiling: tmk_core/common/avr/suspend.c                                                            [OK]
Compiling: tmk_core/common/avr/timer.c                                                              [OK]
Compiling: tmk_core/common/avr/bootloader.c                                                         [OK]
Assembling: tmk_core/common/avr/xprintf.S                                                           [OK]
Compiling: tmk_core/common/magic.c                                                                  [OK]
Compiling: tmk_core/protocol/lufa/lufa.c                                                            [OK]
Compiling: tmk_core/protocol/usb_descriptor.c                                                       [OK]
Compiling: tmk_core/protocol/lufa/outputselect.c                                                    [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Class/Common/HIDParser.c                                       [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/AVR8/Device_AVR8.c                                        [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/AVR8/EndpointStream_AVR8.c                                [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/AVR8/Endpoint_AVR8.c                                      [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/AVR8/Host_AVR8.c                                          [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/AVR8/PipeStream_AVR8.c                                    [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/AVR8/Pipe_AVR8.c                                          [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.c                                 [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/AVR8/USBInterrupt_AVR8.c                                  [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/ConfigDescriptors.c                                       [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/DeviceStandardReq.c                                       [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/Events.c                                                  [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/HostStandardReq.c                                         [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/USBTask.c                                                 [OK]
Linking: .build/planck_rev4_krymtkts.elf                                                            [OK]
Creating load file for flashing: .build/planck_rev4_krymtkts.hex                                    [OK]
Copying planck_rev4_krymtkts.hex to qmk_firmware folder                                             [OK]
Checking file size of planck_rev4_krymtkts.hex                                                      [OK]
 * The firmware size is fine - 26614/28672 (2058 bytes free)
Bootloader Version: 0x00 (0)
Erasing flash...  Success
Checking memory from 0x0 to 0x6FFF...  Empty.
Checking memory from 0x0 to 0x67FF...  Empty.
0%                            100%  Programming 0x6800 bytes...
[&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;]  Success
0%                            100%  Reading 0x7000 bytes...
[&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;]  Success
Validating...  Success
0x6800 bytes written into 0x7000 bytes memory (92.86%).
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;成功した。時期的にrev5だと思ってたけどrev4だったとは😅まあうまくいってよかった。&lt;/p&gt;&lt;p&gt;キーマップはまだしっくり来ていないのでちまちま更新する予定。&lt;/p&gt;</description><pubDate>Thu, 17 Jan 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-01-14-ortho-linear-keyboard-planck</guid><link>https://krymtkts.github.io/posts/2019-01-14-ortho-linear-keyboard-planck</link><title>Ortho-Linear Keyboard "Planck"</title><description>&lt;p&gt;わたしが&lt;a href="https://olkb.com/planck/"&gt;Planck&lt;/a&gt;を手に入れたのは割と遅めのタイミング。&lt;/p&gt;&lt;p&gt;2017年の春に&lt;a href="https://www.massdrop.com/"&gt;Massdrop&lt;/a&gt;で買って、6月末に届く予定だったのだけど、手元に届いたのが秋頃だった。jackhumbertさん(OLKBの中の人)随分忙しかったようで遅れまくり。&lt;/p&gt;&lt;p&gt;普段の仕事では&lt;a href="https://ergodox-ez.com/"&gt;Ergodox EZ&lt;/a&gt;を使ってるんやが、持ち運びに便利なminimalなキーボードが欲しくて買った。&lt;/p&gt;&lt;p&gt;以下はその作業ログである。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;&lt;em&gt;date: 2017-10-07&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2019-01-14-planck/planck-case-keyswitches.jpg" alt="者共" /&gt;&lt;/p&gt;&lt;p&gt;ケース付き、キースイッチ付きでDIYキットを購入。キースイッチはCherry MX Clear。&lt;/p&gt;&lt;h3 id="はじめに"&gt;はじめに&lt;/h3&gt;&lt;h4 id="手順の理解"&gt;手順の理解&lt;/h4&gt;&lt;p&gt;Jack Humbert氏のYoutubeを見てイメージを掴む。&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=S2FApwzVxAQ"&gt;How to Actually Build a Planck (or Preonic or Atomic) from OLKB&lt;/a&gt;&lt;/p&gt;&lt;p&gt;説明動画を見てケッコー以外だったのが、key switchの端子の歪みを素手で直してた所。ピンセットとか使わないんや...&lt;/p&gt;&lt;h3 id="作業に入る"&gt;作業に入る&lt;/h3&gt;&lt;h4 id="検品"&gt;検品&lt;/h4&gt;&lt;p&gt;&lt;img src="/img/2019-01-14-planck/planck-picking.jpg" alt="パーツ欠品確認" /&gt;&lt;/p&gt;&lt;p&gt;パーツは全部揃っている。数も数えたしOK&lt;/p&gt;&lt;p&gt;一箇所Switch Plateに多分プレス時にズレかなんかあったであろう痕があってちょっと残念。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2019-01-14-planck/planck-unfortunate.jpg" alt="プレスミス？" /&gt;&lt;/p&gt;&lt;p&gt;PCBはUSBに接続して音がなればOKとのこと。ファンシーなnoiseが奏でられた&lt;/p&gt;&lt;p&gt;PlanckはLEDにも対応してるけど、今回はデフォ実装するためナシ。でも今後欲しい感じもする。&lt;/p&gt;&lt;h4 id="switchはめ込み"&gt;Switchはめ込み&lt;/h4&gt;&lt;p&gt;Sitch PlateにKey Switchをはめる&lt;/p&gt;&lt;p&gt;48Keyで使う。ちょっと数が多いしはめ込むのは面倒だけど、黙々とやる。
KeySwitchの端子がひん曲がっているやつはピンで直しながらはめ込んでいきく。&lt;/p&gt;&lt;p&gt;真ん中の1 or 2 keyがえらべるところはPCBにはんだ付けするまでswitchがスライドするので注意。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2019-01-14-planck/planck-half.jpg" alt="半分まではめ込んだ" /&gt;&lt;/p&gt;&lt;p&gt;全部はめ込んだ痕でSwitch Plateの裏表があるっぽいことに気づく。裏側のほうがピカピカしてる。でも傷が多いので今のままで行こうと決定&lt;/p&gt;&lt;h4 id="soldering"&gt;Soldering&lt;/h4&gt;&lt;p&gt;マスクを着用。&lt;/p&gt;&lt;p&gt;今回ハンダゴテを新調した。白光のいいやつで温度調節ができる。調べた感じだとkeyboardのPCBにはんだ付けする最適温度が350とのことなので、それがえらべるのが良い。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2019-01-14-planck/planck-solders.jpg" alt="ハンダゴテ比較" /&gt;&lt;/p&gt;&lt;p&gt;ギターの配線用に使ってた旧・ハンダゴテとは随分と違う...&lt;/p&gt;&lt;p&gt;黙々とはんだ付けする。格子状に並んでいるので非常に楽。いやハンダゴテが良いモノだからなのかも。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2019-01-14-planck/planck-soldering.jpg" alt="作業中" /&gt;&lt;/p&gt;&lt;p&gt;はんだ付け完了したのがこちら。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2019-01-14-planck/planck-soldered.jpg" alt="はんだ付け完了" /&gt;&lt;/p&gt;&lt;p&gt;ところどころ熱で弾けたであろうヤニが付いてるので、組込前に掃除にした。&lt;/p&gt;&lt;h4 id="keycapはめ込み"&gt;keycapはめ込み&lt;/h4&gt;&lt;p&gt;今回keycapはセットで買えたXDAのやつにした。もちろん印字なんかは不要。&lt;/p&gt;&lt;p&gt;作業中の写真なし。無念の撮り忘れ😭&lt;/p&gt;&lt;p&gt;完成！&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2019-01-14-planck/planck-complete.jpg" alt="美しい完成品" /&gt;&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;...最後のfirmwareのビルドのところがログに残ってないのだけど、Ergodox EZのキーマップをビルドするDockerでできてたような気がする。firmwareも書き込み済み。&lt;/p&gt;&lt;p&gt;当時使ってたPCではプログラミングしなくなったのと、改めてQMK firmwareのdocument見たらbuild toolsんとこの記事が変わってるので、今度環境構築がてら再確認してfirmwareのとこだけ新しく書こうと思ってる(作業中)。&lt;/p&gt;&lt;p&gt;わたしのkeymapのrepo(&lt;a href="https://github.com/krymtkts/qmk_firmware"&gt;krymtkts/qmk_firmware&lt;/a&gt;)は「デフォのキーマップをコピった」的なコミットを最後に止まってるので、旧PCに遺物が残されてそう😅&lt;/p&gt;&lt;p&gt;去年はWSLで書き込む方法が確か使えてたはずだけど今は非推奨になってて、MSYS2を使う方法が主流になった？？？謎い🤔&lt;/p&gt;&lt;p&gt;にしてもや、この文章を認めるためにOLKBのページを久しぶりに見たが、今のPCBはrevision.6で、hot swappableなkey switch、接続はUSB Type-Cという進化っぷりに驚きを隠せない😰わたしのはrev.5かそれ以前(忘れた)&lt;/p&gt;</description><pubDate>Mon, 14 Jan 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-01-10-make-blog-with-clojure</guid><link>https://krymtkts.github.io/posts/2019-01-10-make-blog-with-clojure</link><title>Clojureでブログを作った</title><description>&lt;p&gt;このブログはClojure製の静的サイトジェネレータ&lt;a href="http://cryogenweb.org/"&gt;Cryogen&lt;/a&gt;で作った。&lt;/p&gt;&lt;h3 id="動機"&gt;動機&lt;/h3&gt;&lt;p&gt;現在有給消化中のため暇である。プログラマ的暇潰しが必要だったのだが、ブログを作るのはそれなりに楽しめそうな気がした。&lt;/p&gt;&lt;p&gt;あと、過去にブログサービスを使ってたときブログが長続きしなかった理由に、わたしは物書きじゃあないので簡単にブログが書けるとかいう部分が琴線に触れない、というようなものが根底にあるような気もする🤔&lt;/p&gt;&lt;p&gt;自分で作るならその心配はない。&lt;/p&gt;&lt;p&gt;ついでに折角GitHubのアカウントも持ってるので、GitHub Pagesを使わない手はない。blogのコードをrepoに登録しておけば芝生も青々としてええな！的な。&lt;/p&gt;&lt;p&gt;また別の観点としてブログサービスを選ぶとなった場合、書く記事の内容が技術的なものだったり単なる趣味の話だったり内容がブレると思うので、利用規約に触れて垢バンされるようなサービスは選び辛い。ちょうど良い選択かも知れない。&lt;/p&gt;&lt;p&gt;そこで今回はブログ自体を自分で作ってしまおうと決めた。&lt;/p&gt;&lt;p&gt;因みにClojureを選んだのは個人的な好みである。&lt;/p&gt;&lt;h3 id="静的サイトジェネレータの選定"&gt;静的サイトジェネレータの選定&lt;/h3&gt;&lt;p&gt;普通にググって調べようと思ってたけど、いまはこんなのクソ便利なんがあるのね...→&lt;a href="https://www.staticgen.com/"&gt;StaticGen&lt;/a&gt;&lt;/p&gt;&lt;p&gt;LanguageをClojureにしたら3個hitしたのでそれぞれ見てみた。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/cryogen-project/cryogen"&gt;Cryogen&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/liquidz/misaki"&gt;Misaki&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/hashobject/perun"&gt;Perun&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Misakiは永らくメンテされてないからなし。
CryogenもPerunも、検索したら日本語の情報にhitするのでやりがいに違いはなさそう。
単純に⭐が多いのとBootを使ったことがないというだけの理由で&lt;a href="https://github.com/cryogen-project/cryogen"&gt;Cryogen&lt;/a&gt;を使うことにした。&lt;/p&gt;&lt;p&gt;(後知恵だが、ここはもっと慎重に考えた方が良かった)&lt;/p&gt;&lt;h3 id="cryogenを使ってぶろぐを作ろうぜ"&gt;&lt;a href="https://github.com/cryogen-project/cryogen"&gt;Cryogen&lt;/a&gt;を使ってぶろぐを作ろうぜ&lt;/h3&gt;&lt;p&gt;ドキュメントが充実してるので、書いたてることに従うだけで簡単にできた。&lt;/p&gt;&lt;p&gt;出来上がったコードはこちら→&lt;a href="https://github.com/krymtkts/blog-cryogen"&gt;My personal blog project&lt;/a&gt;&lt;/p&gt;&lt;p&gt;以降に記すコマンド例はPowerShellで実行したものである。筆者はWindows10ユーザなので。&lt;/p&gt;&lt;h4 id="手始めに"&gt;手始めに&lt;/h4&gt;&lt;p&gt;Leiningenでテンプレートを作成する。&lt;/p&gt;&lt;pre&gt;&lt;code class="poershell"&gt;lein new cryogen blog
Retrieving cryogen/lein-template/0.3.7/lein-template-0.3.7.pom from clojars
Retrieving leinjacker/leinjacker/0.4.2/leinjacker-0.4.2.pom from clojars
Retrieving org/clojure/core.contracts/0.0.1/core.contracts-0.0.1.pom from central
Retrieving org/clojure/pom.contrib/0.0.26/pom.contrib-0.0.26.pom from central
Retrieving org/clojure/core.unify/0.5.3/core.unify-0.5.3.pom from central
Retrieving cryogen/lein-template/0.3.7/lein-template-0.3.7.jar from clojars
Retrieving org/clojure/core.contracts/0.0.1/core.contracts-0.0.1.jar from central
Retrieving org/clojure/core.unify/0.5.3/core.unify-0.5.3.jar from central
Retrieving org/clojure/clojure/1.4.0/clojure-1.4.0.jar from central
Retrieving leinjacker/leinjacker/0.4.2/leinjacker-0.4.2.jar from clojars
Generating fresh 'lein new' Cryogen project.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ブログを動かしてみよう&lt;/p&gt;&lt;pre&gt;&lt;code class="poershell"&gt;lein ring server
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ブラウザに表示された。OK👍&lt;/p&gt;&lt;h4 id="コンテンツを整理する"&gt;コンテンツを整理する&lt;/h4&gt;&lt;p&gt;わたしの場合はMarkdownで書くのでAsciiDocのディレクトリは消してしまう。サーバ起動中にこれをやると例外が発生する、止めてからやるのが良いだろう。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Remove-Item -Recurse -Path ./resources/templates/ascii
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;あとsampleで置いてあるpostやaboutを自分用に書き換えるなど。&lt;/p&gt;&lt;h4 id="テーマを作る"&gt;テーマを作る&lt;/h4&gt;&lt;p&gt;themeはデフォで&lt;code&gt;blue&lt;/code&gt;, &lt;code&gt;blue_centered&lt;/code&gt;, &lt;code&gt;lotus&lt;/code&gt;, &lt;code&gt;nucleus&lt;/code&gt;の4種類置いてある。&lt;code&gt;lotus&lt;/code&gt;を使うとエラーになったけど、これを直すのが目的じゃないので無視した🙈&lt;/p&gt;&lt;p&gt;自分用のテーマとしては何が良いかな？と検討して、お気に入りのSolarizedにしようと決めた。terminalやeditorはSolarized darkを使っているが、ブログはlightでやろうと思う。syntax highlightingについてはいつも通りのdarkを採用することにした。&lt;/p&gt;&lt;p&gt;&lt;a href="https://ethanschoonover.com/solarized/"&gt;Solarized&lt;/a&gt;を参考に自分でthemeを作る。元にするのは&lt;code&gt;blue_centered&lt;/code&gt;にした。ブラウザの開発者ツールで見てみてもレスポンシブデザインになってたし、cssのコード量も少なくてシンプルなのがいい。&lt;/p&gt;&lt;p&gt;&lt;code&gt;resources/templates/themes&lt;/code&gt;にファイル名&lt;code&gt;solarized_light&lt;/code&gt;でコピって書き換える。&lt;/p&gt;&lt;p&gt;基本は書いたあるルールに沿うけど一部それとなく変える。カラーコードの編集はsassにしたら楽だろうけどコピった元はそうじゃないので、該当する箇所を書き換えるだけに留めた。&lt;/p&gt;&lt;p&gt;Cryogenのsyntax highlightingは&lt;code&gt;highlight.js&lt;/code&gt;が採用されている。
デフォの24種だと使わないやつもいるので削って、使いそうな言語を足したものを&lt;a href="https://highlightjs.org/download/"&gt;highlight.js&lt;/a&gt;で作ってダウンロードする。
これは手動でダウンロードして、デフォの&lt;code&gt;highlight.pack.js&lt;/code&gt;に上書きした。&lt;/p&gt;&lt;p&gt;スタイルは&lt;code&gt;base.html&lt;/code&gt;で&lt;code&gt;default&lt;/code&gt;が指定されているので&lt;code&gt;solarized_dark&lt;/code&gt;を選ぶ。ついでにhighlight.jsのversionも9.7から9.13.1へ上げちゃう。&lt;/p&gt;&lt;p&gt;404 Page not foundのときのページがどうやって表示されるのかわからなかったが、GitHub Pagesの機能で提供されるルールに従えば良い様子。&lt;/p&gt;&lt;p&gt;&lt;a href="https://help.github.com/articles/creating-a-custom-404-page-for-your-github-pages-site/"&gt;Customizing GitHub Pages / Creating a custom 404 page for your GitHub Pages site&lt;/a&gt;&lt;/p&gt;&lt;p&gt;デフォの404ページのスタイルが他のページとぜんぜん違うので、スタイルに合わせておいた。&lt;/p&gt;&lt;p&gt;ページが縦に長くなって垂直スクロールバーが出るとコンテンツのズレが生じるのだけど、これ多分bootstrapに起因する問題か🤔悩ましいが一旦そのままに。&lt;/p&gt;&lt;p&gt;これでおおよそのデザイン面は完成した。&lt;/p&gt;&lt;p&gt;作業中のコードは一旦BitBucketのprivate repoにブチ込んでおいたのだけど、GitHubの無償アカウントでもprivate repoが使えるようになって分ける理由がなくなってしまった...まあよし。&lt;/p&gt;&lt;p&gt;あと、&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Bootstrap3から4に上げたい&lt;/li&gt;&lt;li&gt;Google Analytics&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;など残しているが、一旦はコンテンツの公開を優先して後回しにする予定。&lt;/p&gt;&lt;h4 id="github-pagesにうｐる"&gt;GitHub Pagesにうｐる&lt;/h4&gt;&lt;p&gt;&lt;a href="https://pages.github.com/"&gt;GitHub Pages&lt;/a&gt;の説明と&lt;a href="http://cryogenweb.org/docs/deploying-to-github-pages.html"&gt;Cryogen - GitHub Pages&lt;/a&gt;を見たらできる。&lt;/p&gt;&lt;p&gt;作るのはユーザーのpageなので、まず&lt;code&gt;krymtkts.github.io&lt;/code&gt;のrepoを作る。
中身は空で。Licenseの選択もなし。&lt;/p&gt;&lt;p&gt;Cryogenのドキュメントに従い、&lt;code&gt;config.edn&lt;/code&gt;の&lt;code&gt;blog-prefix&lt;/code&gt;キーの値は空にする。&lt;/p&gt;&lt;p&gt;あとはCryogenが出力した&lt;code&gt;resource/public&lt;/code&gt;を先程作ったrepoのmasterブランチにpushするのみ。&lt;/p&gt;&lt;p&gt;この出力先&lt;code&gt;resource/public&lt;/code&gt;を変更する方法がわからなかったので、&lt;code&gt;krymtkts.github.io&lt;/code&gt;という名前のシンボリックリンクを作って、あたかもそういう名前のフォルダをGitで管理してる感を醸し出して茶を濁した。&lt;/p&gt;&lt;pre&gt;&lt;code class="poershell"&gt;New-Item -Value '.\blog\resources\public\' -Path './' -Name 'krymtkts.github.io' -ItemType SymbolicLink
cd krymtkts.github.io
git init
echo "# krymtkts.github.io" &amp;gt;&amp;gt; README.md
git add README.md
git commit -m "First commit"
git add .
git commit -m 'Add contents'
git remote add origin git@github.com:krymtkts/krymtkts.github.io.git
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これでわたしのブログがpublishされたのであった🎉&lt;/p&gt;&lt;p&gt;めでたしめでたし...&lt;/p&gt;&lt;h3 id="to-be-continued"&gt;To be continued&lt;/h3&gt;&lt;p&gt;で終わらなかった。&lt;/p&gt;&lt;p&gt;これを作りきって、急激にCryogenに興味がなくなってしまった。&lt;/p&gt;&lt;p&gt;結局の所、テンプレートエンジンにSelmerを使ってることで、HTMLやスタイルの編集自体にClojure感の薄さがあってなんか楽しみがないのかなと。最初から予想できそうな結果やけどな🤔&lt;/p&gt;&lt;p&gt;コンテンツ自体はMarkdownで書くし可搬性があるので記事の更新はしつつ、次段階としてPerunで作り直してみようと思う。&lt;/p&gt;&lt;p&gt;破壊と創造こそが人類の本質ですね(違う&lt;/p&gt;</description><pubDate>Thu, 10 Jan 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-01-08-first-post</guid><link>https://krymtkts.github.io/posts/2019-01-08-first-post</link><title>ブログを始めた</title><description>&lt;p&gt;ブログを始めてみた。&lt;/p&gt;&lt;p&gt;自分のメモを取るのには永らくEvernoteを使ってるのだけど、そういったものをまとめてアウトプットできるものが欲しいなー、と常々思ってた。&lt;/p&gt;&lt;p&gt;ただ過去にブログサービスを使ってたときは大して続かなく、また中等半端にやめかねないなという気持ちもあったのだが、去年アラフォーになったことであるし、不惑ということで一歩踏み出してみたのである。&lt;/p&gt;&lt;p&gt;自己紹介は&lt;a href="../../pages/about"&gt;About Me&lt;/a&gt;を参照いただきたく🙇&lt;/p&gt;&lt;p&gt;当面は自分の作業ログを清書したものを書いていくつもりやけど、もし誰かの目に留まって、何かの役に立ったなら幸いである。&lt;/p&gt;</description><pubDate>Tue, 08 Jan 2019 00:00:00 +0900</pubDate></item></channel></rss>