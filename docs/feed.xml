<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><atom:link href="https://krymtkts.github.io/" rel="self" type="application/rss+xml"/><title>krymtkts</title><link>https://krymtkts.github.io/</link><description>krymtkts's personal blog</description><lastBuildDate>Sun, 27 Aug 2023 11:52:11 +0900</lastBuildDate><generator>clj-rss</generator><item><guid>https://krymtkts.github.io/posts/2023-08-27-github-streak-a-year</guid><link>https://krymtkts.github.io/posts/2023-08-27-github-streak-a-year</link><title>GitHub streak a year</title><description>&lt;p&gt;&lt;a href="/posts/2023-05-14-rebuild-blog-with-fable-pt3"&gt;5 月の日記で触れた&lt;/a&gt; GitHub Streak が 2023-08-21 ようやく 365 日に到達した。やったね。
次は 730 日を目指すのだけど、マイルストンとしてまずキリよい 400 を置き、次に 500, 600 と目指していく。&lt;/p&gt;&lt;p&gt;Streak にこだわりだしたのは、生涯プログラマであろうとしたらやっぱり日々の鍛錬というか毎日コード書いて感覚を保ちたいよな、というのが根底にある。&lt;/p&gt;&lt;p&gt;とはいえコードを書いてない日、例えばにこの日記のような文章を書くだけのコミットもあるし、 GitHub Streak って Issue や review でも数えられるので厳密ではないのだけど。
でもそのくらいの緩さじゃないと初めから続けられなかっただろうし、ちょうど良い落とし所であろう。&lt;/p&gt;&lt;p&gt;Streak が途絶えたとて何ら困ることないのだけど、途絶えると取り戻すのに同等の時間がかかるものは、続ける方向に適度にプレッシャーが発生して良い。
特にゲーマー脳を少なからず持っていれば、トロコン感覚を持って臨める。
積み重ねてきたものって割と簡単にやめる事ができるので、このような強制力を持って習慣を維持するのは良い案だと感じている。&lt;/p&gt;&lt;p&gt;しかしながら Streak を始めてから今に至るまで、仕事や私生活において日々の生活リズムが狂うようなインパクトの大きい出来事が一度も起こってない。
つまるところそういったインパクトがあったときにも続けられるというサンプルが無いわけだから、もしものときに上手く続けられるかは定かではない。
今の自分ならそういう状況でも淡々とこなせそうな気配は薄っすら感じるが、これも Streak を続けてきたことで得た感触だろう。ゆーても油断は禁物やけど。&lt;/p&gt;&lt;p&gt;次の目標 400 はもうすぐなので、堅実に次につなげていこう。&lt;/p&gt;</description><pubDate>Sun, 27 Aug 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-08-20-writing-cmdlet-in-fsharp-pt21</guid><link>https://krymtkts.github.io/posts/2023-08-20-writing-cmdlet-in-fsharp-pt21</link><title>F# でコマンドレットを書いてる pt.21</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;pocof&lt;/a&gt; の開発をした。
&lt;a href="/posts/2023-07-16-writing-cmdlet-in-fsharp-pt20"&gt;pocof のコンパイルを .NET 7 にした&lt;/a&gt; こともあってなんかテンション的に触りやすくなった(逆に Fable でブログ書き直す方を放置)。
&lt;a href="/posts/2023-08-13-test-publish-psresource"&gt;PSResourceGet への乗り換え&lt;/a&gt; もできたのだけど、その時気になることがあった。&lt;/p&gt;&lt;p&gt;いつかはやらないといけないと考えていたが、配布 DLL が多すぎる。
&lt;a href="https://www.powershellgallery.com/packages/pocof/0.5.0-alpha"&gt;PowerShell Gallery | pocof 0.5.0-alpha&lt;/a&gt; の FileList 見たらわかるけどめちゃくちゃ DLL がある。
pocof で使ってない DLL もいっぱい含まれている。&lt;/p&gt;&lt;p&gt;これは...解決したい。&lt;/p&gt;&lt;p&gt;.NET では実行可能ファイルであれば自己完結型と言われる単一バイナリの生成ができるのだけど、 DLL ではそういうのはない様子。
PowerShell モジュールの場合どういう手段が取れるのかちゃんと理解してなかったが、こういうこと ↓ で大量の DLL 全部ぶちまけられてた。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://www.nuget.org/packages/Microsoft.PowerShell.SDK/#versions-body-tab"&gt;Microsoft.PowerShell.SDK&lt;/a&gt; を参照してる&lt;/li&gt;&lt;li&gt;F# の各言語に localize されたリソースの DLL が出力される&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;これらに対処してバンドルに含まれる DLL を減らしてみた。 &lt;a href="https://github.com/krymtkts/pocof/pull/57"&gt;#57&lt;/a&gt;&lt;/p&gt;&lt;h3 id="microsoftpowershellsdk"&gt;Microsoft.PowerShell.SDK&lt;/h3&gt;&lt;p&gt;pocof のような PowerShell モジュールは PowerShell のランタイム内で動く。
また pocof では PowerShell の機能をモリモリ使って出力結果を生成するようなことがない。
このようなケースでは、 &lt;a href="https://github.com/PowerShell/PowerShellStandard"&gt;PowerShell/PowerShellStandard&lt;/a&gt; のリファレンスライブラリだけでいいみたい。&lt;/p&gt;&lt;p&gt;pocof で &lt;code&gt;Microsoft.PowerShell.SDK&lt;/code&gt; を &lt;code&gt;PowerShellStandard.Library&lt;/code&gt; に入れ替えて全テスト実行してみた。
テストデータ作成のために &lt;code&gt;PSObject&lt;/code&gt; を作成しているところだけ影響があった。
つまり pocof 本体に影響はないので、テストプロジェクトで &lt;code&gt;Microsoft.PowerShell.SDK&lt;/code&gt; を参照してれば OK ということ。&lt;/p&gt;&lt;p&gt;&lt;a href="/posts/2022-05-07-start-to-write-cmdlet-by-fsharp"&gt;一番初めに pocof を書き始めた&lt;/a&gt;ころの記事では &lt;code&gt;PowerShellStandard.Library&lt;/code&gt; を参照してたのだけどなんか途中で変えてみたい。
初回リリースでは既に &lt;code&gt;Microsoft.PowerShell.SDK&lt;/code&gt; に変わってたのだけど、この頃は &lt;a href="https://fsprojects.github.io/FsUnit/"&gt;FsUnit&lt;/a&gt; 使ったテストなかった気がするし、違う理由かなんか分からず変えてそう。コミットログ追えばわかるかな。&lt;/p&gt;&lt;h3 id="f-の-localize-されたリソースの-dlls"&gt;F# の localize されたリソースの DLLs&lt;/h3&gt;&lt;p&gt;pocof では localize されたリソースの DLL 要らない。なんか F# のリソースが使われるとしても英語でいいし。
これらの各言語リソースの DLL を取り除くには &lt;code&gt;SatelliteResourceLanguages&lt;/code&gt; という MSBuild プロパティを指定すれば良いようだ。言語を指定せずに空(&lt;code&gt;null&lt;/code&gt;)だと全言語対象のママになるので、英語を指定しないといけない。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://forums.fsharp.org/t/what-is-the-purpose-of-the-fsharp-core-resource-dll-files/1402"&gt;What is the purpose of the FSharp.Core.resource.dll files? - General - F# Software Foundation Community Forums&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/core/project-sdk/msbuild-props#satelliteresourcelanguages"&gt;SatelliteResourceLanguages | Microsoft.NET.Sdk の MSBuild プロパティ - .NET | Microsoft Learn&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="終わり"&gt;終わり&lt;/h3&gt;&lt;p&gt;MUSBuild の世界は難しいなー。でもこれでかなり DDL が減った。
ただ最後に &lt;code&gt;System.Management.Automation.dll&lt;/code&gt; が残ってる。&lt;/p&gt;&lt;p&gt;これって PowerShell 環境ならかならずあるのでは...という気がするのだけど。
open してる名前空間の関係で消えないのかな？もうちょい検証してみないとわからん。&lt;/p&gt;</description><pubDate>Sun, 20 Aug 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-08-13-test-publish-psresource</guid><link>https://krymtkts.github.io/posts/2023-08-13-test-publish-psresource</link><title>Publish-PSResource を試す</title><description>&lt;p&gt;&lt;a href="/posts/2023-07-23-psresourceget"&gt;以前から気になってた&lt;/a&gt; PSResourceGet の &lt;code&gt;Publish-PSResource&lt;/code&gt; を試す機会があったので試した。
試したと書いてるけど、自分の利用ケースで問題なく使えるか見ただけ。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/PSJobCanAttendance/"&gt;krymtkts/PSJobCanAttendance&lt;/a&gt; を修正する機会があったので、ついでに &lt;code&gt;Publish-PSResource&lt;/code&gt; へ切り替えた。上手くいってた。
&lt;a href="https://github.com/krymtkts/PSJobCanAttendance/pull/9"&gt;#9&lt;/a&gt;&lt;/p&gt;&lt;p&gt;(追記 2023-08-15)
試したバージョンは以下の通り。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; Get-Module *PSResourceGet; $PSVersionTable | Format-Table

ModuleType Version    PreRelease Name                                ExportedCommands
---------- -------    ---------- ----                                ----------------
Binary     0.5.23     beta23     Microsoft.PowerShell.PSResourceGet  {Find-PSResource, Get-InstalledPSResource, Get-PS…


Name                           Value
----                           -----
PSVersion                      7.3.6
PSEdition                      Core
GitCommitId                    7.3.6
OS                             Microsoft Windows 10.0.22621
Platform                       Win32NT
PSCompatibleVersions           {1.0, 2.0, 3.0, 4.0…}
PSRemotingProtocolVersion      2.3
SerializationVersion           1.1.0.1
WSManStackVersion              3.0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.psresourceget/publish-psresource?view=powershellget-3.x"&gt;Publish-PSResource (Microsoft.PowerShell.PSResourceGet) - PowerShell | Microsoft Learn&lt;/a&gt; を参照して、
&lt;code&gt;Path&lt;/code&gt;, &lt;code&gt;ApiKey&lt;/code&gt;, &lt;code&gt;Verbose&lt;/code&gt;, &lt;code&gt;WhatIf&lt;/code&gt; を使った。
&lt;code&gt;Verbose&lt;/code&gt;, &lt;code&gt;WhatIf&lt;/code&gt; は確認用なのでなくても良い。
&lt;code&gt;Repository&lt;/code&gt; も省略できて、省略した場合は優先度が高い repository に公開される。自分の場合は PowerShell Gallery 。&lt;/p&gt;&lt;p&gt;PSJobCanAttendance の場合は公開するファイルが少ないからか、実行したら一瞬で公開された。 PSResourceGet になったら公開まで高速化されるんや。&lt;/p&gt;&lt;p&gt;これでいけそうな感触を得たので、 pocof でも試す。 &lt;a href="https://github.com/krymtkts/pocof/pull/54"&gt;krymtkts/pocof#54&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;AllowPrerelease&lt;/code&gt; とか &lt;code&gt;RequiredVersion&lt;/code&gt; とかのオプションで指定していたところがなくなって、 &lt;code&gt;*.psd1&lt;/code&gt; から読み取るように変わってるぽい。
ただ &lt;code&gt;ModuleName&lt;/code&gt; とかの指定どうなるんやと思ったけど、ディレクトリ名ぽいな。&lt;/p&gt;&lt;p&gt;ということなので、従来の pocof の公開方法である &lt;code&gt;(Get-Module).Path&lt;/code&gt; を渡す方法は無理だってこと。これだと ddl のパスが得られるのだけどこれは弾かれたし、 &lt;code&gt;*.psd1&lt;/code&gt; のパスを渡す方法だと親ディレクトリがバージョン番号になってモジュール名にならない。 API Key にモジュール名の制限をかけてたから権限で弾かれて変な数字の名前をしたモジュールの公開を免れた。
そこんところを公開用のディレクトリにモジュール類をコピーして、その中の &lt;code&gt;pocof.psd1&lt;/code&gt; を &lt;code&gt;Publish-PSResource&lt;/code&gt; するようにしてみた。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;+---.github
+---coverage
+---docs
+---publish
|   \---pocof &amp;lt;- ここへこぴる
|       \---pocof.psd1
+---src
|   \---pocof
        \---bin
            \---Release
                \---*
                    \---pocof.psd1 &amp;lt;- コピー元
\---tests
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;が、以下のようなエラーでまだ上手くいってない。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Error: 2023-08-13 18:59:25:
At C:\Users\takatoshi\dev\github.com\krymtkts\pocof\psakefile.ps1:108 char:5 +     Publish-PSResource @Params +     ~~~~~~~~~~~~~~~~~~~~~~~~~~ [&amp;lt;&amp;lt;==&amp;gt;&amp;gt;] Exception: Repository 'PSGallery': Response status code does not indicate success: 403 (The specified API key is invalid, has expired, or does not have permission to access the specified package.).
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;公開対象のディレクトリ名がモジュール名になるって判断が間違ってるのか...いけそうな感触を持ったけどあかんのかな、挑戦は続く。&lt;/p&gt;&lt;h3 id="追記-2023-08-14"&gt;追記 2023-08-14&lt;/h3&gt;&lt;p&gt;その後、 PowerShell Gallery の API Key を作り直したり、 pocof のみ更新可能に絞っていた package を &lt;code&gt;*&lt;/code&gt; にして全権与えてみたりしたがダメだった。
DDL の Module に対応してないような旨はどこにもなかった気がするけど。&lt;/p&gt;&lt;p&gt;Issue で気になるものとしては、 prerelease の依存関係を持つケースに対応してないというのがある。
&lt;a href="https://github.com/PowerShell/PSResourceGet/issues/1251"&gt;PSResourceGet module prerelease version scheme issues · Issue #1251 · PowerShell/PSResourceGet&lt;/a&gt;
けど pocof 自身はそういう依存関係を持ってないので該当しないはず。
&lt;del&gt;他の可能性があるとしたら、 prerelease のみのバージョン履歴を持つ場合に未知のバグがあるとかかな。&lt;/del&gt;
普通に自家製バグ、見当外れ。&lt;/p&gt;&lt;p&gt;いかんせん条件が定かでないので、一通り他の PSResourceGet の Cmdlet も試してみるとかが妥当だろうけど、めんどくせえええ...
&lt;del&gt;でも解決しないと pocof のプルリク永久に生き続けるし、事象を調べるか誰かが解決するのを待つか、面倒な選択しかない。&lt;/del&gt;
自家製バグが原因なので時間かけてでも調査して当たり前。&lt;/p&gt;&lt;p&gt;&lt;del&gt;なんかいい感じにサクッとできるつもりだったがそうならなかったのは、我ながら「持ってる」な。しらんけど。&lt;/del&gt;
単に休みボケのケアレスミス発動しただけ。&lt;/p&gt;&lt;h3 id="追記-2023-08-16"&gt;追記 2023-08-16&lt;/h3&gt;&lt;p&gt;昨日この件を調べるためのテストモジュールを書いた。
F# で空のモジュールをサクッと書いて PSResourceGet と PowerShellGet の両方で公開できるようなのを。
でも PowerShellGet でも同じような権限のエラーになった。&lt;/p&gt;&lt;p&gt;それもそのはず普通に自分が書いた psake タスクのバグだったわ...恥ずかし。
API Key を &lt;code&gt;string&lt;/code&gt; で取り出さなあかんとこ &lt;code&gt;PSCredential&lt;/code&gt; がそのまま渡ってた...(&lt;code&gt;SecureString&lt;/code&gt; じゃないんやというのは置いといて)&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof/blob/83e3bf2691a8485a6b2595934845204d21b885a2/psakefile.ps1#L101-L108"&gt;pocof/psakefile.ps1 at 83e3bf2691a8485a6b2595934845204d21b885a2 · krymtkts/pocof&lt;/a&gt;&lt;/p&gt;&lt;p&gt;間違いそのママの差分はこんな感じ。&lt;/p&gt;&lt;pre&gt;&lt;code class="diff"&gt;     $Params = @{
-        Name = $ModuleName
-        NugetAPIKey = (Get-Credential API-key -Message 'Enter your API key as the password').GetNetworkCredential().Password
+        Path = $p.FullName
+        Repository = 'PSGallery'
+        ApiKey = (Get-Credential API-key -Message 'Enter your API key as the password') # ここが終わってる
         WhatIf = $DryRun
         Verbose = $true
-        AllowPrerelease = $true
-        RequiredVersion = $RequiredVersion
     }
-    Publish-Module @Params
+    Publish-PSResource @Params
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;正しいのはこう。&lt;/p&gt;&lt;pre&gt;&lt;code class="diff"&gt;-        ApiKey = (Get-Credential API-key -Message 'Enter your API key as the password')
+        ApiKey = (Get-Credential API-key -Message 'Enter your API key as the password').GetNetworkCredential().Password
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2 日浪費したけど解決してよかったわ。&lt;/p&gt;</description><pubDate>Sun, 13 Aug 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-08-06-disassemble-and-clean-keyswitches</guid><link>https://krymtkts.github.io/posts/2023-08-06-disassemble-and-clean-keyswitches</link><title>キースイッチを分解して掃除する</title><description>&lt;p&gt;ビルドログを書いた記憶ないけど、今は &lt;a href="https://keeb.io/collections/iris-split-ergonomic-keyboard"&gt;Keebio の Iris&lt;/a&gt; Rev. 3 を 3 年くらい使ってる。&lt;/p&gt;&lt;p&gt;キースイッチは &lt;a href="https://zealpc.net/products/zilent?variant=5894832357414"&gt;Zealios Zilent 78g&lt;/a&gt;。買った当時はそこそこ高級品の部類に入ってた記憶で、そのスムースさとタクタイル感の強いタッチがとても気に入っている。&lt;/p&gt;&lt;p&gt;だけど 3 年もすると結構チャタリングを起こすようになってきてる。
どうも利用環境のホコリがスイッチに混入してるのと、 Zilent のキースイッチ内で削りカスみたいなのが発生するぽくて、そいつが接点周りで悪さしてることに拠るみたい。&lt;/p&gt;&lt;p&gt;ホコリというのは一般的な毛ぼこりで、これが打鍵のときに軸の隙間から入り込んだり、 LED 用に開いている穴から侵入してるみたい。キースイッチを分解するとスプリングにホコリが付着していることがママある。&lt;/p&gt;&lt;p&gt;Zilent は軸の側面にスムースさと静音を目的としたシリコン的な緩衝材が埋め込まれてるのだけど、こいつがよく使うキーだとはみ出した部分が徐々に擦れて削りカスになる。
あとこれは Zilent 以外でも起こると思うけど、打鍵が垂直でないことでボトムハウジングと軸が擦れることでプラスチックの粉？が発生する。
こういった削りカスが接点の隙間に挟まって感度が悪くなってる様子。&lt;/p&gt;&lt;p&gt;これらはいずれも実際に自機を分解して目視確認したものだけど、現象が自分の利用環境によるのか一般的なものかはわからない。&lt;/p&gt;&lt;p&gt;こういう具合でなのでよくチャタリングしたキーを自分流で分解して掃除しているのだけど、なんか日記にでも残そうかなと思った次第だ。&lt;/p&gt;&lt;p&gt;分解掃除の道具は以下の通り。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Filco のキープラー
&lt;ul&gt;&lt;li&gt;キーキャップを取るのに使う&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;ダブルクリップの針金部分で自作したキースイッチオープナー
&lt;ul&gt;&lt;li&gt;ダブルクリップの針金部分を適度に曲げると MX Compatible キースイッチに適したオープナーができる。結構使いにくい&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;尼で買った先端の精度が甘い精密ピンセット
&lt;ul&gt;&lt;li&gt;分解時の部品取扱とか、接点の掃除に使う&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;SuperMax っていうインド製の両刃カミソリの替刃についてた謎の樹脂製ヒゲブラシ
&lt;ul&gt;&lt;li&gt;これで顔を洗う気に離れなかったが、キーボードのような細かい隙間があるものの簡単な掃除に便利&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;自作キーオープナーは何処かで誰かのアイデアを見かけて試したら上手くいったので長らく使っている。
キーキャップを外し、キースイッチのツメの部分の穴に合わせて左右にキーオープナーを差し込み、適度につまんで適度にひねりを入れるとトップハウジングがパカっと外せる。
今日日みんなキースイッチは hot swappable だろうからこんな苦しんでキースイッチを分解掃除することないんじゃなかろうか。
このように結構面倒なので、最適なキーオープナーあれば買いたい気持ち。&lt;/p&gt;&lt;p&gt;また、わたしは RSA プロファイルのキーキャップを好んで使っているので、キーオープナーでトップハウジングを外そうとしたら左右のキーキャップが干渉する。なので分解するキースイッチの左右のキーキャップも外しておく必要がある。&lt;/p&gt;&lt;p&gt;なんとかしてキースイッチを分解したら、ピンセットでトップハウジング、軸、スプリングを取り出して、先述のヒゲブラシでボトム含めささっと掃除する。スプリングやボトムのホコリはこれでほぼ取れる。&lt;/p&gt;&lt;p&gt;軸が擦れてできるホコリはピンセットで丁寧に取り除くのが良い(めんどい)。特に毛羽立って取れかかってるシリコン的緩衝材などはブラシで取れない。
また接点部分も同様でにピンセットで丁寧に取り除く。取り除くと言ってもピンセットの先端で何回か接点部分を擦ってやる感じ。&lt;/p&gt;&lt;p&gt;この作業をスイッチの数だけ繰り返す。気が狂いそう。
しかしこれで大体のスイッチは元通りの挙動に直せる。時が経てばまた再発するけど。&lt;/p&gt;&lt;p&gt;注意点すべきは、接点部分の掃除とトップをはめ込む際。あまり無理にピンセットでガシガシやると板バネ部分が曲がって死ぬ。
特にトップをはめ込む向きを間違うと板バネが大変なことになる。わたしの 1 キーはそれでほぼ死んでる。キーマップ的に 1 の代替キーがあってそっちをメインで使ってるからそれほど困らないけど、普通は壊さない方がいい。
板バネが死んだキーははんだを外してキースイッチ自体取り替えるしかない。&lt;/p&gt;&lt;p&gt;この様な作業には集中力を要するし、キースイッチ 1 つ調整するのに数分かかる。
ド近眼の不惑ともなると老眼で細かいものも見にくいので、多少チャタっても打鍵角度や押し込む量を調整してなるべく作業しなくていいように誤魔化してしまうのが現状。&lt;/p&gt;&lt;p&gt;ぐだぐだ文句を書き連ねたけど、調整後のスイッチは概ね素晴らしいタイピング体験を提供してくれるから満足。単にだるくて何度もやりたくないのだ。
つい先日左手側を 7 キーほど掃除した(最高)けど、右手側もまたやらないといけなくてほんとだるい。&lt;/p&gt;&lt;p&gt;もっと簡単にキースイッチのメンテナンスをできるようにキーボード自体や整備環境をアップグレードする方がいいかもと感じる。
けど、次のキーボード何がいいかな～という最大の選択をクリアできないからなんとも進まない。
やるならワイヤレスにしたいとか、 Iris よりキー少なくていいなとか、 lube したらホコリカバーできたりするかな？とか。
そういった試行錯誤を色々考えるだけでも時間かかってるからいつかは着手するやろうけど。&lt;/p&gt;</description><pubDate>Sun, 06 Aug 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-07-30-rebuild-blog-with-fable-pt10</guid><link>https://krymtkts.github.io/posts/2023-07-30-rebuild-blog-with-fable-pt10</link><title>Fable でブログを再構築する pt.10</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/blog-fable"&gt;krymtkts/blog-fable&lt;/a&gt; &lt;a href="https://fable.io/"&gt;Fable&lt;/a&gt; でブログを再構築している。&lt;/p&gt;&lt;p&gt;最近日記には書いてなかったが諸々の Issue を解決してた。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/blog-fable/pull/24"&gt;#24&lt;/a&gt; &lt;a href="https://github.com/krymtkts/blog-fable/pull/27"&gt;#27&lt;/a&gt; &lt;a href="https://github.com/krymtkts/blog-fable/pull/32"&gt;#32&lt;/a&gt; &lt;a href="https://github.com/krymtkts/blog-fable/pull/34"&gt;#34&lt;/a&gt; RSS の実装。&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/blog-fable/pull/31"&gt;#31&lt;/a&gt; 出力パス構築を整理するために、手始めとしてエントリポイントの設定を整理。&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/blog-fable/pull/37"&gt;#37&lt;/a&gt; 生 JS の排除。&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/blog-fable/pull/25"&gt;#25&lt;/a&gt; &lt;a href="https://github.com/krymtkts/blog-fable/pull/28"&gt;#28&lt;/a&gt; あと雑多な更新。&lt;/li&gt;&lt;/ul&gt;&lt;hr /&gt;&lt;p&gt;RSS はやっぱわたしがほぼ素人だったのもあってわからないことが多かった。
はじめは普段遣いしている &lt;a href="https://feedly.com/"&gt;feedly&lt;/a&gt; で購読してみて目視で変なところを直した。
最終的には &lt;a href="https://validator.w3.org/feed/check.cgi?url=https%3A%2F%2Fkrymtkts.github.io%2Fblog-fable%2Ffeed.xml"&gt;Feed Validator Results: https://krymtkts.github.io/blog-fable/feed.xml&lt;/a&gt; でエラーを解消する形にした。こんな便利なものがあるとは。とても役に立った。&lt;/p&gt;&lt;p&gt;RSS 周りの実装で改めて Fable が割る言い訳じゃないけど Fable のツラみを感じた。それは JavaScript の API がモロに出てくるところだ。
今回は feed の &lt;code&gt;pubDate&lt;/code&gt; の表記を RFC 822 date format にする必要があって、 &lt;code&gt;Intl.DateTimeFormat&lt;/code&gt; を使った。
こういうとき素直に .NET が使えるととても楽やのに...と思わざるを得ない。&lt;/p&gt;&lt;p&gt;いったんこういう ↓ 激薄 binding を書いて、 &lt;code&gt;obj&lt;/code&gt; を引き回すことで無理くり使っている。&lt;/p&gt;&lt;pre&gt;&lt;code class="fsharp"&gt;module Intl =
    [&amp;lt;Emit "new Intl.DateTimeFormat([$0], $1)"&amp;gt;]
    let DateTimeFormat lang options = jsNative
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="fsharp"&gt;module DateTime =
    open System

    let options: obj =
        !!{| weekday = "short"
             year = "numeric"
             month = "short"
             day = "2-digit"
             hour = "numeric"
             minute = "numeric"
             second = "numeric"
             hourCycle = "h23"
             timeZone = "Asia/Tokyo" // TODO: parametarize it.
             timeZoneName = "short" |}

    // TODO: write binding.
    let formatter: obj = Intl.DateTimeFormat "en-US" options
    let zonePattern = new Regex(@"GMT([+-])(\d+)")

    let toRFC822DateTime (d: DateTime) =
        let parts: obj [] = formatter?formatToParts (d)
        let p: string [] = parts |&amp;gt; Array.map (fun x -&amp;gt; x?value)
        let d = $"{p.[0]}{p.[1]}{p.[4]} {p.[2]} {p.[6]}"
        let t = (p.[8..12] |&amp;gt; String.concat "")

        let z =
            match p.[14] with
            | "UTC" -&amp;gt; "+0000"
            | z -&amp;gt;
                let item = zonePattern.Matches(z)
                let group = item.Item 0
                let op = (group.Groups.Item 1).Value
                let offset = int (group.Groups.Item 2).Value

                $"{op}%02d{offset}00"

        $"{d} {t} {z}"
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;日付操作のための module 入れればいいってだけでもあるけど、このためだけに module いれるのもなあ...となるべく自力で解決する方向。&lt;/p&gt;&lt;p&gt;ただ TODO 残してるのもあるけど、それより Dynamic typing で危なっかしいしちゃんと binding を書きたいところ。
あと添字でアクセスしまくるしか方法思いつかんかったけどもっとマシなのないのかな...&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/blog-fable/pull/37"&gt;#37&lt;/a&gt; で開発モードでの live reloading するために使ってた生 JavaScript を Fable が出力したやつを使うように変えた。&lt;/p&gt;&lt;p&gt;普通であれば webpack とかで bundling するんやろけど、開発モード以外で JavaScript を使う予定がないので、出力された js ファイルを出力先ディレクトリにコピることで実現している。
他に方法あるかわからん。
ただブラウザでもそのまま使える js ファイルを出力する豆知識は得られた。&lt;/p&gt;&lt;pre&gt;&lt;code class="fsharp"&gt;open Browser.Dom
open Browser.WebSocket

let private init _ =
    let ws = WebSocket.Create $"ws://{window.location.host}/websocket"
    ws.onmessage &amp;lt;- fun _ -&amp;gt; window.location.reload ()

window.addEventListener ("load", init)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これ ↑ がこう ↓ なる。 &lt;code&gt;private&lt;/code&gt; をつけておいたら &lt;code&gt;export&lt;/code&gt; されない。&lt;/p&gt;&lt;pre&gt;&lt;code class="js"&gt;function init(_arg) {
  const ws = new WebSocket(`ws://${window.location.host}/websocket`);
  ws.onmessage = (_arg_1) =&amp;gt; {
    window.location.reload();
  };
}

window.addEventListener("load", (arg00$0040) =&amp;gt; {
  init(arg00$0040);
});
&lt;/code&gt;&lt;/pre&gt;&lt;hr /&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/blog-fable/pull/31"&gt;#31&lt;/a&gt; でエントリポイントの render 関数で諸々の設定をするように変えた。
元々好きに関数を組み合わせて出力を作れたらいいかなと思ってたけど、それぞれの関数で整合性を取らないといけない点があってめんどい、というのが設定を導入した理由。&lt;/p&gt;&lt;p&gt;ひとまずこれで外向きのインタフェースは固定して、あとは内側の重複したパス構築部分をまとめていけたら、楽に整合性取れるんじゃないかな。&lt;/p&gt;&lt;p&gt;8 月くらいにできるかなーって思ってたけど、使わない CSS を読んでるやつとかも使ってるやつだけビルドして出せるようにしたいとか、諸々考え出すと実際のところ無理かな。
気長にいこ。&lt;/p&gt;</description><pubDate>Sun, 30 Jul 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-07-23-psresourceget</guid><link>https://krymtkts.github.io/posts/2023-07-23-psresourceget</link><title>PSResourceGet メモ</title><description>&lt;p&gt;&lt;a href="https://github.com/PowerShell/PSResourceGet"&gt;PSResourceGet&lt;/a&gt; を使い始めてまだちょっとだが、明らかに変わったことがある。
これ PowerShellGet v2 より圧倒的に速いな。
PowerShellGet v3 時代からインストールするようにはしてたけど日々使ってなかったから気づいてなかった。&lt;/p&gt;&lt;p&gt;ただ &lt;a href="/posts/2023-07-09-migrate-dev-environment#PSResourceGet"&gt;開発環境をプチ移行する&lt;/a&gt; にも追記したように、 v3 には &lt;code&gt;Get-PSResource&lt;/code&gt; みたいなややこしい Cmdlet もいる。
PSResourceGet を入れてるなら v3 の方は消しとくのが無難。&lt;/p&gt;&lt;p&gt;なのでこの度普段定期的にしかやってなかった古いモジュールの整理をした。既に誰でもやってそうだが習慣的に行えるよう関数にした。
なおこの関数、モジュール依存関係を壊すようなのがあればエラーになるだろう。
それを回避したければ &lt;code&gt;-SkipDependencyCheck&lt;/code&gt; 足してもいいかもだが、とりあえず壊れたときめんどいのでやめた(壊れたモジュール使うまで気づけなさそう)。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function Uninstall-OutdatedModules {
    [CmdletBinding(SupportsShouldProcess)]
    param()
    Get-InstalledPSResource -Scope AllUsers | Group-Object -Property Name | Where-Object -Property Count -GT 1 | ForEach-Object {
        $_.Group | Sort-Object -Property Version -Descending | Select-Object -Skip 1
    } | Uninstall-PSResource -Scope AllUsers
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上記の関数の通り、 &lt;code&gt;Get-InstalledPSResource&lt;/code&gt; は複数 ver 入ってるとそのままあるだけ返してくれる。
v2 時代は &lt;code&gt;Get-Module&lt;/code&gt; しないとダメだったのは &lt;a href="/posts/2022-11-12-clean-up-pwsh-modules"&gt;以前書いた PowerShell モジュールの大掃除日記&lt;/a&gt; でのこと。時代は変わったな。&lt;/p&gt;&lt;p&gt;また、こういう処理も v2 であれば &lt;code&gt;Get-InstalledModule&lt;/code&gt; は結構遅かったのが、 PSResourceGet になってとても速くなった。&lt;/p&gt;&lt;p&gt;AllUsers の scope に 30 位のモジュールがある。
実行するのは自環境、 Razer Blade Stealth 13 Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz 2.00 GHz, Windows 11 22H2, PowerShell 7.3.6 にて。
初回の実行で v2 だと 1 秒くらい、 PSResourceGet だと 50ms 未満。
ショボマシンでこの差は結構でかいな。何らかのローカルなデータストアにキャッシュでもしてんのかな PSResourceGet は。&lt;/p&gt;&lt;p&gt;MS の PowerShell Team の blog 読んだらここに書いたようなこと書いてたかもだが、改めて自分で試してみて新しいツールの利用が身体化されてる感じはするな。&lt;/p&gt;&lt;p&gt;あと &lt;a href="https://github.com/krymtkts/pocof/"&gt;pocof&lt;/a&gt; で気になってる &lt;code&gt;Publish-PSResource&lt;/code&gt; のテストモジュール使った動作確認は未だやってない(めんどくて)。
のでそろそろ手を付けないといけないけど、 web のどっかで情報出てきたらうれしいのだけど。&lt;/p&gt;&lt;p&gt;そういや勤怠スクリプト類などの他の PowerShell モジュールのこと忘れてた。今年の秋には PSResourceGet 対応しとかないとあかんか。&lt;/p&gt;</description><pubDate>Sun, 23 Jul 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-07-16-writing-cmdlet-in-fsharp-pt20</guid><link>https://krymtkts.github.io/posts/2023-07-16-writing-cmdlet-in-fsharp-pt20</link><title>F# でコマンドレットを書いてる pt.20</title><description>&lt;p&gt;久しぶりに &lt;a href="https://github.com/krymtkts/pocof"&gt;pocof&lt;/a&gt; の開発をした。
ゆーても .NET 6 → .NET 7 と、 PowerShellGet → PSResourceGet だけ。&lt;/p&gt;&lt;h3 id="net-6--net-7-53"&gt;.NET 6 → .NET 7 &lt;a href="https://github.com/krymtkts/pocof/pull/53"&gt;#53&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;ASP.NET じゃないけどこれがやることわかりやすくまとまってたので参考にした。
&lt;a href="https://learn.microsoft.com/en-us/aspnet/core/migration/60-70?view=aspnetcore-7.0&amp;amp;tabs=visual-studio-code"&gt;Migrate from ASP.NET Core 6.0 to 7.0 | Microsoft Learn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;SDK を &lt;code&gt;global.json&lt;/code&gt; で固定するようにした。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;dotnet new globaljson --sdk-version 7.0.306 --roll-forward latestFeature
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;その後 &lt;code&gt;*.fsproj&lt;/code&gt; の &lt;code&gt;TargetFramework&lt;/code&gt; を net6.0 → net7.0 にする。
&lt;code&gt;global.json&lt;/code&gt; の作成に先んじて &lt;code&gt;TargetFramework&lt;/code&gt; を変更してビルドするとうまくいかなかったが、変えるとすんなりいった。キャッシュの影響？&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.nuget.org/packages/Microsoft.PowerShell.SDK/7.3.6"&gt;NuGet Gallery | Microsoft.PowerShell.SDK 7.3.6&lt;/a&gt;
を見て .NET 7 と互換性がある Microsoft.PowerShell.SDK に変える。
&lt;code&gt;7.2.4&lt;/code&gt; → &lt;code&gt;7.3.6&lt;/code&gt; にした。&lt;/p&gt;&lt;p&gt;これでビルドが通るようになる。&lt;/p&gt;&lt;p&gt;ビルド後に &lt;code&gt;Regex&lt;/code&gt; 周りでエラーが出るようになった。
&lt;code&gt;Regex.IsMatch&lt;/code&gt;メソッドで型推論できなくなった箇所があったので、型注釈して通るようにする。
&lt;code&gt;IsMatch(ReadOnlySpan&amp;lt;Char&amp;gt;)&lt;/code&gt; が .NET 7 から増えたっぽいのでこの影響かなあ。
&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.ismatch?view=net-7.0#system-text-regularexpressions-regex-ismatch(system-readonlyspan((system-char)))"&gt;Regex.IsMatch Method (System.Text.RegularExpressions) | Microsoft Learn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;また例外の文面も変わったらしくて、 1 つのテストケースで期待値を新しいものに合わせた。&lt;/p&gt;&lt;p&gt;GitHub Actions の job で &lt;code&gt;actions/setup-dotnet@v3&lt;/code&gt; に指定してるバージョンも &lt;code&gt;6.0.x&lt;/code&gt; → &lt;code&gt;7.0.x&lt;/code&gt; に変える。&lt;/p&gt;&lt;p&gt;この際 act 使った GitHub Actions の workflow テスト中に Docker が死んでしまった。
最近 disk 容量少なくなってて、 Docker image が pull されたタイミングで枯渇したの原因(一時的に残 100KB くらいになってた。やば)。&lt;/p&gt;&lt;p&gt;解消するために以下を参考にしたが、 dockerd の再起動だけでは解決しなかった。
&lt;a href="https://stackoverflow.com/questions/68218291/docker-error-with-read-only-file-system-unknown/70071216#70071216"&gt;dockerfile - Docker error with read-only file system unknown - Stack Overflow&lt;/a&gt;&lt;/p&gt;&lt;p&gt;結果的に空き容量確保後に PC 再起動したら直った。&lt;/p&gt;&lt;p&gt;これにて .NET 7 化は完了。&lt;/p&gt;&lt;h3 id="powershellget--psresourceget-54"&gt;PowerShellGet → PSResourceGet &lt;a href="https://github.com/krymtkts/pocof/pull/54"&gt;#54&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;変えたのは &lt;code&gt;Publish-Module&lt;/code&gt; → &lt;code&gt;Publish-PSResource&lt;/code&gt; だけ。
&lt;a href="/posts/2023-07-09-migrate-dev-environment"&gt;前回の日記&lt;/a&gt; にも追記したが、 &lt;code&gt;Get-Module&lt;/code&gt; は &lt;code&gt;Microsoft.PowerShell.Core&lt;/code&gt; の持ち物だったので変える必要なかった。&lt;/p&gt;&lt;p&gt;&lt;code&gt;WhatIf&lt;/code&gt; までの確認に留めている。
というのも、結構パラメータが変わっておりホンマにうまく動くんかこれ...というのがあるため。
&lt;a href="https://github.com/PowerShell/PSResourceGet/issues?q=is%3Aissue+is%3Aopen+Publish-PSResource"&gt;PSResourceGet の Issues&lt;/a&gt; 見て &lt;code&gt;Publish-PSResource&lt;/code&gt; の状況をつかもうとしてるがまだまだあんまわからない。
それに &lt;code&gt;Publish-PSResource&lt;/code&gt; の前例を検索してもほぼない。&lt;/p&gt;&lt;p&gt;既存モジュールでいきなりやるのはちょい不安。やるならまずテスト用の module 作ってそれで試すが吉とみた。
が、作るのめんどくせええええ、というのは否めない。&lt;/p&gt;&lt;h3 id="おわり"&gt;おわり&lt;/h3&gt;&lt;p&gt;&lt;a href="/posts/2022-11-27-writing-cmdlet-in-fsharp-pt8"&gt;昔の日記&lt;/a&gt; で書いてた platyPS の prerelease 使うとエラーになる件忘れていてまた引っかかったが、久しぶりの pocof 開発なんとかできてよかった。&lt;/p&gt;</description><pubDate>Sun, 16 Jul 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-07-09-migrate-dev-environment</guid><link>https://krymtkts.github.io/posts/2023-07-09-migrate-dev-environment</link><title>開発環境をプチ移行する</title><description>&lt;p&gt;旧聞だが、 PowerShellGet が PSResourceGet に改名した。
2023 秋の PowerShell 7.4 リリース前には GA するらしいのでそれに移行することとした。&lt;/p&gt;&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/powershell/psresourceget-preview-is-now-available/"&gt;PSResourceGet Preview is Now Available - PowerShell Team&lt;/a&gt;&lt;/p&gt;&lt;p&gt;ついでに VS Code から VS Code Insiders にも移行したのでメモがてら残す。&lt;/p&gt;&lt;h3 id="vs-code-insiders"&gt;VS Code Insiders&lt;/h3&gt;&lt;p&gt;VS Code Insiders にする理由はまだ順番待ちの GitHub Copilot Chat が落ちてきたら即使えるようにするためだ。
もうかなり待っていても来ないが、最新の VS Code じゃないと動かないとかなんとか。&lt;/p&gt;&lt;p&gt;わたしは chocolatey で入れる。これも以下のコマンドを打つだけだ。
&lt;a href="https://community.chocolatey.org/packages/vscode-insiders"&gt;Chocolatey Software | Visual Studio Code Insiders 1.80.0.20230704&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="bat"&gt;choco install vscode-insiders -y
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;VS Code とは別に VS Code Insiders がインストールされる。&lt;/p&gt;&lt;p&gt;ここで &lt;code&gt;code-insiders .&lt;/code&gt; を実行して VS Code Insiders を開くとまっさらになっている。はじめは Setting Sync が有効でないためだ。
最も簡単に VS Code から VS Code Insiders へ設定を移行する方法は、一時的に VS Code Insiders で Stable の Setting Sync に繋ぐ方法だろう。
わたしの場合は非公開になってしまった拡張機能以外はこれで問題なく移行できた。
移行後は Setting Sync を off にして Stable から離脱、再度 Setting Sync を on にして Insiders へ接続するようにすれば良い。
たまに Stable と Insiders で非互換があるらしいし、自身の利用端末全てで VS Code Insiders に移行するまではリスクがあると見て分けておくのが無難やろな。
例外的に、認証情報の類は &lt;code&gt;setting.json&lt;/code&gt; に token を書くような野蛮なもの以外すべてポチポチ再認証が必要だが、それでも随分楽なもんやな。&lt;/p&gt;&lt;p&gt;VS Code Insiders ではコマンドも &lt;code&gt;code&lt;/code&gt; から &lt;code&gt;code-insiders&lt;/code&gt; に変わるので、これまた PowerShell の profile で該当の箇所を変えてやる必要がある。
普段から &lt;code&gt;code&lt;/code&gt; を使う場面は &lt;a href="https://github.com/x-motemen/ghq"&gt;ghq&lt;/a&gt; で一覧から選択した repo を開くときだけだ。
面倒なので今回 current directory を開く関数を profile に新設した。さすがに &lt;code&gt;code-insiders&lt;/code&gt; って長すぎるので許容できない。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# もとからあるやつ
function Set-SelectedRepository {
    ghq list | Select-Pocof | Select-Object -First 1 | ForEach-Object { Set-Location "$(ghq root)/$_" }
}
Set-Alias gcd Set-SelectedRepository -Option AllScope
# 新設
function Open-SelectedRepository {
    param(
        [Parameter()]
        [ValidateSet('Stable', 'Insider')]
        [string]
        $Channel = 'Insider'
    )
    $code = switch ($Channel) {
        'Stable' { 'code' }
        'Insider' { 'code-insiders' }
    }
    Set-SelectedRepository &amp;amp;&amp;amp; &amp;amp; $code .
}
Set-Alias gcode Open-SelectedRepository -Option AllScope
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これ &lt;code&gt;gcd&lt;/code&gt; で選択肢がなかった場合の &lt;code&gt;code-insiders&lt;/code&gt; が current directory になるのでなんか改善したほうが良いけど、いったんこれで。&lt;/p&gt;&lt;h3 id="psresourceget"&gt;PSResourceGet&lt;/h3&gt;&lt;p&gt;PSResourceGet のインストールも大したことない。ブログに示されるコマンドでインストールすれば良い。
わたしの場合は管理者権限で全ユーザ対象にインストールしてるので、追加でそのオプションだけつける。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Install-Module -Name Microsoft.PowerShell.PSResourceGet -AllowPrerelease -Scope AllUsers
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;インストールしたら PowerShell の profile で書いてる PowerShellGet のコマンドを PSResourceGet のものに置き換える。
今回対象になったのは以下だ。基本 &lt;code&gt;Module&lt;/code&gt; だった部分が &lt;code&gt;PSResource&lt;/code&gt; になるだけだが、オプションも微妙に変わっているところもある。
profile で使ってるコマンドは以下の感じに置き換わる。意外に多かった。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;Get-InstalledModule&lt;/code&gt; -&amp;gt; &lt;code&gt;Get-InstalledPSResource&lt;/code&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;-Scope&lt;/code&gt; の指定がいる&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Install-Module&lt;/code&gt; -&amp;gt; &lt;code&gt;Install-PSResource&lt;/code&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;-AllowPrerelease&lt;/code&gt; -&amp;gt; &lt;code&gt;-Prerelease&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;-AllowClobber&lt;/code&gt; -&amp;gt; default 挙動に。 従来の挙動は &lt;code&gt;-NoClobber&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Set-PSRepository&lt;/code&gt; -&amp;gt; &lt;code&gt;Set-PSResourceRepository&lt;/code&gt;&lt;ul&gt;&lt;li&gt;追記: こいつもあったわ &lt;code&gt;-InstallationPolicy Trusted&lt;/code&gt; -&amp;gt; &lt;code&gt;-Trusted&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Get-Module&lt;/code&gt; -&amp;gt; &lt;del&gt;&lt;code&gt;Get-PSResource&lt;/code&gt;&lt;/del&gt;&lt;ul&gt;&lt;li&gt;追記:
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Get-PSResource&lt;/code&gt; は PowerShellGet v3 にはあったけど PSResourceGet にはない。つまり何に変わったんだこれ？&lt;/li&gt;&lt;li&gt;&lt;code&gt;Get-Module&lt;/code&gt; は &lt;code&gt;Microsoft.PowerShell.Core&lt;/code&gt; が Source なのでそのまま使えば良いのか&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Find-Module&lt;/code&gt; -&amp;gt; &lt;code&gt;Find-PSResource&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Update-Module&lt;/code&gt; -&amp;gt; &lt;code&gt;Update-PSResource&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;これらの破壊的変更、どうも repo の CHANGELOG にまとまってないぽくて、すべてを一箇所で見つけることはできなかった。
&lt;a href="https://devblogs.microsoft.com/powershell/psresourceget-preview-is-now-available/"&gt;PowerShell Team のブログ&lt;/a&gt; とか追っていったら全貌わかるかもだが、面倒だ。
&lt;code&gt;NoClobber&lt;/code&gt; の挙動とかは以下を参考にした。信頼の Ironman 。
&lt;a href="https://blog.ironmansoftware.com/powershellget-v3/"&gt;What's new in PowerShellGet v3?&lt;/a&gt;&lt;/p&gt;&lt;p&gt;これらの変更を profile に施したあとうまく動いてるのが確認できたら仕事機にも反映する。&lt;/p&gt;&lt;p&gt;個人的にちょっとめんどいのが &lt;a href="https://github.com/aws/aws-tools-for-powershell"&gt;AWS Tools for PowerShell&lt;/a&gt; との今後の付き合い。
AWS Tools for PowerShell が PSResourceGet に移行するまで、当面は v2 v3 並行稼働という感じになるのだろうか。うまくいくのだろうか。
互換モジュールが提供されてるから、そっちを使うのが良さげ。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/PowerShell/CompatPowerShellGet"&gt;PowerShell/CompatPowerShellGet: This module provide functions used with PowerShellGet v3 to provide compatibility with scripts expecting PowerShellGet v2&lt;/a&gt;&lt;/p&gt;&lt;p&gt;あと開発環境とは別に &lt;a href="https://github.com/krymtkts/pocof/"&gt;pocof&lt;/a&gt; の方でも PSResourceGet への移行を反映したい。
具体的にはコマンドの名前が変わったこの辺。これらは Issue にしてればいいかな。未だ .NET 7 にも移行してないから、そういうのもやっていき。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;Get-Module&lt;/code&gt; -&amp;gt; &lt;del&gt;&lt;code&gt;Get-PSResource&lt;/code&gt;&lt;/del&gt;&lt;ul&gt;&lt;li&gt;追記: 先述の通り&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Publish-Module&lt;/code&gt; -&amp;gt; &lt;code&gt;Publish-PSResource&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="追記-1"&gt;追記 1&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Find-AWSToolsModule&lt;/code&gt; が &lt;code&gt;Find-Module&lt;/code&gt; に依存してて、事前にダミーの &lt;code&gt;Find-Module&lt;/code&gt; してないとエラーになるやつ未だ直ってないようだ。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Find-AWSToolsModule: The term 'PowerShellGet\Find-Module' is not recognized as a name of a cmdlet, function, script file, or executable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;自分用にはこれを回避するために関数を書いてたが、CompatPowerShellGet を使うとこの依存関係が永久に解決できないみたい。
module 違うからなあ...やはり v2 v3 の並行稼働しかなさそう...だいじょぶかな。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Get-PSResource&lt;/code&gt; も戻り値の property に変化があって、対処が必要だった。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;Path&lt;/code&gt; -&amp;gt; &lt;code&gt;InstalledLocation&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="追記-2"&gt;追記 2&lt;/h3&gt;&lt;p&gt;PowerShellGet に &lt;code&gt;-AllowPrerelease&lt;/code&gt; つけて v3 をインストールしてたがややこしい。
PSResourceGet にない Cmdlet もあったりして危ない。おまえのことやぞ &lt;code&gt;Get-PSResource&lt;/code&gt; 。
PowerShellGet は prerelease 版を入れないようにするのが無難。&lt;/p&gt;</description><pubDate>Sun, 09 Jul 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-07-02-rebuild-blog-with-fable-pt9</guid><link>https://krymtkts.github.io/posts/2023-07-02-rebuild-blog-with-fable-pt9</link><title>Fable でブログを再構築する pt.9</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/blog-fable"&gt;krymtkts/blog-fable&lt;/a&gt; &lt;a href="https://fable.io/"&gt;Fable&lt;/a&gt; でブログを再構築している。&lt;/p&gt;&lt;p&gt;細々とした修正だけやった。 &lt;a href="https://github.com/krymtkts/blog-fable/pull/23"&gt;#23&lt;/a&gt;&lt;/p&gt;&lt;p&gt;O'reilly の F# 本で勉強してたからか最近まで &lt;a href="https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/interpolated-strings"&gt;Interpolated strings - F# | Microsoft Learn&lt;/a&gt; わかってなかったのでそれに書き換えたり。あと &lt;a href="https://github.com/fable-compiler/fable-node"&gt;Fable.Node&lt;/a&gt; の process 予約語で警告が出るやつも自前でかいた binding を使うことで解消した。
利用する範囲そんなに多くなければ最小の範囲に絞り込んで Node.js の binding を書き Fable.Node 排除するのもよいが、なんとなく先延ばしにした。&lt;/p&gt;&lt;p&gt;RSS Feed に取り組み始めた。
まずは RSS feed の構造を知らんかったので、自ブログの出力した &lt;a href="https://krymtkts.github.io/feed.xml"&gt;feed.xml&lt;/a&gt; と &lt;a href="https://validator.w3.org/feed/docs/rss2.html"&gt;RSS 2.0 specification&lt;/a&gt; &lt;a href="https://datatracker.ietf.org/doc/html/rfc4287"&gt;RFC 4287 - The Atom Syndication Format&lt;/a&gt; を学んでる。
自ブログは RSS 2.0 で書かれていて &lt;code&gt;atom:link&lt;/code&gt; セクションを使うことで追加の機能を入れてるらしい。&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.rssboard.org/rss-validator/"&gt;RSS Validator&lt;/a&gt; なんてのも初めて知ったわ。試しに feed.xml を読ませてみたところ valid な RSS Feed と判定されてるが推奨事項がチラホラあった。
Fable でやるにあたってこういうのも丁寧に対応できると良いな。&lt;/p&gt;&lt;p&gt;feed.xml を作るにあたって sitemap.xml を書いたのと同じく自前で &lt;a href="https://github.com/Zaid-Ajaj/Fable.SimpleXml"&gt;Fable.SimpleXml&lt;/a&gt; を使って書くのか、楽に Node.js のモジュールを使うのかがちょっと悩ましいところ。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/jpmonette/feed"&gt;jpmonette/feed: A RSS, Atom and JSON Feed generator for Node.js, making content syndication simple and intuitive! 🚀&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/dylang/node-rss"&gt;dylang/node-rss: RSS feed generator for Node.&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;この辺りが有名なモジュールのようだけど最後のコミットがちょっと古い。
&lt;a href="https://github.com/jpmonette/feed"&gt;feed&lt;/a&gt; の場合以下みたいにオブジェクトをもりもり書いていくだけっぽくて、 Fable.SimpleXml 使って自分で構築するのと変わらんのでは...
という懸念があり、なんか自分でやったほうが良さそうに思っている。 RSS/Atom の知識乏しいけど、既存の焼き直しであればまあできるやろ的な。&lt;/p&gt;&lt;pre&gt;&lt;code class="ts"&gt;// 以下はあくまでサンプルだがこれは書いてて楽しくなさそうな気配
// feed
const feed = new Feed({
  title: "krymtkts",
  description: "krymtktss blog",
  id: "http://krymtkts.github.io/",
  link: "http://krymtkts.github.io/",
  image: "http://krymtkts.github.io/image.png",
  favicon: "http://krymtkts.github.io/favicon.ico",
  copyright: "Copyright © 2019-2023 krymtkts",
  updated: new Date(2023, 7, 02),
  feedLinks: {
    json: "https://krymtkts.github.io/json",
    atom: "https://krymtkts.github.io/atom",
  },
});

// node-rss
var feed = new RSS({
  title: "krymtkts",
  description: "krymtktss blog",
  site_url: "http://krymtkts.github.io",
  image_url: "http://krymtkts.github.io/icon.png",
  copyright: "Copyright © 2019-2023 krymtkts",
  pubDate: "May 20, 2012 04:00:00 GMT",
  feed_url: "http://krymtkts.github.io/rss.xml",
});
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="fsharp"&gt;let generateRssFeed (conf: RssFeed) =
    let items = ...

    let rss =
        {
            title = conf.title
            description = conf.description
            link = conf.link
            lastBuildDate = now.ToString("yyyy-MM-dd")
            generator = "blog-fable"
            items = items
        } |&amp;gt; convertToSimpleXml

    rss
    |&amp;gt; serializeXml
    |&amp;gt; (+) @"&amp;lt;?xml version=""1.0"" encoding=""UTF-8""?&amp;gt;"
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;イメージ雑いけどこんな感じにならんかな？
自前でやることによって進捗が鈍化しそうやけど、しゃーないかという感じ。&lt;/p&gt;</description><pubDate>Sun, 02 Jul 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-06-25-rebuild-blog-with-fable-pt8</guid><link>https://krymtkts.github.io/posts/2023-06-25-rebuild-blog-with-fable-pt8</link><title>Fable でブログを再構築する pt.8</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/blog-fable"&gt;krymtkts/blog-fable&lt;/a&gt; &lt;a href="https://fable.io/"&gt;Fable&lt;/a&gt; でブログを再構築している。&lt;/p&gt;&lt;p&gt;先日の開発サーバ作成、 404 に生成済み HTML 表示するのもわかったので完了した。&lt;a href="https://github.com/krymtkts/blog-fable/pull/20"&gt;#20&lt;/a&gt;&lt;/p&gt;&lt;p&gt;再ビルドのパフォ改善は、今やらないと言うかできないと判断した。
指定のファイル一覧だけを対象に HTML や関連する XML を再生成するって感じの機構を取り入れる必要があって、根本的に変えないとどうにもならんので、一通り必要と考える機能が揃ってから着手したい。&lt;/p&gt;&lt;p&gt;次に XML の類に取り掛かった。まずはデータ量少ない sitemap.xml のほう。 &lt;a href="https://github.com/krymtkts/blog-fable/pull/22"&gt;#22&lt;/a&gt;&lt;/p&gt;&lt;p&gt;sitemap.xml に関しては何の XML か知らなかったが検索エンジンのクローラにより正確な情報を与えるためのデータらしいのは理解した。
今の Cryogen で生成されてる sitemap.xml がめちゃくちゃテキトーに作られてるのも含め。
こちらを参考に知識を補った。
&lt;a href="https://developers.google.com/search/docs/crawling-indexing/sitemaps/build-sitemap"&gt;Build and Submit a Sitemap | Google Search Central  |  Documentation  |  Google for Developers&lt;/a&gt;&lt;/p&gt;&lt;p&gt;我がブログの運用に限れば、計測タグも設置してないし何 1 つ SEO 効果を期待してないけど、 wev.dev の PageSpeed Insights とかで良いスコアは出したい。
ハイスコア狙いのゲーム感覚なのだ。
だからこそいま全部同じ &lt;code&gt;loc&lt;/code&gt; の全部同じ &lt;code&gt;lastmod&lt;/code&gt; が出てるので、 &lt;code&gt;loc&lt;/code&gt; を URL 毎にするとか &lt;code&gt;lastmod&lt;/code&gt; に最終更新日を反映させるとかちょっとはマシにしたい。&lt;/p&gt;&lt;p&gt;折角なので &lt;code&gt;priority&lt;/code&gt; も定めてみる。とりま index は &lt;code&gt;1.0&lt;/code&gt; として Archives, Tags はカテゴリ系なので生成の度更新するし &lt;code&gt;0.9&lt;/code&gt; としてみた。
新しめのページは高い方が良いんか？
結局全てが生成ファイルなので単純に post は投稿日付降順くらいしかできなそうやけど、ちょっとめんどいなあと思ったので今は控えて全部同じ &lt;code&gt;0.8&lt;/code&gt; とした。
代わりに投稿日付とは別に front matter に日付を持たせて、更新日付ぽい扱いができるよう悪あがきだけしておいた。&lt;/p&gt;&lt;p&gt;Fable で XML を操作するのには &lt;a href="https://github.com/Zaid-Ajaj/Fable.SimpleXml"&gt;Zaid-Ajaj/Fable.SimpleXml&lt;/a&gt; を使う。 &lt;a href="https://github.com/Zaid-Ajaj/Feliz"&gt;Feliz&lt;/a&gt; 作者の作品。
使いたい機能は大体誰かが用意してくれていてありがたい限りである。&lt;/p&gt;&lt;p&gt;femto で足したらエラーになった。でも &lt;code&gt;fsproj&lt;/code&gt; はちゃんと変更されてたから大丈夫ぽい。 npm モジュールが無いからエラーになる。
README には &lt;code&gt;paket&lt;/code&gt; 使って足せと書いてあった(先に読め)。うちは使ってないから単純に &lt;code&gt;dotnet add&lt;/code&gt; で足す。これでも十分シンプルに使えるし。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;dotnet add .\src\App.fsproj package Fable.SimpleXml
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Fable.SimpleXml は XML 宣言の読み込みは対応してるけど出力は対応してないみたいなので、手書き文字列を添えて出力してやる必要があった。
それ以外に関しては Feliz で HTML を書くのと同じ感覚で書ける。
参考として、以下に Fable.SimpleXml を使って sitemap.xml の文字列を作成する箇所を抜粋する。&lt;/p&gt;&lt;pre&gt;&lt;code class="fsharp"&gt;    let generateSitemap root locs =
        let urls =
            locs
            |&amp;gt; Seq.map (fun loc -&amp;gt;
                node
                    "url"
                    []
                    [ node "loc" [] [ text $"{root}{loc.loc}" ]
                      node "lastmod" [] [ text loc.lastmod ]
                      //   node "changefreq" [] [ text "monthly" ]
                      node "priority" [] [ text loc.priority ] ])
            |&amp;gt; List.ofSeq

        let urlSet =
            node
                "urlset"
                [ attr.value ("xmlns", "http://www.sitemaps.org/schemas/sitemap/0.9")
                  attr.value ("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance") ]
                urls

        urlSet
        |&amp;gt; serializeXml
        |&amp;gt; (+) @"&amp;lt;?xml version=""1.0"" encoding=""UTF-8""?&amp;gt;"
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;XML 宣言も文字列なんぞ使わずにサクッと書けるとカッコよいのだけど。&lt;/p&gt;&lt;p&gt;あとコメントアウトがあってダサいが、これは &lt;code&gt;changefreq&lt;/code&gt; も足したいなーと思ってやらなかった残穢だ。
Index, Archives, Tags は post の投稿間隔から自動算出できるが、いま面倒でやらなかったので戒めとして残している。&lt;/p&gt;&lt;p&gt;これで次は RSS Feed の XML を作ったら最低限必要なものは揃う。スタイルや前後の post へのリンクみたいな細かな調整は必要だろうけど。
RSS Feed の仕組み、例えば既存の投稿に変更がある場合にどうなんの？とかもあんま知らんので、これを機に知識を補いたい。
結構 post 周りのコード手を入れないと Markdown から抽出・生成したタイトル・公開日・ HTML 後続処理に回せんな...
というのがあるので結構ダルそうではあるが、いい感じの手間がかかる点は最後に越える山としてふさわしい(と自分に言い聞かせる)。&lt;/p&gt;&lt;p&gt;場当たり的なコードも積もってきたし、細々とした気になってる点を補正する等も着手していこう。&lt;/p&gt;</description><pubDate>Sun, 25 Jun 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-06-18-rebuild-blog-with-fable-pt7</guid><link>https://krymtkts.github.io/posts/2023-06-18-rebuild-blog-with-fable-pt7</link><title>Fable でブログを再構築する pt.7</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/blog-fable"&gt;krymtkts/blog-fable&lt;/a&gt; &lt;a href="https://fable.io/"&gt;Fable&lt;/a&gt; でブログを再構築している。&lt;/p&gt;&lt;p&gt;当初開発サーバに使ってた &lt;a href="https://github.com/tapio/live-server"&gt;tapio/live-server&lt;/a&gt; は npm の vulnerability 報告がずっと出てた。
開発用なので構わないといえばそうだがやっぱいい気分ではないので、自力で開発サーバを立てるように変えていく(現在作業中)。
&lt;a href="https://github.com/krymtkts/blog-fable/pull/20"&gt;#20&lt;/a&gt;&lt;/p&gt;&lt;p&gt;F# Weekly の Sergey Tihon 氏がちょうどよい F# script を書いてるのを見つけたので、それをベースにする。
Web サーバに F# 製の &lt;a href="https://github.com/SuaveIO/suave"&gt;SuaveIO/suave&lt;/a&gt; を使うようになる。&lt;/p&gt;&lt;p&gt;&lt;a href="https://stackoverflow.com/questions/34603913/suave-in-watch-mode-during-development"&gt;f# - Suave in watch mode (during development) - Stack Overflow&lt;/a&gt;&lt;/p&gt;&lt;p&gt;これに従うと、変更イベントで WebSocket のメッセージをページに送って、ページはメッセージを受け取ったらリロードする、という流れで live reload をすることになる。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;ファイルの変更検知して変更イベントを発火する&lt;/li&gt;&lt;li&gt;変更イベントで WebSocket のメッセージ送信する&lt;/li&gt;&lt;li&gt;ページに差し込んだ JavaScript で WebSocket のメッセージを受け取ったら reload する&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;この開発サーバ用 F# スクリプトを開発するにあたり、
F# Interactive 特有の挙動とかあまりわかってなかったので、以下を参照に勉強した。
&lt;a href="https://learn.microsoft.com/en-us/dotnet/fsharp/tools/fsharp-interactive/"&gt;F# Interactive (dotnet) Reference | Microsoft Learn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;今回ファイルの変更を監視するのと、 &lt;code&gt;dotnet&lt;/code&gt; コマンド実行するのに &lt;a href="https://fake.build/index.html"&gt;FAKE&lt;/a&gt; のモジュールがいくつか必要だったので NuGet から取得する形にした。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://www.nuget.org/packages/Fake.Core.Trace"&gt;NuGet Gallery | Fake.Core.Trace 6.0.0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://www.nuget.org/packages/Fake.DotNet.Cli"&gt;NuGet Gallery | Fake.DotNet.Cli 6.0.0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://www.nuget.org/packages/Fake.IO.FileSystem"&gt;NuGet Gallery | Fake.IO.FileSystem 6.0.0&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;FAKE はいつか勉強せなあかんなと思っていたが、タイミング良く使う機会が来た。その良さもなんとなく感じており、なんでも F# で書きたくなる気持ちがわかってくる。&lt;/p&gt;&lt;p&gt;先述の WebSocket でやり取りする JavaScript は、デプロイするブツには不要だ。
なので今回開発モードをこしらえて、その場合のみ WebSocket 用の JavaScript をロードする &lt;code&gt;script&lt;/code&gt; タグを差し込むようにした。
開発モード自体は SSG 実行時のオプションで渡す形にしている。設定ファイルなしでスクリプトだけで完結する世界観にしたいので。&lt;/p&gt;&lt;p&gt;この開発用 JavaScript も、そのうち &lt;a href="https://github.com/fable-compiler/fable-browser/tree/master/src/WebSocket"&gt;Fable.Browser.WebSocket&lt;/a&gt; で書いてトランスパイルしたものを使うようにしたい。&lt;/p&gt;&lt;p&gt;一通り作ってみて、いい感じに動いてるっぽい。
ただし強烈に遅いのと、 Suave で 404 ページを表示する方法がわからないので、今後の課題かな。差分ビルドとかできるとかっこよい。&lt;/p&gt;&lt;p&gt;以下に今回のハマりどころを記載しておく。&lt;/p&gt;&lt;h3 id="ハマりどころ"&gt;ハマりどころ&lt;/h3&gt;&lt;p&gt;Suave 、 Fable 共にそうだけどドキュメントに書いてないことがチラホラあるので、分からなくてコード読む必要があった。備忘のためいくつかメモを記録しておく。&lt;/p&gt;&lt;h4 id="suave"&gt;Suave&lt;/h4&gt;&lt;p&gt;Suave で以下のエラーが出たときは、権限じゃなくてサーバの 設定が足りない。&lt;/p&gt;&lt;pre&gt;&lt;code class="log"&gt;System.UnauthorizedAccessException: Access to the path 'C:\Program Files\dotnet\sdk\7.0.302\FSharp\_temporary_compressed_files' is denied.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これを解消するには権限を与えるのではなく、 Sauve がデフォルトで使ってる圧縮ファイルのパスを config に指定しないといけない(デフォでなんかやってくれよめんどくせえ)。
&lt;a href="https://github.com/SuaveIO/suave/blob/8efe4b32ea0dc52f36c10c8d8fec8191c6ae901c/src/Suave/Web.fs#L42"&gt;suave/Web.fs at 8efe4b32ea0dc52f36c10c8d8fec8191c6ae901c · SuaveIO/suave&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="fs"&gt;compressedFilesFolder = Some(home)
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id="fakedotnet"&gt;Fake.DotNet&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Fake.DotNet&lt;/code&gt; の使い方は &lt;a href="https://github.com/SAFE-Stack/SAFE-template"&gt;SAFE-Stack のテンプレ&lt;/a&gt; が参考になる。
&lt;a href="https://github.com/SAFE-Stack/SAFE-template/blob/db892ace1ecd1589a9a03a484e388a97f3b71718/Build.fs#L70-L75"&gt;SAFE-template/Build.fs at db892ace1ecd1589a9a03a484e388a97f3b71718 · SAFE-Stack/SAFE-template&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;command&lt;/code&gt; と &lt;code&gt;args&lt;/code&gt; どう分けるか謎だが、あんまきにしなくていいっぽい。
現に ↓ のように &lt;code&gt;cmd&lt;/code&gt; に引数が混ざっていても動くという。&lt;/p&gt;&lt;pre&gt;&lt;code class="fsharp"&gt;let cmd = "fable src"
let args = "--runScript dev" // NOTE: run script with development mode.
let result = DotNet.exec (fun x -&amp;gt; { x with DotNetCliPath = "dotnet" }) cmd args
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id="fable"&gt;Fable&lt;/h4&gt;&lt;p&gt;Fable に &lt;code&gt;--runScript&lt;/code&gt; をつけて呼び出したときに引数を与えられるのかについては、ドキュメントの記載は見つけられなかったがソースコードを見る限り与えることができる。
&lt;a href="https://github.com/fable-compiler/Fable/blob/ac4d44997f69d5b1b7109730ccb45e354a4ec368/src/Fable.Cli/Entry.fs#L390"&gt;Fable/src/Fable.Cli/Entry.fs at ac4d44997f69d5b1b7109730ccb45e354a4ec368 · fable-compiler/Fable&lt;/a&gt;&lt;/p&gt;&lt;p&gt;この形式なので、以下のようにコマンドを打てばよい。&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;dotnet fable src --runScript dev
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;--runScript&lt;/code&gt; で実行するスクリプトの方では、 Node.js の引数の取り方を使えば良い。つまり &lt;code&gt;process.argv&lt;/code&gt; を使う。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/fable-compiler/fable-node"&gt;Fable.Node&lt;/a&gt; を使ってたら &lt;code&gt;process.argv&lt;/code&gt; が簡単に使える。
でも &lt;code&gt;process&lt;/code&gt; は F# の予約語で警告が出るので、気持ち悪いからそのうち自前で binding するように直すかも。&lt;/p&gt;</description><pubDate>Sun, 18 Jun 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-06-11-rebuild-blog-with-fable-pt6</guid><link>https://krymtkts.github.io/posts/2023-06-11-rebuild-blog-with-fable-pt6</link><title>Fable でブログを再構築する pt.6</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/blog-fable"&gt;krymtkts/blog-fable&lt;/a&gt; &lt;a href="https://fable.io/"&gt;Fable&lt;/a&gt; でブログを再構築しようとしている。&lt;/p&gt;&lt;p&gt;GitHub Actions で GitHub Pages のデプロイするようにした。
あと個人プロジェクトの repo を deploy したときの root 間違ってたので手直しする必要があった。
&lt;a href="https://github.com/krymtkts/blog-fable/pull/16"&gt;#16&lt;/a&gt;,
&lt;a href="https://github.com/krymtkts/blog-fable/pull/18"&gt;#18&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitHub Pages はこちら → &lt;a href="https://krymtkts.github.io/blog-fable/index.html"&gt;Blog Title - February&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitHub Actions を使った GitHub Pages の deploy は現行ブログでもやりたかったネタで、長らく放置してた。
ブログ再構築のタイミングなら導入するのにちょうどよいので以下の記事を参考に導入した。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://docs.github.com/en/pages/getting-started-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site#publishing-with-a-custom-github-actions-workflow"&gt;Publishing with a custom GitHub Actions workflow - Configuring a publishing source for your GitHub Pages site - GitHub Docs&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://developer.mamezou-tech.com/blogs/2022/09/08/github-pages-new-deploy-method/"&gt;カスタムワークフローで GitHub Pages デプロイが可能に | 豆蔵デベロッパーサイト&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;注意点は先述の通り、個人プロジェクトの場合は &lt;code&gt;{account}.github.io/{repo-name}/&lt;/code&gt; がページの root になる点くらい。
これは自動的に付与されるので、その前提でリンクやら調整する必要がある。
ただし開発サーバでは自動で付与されないので、 root は &lt;code&gt;docs&lt;/code&gt; にしつつ他は repo name のディレクトリを介すようにする。
今回のケースでは以下を調整していい感じにした。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;諸々のリンクに repo name のディレクトリを入れる&lt;/li&gt;&lt;li&gt;開発用サーバの index や 404 を repo name のディレクトリを介すよう調整する&lt;/li&gt;&lt;li&gt;&lt;code&gt;actions/upload-pages-artifact&lt;/code&gt; の &lt;code&gt;path&lt;/code&gt; は repo name のディレクトリにする ← 重要&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;いまの workflow と開発サーバの設定を転記しておく。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/blog-fable/blob/4cb5d81ac8099889dd55e50ae39ebb20935e96f5/.github/workflows/gh-pages.yml"&gt;blog-fable/gh-pages.yml at 4cb5d81ac8099889dd55e50ae39ebb20935e96f5 · krymtkts/blog-fable · GitHub&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="yaml"&gt;name: Deploy GitHub Pages

on:
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: true

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: Setup Pages
        uses: actions/configure-pages@v2
      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: 7.0.x
      - uses: actions/setup-node@v3
        with:
          node-version: 18
      - name: Install dependencies
        run: npm install
      - name: Build pages
        run: npm run build
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v1
        with:
          path: docs/blog-fable/ # ここ重要。 docs/ ではない

  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;開発サーバは今暫定的に &lt;a href="https://github.com/tapio/live-server"&gt;live-server&lt;/a&gt; を使っているが、その場合以下のように index と 404 を指定して起動する。&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;live-server docs --open=blog-fable/index.html --entry-file=blog-fable/404.html
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;長々と書いたが、個人ページを作るなら &lt;code&gt;{account}.github.io/&lt;/code&gt; の repo を使うだろうから、そんなに心配することはない。&lt;/p&gt;&lt;p&gt;今回の GitHub Pages の対応でベタ書きだったパス類をエントリポイントへ全部まとめるようにしたので、幾分設定しやすくなった。
これでサイトマップとフィードの XML 、開発サーバの置き換えあたりに着手できる。一段落までもうちょいかな。&lt;/p&gt;</description><pubDate>Sun, 11 Jun 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-06-04-rebuild-blog-with-fable-pt5</guid><link>https://krymtkts.github.io/posts/2023-06-04-rebuild-blog-with-fable-pt5</link><title>Fable でブログを再構築する pt.5</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/blog-fable"&gt;krymtkts/blog-fable&lt;/a&gt; &lt;a href="https://fable.io/"&gt;Fable&lt;/a&gt; でブログを再構築しようとしている。&lt;/p&gt;&lt;p&gt;雑多な更新 &lt;a href="https://github.com/krymtkts/blog-fable/pull/11"&gt;#11&lt;/a&gt; &lt;a href="https://github.com/krymtkts/blog-fable/pull/12"&gt;#12&lt;/a&gt; &lt;a href="https://github.com/krymtkts/blog-fable/pull/13"&gt;#13&lt;/a&gt; 。
favicon が出てなかったの直したり、 404 ページ作ったり、あとやりたかった module の整理。&lt;/p&gt;&lt;p&gt;ファイルは雑に 共通系 -&amp;gt; 生成系 -&amp;gt; アプリ の依存関係に切り分けて、それぞれのファイル内に雑多な module が詰まってるようにした。 元は 2 ファイルだったのでこれでもだいぶマシかな。でも module の整理は今結構雑な感じで置いていて、もうちょいと関数を細切れにできるのでその後また見直す。互いに変な依存関係してたり、 生成系関数のインタフェースが不一致だったりするのとか、気になるのが残ってる感じ。
それより優先して細々した直したい部分があってわざと置いてる。&lt;/p&gt;&lt;p&gt;細々した直したい部分というのは navbar で、 Bulma (暫定的にこいつで行くことにしたから)の &lt;a href="https://bulma.io/documentation/components/navbar/"&gt;Navbar Component&lt;/a&gt; 見てみたのだけどこんな複雑に使い分けなあかんの？みたいな div div した感じになってて、これ導入したくないなあと感じてた。
nav -&amp;gt; ul -&amp;gt; li でだめなんか。
&lt;a href="https://v1.tailwindcss.com/components/navigation"&gt;Tailwind の Navigation&lt;/a&gt; だと思ったようなシンプルな感じのものが得られるのだけど、あの大量の class をつけるのもなあという感じだった。
世の中 Navbar はみんなグリグリ動いたり深ーい階層の div div したやつを、好きでやってんのかな。いやないはずだ。
とりあえず自分のやつではやりたくないなって感じの奴らなことは確かな感触を持った。
ちょうど &lt;a href="https://bulma.io/documentation/components/tabs/"&gt;Tabs Component&lt;/a&gt; というもっとシンプルで ul -&amp;gt; li に被せられるスタイルがあったので、これを適用する感じにし、諸々調整した。 &lt;a href="https://github.com/krymtkts/blog-fable/pull/14"&gt;#14&lt;/a&gt; &lt;a href="https://github.com/krymtkts/blog-fable/pull/15"&gt;#15&lt;/a&gt;
Tailwind の Navigation で得られるシンプルなやつに近い感じ。モバイルなんかでもグリグリ UI が変わらず同じ見た目でスライドするだけなので、この方がいい。&lt;/p&gt;&lt;p&gt;とはいえこういう div div したくないというのは &lt;a href="https://github.com/Zaid-Ajaj/Feliz"&gt;Feliz&lt;/a&gt; で HTML を直書きする方向性を選んだから書くのがだるいのも多少ある。
もちろん生成物が div div してるとキモいなというのが一番だけど。
ここにきて&lt;a href="https://fulma.github.io/Fulma/#home"&gt;Fulma&lt;/a&gt;を導入したら楽になるのか？というのを Navbar のくだりで多少試したのだけど、なんか Feliz より書き味良くなかった(慣れの問題かも)ので今は据え置きにしている。
仮に Fulma を導入するとなると、あの div div した生成物を受け入れるってことやからな。&lt;/p&gt;&lt;p&gt;div div 書きまくってどれだけあれが好きでないかというのが伝わっただろうが、仕事ではそういう div div した構造を目当てのレイアウトを得るために書くこともあるということは断っておきたい。
必要な div なら仕方がない。でも自分の趣味プロで書くのであれば、仕事と同じことしても余白が狭すぎるし、極力簡素にしたいということでね。&lt;/p&gt;&lt;p&gt;もう最近やったことまとめと化してるけど、これも振り返りにちょうどよいので悪くない。
ひとり(プラス GitHub Copilot サンと ChatGPT サン)で黙々とやってると、フィードバック得られるところも限られるからな。こういうことをダラダラと書き連ねるだけでも、次のアイデアにつながる。
ちょうどこの記事をしたためいている中で、 footer 要素がないわ...というのに気づけた。
とりあえずこの記事を push してから、それに取り掛かることとする。&lt;/p&gt;</description><pubDate>Sun, 04 Jun 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-05-28-rebuild-blog-with-fable-pt4</guid><link>https://krymtkts.github.io/posts/2023-05-28-rebuild-blog-with-fable-pt4</link><title>Fable でブログを再構築する pt.4</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/blog-fable"&gt;krymtkts/blog-fable&lt;/a&gt; &lt;a href="https://fable.io/"&gt;Fable&lt;/a&gt; でブログを再構築しようとしている。&lt;/p&gt;&lt;p&gt;YAML で書かれたメタデータ(Front Matter というらしい)の抽出を作った。 &lt;a href="https://github.com/krymtkts/blog-fable/pull/5"&gt;#5&lt;/a&gt;&lt;/p&gt;&lt;p&gt;またそれに伴って記事へのリンクのタイトルに front matter が使えるようになったので諸々手直しした。 &lt;a href="https://github.com/krymtkts/blog-fable/pull/10"&gt;#10&lt;/a&gt;&lt;/p&gt;&lt;p&gt;front matter 抽出については、まず最初に remark 使ってみた。
けど、 &lt;a href="https://github.com/fable-compiler/ts2fable"&gt;ts2fable&lt;/a&gt; で binding を出力したところ &lt;a href="https://github.com/unifiedjs/unified"&gt;unified&lt;/a&gt; 、 &lt;a href="https://github.com/remarkjs/remark"&gt;remark&lt;/a&gt; とその Plugin たちの間で型の整合性が取れなかった。
整合取ろうとしたら自力で調整しないとどうにもならないので、とてもじゃないがすぐには使えないと判断して早々に諦めた。
remark のパーサを作る部分を JavaScript で書いて、それを import する形でやれば簡単にできるが、そこは F# で書いてこそ意味がある。&lt;/p&gt;&lt;p&gt;というわけで marked のまま、 front matter の抽出を古典的な方法、つまり正規表現を使って自力でやった。
front matter 自体は YAML で書くので、 &lt;a href="https://github.com/eemeli/yaml"&gt;eemeli/yaml&lt;/a&gt; を導入した。 yaml module は ts2fable で Fable の binding が生成されなかったので、雑なやつを手で書いた。&lt;/p&gt;&lt;p&gt;front matter 抽出ができるようになると、 Archives や Tags で作ってたページリンクにメタデータのタイトルを使えるようになる。
タグ付けされたページにタグリンクもつけられるし。
それに伴い諸々の手直しをし、ついでに参照元のコードのまま使ってた CSS とかを最新のものまで更新した。とりまいまは CDN のを借りてる。
ついでに highlight.js の CSS を足した。
Index Archives Tags が出揃って、ページにタグが付き、 syntax highlighting も効くようになったから、結構ブログっぽくなってきたのでは？&lt;/p&gt;&lt;p&gt;諸々のスタイル調整はぜんぜんやってないけど。
スタイル調整に対する欲求が低くて、どうしようか考えるとのがとてつもなくだるい。とりあえず色味だけは Solarized Dark でいこうと思ってるけど。ただ Solarized Dark のコンテンツに Solarized Dark の syntax highlighting だと境界ワカランのちゃうかな？というのはある。なので現にいまのブログでは Solarized Light をコンテンツに使ってるし。
スタイルに関してはこのまま Bulma でいくか決めないといけないのだけど、こういう感じの自分であまり考えたくないケースに案外ハマってるかも、しらんけど。&lt;/p&gt;&lt;p&gt;最近の機能拡充に伴ってエントリーポイントである &lt;code&gt;App.fs&lt;/code&gt; と &lt;code&gt;Helpers.fs&lt;/code&gt; がむやみに肥大化しているので、そろそろ整理したいところ。
いまは &lt;code&gt;App.fs&lt;/code&gt; に色々書いてるけど、これ多分 &lt;code&gt;render&lt;/code&gt; 関数以外はもう module に切り出した方がいいねんよな。&lt;/p&gt;&lt;p&gt;イメージ的には、 &lt;code&gt;render&lt;/code&gt; 関数で用意した関数を組み合わせるだけにする。
いま navbar に表示するページだったり index に最新のポストを表示するのが固定でやってるけど、こういうのも front matter に寄せたらスッキリするかな。
設定ファイルとかはなしで、ディレクトリ構造とコンテンツの front matter だけで制御できたら楽かなあ。&lt;/p&gt;&lt;p&gt;道程は長い。&lt;/p&gt;</description><pubDate>Sun, 28 May 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-05-20-bump-openssh-chocolatey</guid><link>https://krymtkts.github.io/posts/2023-05-20-bump-openssh-chocolatey</link><title>Chocolatey で Portable OpenSSH を更新する 2023</title><description>&lt;p&gt;久しぶりに、 Chocolatey に OpenSSH の β が降ってきてた。&lt;/p&gt;&lt;p&gt;前回は 2019 年だった。 &lt;a href="/posts/2019-03-31-win-openssh-is-gone"&gt;Windows10 の更新で OpenSSH が逝った&lt;/a&gt; &lt;a href="/posts/2019-06-29-season-of-openssh-error"&gt;また OpenSSH が動かなくなる季節がやってきた&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://community.chocolatey.org/packages/openssh#versionhistory"&gt;Chocolatey Software | Win32 OpenSSH (Universal Installer) 9.2.2-beta1&lt;/a&gt;&lt;/p&gt;&lt;p&gt;ので更新してみたところ、以下のエラーログが。&lt;/p&gt;&lt;pre&gt;&lt;code class="log"&gt;ERROR: There is a configured instance of the SSHD service, please specify the /SSHServerFeature to confirm it is OK to shutdown and upgrade the SSHD service at this time.
The upgrade of openssh was NOT successful.
Error while running 'C:\ProgramData\chocolatey\lib\openssh\tools\chocolateyinstall.ps1'.
 See log for details.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;はて？ &lt;code&gt;sshd&lt;/code&gt; 入れてたっけ？と思ったが見たら入ってた。 chocolatey で自動で入ったんやっけ？&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; get-service *ssh*

Status   Name               DisplayName
------   ----               -----------
Running  ssh-agent          ssh-agent
Running  sshd               sshd
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;いる！しかも実行中なのがなんかキモい。&lt;/p&gt;&lt;p&gt;こいつを停止させるのはあとにするとして、ひとまず &lt;code&gt;choco upgrade&lt;/code&gt; を成功させるにはどうしたら良いか。
こういうときはちゃんとマニュアルを読む。 Chocolatey の Package Source のリンクを辿れば良い。&lt;/p&gt;&lt;p&gt;&lt;a href="https://gitlab.com/DarwinJS/ChocoPackages/-/tree/master/openssh#-params-sshserverfeature-install-and-uninstall"&gt;openssh · master · DarwinJS / ChocoPackages · GitLab&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;h2 id="-params-sshserverfeature-install-and-uninstall"&gt;-params '"/SSHServerFeature"' (Install and Uninstall)&lt;/h2&gt;&lt;p&gt;Also install sshd Windows Service - including opening port 22.
If this parameter is not included on an upgrade or uninstall and
the sshd server is installed - an error is generated. You must
use this switch to indicate you have made preparations for the
sshd service to be interrupted or removed.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;どう見てもこれ。以下を実行する。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;choco upgrade openssh -params '"/SSHServerFeature"' -y
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;この後再起動をして Windows Terminal で PowerShell を開くと作業が完了した。
すっかり忘れていが、わたしの &lt;code&gt;$PROFILE&lt;/code&gt; は「 &lt;code&gt;ssh-agent&lt;/code&gt; のサービスがいない ≒ Windows の OpenSSH が更新された」と判定し、インストールスクリプトを実行するのだった。
&lt;a href="https://gist.github.com/krymtkts/f8af667c32b16fc28a815243b316c5be#file-microsoft-powershell_profile-ps1-L910-L923"&gt;ここ&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# install ssh-agent service if not exists.
# it will be triggered after updating Windows OpenSSH.
if (! ($SshAgent = (Get-Service -Name 'ssh-agent' -ErrorAction SilentlyContinue))) {
    install-sshd.ps1
    Set-Service -Name 'ssh-agent' -StartupType Automatic
    Start-Service ssh-agent
}
elseif ($SshAgent.StartType -eq 'Disabled') {
    Set-Service -Name 'ssh-agent' -StartupType Automatic
    Start-Service ssh-agent
}
else {
    Start-Service ssh-agent
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;インストールスクリプトは Portable OpenSSH に提供されるもので &lt;code&gt;ssh-agent&lt;/code&gt; と &lt;code&gt;sshd&lt;/code&gt; が一緒くたにインストールされてたのね...なんか他にやりようないか考えても良いのかな。&lt;/p&gt;&lt;p&gt;とりあえずこれで事なきを得た。 &lt;code&gt;sshd&lt;/code&gt; の起動タイプも手動になっておりヨシ。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; get-service *ssh* | select -Property Name,Status,StartType

Name       Status StartType
----       ------ ---------
ssh-agent Running Automatic
sshd      Stopped    Manual
&lt;/code&gt;&lt;/pre&gt;</description><pubDate>Sat, 20 May 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-05-14-rebuild-blog-with-fable-pt3</guid><link>https://krymtkts.github.io/posts/2023-05-14-rebuild-blog-with-fable-pt3</link><title>Fable でブログを再構築する pt.3</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/blog-fable"&gt;krymtkts/blog-fable&lt;/a&gt; &lt;a href="https://fable.io/"&gt;Fable&lt;/a&gt; でブログを再構築しようとしている。
こちらに手をかけてることで最近 &lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; 触っておらず多少不安になってきたが、もう少し Fable に慣れるまではお預け。&lt;/p&gt;&lt;p&gt;簡単に Index のページに最新ポストをコピるのと、 投稿一式から Archive ページを作るのをやってみている。 &lt;a href="https://github.com/krymtkts/blog-fable/pull/4"&gt;#4&lt;/a&gt;
徐々にコード量が増えることでここは関数にしておいて～とか、コレコレをモジュールにしておいて～とか、楽しくなってきた。
一緒に Tags のページを作りたかったのだけど、いま Markdown 内のタグはじめとしたメタデータをパースしてないから作れない。
先に &lt;a href="https://github.com/remarkjs/remark"&gt;remark&lt;/a&gt; の導入やらないと投稿のメタデータであるタグは(自力で書かない限り)抜けないから、後回しにしておいた。&lt;/p&gt;&lt;p&gt;今回 Archive ページを作るにあたりコードを書いてると、設定で分ける想定をしてコードを汎化した方がスッキリする雰囲気になってきた。
元は完全に自分用のイメージで作っているので、設定に基づいて出力をどうこうするというのは考えてなかった。
現時点ではベタの部分と、設定(というか関数の引数)によって挙動を決める部分が混じり合っているので、徐々に後者に倒していく。&lt;/p&gt;&lt;p&gt;とはいえまだ Tags ページと RSS ができてないので、今後の予定としては以下かなと。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/markedjs/marked"&gt;marked&lt;/a&gt; → &lt;a href="https://github.com/remarkjs/remark"&gt;remark&lt;/a&gt; へ移行する&lt;/li&gt;&lt;li&gt;Markdown ファイルのメタデータ(YAML)が読めるようになるので Tags ページが作れるようになる&lt;/li&gt;&lt;li&gt;RSS 機能を作成する&lt;/li&gt;&lt;li&gt;全体的な汎化で設定の切り出し&lt;/li&gt;&lt;li&gt;ブログのカラーテーマを作る(今は元コードから引き継いだ &lt;a href="https://bulma.io/"&gt;Bulma&lt;/a&gt; のスタイルが適用されてるだけ)&lt;/li&gt;&lt;li&gt;既存ブログとの互換性調整 etc&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;いまんとこ毎週末のスキマ時間で亀進捗出してるので、多少作業が多かろうが大丈夫な気がしてきたな。
最後の互換性のやつだけあんま自信ないけど、リンク切れだけは起こらないように慎重に URL を調整する。
RSS フィードのは、わたしがリーダー側の仕組みがよくわかってなくて、どうなるかわからん。
実際過去に自分が購読してるフィードも全部再配信みたいになってることがあった。せめてそういうのはなくしたいが、先述の通りどうなるかわからん。
わたしの観測範囲ではわたし以外にも一人だけ RSS 購読者がいるっぽいし、たまーに記事が参照されてることもあるので、なるべき気をかけたい。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;あと GitHub の streak 365 まで 100 日切ってた。残りも淡々と続けてこー。&lt;/p&gt;</description><pubDate>Sun, 14 May 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-05-07-rebuild-blog-with-fable-pt2</guid><link>https://krymtkts.github.io/posts/2023-05-07-rebuild-blog-with-fable-pt2</link><title>Fable でブログを再構築する pt.2</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/blog-fable"&gt;krymtkts/blog-fable&lt;/a&gt; の話。
Fable でブログを再構築しようとしている。&lt;/p&gt;&lt;p&gt;repo 公開時点で &lt;code&gt;README.md&lt;/code&gt; をレンダリングするだけに留めていたので、ブログらしく post と固定ページ を出力できるように最低限手を加えた。
&lt;a href="https://github.com/krymtkts/blog-fable/pull/2"&gt;#2&lt;/a&gt;&lt;/p&gt;&lt;p&gt;あと node module に型を与える Fable bindings を利用しようと思い、 &lt;a href="https://github.com/markedjs/marked"&gt;markedjs/marked&lt;/a&gt;, &lt;a href="https://github.com/highlightjs/highlight.js"&gt;highlightjs/highlight.js&lt;/a&gt; でそれを試した。
これが結構大変で、まだ慣れてない。&lt;/p&gt;&lt;p&gt;bindings は自動生成できる。それには &lt;a href="https://github.com/fable-compiler/ts2fable"&gt;fable-compiler/ts2fable&lt;/a&gt; を利用する。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# こんなん。型定義されてない module には使えない。
npx ts2fable node_modules\@types\marked\index.d.ts src/bindings/Marked.fs
npx ts2fable node_modules\@types\highlightjs\index.d.ts src/bindings/HighlightJs.fs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;で出力された型を Fable の F# コードで利用するのだけど、うまく使うために色々覚えないといけない Fable 独自の型・関数・演算子がある。
&lt;code&gt;ImportAttribute&lt;/code&gt; 、 Union Type の &lt;code&gt;U2&lt;/code&gt; その他大勢、動的キャスト演算子 &lt;code&gt;!!&lt;/code&gt; と Anonymous record の組み合わせ、 &lt;code&gt;jsOptions&amp;lt;'a&amp;gt;&lt;/code&gt; ...
まだ勉強中だが、早い話 &lt;a href="https://fable.io/docs/communicate/js-from-fable.html"&gt;Fable · Call JS from Fable&lt;/a&gt; に載ってるの全部知っといた方というか知っとかないとキツイ雰囲気を感じている。
何故なら Fable の真髄であろう JavaScript と F# の型で守られた相互運用がそこに詰まっており、知らないとうまくできないから。&lt;/p&gt;&lt;p&gt;寝かしつけ中にこのページ重要そうなの気づいて何度も読んだけど、実際に書いてみると全く活かせてない。また何度も読み直してる。
何の気なく書かれてる一行のサンプルコードが重要だったり。 JavaScript の Module system に詳しいとピンとくるんかなー。
このテーマに関しては GPT-4 に聞いたところでホラ吹いてくるので、自力で勉強せなあかん。&lt;/p&gt;&lt;p&gt;あと ts2fable で自動生成できない場合は自力で bindings を書く必要があるところも、パンチが効いてる。
今の marked で Syntax Highlighting を使うには&lt;a href="https://github.com/markedjs/marked-highlight"&gt;markedjs/marked-highlight: Add code highlighting to marked&lt;/a&gt; を使う。
けどこいつには Type Declarations &lt;code&gt;.d.ts&lt;/code&gt; が提供されてないので、今回は &lt;code&gt;Fable.Core.JsInterop&lt;/code&gt; の &lt;code&gt;importMember&lt;/code&gt; で茶を濁した。
highlight.js の方も、実は Type Definitions が古くて新しいインタフェースになってない。&lt;/p&gt;&lt;p&gt;このように Fable の技術スタックは JavaScript のそれの上に乗っかって相互に混ざり合ってるので、両方に対して結構詳しくなるまで辛い気がする。
ただその頂きを超えたところに Fable の楽しみがあるのかも、しらんけど。
まあ書いていておもろいのは確かで、色々つまづきながら進めている。&lt;/p&gt;&lt;p&gt;あとここまでやって気づいたのだけど、 marked 自体には Markdown 中に書かれた &lt;code&gt;title&lt;/code&gt; とか &lt;code&gt;tag&lt;/code&gt; とかを読み取る機能ないっぽい。
実現しようとしたらなんか自分で &lt;code&gt;---&lt;/code&gt; でファイルコンテンツ区切って YAML にパースするとかしないとだめみたい。
そもそもこのメタ情報の部分 YAML だとこの機会に初めて知ったわ。
自力で書いてもいいけど、この際 &lt;a href="https://github.com/remarkjs/remark"&gt;remarkjs/remark&lt;/a&gt; みたいなプラグインでそれが実現できるやつを使うのもいいかなと思った。
Markdown のレンダリング部分を換装するのは大変じゃなさそうなので、 navbar 作るとか RSS 作るとかの後に回す。&lt;/p&gt;&lt;p&gt;他にも、開発用途で問題ないとはいえ &lt;a href="https://github.com/tapio/live-server"&gt;tapio/live-server&lt;/a&gt; にいちいち脆弱性の警告出るのも煩わしく、ここを F# のスクリプトに置き換えたい。&lt;/p&gt;&lt;p&gt;やりたいこと盛りだくさん。年内には SSG 乗り換え実施したいな...なんとなく。&lt;/p&gt;</description><pubDate>Sun, 07 May 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-04-30-rebuild-blog-with-fable</guid><link>https://krymtkts.github.io/posts/2023-04-30-rebuild-blog-with-fable</link><title>Fable でブログを再構築する pt.1</title><description>&lt;p&gt;&lt;a href="https://fable.io/"&gt;Fable&lt;/a&gt; の練習を始めた。&lt;/p&gt;&lt;p&gt;Fable にしたのはフロントエンドのエコシステムと統合するのに良さそうだったから。
いまの Clojure 製 Cryogen はフロントエンドとは切り離された感じで、一応 Bootstrap を使ってりはしてるが module 管理とかしてない。なのでフロントエンドの依存性の管理みたいのも一緒にしたいなーと考えていた。&lt;/p&gt;&lt;p&gt;今使ってる Clojure 製の &lt;a href="https://cryogenweb.org/"&gt;Cryogen&lt;/a&gt; と同じ雰囲気を F# で再現するなら &lt;a href="https://github.com/ionide/Fornax"&gt;ionide/Fornax&lt;/a&gt; が正にそんな感じっぽかった。
でも折角なので HTML, JavaScript, CSS 共に F# へ統合した感じにしたい。 Fable ならそれができそうに思えた。&lt;/p&gt;&lt;p&gt;実際のところ Fable は F# を他言語へ変換するトランスパイラなので、静的サイトジェネレーターとして使うにはオーバスペックな感じはある。
けど、こんな機会でもないと一生触らないテクノロジなので、やるならこっちやろ！と考えた。&lt;/p&gt;&lt;p&gt;実現したいことは以下の通り。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Markdown で書いたコンテンツを静的サイトに変換する(Cryogen と同じ使用感)&lt;/li&gt;&lt;li&gt;RSS feed の XML を出す(Cryogen で出したのと同じやつ)&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;ここ 2, 3 週間ほど、子供の寝かしつけ中とかに片手間で Fable やその周辺ツール・モジュールのドキュメントとか諸々の repo を見ていた。けどあんまドキュメント充実しておらず、テンプレプロジェクトを生成して壊してを繰り返してようやく雰囲気がわかってきた。見た目は同じでも中身は違うわ、ってかんじ。&lt;/p&gt;&lt;p&gt;色々試行錯誤した成果として先述の 1 を最小限に実現できたので、一旦日記にまとめる。
&lt;a href="https://github.com/krymtkts/blog-fable"&gt;krymtkts/blog-fable&lt;/a&gt;&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;実現手段はいくつか調査した。
まず Fable 作者の Fable で静的サイトを作った例&lt;sup id="fnref-1"&gt;&lt;a class="footnote-ref" href="#fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt;が既にある。
でも激古なためかわたしが理解不足なのか、全くもって動かすことができなかった。
また &lt;a href="https://bulma.io/"&gt;Bulma&lt;/a&gt; という CSS Framework の Fable wrapper である &lt;a href="https://fulma.github.io/Fulma/#home"&gt;Fulma&lt;/a&gt; のテンプレ&lt;sup id="fnref-2"&gt;&lt;a class="footnote-ref" href="#fn-2"&gt;2&lt;/a&gt;&lt;/sup&gt;もあったのだけど、これも同様に動かし方がわからなかった。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/fable-compiler/fable-compiler.github.io"&gt;Fable の site&lt;/a&gt; で使われている &lt;a href="https://github.com/MangelMaxime/Nacara"&gt;MangelMaxime/Nacara&lt;/a&gt; を試してみたけど、これ RSS 以外をほぼ自分で組り込むところがなくて F# で書く楽しさなさそうったので却下。&lt;/p&gt;&lt;p&gt;ここまで来たら、自力で練習がてら Fable の無垢のテンプレに付け足ししていくしかあるまいなとなった。というか周辺ツールの不理解もあって 1 から自分でやらないと無理ゲーと化してた。&lt;/p&gt;&lt;p&gt;まず &lt;a href="https://fable.io/docs/2-steps/your-first-fable-project.html"&gt;Fable · Start a new project&lt;/a&gt; で素朴なプロジェクトを作成しする。&lt;/p&gt;&lt;p&gt;次に &lt;a href="https://github.com/fable-compiler/static-web-generator"&gt;fable-compiler/static-web-generator&lt;/a&gt; でやってることを移植していく。
ここではエントリポイントで Markdown などのコンテンツを読み込んでテンプレに埋め込み、 HTML にレンダリングした結果をファイル出力している。
なので、まずは素朴な手書きの HTML でいいからファイル出力できる状態にし、その後 React の wrapper を追加する形で進める。&lt;/p&gt;&lt;p&gt;RSS は、 &lt;a href="https://fable.io/docs/dotnet/compatibility.html"&gt;Fable · .NET and F# compatibility&lt;/a&gt; を見るに .NET の機能はまあ使えないので、 Node.js で xml を出力するやつを移植することになるハズ。
なんかハードな気配してきた。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;何度も作っては消しを繰り返して得た確かな手順は以下の通り。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Fable のプロジェクト作成は &lt;a href="https://fable.io/docs/2-steps/your-first-fable-project.html"&gt;Fable · Start a new project&lt;/a&gt; を参照&lt;/li&gt;&lt;li&gt;.NET 系ツールの取り回しは以下を参照
&lt;ul&gt;&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/core/tools/global-tools"&gt;How to manage .NET tools - .NET CLI | Microsoft Learn&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/core/tools/global-json"&gt;global.json overview - .NET CLI | Microsoft Learn&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;(後述する) Femto は &lt;a href="https://fable.io/blog/2019/2019-06-29-Introducing-Femto.html"&gt;Fable · Introducing Femto&lt;/a&gt; を参照&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href="https://github.com/fsprojects/Paket"&gt;Paket&lt;/a&gt; を使うと依存関係の管理が楽になる(project ファイルから外に出せるから)のだけど、今回は導入しなかった。関係するツールが多すぎて腹いっぱいになってる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# 無垢の Fable project 作成する。
dotnet new install Fable.template
dotnet new fable --name blog-fable
cd blog-fable
git init
git commit --allow-empty -m 'Initial commit.'
git add .
git commit -m 'Add minimal Fable template.'

# dotnet tool を更新する。
dotnet tool update fable
dotnet tool update femto

# 動くことを確認する。
npm install
npm run start

# global.json の更新方法わからないので力づくで書き換えて更新する。
dotnet new globaljson --sdk-version 7.0.203 --roll-forward latestFeature --force
dotnet tool restore
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;build target が .Net Core 2.0 なので .Net 7 にする。
&lt;code&gt;src\App.fsproj&lt;/code&gt; を編集する。&lt;/p&gt;&lt;pre&gt;&lt;code class="patch"&gt; &amp;lt;Project Sdk="Microsoft.NET.Sdk"&amp;gt;
   &amp;lt;PropertyGroup&amp;gt;
-    &amp;lt;TargetFramework&amp;gt;netstandard2.0&amp;lt;/TargetFramework&amp;gt;
+    &amp;lt;TargetFramework&amp;gt;net7&amp;lt;/TargetFramework&amp;gt;
   &amp;lt;/PropertyGroup&amp;gt;
   &amp;lt;ItemGroup&amp;gt;
     &amp;lt;Compile Include="App.fs" /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Fable も最新版の 4 にする。
これには &lt;a href="https://github.com/Zaid-Ajaj/Femto"&gt;Femto&lt;/a&gt; という tool を使うみたい。 Femto は packet と npm の仲介役のようなやつで、 Nuget から Fable のモジュールを持ってきたらついでに npm してくれるようなやつっぽい。
さっぱりわからんが、コマンド打ったら確かに更新された。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;femto install Fable.Core .\src
femto install Fable.Browser.Dom .\src
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;↓ こうなった。&lt;/p&gt;&lt;pre&gt;&lt;code class="patch"&gt;   &amp;lt;ItemGroup&amp;gt;
-    &amp;lt;PackageReference Include="Fable.Browser.Dom" Version="2.2.0" /&amp;gt;
-    &amp;lt;PackageReference Include="Fable.Core" Version="3.2.3" /&amp;gt;
+    &amp;lt;PackageReference Include="Fable.Browser.Dom" Version="2.14.0" /&amp;gt;
+    &amp;lt;PackageReference Include="Fable.Core" Version="4.0.0" /&amp;gt;
   &amp;lt;/ItemGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;npm run start&lt;/code&gt; &lt;code&gt;npm run build&lt;/code&gt; あたりが動いてたら大丈夫だろう。
(&lt;code&gt;dotnet tool restore&lt;/code&gt; が &lt;code&gt;postinstall&lt;/code&gt; で走る記述になってる)&lt;/p&gt;&lt;p&gt;webpack も古かったのでとりあえず上げておいたが、 SSG したいだけなのでこれらは後ほど消した。&lt;/p&gt;&lt;p&gt;ついでに solution も作っとく。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;dotnet new sln
dotnet sln add ./src
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ここまでやってまだテンプレが最新化されただけ...&lt;/p&gt;&lt;p&gt;ここからが本番。
無味乾燥したテンプレに &lt;a href="https://github.com/fable-compiler/static-web-generator"&gt;fable-compiler/static-web-generator&lt;/a&gt; の要素を足していく。&lt;/p&gt;&lt;p&gt;以下の Fable の package が使われており、そのうちいくつかは deprecated されてる。分割されている package を追うのは直に repo でコードを追うしかなく、なかなかハードな道のりだった。
そして調べた内容で書き換えをした。書き換えの内容は &lt;a href="https://github.com/krymtkts/blog-fable"&gt;krymtkts/blog-fable&lt;/a&gt; を直に見るのが良い(書くのめんどい)。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Fable.PowerPack ← &lt;a href="https://github.com/fable-compiler/fable-powerpack"&gt;fable-compiler/fable-powerpack: Utilities for Fable apps&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/fable-compiler/fable-powerpack/issues/63"&gt;Split Fable.PowerPack in multiple packages? · Issue #63 · fable-compiler/fable-powerpack&lt;/a&gt; 分割された&lt;/li&gt;&lt;li&gt;そもそも使ってなくね？ということで移植しない&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Fable.React ← &lt;a href="https://github.com/Zaid-Ajaj/Feliz"&gt;Zaid-Ajaj/Feliz&lt;/a&gt; 使えと&lt;/li&gt;&lt;li&gt;Fable.Import 系はデカすぎて repo が分かれた &lt;a href="https://github.com/fable-compiler/fable-import/issues/80"&gt;Track repo splits · Issue #80 · fable-compiler/fable-import&lt;/a&gt;&lt;ul&gt;&lt;li&gt;Fable.Import.Browser ← &lt;a href="https://github.com/fable-compiler/fable-browser"&gt;fable-browser&lt;/a&gt;&lt;/li&gt;&lt;li&gt;Fable.Import.Node ← &lt;a href="https://github.com/fable-compiler/fable-node"&gt;fable-compiler/fable-node: Bindings for node.js native modules&lt;/a&gt; めちゃ古だがまだ動くらしい？&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Fulma ← 今回は使わなかった&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;これら新しい package を移植し多少のコードを変更することで、やっと Markdown(今は &lt;code&gt;README.md&lt;/code&gt; のみ) → HTML とパースして表示できるようになった。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;ひとまずここまで。&lt;/p&gt;&lt;p&gt;まだたった 1 ページを出力できただけで先は長いが、 Fable の雰囲気わかってきてできそうな感触を得ている。&lt;/p&gt;&lt;p&gt;やっぱ Node.js の変更周り全然わからんことだらけなので、そこは &lt;a href="https://github.com/MangelMaxime/Nacara/blob/master/src/Nacara.Core/Node.Extra.fs#L8"&gt;Nacara/Node.Extra.fs at master · MangelMaxime/Nacara&lt;/a&gt; のイケてる実装を参照するなどして組んでいけたら良さそう。&lt;/p&gt;&lt;p&gt;あとやっぱ F# は .NET へ重依存なので .NET を部分的にしか使わない Fable だとかなり書き味が違う。これに慣れるのはちょっとかかりそう。&lt;/p&gt;&lt;p&gt;続く。&lt;/p&gt;&lt;div class="footnotes"&gt;&lt;hr /&gt;&lt;ol&gt;&lt;li id="fn-1"&gt;&lt;p&gt;&lt;a href="https://github.com/fable-compiler/static-web-generator"&gt;fable-compiler/static-web-generator: Simple Fable Node.js app to generate static pages&lt;/a&gt;&lt;/p&gt;&lt;a href="#fnref-1" class="footnote-backref"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id="fn-2"&gt;&lt;p&gt;&lt;a href="https://fulma.github.io/Fulma/#template"&gt;Template - Fulma&lt;/a&gt;&lt;/p&gt;&lt;a href="#fnref-2" class="footnote-backref"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description><pubDate>Sun, 30 Apr 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-04-23-1-year-of-pocof</guid><link>https://krymtkts.github.io/posts/2023-04-23-1-year-of-pocof</link><title>pocof の 1 年間</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。&lt;/p&gt;&lt;p&gt;明日 2023-04-24 で pocof の開発を始めてから 1 年になるらしい。
開発しない週があったり、そもそも進捗は亀だが、続けてきたのは我ながらエライ。
折角なので Git の commit history を基に活動を振り返ってみる。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;書き捨てのスクリプトは以下。案外役に立ったのでなんか小綺麗にして使える感じにしてもいいな。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# merge commit 除く。
$logs = git log --pretty=format:"%cd,%s" --date=iso-strict | ConvertFrom-Csv -Header CommitDate, Message | Where-Object -Property Message -NotLike 'Merge pull request*' | ForEach-Object { [PSCustomObject]@{
        CommitDate = Get-Date $_.CommitDate
        Message = $_.Message
    } }

# 年月ごとのコミット数。
$logs | ForEach-Object { $_.CommitDate.ToString('yyyy-MM') } | Group-Object | Select-Object -Property Name, Count

# 追加・削除行数。
$ret = @{}
$stats = git log --numstat --pretty="%cd" --date=iso-strict | ForEach-Object {
    switch ($_) {
        { $_ -match '\d{4}-\d{2}-\d{2}' } {
            $key = Get-Date $_
        }
        default {
            $values = $_ -split "`t"
            if ($values.Count -eq 3) {
                if ($ret.ContainsKey($key)) {
                    $entry = $ret[$key]
                    $ret[$key] = [PSCustomObject]@{
                        Add = [int]$values[0] + $entry.Add
                        Remove = [int]$values[1] + $entry.Remove
                    }
                }
                else {
                    $ret[$key] = [PSCustomObject]@{
                        Add = [int]$values[0]
                        Remove = [int]$values[1]
                    }
                }
            }
        }
    }
} -End { $ret }
$stats.GetEnumerator() | ForEach-Object { [PSCustomObject]@{Add = $_.Value.Add; Remove = $_.value.remove } } | Measure-Object -Property add, remove -Sum | Format-Table

# 年月ごとの追加・削除行数。
$ret = @{}
$monthly = $stats.GetEnumerator() | ForEach-Object { [PSCustomObject]@{YM = $_.Key.ToString('yyyy-MM'); Add = $_.Value.Add; remove = $_.value.Remove } } | ForEach-Object {
    if ($ret.ContainsKey($_.YM)) {
        $entry = $ret[$_.YM]
        $ret[$_.YM] = [PSCustomObject]@{
            Add = [int]$_.Add + $entry.Add
            Remove = [int]$_.Remove + $entry.Remove
        }
    }
    else {
        $ret[$_.YM] = [PSCustomObject]@{
            Add = [int]$_.Add
            Remove = [int]$_.Remove
        }
    }
} -End { $ret }
$monthly.GetEnumerator() | Sort-Object -Property Key | ForEach-Object { [PSCustomObject]@{YM = $_.Key; Add = $_.Value.Add; Remove = $_.value.remove } }

# ファイルごとの追加・削除行数。
$ret = @{}
$fileStats = git log --numstat --pretty="%cd" --date=iso-strict | ForEach-Object {
    $values = $_ -split "`t"
    if ($values.Count -eq 3) {
        $key = $values[2]
        if ($ret.ContainsKey($key)) {
            $entry = $ret[$key]
            $ret[$key] = [PSCustomObject]@{
                Add = [int]$values[0] + $entry.Add
                Remove = [int]$values[1] + $entry.Remove
            }
        }
        else {
            $ret[$key] = [PSCustomObject]@{
                Add = [int]$values[0]
                Remove = [int]$values[1]
            }
        }
    }
} -End { $ret }
$fileStats.GetEnumerator() | ForEach-Object { [PSCustomObject]@{File = $_.Key; Add = $_.Value.Add; Remove = $_.Value.Remove } } | Sort-Object -Property Add, Remove -Descending

# 年月・ファイルごとの追加・削除行数。
$ret = @{}
$fileStats = git log --numstat --pretty="%cd" --date=iso-strict | ForEach-Object {
    switch ($_) {
        { $_ -match '\d{4}-\d{2}-\d{2}' } {
            $date = Get-Date $_
        }
        default {
            $values = $_ -split "`t"
            if ($values.Count -eq 3) {
                $key = "$($date.ToString('yyyy-MM')) $($values[2])"
                if ($ret.ContainsKey($key)) {
                    $entry = $ret[$key]
                    $ret[$key] = [PSCustomObject]@{
                        Add = [int]$values[0] + $entry.Add
                        Remove = [int]$values[1] + $entry.Remove
                    }
                }
                else {
                    $ret[$key] = [PSCustomObject]@{
                        Add = [int]$values[0]
                        Remove = [int]$values[1]
                    }
                }
            }
        }
    }
} -End { $ret }
$fileStats.GetEnumerator() | ForEach-Object { [PSCustomObject]@{File = $_.Key; Add = $_.Value.Add; Remove = $_.Value.Remove } } | Sort-Object -Property File, Add, Remove
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Merge commit を除いたコミット数が 113 。 2023 年に入ってからは前年より多少活発。&lt;/p&gt;&lt;p&gt;以下は年月ごとのコミット数。
開発してない月あるんじゃないかって気がしてたが、ギリギリ毎月開発してた様子。&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;YM&lt;/th&gt;&lt;th align="right"&gt;Commit&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;2022-04&lt;/td&gt;&lt;td align="right"&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-05&lt;/td&gt;&lt;td align="right"&gt;16&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-06&lt;/td&gt;&lt;td align="right"&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-07&lt;/td&gt;&lt;td align="right"&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-08&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-09&lt;/td&gt;&lt;td align="right"&gt;11&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-10&lt;/td&gt;&lt;td align="right"&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-11&lt;/td&gt;&lt;td align="right"&gt;7&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-12&lt;/td&gt;&lt;td align="right"&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-01&lt;/td&gt;&lt;td align="right"&gt;7&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-02&lt;/td&gt;&lt;td align="right"&gt;15&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-03&lt;/td&gt;&lt;td align="right"&gt;24&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-04&lt;/td&gt;&lt;td align="right"&gt;16&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;コードの変更を伴うコミットが今まで 109 あって、
追加された行が 6312 、削除された行が 2821 。44% 位を書き直してるのが意外だった。時期的にはテストコード拡充とそれによるリファクタが大きい要因か。&lt;/p&gt;&lt;p&gt;以下が年月ごとの追加・削除行数。&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;YM&lt;/th&gt;&lt;th align="right"&gt;Add&lt;/th&gt;&lt;th align="right"&gt;Remove&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;2022-04&lt;/td&gt;&lt;td align="right"&gt;717&lt;/td&gt;&lt;td align="right"&gt;83&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-05&lt;/td&gt;&lt;td align="right"&gt;1425&lt;/td&gt;&lt;td align="right"&gt;386&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-06&lt;/td&gt;&lt;td align="right"&gt;83&lt;/td&gt;&lt;td align="right"&gt;26&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-07&lt;/td&gt;&lt;td align="right"&gt;61&lt;/td&gt;&lt;td align="right"&gt;56&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-08&lt;/td&gt;&lt;td align="right"&gt;30&lt;/td&gt;&lt;td align="right"&gt;17&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-09&lt;/td&gt;&lt;td align="right"&gt;233&lt;/td&gt;&lt;td align="right"&gt;145&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-10&lt;/td&gt;&lt;td align="right"&gt;69&lt;/td&gt;&lt;td align="right"&gt;27&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-11&lt;/td&gt;&lt;td align="right"&gt;365&lt;/td&gt;&lt;td align="right"&gt;170&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-12&lt;/td&gt;&lt;td align="right"&gt;57&lt;/td&gt;&lt;td align="right"&gt;19&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-01&lt;/td&gt;&lt;td align="right"&gt;358&lt;/td&gt;&lt;td align="right"&gt;245&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-02&lt;/td&gt;&lt;td align="right"&gt;214&lt;/td&gt;&lt;td align="right"&gt;143&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-03&lt;/td&gt;&lt;td align="right"&gt;2163&lt;/td&gt;&lt;td align="right"&gt;1134&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-04&lt;/td&gt;&lt;td align="right"&gt;537&lt;/td&gt;&lt;td align="right"&gt;370&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;ファイル別の分析はちょっと面倒で、 rename したものやドキュメント類も含まれてしまってる。
が、 目 grep した感じだと最近テストを頑張って書いてた &lt;code&gt;Action.fs&lt;/code&gt;, &lt;code&gt;Data.fs&lt;/code&gt; あたりの新陳代謝ができており、それにつられて依存関係の &lt;code&gt;Library.fs&lt;/code&gt; の変更も多いと。
&lt;code&gt;Query.fs&lt;/code&gt; はコア部分なので削除少ないのはおっかなびっくりいじってるからかな？
&lt;code&gt;UI.fs&lt;/code&gt; なんかは全然いじれてないので削除行数少なめ。&lt;/p&gt;&lt;p&gt;以下がファイルごとの追加・削除行数。&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;File&lt;/th&gt;&lt;th align="right"&gt;Add&lt;/th&gt;&lt;th align="right"&gt;Remove&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;src/pocof.Test/Tests.fs&lt;/td&gt;&lt;td align="right"&gt;798&lt;/td&gt;&lt;td align="right"&gt;798&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;src/pocof.Test/PocofData.fs&lt;/td&gt;&lt;td align="right"&gt;705&lt;/td&gt;&lt;td align="right"&gt;145&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;src/pocof/Action.fs&lt;/td&gt;&lt;td align="right"&gt;569&lt;/td&gt;&lt;td align="right"&gt;179&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;src/pocof/Data.fs&lt;/td&gt;&lt;td align="right"&gt;517&lt;/td&gt;&lt;td align="right"&gt;451&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;src/pocof/Library.fs&lt;/td&gt;&lt;td align="right"&gt;470&lt;/td&gt;&lt;td align="right"&gt;282&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;src/pocof.Test/PocofQuery.fs&lt;/td&gt;&lt;td align="right"&gt;459&lt;/td&gt;&lt;td align="right"&gt;131&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;src/pocof/Query.fs&lt;/td&gt;&lt;td align="right"&gt;430&lt;/td&gt;&lt;td align="right"&gt;261&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;.gitignore&lt;/td&gt;&lt;td align="right"&gt;399&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;src/pocof/pocof.dll-Help.xml&lt;/td&gt;&lt;td align="right"&gt;382&lt;/td&gt;&lt;td align="right"&gt;60&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;tests/pocof.Tests.ps1&lt;/td&gt;&lt;td align="right"&gt;263&lt;/td&gt;&lt;td align="right"&gt;113&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;docs/Select-Pocof.md&lt;/td&gt;&lt;td align="right"&gt;260&lt;/td&gt;&lt;td align="right"&gt;31&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;src/pocof/UI.fs&lt;/td&gt;&lt;td align="right"&gt;238&lt;/td&gt;&lt;td align="right"&gt;112&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;src/pocof/pocof.psd1&lt;/td&gt;&lt;td align="right"&gt;231&lt;/td&gt;&lt;td align="right"&gt;99&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;src/pocof.Test/PocofAction.fs&lt;/td&gt;&lt;td align="right"&gt;171&lt;/td&gt;&lt;td align="right"&gt;23&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;psakefile.ps1&lt;/td&gt;&lt;td align="right"&gt;134&lt;/td&gt;&lt;td align="right"&gt;31&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;src/pocof/{Action.fs =&amp;gt; Data.fs}&lt;/td&gt;&lt;td align="right"&gt;71&lt;/td&gt;&lt;td align="right"&gt;82&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;src/pocof/pocof.fsproj&lt;/td&gt;&lt;td align="right"&gt;38&lt;/td&gt;&lt;td align="right"&gt;17&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;pocof.sln&lt;/td&gt;&lt;td align="right"&gt;36&lt;/td&gt;&lt;td align="right"&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;src/pocof.Test/pocof.Test.fsproj&lt;/td&gt;&lt;td align="right"&gt;36&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;README.md&lt;/td&gt;&lt;td align="right"&gt;33&lt;/td&gt;&lt;td align="right"&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;.github/workflows/pr.yml&lt;/td&gt;&lt;td align="right"&gt;30&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;LICENSE&lt;/td&gt;&lt;td align="right"&gt;21&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;test/pocof.Tests.ps1&lt;/td&gt;&lt;td align="right"&gt;17&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;src/pocof.Test/Program.fs&lt;/td&gt;&lt;td align="right"&gt;4&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;{test =&amp;gt; tests}/pocof.Tests.ps1&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;以下が年月・ファイルごとの追加・削除行数。&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;File&lt;/th&gt;&lt;th align="right"&gt;Add&lt;/th&gt;&lt;th align="right"&gt;Remove&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;2022-04 .gitignore&lt;/td&gt;&lt;td align="right"&gt;398&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-04 pocof.sln&lt;/td&gt;&lt;td align="right"&gt;27&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-04 src/pocof/Library.fs&lt;/td&gt;&lt;td align="right"&gt;57&lt;/td&gt;&lt;td align="right"&gt;3&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-04 src/pocof/pocof.dll-Help.xml&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-04 src/pocof/pocof.fsproj&lt;/td&gt;&lt;td align="right"&gt;22&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-04 src/pocof/pocof.psd1&lt;/td&gt;&lt;td align="right"&gt;212&lt;/td&gt;&lt;td align="right"&gt;80&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-05 {test =&amp;gt; tests}/pocof.Tests.ps1&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-05 docs/Select-Pocof.md&lt;/td&gt;&lt;td align="right"&gt;181&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-05 LICENSE&lt;/td&gt;&lt;td align="right"&gt;21&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-05 pocof.sln&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-05 psakefile.ps1&lt;/td&gt;&lt;td align="right"&gt;90&lt;/td&gt;&lt;td align="right"&gt;13&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-05 README.md&lt;/td&gt;&lt;td align="right"&gt;15&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-05 src/pocof/{Action.fs =&amp;gt; Data.fs}&lt;/td&gt;&lt;td align="right"&gt;71&lt;/td&gt;&lt;td align="right"&gt;82&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-05 src/pocof/Action.fs&lt;/td&gt;&lt;td align="right"&gt;346&lt;/td&gt;&lt;td align="right"&gt;46&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-05 src/pocof/Data.fs&lt;/td&gt;&lt;td align="right"&gt;89&lt;/td&gt;&lt;td align="right"&gt;107&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-05 src/pocof/Library.fs&lt;/td&gt;&lt;td align="right"&gt;150&lt;/td&gt;&lt;td align="right"&gt;112&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-05 src/pocof/pocof.dll-Help.xml&lt;/td&gt;&lt;td align="right"&gt;261&lt;/td&gt;&lt;td align="right"&gt;3&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-05 src/pocof/pocof.fsproj&lt;/td&gt;&lt;td align="right"&gt;8&lt;/td&gt;&lt;td align="right"&gt;9&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-05 src/pocof/pocof.psd1&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-05 src/pocof/Query.fs&lt;/td&gt;&lt;td align="right"&gt;39&lt;/td&gt;&lt;td align="right"&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-05 src/pocof/UI.fs&lt;/td&gt;&lt;td align="right"&gt;128&lt;/td&gt;&lt;td align="right"&gt;10&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-05 test/pocof.Tests.ps1&lt;/td&gt;&lt;td align="right"&gt;17&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-05 tests/pocof.Tests.ps1&lt;/td&gt;&lt;td align="right"&gt;7&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-06 src/pocof/Library.fs&lt;/td&gt;&lt;td align="right"&gt;3&lt;/td&gt;&lt;td align="right"&gt;3&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-06 src/pocof/pocof.fsproj&lt;/td&gt;&lt;td align="right"&gt;3&lt;/td&gt;&lt;td align="right"&gt;3&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-06 src/pocof/Query.fs&lt;/td&gt;&lt;td align="right"&gt;43&lt;/td&gt;&lt;td align="right"&gt;11&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-06 src/pocof/UI.fs&lt;/td&gt;&lt;td align="right"&gt;34&lt;/td&gt;&lt;td align="right"&gt;9&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-07 src/pocof/Data.fs&lt;/td&gt;&lt;td align="right"&gt;7&lt;/td&gt;&lt;td align="right"&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-07 src/pocof/Library.fs&lt;/td&gt;&lt;td align="right"&gt;4&lt;/td&gt;&lt;td align="right"&gt;11&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-07 src/pocof/Query.fs&lt;/td&gt;&lt;td align="right"&gt;41&lt;/td&gt;&lt;td align="right"&gt;38&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-07 src/pocof/UI.fs&lt;/td&gt;&lt;td align="right"&gt;9&lt;/td&gt;&lt;td align="right"&gt;3&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-08 psakefile.ps1&lt;/td&gt;&lt;td align="right"&gt;3&lt;/td&gt;&lt;td align="right"&gt;3&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-08 src/pocof/Library.fs&lt;/td&gt;&lt;td align="right"&gt;27&lt;/td&gt;&lt;td align="right"&gt;14&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-09 psakefile.ps1&lt;/td&gt;&lt;td align="right"&gt;17&lt;/td&gt;&lt;td align="right"&gt;8&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-09 README.md&lt;/td&gt;&lt;td align="right"&gt;18&lt;/td&gt;&lt;td align="right"&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-09 src/pocof/Action.fs&lt;/td&gt;&lt;td align="right"&gt;11&lt;/td&gt;&lt;td align="right"&gt;8&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-09 src/pocof/Data.fs&lt;/td&gt;&lt;td align="right"&gt;18&lt;/td&gt;&lt;td align="right"&gt;18&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-09 src/pocof/Library.fs&lt;/td&gt;&lt;td align="right"&gt;88&lt;/td&gt;&lt;td align="right"&gt;51&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-09 src/pocof/pocof.fsproj&lt;/td&gt;&lt;td align="right"&gt;2&lt;/td&gt;&lt;td align="right"&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-09 src/pocof/pocof.psd1&lt;/td&gt;&lt;td align="right"&gt;15&lt;/td&gt;&lt;td align="right"&gt;15&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-09 src/pocof/Query.fs&lt;/td&gt;&lt;td align="right"&gt;18&lt;/td&gt;&lt;td align="right"&gt;17&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-09 src/pocof/UI.fs&lt;/td&gt;&lt;td align="right"&gt;8&lt;/td&gt;&lt;td align="right"&gt;12&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-09 tests/pocof.Tests.ps1&lt;/td&gt;&lt;td align="right"&gt;38&lt;/td&gt;&lt;td align="right"&gt;12&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-10 src/pocof/Library.fs&lt;/td&gt;&lt;td align="right"&gt;19&lt;/td&gt;&lt;td align="right"&gt;12&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-10 src/pocof/pocof.fsproj&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-10 src/pocof/pocof.psd1&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-10 src/pocof/Query.fs&lt;/td&gt;&lt;td align="right"&gt;16&lt;/td&gt;&lt;td align="right"&gt;8&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-10 src/pocof/UI.fs&lt;/td&gt;&lt;td align="right"&gt;6&lt;/td&gt;&lt;td align="right"&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-10 tests/pocof.Tests.ps1&lt;/td&gt;&lt;td align="right"&gt;26&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-11 docs/Select-Pocof.md&lt;/td&gt;&lt;td align="right"&gt;58&lt;/td&gt;&lt;td align="right"&gt;26&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-11 src/pocof/Action.fs&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-11 src/pocof/Data.fs&lt;/td&gt;&lt;td align="right"&gt;29&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-11 src/pocof/Library.fs&lt;/td&gt;&lt;td align="right"&gt;6&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-11 src/pocof/pocof.dll-Help.xml&lt;/td&gt;&lt;td align="right"&gt;97&lt;/td&gt;&lt;td align="right"&gt;57&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-11 src/pocof/pocof.fsproj&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-11 src/pocof/pocof.psd1&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-11 src/pocof/Query.fs&lt;/td&gt;&lt;td align="right"&gt;66&lt;/td&gt;&lt;td align="right"&gt;53&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-11 src/pocof/UI.fs&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-11 tests/pocof.Tests.ps1&lt;/td&gt;&lt;td align="right"&gt;106&lt;/td&gt;&lt;td align="right"&gt;30&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-12 src/pocof/Data.fs&lt;/td&gt;&lt;td align="right"&gt;13&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-12 src/pocof/Library.fs&lt;/td&gt;&lt;td align="right"&gt;23&lt;/td&gt;&lt;td align="right"&gt;9&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-12 src/pocof/Query.fs&lt;/td&gt;&lt;td align="right"&gt;5&lt;/td&gt;&lt;td align="right"&gt;5&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-12 src/pocof/UI.fs&lt;/td&gt;&lt;td align="right"&gt;16&lt;/td&gt;&lt;td align="right"&gt;5&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-01 src/pocof/Action.fs&lt;/td&gt;&lt;td align="right"&gt;3&lt;/td&gt;&lt;td align="right"&gt;3&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-01 src/pocof/Data.fs&lt;/td&gt;&lt;td align="right"&gt;204&lt;/td&gt;&lt;td align="right"&gt;154&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-01 src/pocof/Library.fs&lt;/td&gt;&lt;td align="right"&gt;14&lt;/td&gt;&lt;td align="right"&gt;7&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-01 src/pocof/Query.fs&lt;/td&gt;&lt;td align="right"&gt;124&lt;/td&gt;&lt;td align="right"&gt;50&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-01 src/pocof/UI.fs&lt;/td&gt;&lt;td align="right"&gt;13&lt;/td&gt;&lt;td align="right"&gt;31&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-02 docs/Select-Pocof.md&lt;/td&gt;&lt;td align="right"&gt;21&lt;/td&gt;&lt;td align="right"&gt;5&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-02 src/pocof/Action.fs&lt;/td&gt;&lt;td align="right"&gt;9&lt;/td&gt;&lt;td align="right"&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-02 src/pocof/Data.fs&lt;/td&gt;&lt;td align="right"&gt;21&lt;/td&gt;&lt;td align="right"&gt;14&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-02 src/pocof/Library.fs&lt;/td&gt;&lt;td align="right"&gt;22&lt;/td&gt;&lt;td align="right"&gt;11&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-02 src/pocof/pocof.dll-Help.xml&lt;/td&gt;&lt;td align="right"&gt;23&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-02 src/pocof/pocof.fsproj&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-02 src/pocof/pocof.psd1&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-02 src/pocof/Query.fs&lt;/td&gt;&lt;td align="right"&gt;18&lt;/td&gt;&lt;td align="right"&gt;12&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-02 src/pocof/UI.fs&lt;/td&gt;&lt;td align="right"&gt;17&lt;/td&gt;&lt;td align="right"&gt;25&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-02 tests/pocof.Tests.ps1&lt;/td&gt;&lt;td align="right"&gt;81&lt;/td&gt;&lt;td align="right"&gt;70&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-03 .gitignore&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-03 pocof.sln&lt;/td&gt;&lt;td align="right"&gt;8&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-03 psakefile.ps1&lt;/td&gt;&lt;td align="right"&gt;17&lt;/td&gt;&lt;td align="right"&gt;7&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-03 src/pocof.Test/pocof.Test.fsproj&lt;/td&gt;&lt;td align="right"&gt;36&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-03 src/pocof.Test/PocofAction.fs&lt;/td&gt;&lt;td align="right"&gt;113&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-03 src/pocof.Test/PocofData.fs&lt;/td&gt;&lt;td align="right"&gt;530&lt;/td&gt;&lt;td align="right"&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-03 src/pocof.Test/PocofQuery.fs&lt;/td&gt;&lt;td align="right"&gt;404&lt;/td&gt;&lt;td align="right"&gt;118&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-03 src/pocof.Test/Program.fs&lt;/td&gt;&lt;td align="right"&gt;4&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-03 src/pocof.Test/Tests.fs&lt;/td&gt;&lt;td align="right"&gt;798&lt;/td&gt;&lt;td align="right"&gt;798&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-03 src/pocof/Action.fs&lt;/td&gt;&lt;td align="right"&gt;161&lt;/td&gt;&lt;td align="right"&gt;91&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-03 src/pocof/Data.fs&lt;/td&gt;&lt;td align="right"&gt;81&lt;/td&gt;&lt;td align="right"&gt;112&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-03 src/pocof/Library.fs&lt;/td&gt;&lt;td align="right"&gt;2&lt;/td&gt;&lt;td align="right"&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-03 src/pocof/Query.fs&lt;/td&gt;&lt;td align="right"&gt;7&lt;/td&gt;&lt;td align="right"&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-03 tests/pocof.Tests.ps1&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-04 .github/workflows/pr.yml&lt;/td&gt;&lt;td align="right"&gt;30&lt;/td&gt;&lt;td align="right"&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-04 psakefile.ps1&lt;/td&gt;&lt;td align="right"&gt;7&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-04 src/pocof.Test/PocofAction.fs&lt;/td&gt;&lt;td align="right"&gt;58&lt;/td&gt;&lt;td align="right"&gt;23&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-04 src/pocof.Test/PocofData.fs&lt;/td&gt;&lt;td align="right"&gt;175&lt;/td&gt;&lt;td align="right"&gt;143&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-04 src/pocof.Test/PocofQuery.fs&lt;/td&gt;&lt;td align="right"&gt;55&lt;/td&gt;&lt;td align="right"&gt;13&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-04 src/pocof/Action.fs&lt;/td&gt;&lt;td align="right"&gt;38&lt;/td&gt;&lt;td align="right"&gt;27&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-04 src/pocof/Data.fs&lt;/td&gt;&lt;td align="right"&gt;55&lt;/td&gt;&lt;td align="right"&gt;42&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-04 src/pocof/Library.fs&lt;/td&gt;&lt;td align="right"&gt;55&lt;/td&gt;&lt;td align="right"&gt;46&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-04 src/pocof/Query.fs&lt;/td&gt;&lt;td align="right"&gt;53&lt;/td&gt;&lt;td align="right"&gt;63&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-04 src/pocof/UI.fs&lt;/td&gt;&lt;td align="right"&gt;7&lt;/td&gt;&lt;td align="right"&gt;12&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-04 tests/pocof.Tests.ps1&lt;/td&gt;&lt;td align="right"&gt;4&lt;/td&gt;&lt;td align="right"&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr /&gt;&lt;p&gt;2 年目も細々と開発を続けていく。他にやることで Fable でブログ再構築する際の調べ物あるけど、直感ではそんなに失速しないんじゃないかなという気がしている(気だけかも)。&lt;/p&gt;</description><pubDate>Sun, 23 Apr 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-04-16-writing-cmdlet-in-fsharp-pt19</guid><link>https://krymtkts.github.io/posts/2023-04-16-writing-cmdlet-in-fsharp-pt19</link><title>F#でコマンドレットを書いてる pt.19</title><description>&lt;p&gt;本当は Fable のメモを記録したかった。 Fable の練習を始めようと思って &lt;a href="https://fable.io/docs/2-steps/your-first-fable-project.html"&gt;Fable · Start a new project&lt;/a&gt; を参考にプロジェクトを作成(以下)した。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;dotnet new fable --name krymtkts.github.io
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;その後作成されたプロジェクトを VS Code で開いたら OOM で VS Code がお亡くなりになったので、また今度やるか...という気持ちに切り替わってしまった。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;閑話休題。&lt;/p&gt;&lt;p&gt;また &lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。&lt;/p&gt;&lt;p&gt;もう 2023-04 も半ばを過ぎ、前回の pocof 0.4.0-alpha から 2 ヶ月経とうとしてるが、粛々とテスト追加と書き直しをしている。&lt;/p&gt;&lt;p&gt;以前 GitHub Actions の Workflow を作成した時に、 &lt;code&gt;ubuntu_latest&lt;/code&gt; つまり非 Windows でも &lt;a href="https://github.com/pester/Pester"&gt;Pester&lt;/a&gt; のテストが問題なく緑になるんだなというのがわかった。
これを機に OS の build matrix を組んで Windows, Linux, Mac の 3 つのプラットフォームのテストを有効にしてみた。 &lt;a href="https://github.com/krymtkts/pocof/pull/48"&gt;#48&lt;/a&gt;&lt;/p&gt;&lt;p&gt;すべてのプラットフォームでテストが成功したのを見て、 .NET 良く出来てるなあと思った(小並感)。
とはいえ実際に PowerShell on Ubuntu でインタラクティブな動作テストしたわけじゃないし、 .NET はキー周りが大変だと聞く。
わたしが持っているこの辺の知識はこれしかないけど →
&lt;a href="https://devblogs.microsoft.com/dotnet/console-readkey-improvements-in-net-7/"&gt;Console.ReadKey improvements in .NET 7 - .NET Blog&lt;/a&gt;&lt;/p&gt;&lt;p&gt;なので、いつか時間を取って人力で確認しないといけないのではと思っている。
実際問題、例えば Ubuntu に PowerShell 入れるのって相当動機づけされてないとやらなそうなのだけど、機が熟しつつある。
良いのか悪いのかは知らん。ただ面白そうではある。&lt;/p&gt;&lt;p&gt;pocof の機能追加はやってなくて、 CLI の UI をいじるところ以外はテストも揃ってきたので、リファクタリングと称して主に構造変換をそれほど伴わない書き直しをしている。 &lt;a href="https://github.com/krymtkts/pocof/pull/49"&gt;#49&lt;/a&gt;&lt;/p&gt;&lt;p&gt;pocof は PowerShell で書かれた &lt;a href="https://github.com/jasonmarcher/poco"&gt;poco&lt;/a&gt; を F# で写経するところから始まっているので、あまり F# ぽくない感じの箇所が多々ある。その環境の中にコードを足していってるので周りに引きづられて F# ぽくない部分も多かった。&lt;/p&gt;&lt;p&gt;それらは例えば &lt;code&gt;string&lt;/code&gt; じゃなくて &lt;code&gt;ToString&lt;/code&gt; メソッドを使ってるとか、一番気になってたのは conditional expression の &lt;code&gt;if&lt;/code&gt; をいっぱい使ってた点。
別に &lt;code&gt;if&lt;/code&gt; の方が短く済むときもあるし使っても構わんのだけど、式としてじゃなくて制御構文として使ったときの &lt;code&gt;else&lt;/code&gt; が必須じゃないのが気になってた。また match expression と違って網羅できてるか人目でわからないのが一番心配で、結局これらを &lt;code&gt;match ... with&lt;/code&gt; で書き直すことにした。
その結果、一部には active pattern も利用したりして、パッと見わかりやすくなった気がする。&lt;/p&gt;&lt;p&gt;&lt;code&gt;if ... then&lt;/code&gt; を &lt;code&gt;match ... with&lt;/code&gt; に書き換えたら以下のようになって、 &lt;code&gt;true&lt;/code&gt; がなんか判然とせんなーという気は多少あるので、自前のロジックに関しては判別共用体に直すとか検討するとより良いのかも知れん。&lt;/p&gt;&lt;pre&gt;&lt;code class="fsharp"&gt;// before
if nanigashi x then
    Some(x)
else
    None

// after
match nanigashi x with
| true -&amp;gt; Some(x) // この true ってのもなーんか気に食わん
| _ -&amp;gt;  None
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;こういうところにも active pattern を積極的に使っていったら良いのかもやけど、今回はまだ使わなかった。
データの変換・分解を伴うようなパターンだとバッチリハマった感じだったが、単純なケースに使うと記述量だけ増えて表現力変わらないなとい感触だったため(書き方がまずいのか)。
とはいえ積極的に使いたいものではあった。&lt;/p&gt;&lt;p&gt;コードの見通しも良くなってきて、そろそろ積み残しタスクにも着手しやすくなってきた感じがする。次やるとしたら &lt;a href="https://github.com/krymtkts/pocof/issues/35"&gt;#35&lt;/a&gt; あたりかな。&lt;/p&gt;&lt;p&gt;でもテスト追加とリファクタリングはまだやりたいところが残っていて、悩ましい。 UI のテストを入れて置きたいのと、 &lt;code&gt;PocofQuery&lt;/code&gt; をシンプルにするのと、 &lt;code&gt;Library.fs&lt;/code&gt; から極力ロジックを引き剥がす点だ。
なんかダルそうだなというのもあって手が出しにくいので、積み残しタスク減らしてからやると気分転換になるのかも知れん。&lt;/p&gt;</description><pubDate>Sun, 16 Apr 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-04-09-writing-cmdlet-in-fsharp-pt18</guid><link>https://krymtkts.github.io/posts/2023-04-09-writing-cmdlet-in-fsharp-pt18</link><title>F#でコマンドレットを書いてる pt.18</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。&lt;/p&gt;&lt;p&gt;&lt;code&gt;PocofQuery.run&lt;/code&gt; のテストをそれなりに足した。
多少テストが増えてきたので CI が欲しくなってきた。ここで以前立てた Issue &lt;a href="https://github.com/krymtkts/pocof/issues/34"&gt;#34&lt;/a&gt; を回収しておくとことにした。&lt;/p&gt;&lt;p&gt;Issue にも書いてたけど、基本 GitHub Docs に書いてたやつをなぞるだけ。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-net"&gt;Building and testing .NET - GitHub Docs&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-powershell"&gt;Building and testing PowerShell - GitHub Docs&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;runner image は今の開発環境に合わせて &lt;code&gt;windows-latest&lt;/code&gt; にしておく。 pocof 自体は今後他の OS でも動くことを保証してみたいけど、最初なのでシンプルにいく。
この記事を書いた時点の &lt;code&gt;windows-latest&lt;/code&gt; に含まれるツール類は以下を参照した。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/actions/runner-images/blob/main/images/win/Windows2022-Readme.md"&gt;runner-images/Windows2022-Readme.md at main · actions/runner-images · GitHub&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;dotnet&lt;/code&gt; のセットアップは必須のよう。 pocof はまだ 6 なのでそれを使う。&lt;/p&gt;&lt;p&gt;PowerShell はデフォで 7.2.10 が入ってるらしい。いろんなバージョンで動くことをチェックするのであれば PowerShell の version で &lt;code&gt;matrix&lt;/code&gt; 組むのが妥当だが、これも最初なので簡単に。&lt;/p&gt;&lt;p&gt;pocof のテストに必要な PowerShell モジュール Pester, PSScriptAnalyzer あたりも入ってるが、肝心の &lt;a href="https://github.com/psake/psake"&gt;psake&lt;/a&gt; が入ってない。ならば workflow で全部ひっくるめで force install するようにしておく。
このへんも &lt;a href="https://github.com/RamblingCookieMonster/PSDepend"&gt;PSDepend&lt;/a&gt; を使うようにしておけば YAML にかき分ける必要もないし良さげか。&lt;/p&gt;&lt;p&gt;ここまでやれば &lt;code&gt;psakefile.ps1&lt;/code&gt; に書いた全テストタスクを実行すれば完了する。キャッシュあった方が速いだろうけど、そもそもそんなに時間かからんので対応しないでおく。&lt;/p&gt;&lt;p&gt;あと一番重要な GitHub Actions の YAML のファイル名と名前の部分、結構いろんな repo みても付け方がバラバラでイケてるパクリ元がない。
ここは GitHub の Pull Request や Actions の画面で見られることを考えてない名称は避けたかった。
最終的に、 &lt;a href="https://github.com/fsprojects/FSharp.Formatting/tree/3fdd5b9a186e35798d87ceee4bee692374304bed/.github/workflows"&gt;FSharp.Formatting&lt;/a&gt; の命名規則が気に入ったのでそれを模した。
ファイル名は &lt;code&gt;pull-requests.yml&lt;/code&gt; を短縮して &lt;code&gt;pr.yml&lt;/code&gt; で、名前は &lt;code&gt;Build and Test on Pull Request&lt;/code&gt; だ。これなら GitHub の画面で見ても自然だ。&lt;/p&gt;&lt;p&gt;出来上がった素朴な YAML はこちら。 &lt;a href="https://github.com/krymtkts/pocof/blob/1dda928ff1ae56938a26ae70568a9a05807f0852/.github/workflows/pr.yml"&gt;pocof/pr.yml&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="yaml"&gt;name: Build and Test on Pull Request

on:
  pull_request:
    branches: ["main"]

jobs:
  test:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: 6.0.x
      - name: Install modules from PSGallery
        shell: pwsh
        run: |
          Set-PSRepository PSGallery -InstallationPolicy Trusted
          Install-Module Psake,Pester,PSScriptAnalyzer -Scope CurrentUser -Force
      - name: Execute All Tests
        shell: pwsh
        run: Invoke-Psake -taskList TestAll
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;GitHub Actions の難点としてテストしにくい点があるが、&lt;a href="https://github.com/nektos/act"&gt;nektos/act&lt;/a&gt; を使えば &lt;code&gt;ubuntu-*&lt;/code&gt; の runner に限ればテストできる。
仕事では act を使ってるが自機には積んでなかったんで、この際に Chocolaty で入れた。&lt;/p&gt;&lt;pre&gt;&lt;code class="dos"&gt;choco install act-cli
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ではテストとばかりに &lt;code&gt;windows-latest&lt;/code&gt; を &lt;code&gt;ubuntu-latest&lt;/code&gt; に変えて実行する。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; act pull_request --verbose --platform windows-latest=catthehacker/ubuntu:act-latest
# ...省略
| OCI runtime exec failed: exec failed: unable to start container process: exec: "pwsh": executable file not found in $PATH: unknown
# ...省略
Error: Job 'test' failed
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;なん...だと...
&lt;code&gt;pwsh&lt;/code&gt; コマンドが無いと言われた... &lt;code&gt;act&lt;/code&gt; のセットアップ時に MEDIUM 選んだらどうも入ってないっぽい。
流石は minority の PowerShell 、参ったね。&lt;/p&gt;&lt;p&gt;しかし &lt;code&gt;act&lt;/code&gt; が使うイメージを見てたら &lt;code&gt;pwsh&lt;/code&gt; というキーワード付きの image があるじゃないの。 &lt;a href="https://github.com/catthehacker/docker_images#images-available"&gt;catthehacker/docker_images: Docker images&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;/linux/ubuntu/pwsh - ghcr.io/catthehacker/ubuntu:act-* but with pwsh tools and modules installed&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;こりゃきたな。試す。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; act pull_request --verbose --platform windows-latest=ghcr.io/catthehacker/ubuntu:pwsh-latest
# ...省略
[Build and Test on Pull Request/test] 🏁  Job succeeded
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;おーいけた。 6 分超かかったけど。
これでなんとか PowerShell の場合でもローカルテストできそう。
Docker Hub に同じイメージ &lt;a href="https://hub.docker.com/layers/catthehacker/ubuntu/pwsh-latest/images/sha256-3b4b83b4458dd875509bc74b9f1d4ecaa57101c65ec529cb463fed2d859228e4?context=explore"&gt;catthehacker/ubuntu:pwsh-latest&lt;/a&gt; あったので、これを使っていこう。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;act pull_request --verbose --platform windows-latest=catthehacker/ubuntu:pwsh-latest
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;...でもいちいちこのクソながオプション書きたく無いなあ...設定ファイルとかはなさそう。関数にするか psake のタスクにするしかないか。なんか大げさな気がするけど。&lt;/p&gt;&lt;p&gt;そんなこんなで &lt;a href="https://github.com/krymtkts/pocof/pull/45"&gt;#45&lt;/a&gt; を作れた。
matrix はまだ設定してないけど、少なくともテスト類は ubuntu でも動くことわかったし、追々対応していく。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;おまけ。&lt;/p&gt;&lt;p&gt;DockerDesktop でログインしてると、 &lt;code&gt;act&lt;/code&gt; 実行中にある DockerHub から &lt;code&gt;catthehacker/ubuntu:act-latest&lt;/code&gt; を pull するのができなかった。ログアウトしてるといける。↓ このへんの関係ぽいが深く追ってない。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/nektos/act/discussions/1165"&gt;m1: act fails to pull with unauthorized: incorrect username or password · nektos/act · Discussion #1165&lt;/a&gt;&lt;/p&gt;&lt;p&gt;あとなんか知らんが &lt;code&gt;act&lt;/code&gt; 実行後に &lt;code&gt;[45;3R&lt;/code&gt; って謎キーワードが terminal の input に出てくる、必ず。 ansi escape sequences ぽいけどよくわからん。&lt;/p&gt;</description><pubDate>Sun, 09 Apr 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-04-02-oauth-with-pwsh-to-download-gss-as-csv</guid><link>https://krymtkts.github.io/posts/2023-04-02-oauth-with-pwsh-to-download-gss-as-csv</link><title>PowerShell で OAuth して Google Sheet を CSV で DL する</title><description>&lt;p&gt;最近役目を終えたスクリプトに、 Google Sheet を CSV でダウンロードするやつがいた。考慮不足等、諸々至らぬ点あろうが、スクリプトを供養するため日記にする。&lt;/p&gt;&lt;p&gt;モジュール導入したくないなーという事情があったので、下記を見てヒイヒイ言いながら実装した記憶がある。
「Google Sheet から CSV をダウンロードする」には &lt;code&gt;https://www.googleapis.com/auth/drive&lt;/code&gt; のスコープがいるみたい。てっきりスプシのスコープと勘違いして、無駄に時間かかった。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/63125283/how-to-connect-api-from-powershell-with-oauth-2-0"&gt;How to connect API from PowerShell with OAUTH 2.0? - Stack Overflow&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://lazyadmin.nl/it/connect-to-google-api-with-powershell/"&gt;Connect to Google API with Powershell — LazyAdmin&lt;/a&gt; して - &lt;a href="https://stackoverflow.com/questions/37705553/how-to-export-a-csv-from-google-sheet-api/61107170#61107170"&gt;r googlesheets - How to export a csv from Google Sheet API? - Stack Overflow&lt;/a&gt; する&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;スクリプトは Gist に登録しておいた。
それに伴い Comment-Based Help を書いたり、関数の名前を変えたりした。Google Sheets ってサービス名に対してスプシ自体は spreadsheet だったりしてマジでややこしい。&lt;/p&gt;&lt;p&gt;&lt;a href="https://gist.github.com/krymtkts/0618fe495df0d3e567e9fb18ca2e308b"&gt;GoogleSpreadSheetOAuth.ps1&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;&amp;lt;#
.SYNOPSIS
Download Google Sheet as CSV.
.DESCRIPTION
Download Google Sheet as CSV using GCP OAuth Client.
.PARAMETER OAuthClientSecretsPath
The path to the JSON file for the OAuth 2.0 Client Secrets created on GCP.
.PARAMETER OAuthStorePath
The path to save authentication tokens.
.EXAMPLE
. ./GoogleSheetsOAuth.ps1 `
    -OAuthClientSecretsPath './client-secrets.json' `
    -OAuthStorePath './gss-credential'
Get-GoogleSpreadSheetAsCsv `
    -SpreadSheet 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' `
    -SheetId '000000000' `
    -OutFile './test.csv'
#&amp;gt;
[CmdletBinding()]
param (
    [Parameter(Mandatory)]
    [string]
    $OAuthClientSecretsPath,
    [Parameter(Mandatory)]
    [string]
    $OAuthStorePath
)

class OAuthCredentialStore {
    [SecureString] $AccessToken
    [SecureString] $RefreshToken
    OAuthCredentialStore(
        [SecureString] $AccessToken,
        [SecureString] $RefreshToken
    ) {
        $this.AccessToken = $AccessToken
        $this.RefreshToken = $RefreshToken
    }
}

$script:OAuthCredential = $null

function Get-GoogleSheetsAuthInitToken {
    [CmdletBinding(SupportsShouldProcess)]
    param ()

    if (-not (Split-Path $OAuthStorePath -Parent | Test-Path)) {
        throw "${OAuthStorePath} not found."
    }

    if (-not (Test-Path $OAuthClientSecretsPath)) {
        throw "${OAuthClientSecretsPath} not found."
    }
    $secrets = Get-Content $OAuthClientSecretsPath | ConvertFrom-Json | Select-Object -ExpandProperty installed

    $Scope = [System.Web.HttpUtility]::UrlEncode('https://www.googleapis.com/auth/drive')
    $ClientID = $secrets.client_id
    $ClientSecret = $secrets.client_secret
    $RedirectUri = $secrets.redirect_uris[0]
    $Uri = "https://accounts.google.com/o/oauth2/v2/auth?response_type=code&amp;amp;client_id=${ClientID}&amp;amp;redirect_uri=${RedirectUri}&amp;amp;scope=${Scope}&amp;amp;access_type=offline"

    Start-Process $Uri
    $AuthorizationCode = Read-Host 'paste auth code here!'

    $AuthData = @{
        code = $AuthorizationCode;
        client_id = $ClientID;
        client_secret = $ClientSecret;
        redirect_uri = $RedirectUri;
        grant_type = 'authorization_code';
        access_type = 'offline';
    }

    Write-Host 'try to get access token...'
    $TokenResponse = Invoke-RestMethod -Method Post -Uri 'https://www.googleapis.com/oauth2/v4/token' -Body $AuthData
    if (-not $?) {
        throw 'request failed.'
    }

    Write-Host 'done.'

    $script:OAuthCredential = [OAuthCredentialStore]::new(
        ($TokenResponse.access_token | ConvertTo-SecureString -AsPlainText),
        ($TokenResponse.refresh_token | ConvertTo-SecureString -AsPlainText)
    )

    $store = @{
        AccessToken = $OAuthCredential.AccessToken | ConvertFrom-SecureString;
        RefreshToken = $OAuthCredential.RefreshToken | ConvertFrom-SecureString;
    }

    if ($PSCmdlet.ShouldProcess($OAuthStorePath)) {
        New-Item -Path $OAuthStorePath -Force | Out-Null
        $store | ConvertTo-Json -Compress | Set-Content -Path $OAuthStorePath -Force
    }

    $OAuthCredential.AccessToken, $OAuthCredential.RefreshToken
}

function Get-GoogleSheetsAuthToken {
    [CmdletBinding(SupportsShouldProcess)]
    param ()
    Write-Verbose "$OAuthStorePath"
    $content = Get-Content -Path $OAuthStorePath -ErrorAction Ignore
    if ([String]::IsNullOrEmpty($content)) {
        $token, $_ = Get-GoogleSheetsAuthInitToken
        return $token
    }
    try {
        $cred = $content | ConvertFrom-Json
        $script:OAuthCredential = [OAuthCredentialStore]::new(
            ($cred.AccessToken | ConvertTo-SecureString),
            ($cred.RefreshToken | ConvertTo-SecureString)
        )
    }
    catch {
        throw 'Invalid SecureString stored for this module. Remove gs-credential and try again.'
    }
    $RefreshToken = $script:OAuthCredential.RefreshToken | ConvertFrom-SecureString -AsPlainText
    if (-not $RefreshToken) {
        $token, $_ = Get-GoogleSheetsAuthInitToken
        return $token
    }

    $secrets = Get-Content $OAuthClientSecretsPath | ConvertFrom-Json | Select-Object -ExpandProperty installed
    $RefreshData = @{
        refresh_token = $RefreshToken
        client_id = $secrets.client_id
        client_secret = $secrets.client_secret
        grant_type = 'refresh_token'
        access_type = 'offline'
    }

    $Response = Invoke-RestMethod -Method Post -Uri 'https://www.googleapis.com/oauth2/v4/token' -Body $RefreshData
    if (-not $?) {
        throw 'request failed.'
    }

    return $Response.access_token | ConvertTo-SecureString -AsPlainText
}

function Get-GoogleSpreadSheetAsCsv {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        [String]
        $SpreadSheet,
        [Parameter(Mandatory)]
        [String]
        $SheetId,
        [Parameter(Mandatory)]
        [String]
        $OutFile
    )

    $accessToken, $refreshToken = Get-GoogleSheetsAuthToken
    if (-not $?) {
        return
    }

    $Params = @{
        Uri = "https://docs.google.com/spreadsheets/d/$SpreadSheet/gviz/tq?tqx=out:csv&amp;amp;gid=$($_.SheetId)"
        Method = 'GET'
        Authentication = 'Bearer'
        Token = $accessToken
        OutFile = $ExecutionContext.SessionState.Path.GetUnresolvedProviderPathFromPSPath($OutFile)
    }
    Invoke-WebRequest @Params | Out-Null
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;このスクリプトでは認証コードを得るのに手でコピってる。
これを &lt;code&gt;System.Net.HttpListener&lt;/code&gt; で自鯖を立てて取る方式にしたかったけど、コピペするのは初回だけだし放置してたらそのままスクリプトの寿命が来てしまった。
自動で認証コードを得る方式は以前ググってそれっぽいの見つけてたはずだが、 URL を失念してしまった。
今なら ChatGPT サンにお願いしたら書いてくれそうな雰囲気するなと思い試したらそれっぽいのが出たが、 OAuth client の Redirect URL を変えるのが手間で検証しなかった。怠けてる。
次にやる機会が来るその日まで、自鯖で認証コード取る方式は寝かせておく(やる日は来るのか)。&lt;/p&gt;</description><pubDate>Sun, 02 Apr 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-03-26-writing-cmdlet-in-fsharp-pt17</guid><link>https://krymtkts.github.io/posts/2023-03-26-writing-cmdlet-in-fsharp-pt17</link><title>F#でコマンドレットを書いてる pt.17</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。&lt;/p&gt;&lt;p&gt;もう 4 月なのでそろそろ Fable Compiler を試してみたいと思ってるが、 pocof のテスト書くのと bugfix が落ち着かず、できていない。
ちょっと今までのテストを小綺麗にする作業にも取り組んだ。&lt;/p&gt;&lt;p&gt;&lt;a href="/posts/2023-03-19-writing-cmdlet-in-fsharp-pt16"&gt;前回&lt;/a&gt;、 &lt;code&gt;module&lt;/code&gt; を多層化することでテストケースをグルーピングしている話を書いた。
その時はテストケースを 1 つのファイルにまとめて書いていたのだけど、 &lt;code&gt;PocofQuery.run&lt;/code&gt; のテストを書き始めるにあたり、テストケースが爆増するのに備えてファイルを分割したいと思っていた。&lt;/p&gt;&lt;p&gt;はじめ F# ではどうテストプロジェクトのファイル分割をするのかわからなかったが、 F# の repo をいくつか参照してみて &lt;a href="https://github.com/fsprojects/FSharp.Data.Adaptive"&gt;fsprojects/FSharp.Data.Adaptive&lt;/a&gt; が参考になりそうとわかった。
それを pocof に提供したところ、上手く分割できた。要は普通の F# Project と同じようにするだけだった。コミットは &lt;a href="https://github.com/krymtkts/pocof/commit/dff10c89963cdca60cd6ca9e7afeb7f7915e2ff4"&gt;krymtkts/pocof@dff10c8&lt;/a&gt; 。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/fsprojects/FSharp.Data.Adaptive/tree/5e92ab426e5a438d70986cefff638ecf2acef576/src/Test/FSharp.Data.Adaptive.Tests"&gt;FSharp.Data.Adaptive/src/Test/FSharp.Data.Adaptive.Tests&lt;/a&gt; がテストプロジェクトのディレクトリ。
ここに分割されたテストコードのファイルが色々あるのと、テストプロジェクトのエントリポイントになる &lt;code&gt;Program.fs&lt;/code&gt; が配置されている。
プロジェクト &lt;a href="https://github.com/fsprojects/FSharp.Data.Adaptive/blob/5e92ab426e5a438d70986cefff638ecf2acef576/src/Test/FSharp.Data.Adaptive.Tests/FSharp.Data.Adaptive.Tests.fsproj"&gt;FSharp.Data.Adaptive.Tests.fsproj&lt;/a&gt; を参照するとエントリポイント &lt;code&gt;Program.fs&lt;/code&gt; が最後の読み込みなっているのがわかる。
それ以前のファイルにモジュールを小分けにしたテストを書いたら良い。&lt;/p&gt;&lt;p&gt;ファイル分割の粒度はモジュール別に 1 ファイルした。
あまり細かく分けると何処にテストを書くか悩みがちなので、シンプルにモジュールと対にしている。複雑なクエリのテストを書くとまた量が増えて更にファイルを分割したくなるだろうが、今ではない。&lt;/p&gt;&lt;p&gt;ひとまず満足な形に分解できたのでヨシ。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;あとこの &lt;a href="https://github.com/fsprojects/FSharp.Data.Adaptive"&gt;fsprojects/FSharp.Data.Adaptive&lt;/a&gt; を参考にしたとき気づいたのだけど、 &lt;a href="https://github.com/fscheck/FsCheck"&gt;FsCheck&lt;/a&gt; というモジュールを使ってるようだった。 Property-based Testing をするためのやつだ(今書いてるのは所謂「おなじみ」の Example-based Testing という)。
&lt;a href="https://fsharpforfunandprofit.com/series/property-based-testing/"&gt;The 'Property Based Testing' series | F# for fun and profit&lt;/a&gt; が参考になった。&lt;/p&gt;&lt;p&gt;実際 pocof でもテストケースが貧弱で、テストは成功するがバグってたようなケースがもちらほらあるので、こういうより強力な方法を使うのが良いかもなーと興味深く思っている。
とはいえ興味の範囲で無限にやること増えていく。
かなりやってみたいのだけど、キャッチアップのほうが追いついてない感じ。&lt;/p&gt;&lt;p&gt;まずは所謂「おなじみ」の Example-based Testing である程度カバーしてから、 FsCheck で強化するってステップを踏むのが良さげ。徐々に... ひとまず今ある draft の pull request を merge してから、今後どう取り組んでいくか考えよかな(タスクを未来にブン投げる)。&lt;/p&gt;</description><pubDate>Sun, 26 Mar 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-03-19-writing-cmdlet-in-fsharp-pt16</guid><link>https://krymtkts.github.io/posts/2023-03-19-writing-cmdlet-in-fsharp-pt16</link><title>F#でコマンドレットを書いてる pt.16</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。&lt;/p&gt;&lt;p&gt;&lt;a href="https://fsprojects.github.io/FsUnit/xUnit.html"&gt;FsUnit x xUnit&lt;/a&gt; を使ったテストコード追加とリファクタはまだ続けていて、前回から引き続きバグがもりもり見つかる。
&lt;code&gt;PocofData.invokeAction&lt;/code&gt; はアクションに対応づいた各ロジックを呼び出して、内部状態を担うレコードを変更して返すだけの処理だけど、油断ならん。
&lt;a href="https://github.com/krymtkts/pocof/issues/39"&gt;#39&lt;/a&gt;, &lt;a href="https://github.com/krymtkts/pocof/issues/40"&gt;#40&lt;/a&gt;&lt;/p&gt;&lt;p&gt;まだ合計時間にしたら 10 時間も FsUnit(というか &lt;a href="https://fsprojects.github.io/FsUnit/FsUnitTyped.html"&gt;FsUnitTyped&lt;/a&gt;) 使ってないし、なんなら &lt;code&gt;shouldEqual&lt;/code&gt; と &lt;code&gt;shouldFail&lt;/code&gt; くらいしか使ってない。
けど、手になじんできた気がする。&lt;/p&gt;&lt;p&gt;&lt;code&gt;shouldEqual&lt;/code&gt; 使っていて良いのは、型間違うことがないところ(当たり前すぎるか)。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/fsprojects/FsUnit/blob/d8b95201efc7f478da3d677215291b5aa5487185/src/FsUnit.Xunit/FsUnit.fs#L32"&gt;&lt;code&gt;should&lt;/code&gt;&lt;/a&gt; の関数シグネチャがこう &lt;code&gt;obj&lt;/code&gt; になってる。&lt;/p&gt;&lt;pre&gt;&lt;code class="fsharp"&gt;let inline should (f: 'a -&amp;gt; ^b) x (actual: obj) =
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;片や &lt;a href="https://github.com/fsprojects/FsUnit/blob/d8b95201efc7f478da3d677215291b5aa5487185/src/FsUnit.Xunit/FsUnitTyped.fs#L13"&gt;shouldEqual&lt;/a&gt;はジェネリックになってる。&lt;/p&gt;&lt;pre&gt;&lt;code class="fsharp"&gt;    let shouldEqual&amp;lt;'a&amp;gt; (expected: 'a) (actual: 'a) =
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然ながらその分テストを書くときに楽ができる。実際には以下のような一見して間違いがわかる派手な例はないだろうけど。
テストコードのバグも有り得るので、とにかく安全な方に激ぶりしてかつ楽ができるのは、良い。&lt;/p&gt;&lt;pre&gt;&lt;code class="fsharp"&gt;"a" |&amp;gt; should equal 1 // エラーじゃない。
"a" |&amp;gt; shouldEqual 1 // 型不一致のエラー。良い。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;あとは、パイプ演算子のお陰で「英文ぽい」順番で記述できるのも良い。ただこの文脈でいえば、FsUnit の見た目に分がある。 &lt;code&gt;should&lt;/code&gt; と &lt;code&gt;equal&lt;/code&gt; 等分かち書きできるからな。&lt;/p&gt;&lt;pre&gt;&lt;code class="fsharp"&gt;actual |&amp;gt; shouldEqual expected
actual |&amp;gt; should equal expected // &amp;lt;- 見た目とても良いけど型検査できなくて片手落ち。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;OOP なんかでも &lt;code&gt;test(actual).shouldEqual(expected)&lt;/code&gt; みたいな形式なら同じ感覚だろうけど、個人的にカッコがなくより自然(Lisper みたいに熟達すればカッコが透けて見える可能性もあろうが)。&lt;/p&gt;&lt;p&gt;とはいえ良いこと尽くめではない。ちょっと困ったのはテストのグループ化。
例えば同じ関数に対するテストとか、関連あるグループをまとめたら平置きじゃない分だけ注力スべきコードが絞られて見やすくなるので、個人的には積極的にグループ化する。&lt;/p&gt;&lt;p&gt;FsUnit というか xUnit だと、 F# ではこんな感じに &lt;code&gt;module&lt;/code&gt; を多層化するか &lt;code&gt;module&lt;/code&gt; と &lt;code&gt;type&lt;/code&gt; を使うか 2 通りの手法があるみたい。以下にその 2 通りのテストコードもどき。&lt;/p&gt;&lt;pre&gt;&lt;code class="fsharp"&gt;module Tests

// module と type。
module ``PocofAction Tests`` =
    type ``toKeyPattern should returns`` () =
        [&amp;lt;Fact&amp;gt;]
        member x.``A without modifiers.`` () = // 以下略。

// module 多層化。
module ``PocofAction Tests`` =
    module ``toKeyPattern should returns`` =
        [&amp;lt;Fact&amp;gt;]
        let ``A without modifiers.`` () = // 以下略。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;pocof ではまだテストで状態を持つことないのと、単にカッコや自己識別子を書く回数が減るってだけで &lt;code&gt;module&lt;/code&gt; で多層化してる。&lt;/p&gt;&lt;p&gt;まあここまでは良い。これを &lt;code&gt;dotnet test --list-tests&lt;/code&gt; したときにでるテストケースごとの名称のつなぎ方？が気に入らなくて、なんとかならんのかなと思ってる。
先述の例の場合だと、 &lt;code&gt;Tests+PocofAction Tests+toKeyPattern shoud returns.A without modifiers.&lt;/code&gt; のようなテストケース名になる。これ &lt;code&gt;+&lt;/code&gt; とか &lt;code&gt;.&lt;/code&gt; とかどうにかならんのかな。理想は whitespace で繋いでほしい。
単に制御可能でその設定方法を知らないだけという可能性もあるので、追って調べたい。&lt;/p&gt;&lt;p&gt;多少気に入らないところを愚痴ったが、概ね満足している。今後もテストを足していってもりもりバグを洗い出す。かなーりテストコードに時間かかってる気がするけど、マイペースに。&lt;/p&gt;</description><pubDate>Sun, 19 Mar 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-03-12-writing-cmdlet-in-fsharp-pt15</guid><link>https://krymtkts.github.io/posts/2023-03-12-writing-cmdlet-in-fsharp-pt15</link><title>F#でコマンドレットを書いてる pt.15</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。&lt;/p&gt;&lt;p&gt;前回困ってた Ionide 、理解が難しくあんまわかってないけどこれっぽい。
&lt;a href="https://github.com/ionide/ionide-vscode-fsharp/issues/1756"&gt;Test Explorer doesn't support tests with &lt;code&gt;TestCaseAttribute&lt;/code&gt; · Issue #1756 · ionide/ionide-vscode-fsharp&lt;/a&gt;
Subscribe して様子を見る。&lt;/p&gt;&lt;p&gt;FsUnit を使ったテストコード追加とリファクタをほそぼそと続けている。 &lt;a href="https://github.com/krymtkts/pocof/pull/32"&gt;#32&lt;/a&gt;, &lt;a href="https://github.com/krymtkts/pocof/pull/37"&gt;#37&lt;/a&gt;&lt;/p&gt;&lt;p&gt;テストをあとから書いてると、ケアレスミスの bug ポツポツ見つかる。わたしは練習不足なのかテストファーストどうしてもできないのであとがきでもいいかと思ってるが、こう bug が多いとちょっとドキッとする。 main branch へ merge する前にあとがきテストを添えるようにして減らそう。&lt;/p&gt;&lt;p&gt;いま簡単なところからテストを書いてるので、本丸である &lt;code&gt;Query.fs&lt;/code&gt; のところを書けたらかなりいい感じ。 &lt;code&gt;UI.fs&lt;/code&gt; に関してはどないしょ...という感じになってるけど。
いま直で &lt;code&gt;Console.Write&lt;/code&gt; へアクセスするような形になってるの、差し替え可能にしておいた方がいいんやろな。&lt;/p&gt;&lt;p&gt;また、 &lt;code&gt;psakefile.ps1&lt;/code&gt; にも unit test や coverage 用のタスクを追加した。というかそれ以外のタスクも見直す必要があった。
というのも、 &lt;code&gt;src&lt;/code&gt; ディレクトリ配下からビルド対象のプロジェクトを見つけるスクリプトが単一のプロジェクトしか想定してなかったので、そのまま使えなかったからだ。この度アプリとテストの 2 プロジェクトができたので、指定のプロジェクトのみ対象とするよう変更した。&lt;/p&gt;&lt;p&gt;まだ頻出ワードを変数にしておくとかの最適化してなかったり、タスクランナー自体小綺麗にできるんじゃないかなーというのはあるが、無闇に依存関係を増やすのもなと思って手を出せてない。
&lt;a href="https://github.com/psake/PowerShellBuild"&gt;PowerShellBuild&lt;/a&gt;, &lt;a href="https://github.com/RamblingCookieMonster/PSDepend"&gt;PSDepend&lt;/a&gt; あたりの導入できれいになるかも知れんけど、なるべく依存関係をなくす方が結果的にシンプルなプロジェクトになるのを知ってるし。
現時点でも psake PSScriptAnalyzer Pester PowerShellGet に依存してるから、四の五の言わずに PSDepend だけでもはよ入れろよという感じはある。
だが、覚悟ができてからやる(先延ばし)。&lt;/p&gt;&lt;hr /&gt;&lt;h3 id="おまけ"&gt;おまけ&lt;/h3&gt;&lt;p&gt;最近になって仕事でも AI チャットを使う流れがきており、練習がてら &lt;a href="https://github.com/dfinke/PowerShellAI"&gt;PowerShellAI&lt;/a&gt; と一緒に仕事し始めてみた。 VS Code Extension はちょっと種類が多すぎてどれが信頼できるかいちいち調べられてないし、やってない。
上手く使えて、わたし・ Tabnine ・ OpenAI の三人力な感じを出せると良いが。
ちょっと使ってみた感覚的に、仕事で使うような特定用途に特化した回答をさせたい時と普段遣いで雑に使う感じでは、 prompt に結構差がある感触。
これほんま練習になるんかな。&lt;/p&gt;&lt;p&gt;にしても OpenAI の token がガリガリ消費されるのを見てると「ﾋｪｴ...」となる。&lt;/p&gt;</description><pubDate>Sun, 12 Mar 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-03-05-writing-cmdlet-in-fsharp-pt14</guid><link>https://krymtkts.github.io/posts/2023-03-05-writing-cmdlet-in-fsharp-pt14</link><title>F#でコマンドレットを書いてる pt.14</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。&lt;/p&gt;&lt;p&gt;以下を参考に xUnit と FsUnit を導入した。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/core/testing/unit-testing-fsharp-with-dotnet-test"&gt;dotnet テストと xUnit を使用した .NET Core での単体テスト F# - .NET | Microsoft Learn&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://fsprojects.github.io/FsUnit/xUnit.html"&gt;FsUnit for xUnit&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://fsprojects.github.io/FsUnit/FsUnitTyped.html"&gt;What is FsUnitTyped?&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/core/testing/unit-testing-code-coverage?tabs=windows#code-coverage-tooling"&gt;単体テストにコードカバレッジを使用する - .NET | Microsoft Learn&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;repo ルートを作業ディレクトリとする。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;cd (mkdir pocof.Test)
dotnet new xunit -lang "F#"
dotnet add reference ../pocof/pocof.fsproj
dotnet sln ../../pocof.sln add .\pocof.Test.fsproj
cd ../../
dotnet build
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一応ここでちゃんとテストできるか確認をする。&lt;code&gt;Tests.fs&lt;/code&gt; のコードを単純なのに書き換える。&lt;/p&gt;&lt;pre&gt;&lt;code class="fsharp"&gt;module Tests

open System
open Xunit

[&amp;lt;Fact&amp;gt;]
let ``My test`` () = Assert.True(true)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;VS Code からでもよし、 CLI でなら repo のルートで以下の通り。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; dotnet test
  Determining projects to restore...
  All projects are up-to-date for restore.
  pocof -&amp;gt; C:\Users\takatoshi\dev\github.com\krymtkts\pocof\src\pocof\bin\Debug\net6.0\pocof.dll
C:\Users\takatoshi\dev\github.com\krymtkts\pocof\src\pocof.Test\Tests.fs(7,39): warning FS0988: Main module of program is empty: noth
ing will happen when it is run [C:\Users\takatoshi\dev\github.com\krymtkts\pocof\src\pocof.Test\pocof.Test.fsproj]
  pocof.Test -&amp;gt; C:\Users\takatoshi\dev\github.com\krymtkts\pocof\src\pocof.Test\bin\Debug\net6.0\pocof.Test.dll
Test run for C:\Users\takatoshi\dev\github.com\krymtkts\pocof\src\pocof.Test\bin\Debug\net6.0\pocof.Test.dll (.NETCoreApp,Version=v6.0)
Microsoft (R) Test Execution Command Line Tool Version 17.5.0 (x64)
Copyright (c) Microsoft Corporation.  All rights reserved.

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:     1, Skipped:     0, Total:     1, Duration: &amp;lt; 1 ms - pocof.Test.dll (net6.0)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;あと &lt;code&gt;dotnet new xunit -lang "F#"&lt;/code&gt; で生成された &lt;code&gt;Program.fs&lt;/code&gt; は不要なので削除、 &lt;code&gt;pocof.Text.fsproj&lt;/code&gt; からも削除する。&lt;/p&gt;&lt;p&gt;次に FsUnit を追加する。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;dotnet add ./src/pocof.Test/pocof.Test.fsproj package FsUnit.xUnit
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;テストをこんな感じで書き換え、 &lt;code&gt;dotnet test&lt;/code&gt; が成功したら完了。&lt;/p&gt;&lt;pre&gt;&lt;code class="diff"&gt; module Tests

-open System
 open Xunit
+open FsUnitTyped

-[&amp;lt;Fact&amp;gt;]
-let ``My test`` () = Assert.True(true)
+module ``Pocof Tests`` =
+
+    [&amp;lt;Fact&amp;gt;]
+    let ``Sample test should equals 1`` () = 1 |&amp;gt; shouldEqual 1
+
+[&amp;lt;EntryPoint&amp;gt;]
+let main argv = 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href="https://github.com/dotnet/fsharp/issues/2669"&gt;"Main module of program is empty: nothing will happen when it is run" warning when running xunit tests on .net core. · Issue #2669 · dotnet/fsharp&lt;/a&gt; で知ったが、 テストプロジェクトはコンソールアプリなので &lt;code&gt;&amp;lt;EntryPoint&amp;gt;&lt;/code&gt; を必ず持たないと警告がでる。 xUnit 追加後シンプルにしたテストコードでは &lt;code&gt;&amp;lt;EntryPoint&amp;gt;&lt;/code&gt; がなかったので警告が出てた。&lt;/p&gt;&lt;p&gt;ちょっとわからないのが VS Code からの実行だとハングしてるようだった。
テストを実行するための DotNet CLI が後ろで実行されるみたいだが、そのプロセスは上手く行ってそうに見える。でも GUI がずっとくるくる止まる。どうも Inonide がエラーしてるっぽい。 xUnit の実行確認のときはいけたので FsUnit 起因か？ちょっと調べる必要ありだが、今回は先送りにする。&lt;/p&gt;&lt;pre&gt;&lt;code class="log"&gt;2023-03-04 15:50:47.005 [error] Error:
    at MapTreeModule_find (c:\Users\takatoshi\.vscode\extensions\ionide.ionide-fsharp-7.5.1\webpack:\out\fable_modules\fable-library.4.0.0-theta-018\Map.js:245:15)
    at FSharpMap__get_Item (c:\Users\takatoshi\.vscode\extensions\ionide.ionide-fsharp-7.5.1\webpack:\out\fable_modules\fable-library.4.0.0-theta-018\Map.js:1179:12)
    at f (c:\Users\takatoshi\.vscode\extensions\ionide.ionide-fsharp-7.5.1\webpack:\out\fable_modules\fable-library.4.0.0-theta-018\Map.js:1297:12)
    at Kt (c:\Users\takatoshi\.vscode\extensions\ionide.ionide-fsharp-7.5.1\webpack:\out\fable_modules\fable-library.4.0.0-theta-018\Array.js:70:21)
    at c:\Users\takatoshi\.vscode\extensions\ionide.ionide-fsharp-7.5.1\webpack:\out\Components\TestExplorer.js:138:27
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Promise.all (index 0)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;コードカバレッジは xUnit のテンプレなら初めから統合されてるらしくて、すぐ出せる。これはめちゃくちゃ楽。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;dotnet test --collect:"XPlat Code Coverage"
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;こんな感じでレポート出力できる。出力しておいたら VS Code の &lt;a href="https://marketplace.visualstudio.com/items?itemName=ryanluker.vscode-coverage-gutters"&gt;Coverage Gutters&lt;/a&gt; で取り込めるしこりゃいいな。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;reportgenerator -reports:".\src\pocof.Test\TestResults\*\coverage.cobertura.xml" -targetdir:"coverage" -reporttypes:Html
&lt;/code&gt;&lt;/pre&gt;&lt;hr /&gt;&lt;p&gt;昔は Visual Studio からしか Solution とか作るしかなかったようなキヲクをがある(無能だっただけやも知れんが)。
いまの DotNet CLI ある時代めちゃくちゃ便利でびっくりした。&lt;/p&gt;&lt;p&gt;あと FsUnit 非常によい。
入力キーから処理を導くところのリファクタするのに役立っている。
サクサク書けるし、バグってた状態で放置してるとこが見つかったり(&lt;a href="https://github.com/krymtkts/pocof/pull/33"&gt;#33&lt;/a&gt;)いまのところ良いことしか無い。&lt;/p&gt;&lt;p&gt;いい感じにテスト揃ってきたら、 GitHub Actions で FsUnit と Pester 実行するようにしよう。&lt;/p&gt;</description><pubDate>Sun, 05 Mar 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-02-26-writing-cmdlet-in-fsharp-pt13</guid><link>https://krymtkts.github.io/posts/2023-02-26-writing-cmdlet-in-fsharp-pt13</link><title>F#でコマンドレットを書いてる pt.13</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。
&lt;a href="https://www.powershellgallery.com/packages/pocof/0.4.0-alpha"&gt;pocof 0.4.0-alpha&lt;/a&gt; を公開した。&lt;/p&gt;&lt;p&gt;諸々の bugfix を主として行った。
&lt;a href="https://github.com/krymtkts/pocof/issues/28"&gt;#28&lt;/a&gt; &lt;a href="https://github.com/krymtkts/pocof/issues/25"&gt;#25&lt;/a&gt; &lt;a href="https://github.com/krymtkts/pocof/issues/23"&gt;#23&lt;/a&gt; &lt;a href="https://github.com/krymtkts/pocof/issues/21"&gt;#21&lt;/a&gt; &lt;a href="https://github.com/krymtkts/pocof/issues/20"&gt;#20&lt;/a&gt; &lt;a href="https://github.com/krymtkts/pocof/issues/18"&gt;#18&lt;/a&gt;&lt;/p&gt;&lt;p&gt;修正自体は軽微だが、結構使っていてイヤーな感じをもたらす bug が多かったし、直して良かった。
機能的なところでは入力中のプロパティ候補の表示非表示を切り替えるオプションを付与したのみに留まる。&lt;/p&gt;&lt;p&gt;正直なところプロパティの TAB 補完できてから公開したかったが、先送りにした。
こいつをやるには内部的な状態を増やす必要があると思っていて、そのためにはリファクタリングをしてから着手する方が良い。
要はリファクタリングしだすと、色々気になって手を入れてしまいズルズルとリリースを遅らせがちなので、切の良いタイミングで公開しておいたという算段だ。&lt;/p&gt;&lt;p&gt;増やす状態は、カーソルがクエリの分かち書きの何個目にいるか、単語の何文字目にいるとかを指す。 TAB 補完したときにクエリの書き換えとカーソル末尾への移動をするが、その計算にこれらの状態があると良い。
今の実装だと単純にクエリ文字列と検索中のプロパティを保持しているだけなので、そこを小綺麗に整理した後にそれらを付与するようなイメージ。判別共用体を上手く使ってできる感覚を持っている。&lt;/p&gt;&lt;p&gt;ただしデータ構造の変更に伴いクエリ実行そのものも書き換える必要がある。
&lt;a href="/posts/2023-02-05-writing-cmdlet-in-fsharp-pt12"&gt;前の日記&lt;/a&gt; でも触れてたように、やっぱこのタイミングで &lt;a href="https://github.com/fsprojects/FsUnit"&gt;FsUnit&lt;/a&gt; 導入して動作保証しながらの開発は必須、避けられない。&lt;/p&gt;&lt;p&gt;話は逸れるが、FsUnit 使うに当たり .NET のテストライブラリを入れる必要があるのだけど、全然知らん。
&lt;a href="https://fsprojects.github.io/FsUnit/index.html"&gt;What is FsUnit?&lt;/a&gt; を見るに &lt;a href="https://github.com/xunit/xunit"&gt;xunit&lt;/a&gt; 、 &lt;a href="https://github.com/nunit/nunit"&gt;nunit&lt;/a&gt; と &lt;a href="https://github.com/microsoft/testfx"&gt;MSTest&lt;/a&gt; がある。
FsUnit からはどれでも使えるけどそれぞれの推しどころわからず、どれを使えばいいかわからんというアレな状態。
GitHub の star 見るに xUnit が人気ぽいが、 &lt;a href="https://github.com/fsprojects/fantomas/blob/a7ed99fb74fee6db55487f315005c0200d19a0b4/src/Fantomas.Tests/Fantomas.Tests.fsproj"&gt;fantomas&lt;/a&gt; は FsUnit と NUnit の組み合わせっぽかった。
FsUnit のドキュメント見てたら、強力な型付きの &lt;a href="https://fsprojects.github.io/FsUnit/FsUnitTyped.html"&gt;FsUnitTyped&lt;/a&gt; は NUnit か xUnit しかサポートしてないって書いてるし、なんとか二択までは絞れた...こっからがだるい。&lt;/p&gt;&lt;p&gt;話を戻して、クエリの内部状態以外にも判別共用体で書き直したい箇所があって、それは入力時のキー判定や今は文字列で保持しているキーマップだったりだ。
キーマップの方は外部保存した設定ファイルを読み込む方式も検討したいのでハマるかわからんけど。入力時のキー判定の方は、いま if 式をこねくっているのもあって、パターンマッチング式に置き換えられるからハマるなという感覚がある。&lt;/p&gt;&lt;p&gt;また機能追加が滞りそうではあるが、あと 2 ヶ月ほどで pocof の initial commit から 1 年経つのもあり、掃除するにはちょうどいい頃合いではないかと。ちょっとは F# Ninja Level も上がったやろ。&lt;/p&gt;</description><pubDate>Sun, 26 Feb 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-02-19-aws-ssm-session-manager-with-powershell</guid><link>https://krymtkts.github.io/posts/2023-02-19-aws-ssm-session-manager-with-powershell</link><title>AWS SSM Session Manager を PowerShell で</title><description>&lt;p&gt;AWS SSM Session Manager を使って EC2 Instance とかに接続するやつがある。
AWS CLI であれば Session Mangger plugin&lt;sup id="fnref-1"&gt;&lt;a class="footnote-ref" href="#fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt; を入れておけば &lt;code&gt;aws ssm start-session&lt;/code&gt; で SSH 感覚でつなげる。 Security Group に自分とこの外部 IP を含めなくていいし、最高のやつだ。&lt;/p&gt;&lt;p&gt;だが AWS Tools for PowerShell で対になる &lt;code&gt;Start-SSMSession&lt;/code&gt;は &lt;a href="https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_StartSession.html"&gt;StartSession API&lt;/a&gt; の戻り値を返すだけ。
(公式回答なのか？) AWS dev サポの方が AWS Tools for PowerShell の Issue&lt;sup id="fnref-2"&gt;&lt;a class="footnote-ref" href="#fn-2"&gt;2&lt;/a&gt;&lt;/sup&gt; にて Session Manager plugin に対応してなさそうなコメントしてる。
また Session Manager plugin 自体、その本丸である WebSocket の URL やらをどのようにこねくり回して渡せばいいかが文書化されてない。&lt;/p&gt;&lt;p&gt;PowerShell では Session Manager 無理かな...半ば諦めていたところに、なんと Remote Desktop で繋げられたという記事を発見した。
これはマジですごい。 Linux 上で &lt;code&gt;aws ssm start-session&lt;/code&gt; を &lt;code&gt;strace&lt;/code&gt; して解析したらしい。鬼テク。&lt;/p&gt;&lt;p&gt;&lt;a href="https://cloudsoft.io/blog/remote-access-to-windows-ec2-instances-the-easy-and-secure-way"&gt;Remote Access to Windows EC2 instances, the easy (and secure) way&lt;/a&gt;&lt;/p&gt;&lt;p&gt;解析結果から作成され接続確認された PowerShell モジュールが GitHub に公開されている。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/cloudsoft/EC2Access/blob/v1.0.0/EC2Access.psm1#L170-L243"&gt;EC2Access/EC2Access.psm1 at v1.0.0 · cloudsoft/EC2Access&lt;/a&gt;&lt;/p&gt;&lt;p&gt;元記事は RemoteDesktop を対象としているが、ぱっと見 SSH でも同様のことができそう。
コミットが 1 年半くらい前なので Session Manager の API に変更がなければ、やけど。
Session Manager plugin にパラメータを渡す部分を参考に、接続を試行してみる。
&lt;a href="https://github.com/cloudsoft/EC2Access/blob/v1.0.0/LICENSE"&gt;ライセンスは Apache License 2&lt;/a&gt; なので無償利用・改変もヨシ。&lt;/p&gt;&lt;p&gt;試してみる。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;まず AWS CLI の場合だが以下のような感じで使ってた。
見やすさのために改行成分多く含んでいる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Get-EC2Instance -Filter @{
    Name = 'tag:Name'
    Values = 'instance-name'
} | Select-Object -ExpandProperty Instances -First 1 | ForEach-Object {
    aws ssm start-session --target $_.InstanceId # ここを変えたいんや
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これを一先ずこんな風に使えるような関数を作成してみてはどうか？(&lt;code&gt;ForEach-Object&lt;/code&gt; 要らんが SSH は単発でつなぎたいし一先ず)。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Get-EC2Instance -Filter @{
    Name = 'tag:Name'
    Values = 'instance-name'
} | Select-Object -ExpandProperty Instances -First 1 | ForEach-Object {
    Start-SSMSshSession -Instance $_.InstanceId # こういう関数がほしい
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;先述の &lt;a href="https://github.com/cloudsoft/EC2Access/blob/v1.0.0/EC2Access.psm1#L170-L243"&gt;EC2Access.psm1&lt;/a&gt; からコードを拝借する。
&lt;code&gt;Start-SSMSession&lt;/code&gt; の戻り値をこねくる部分と、 Session Manager plugin を取り扱う箇所が対象だ。
コメントも処理の解析に有用なのでそのまま残させていただく。&lt;/p&gt;&lt;p&gt;元コードは RemoteDesktop を対象にしているので、認証情報の作成、 port forwarding 、あと最後の接続の箇所だけ SSH 用に書き換える。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function Start-SSMSshSession {
    [CmdletBinding(SupportsShouldProcess)]
    param (
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]
        $InstanceId,
        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $Region = 'ap-northeast-1',
        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $SshUser = 'ec2-user',
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]
        $CertPath,
        [Parameter()]
        [int]
        $LocalPort = 10022
    )

    $PortForwardParams = @{ portNumber = (, '22'); localPortNumber = (, $LocalPort.ToString()) }
    $session = Start-SSMSession -Target $InstanceId -DocumentName 'AWS-StartPortForwardingSession' -Parameters $PortForwardParams

    # We now need to emulate awscli - it invokes session-manager-plugin with the new session information.
    # AWS Tools for PowerShell don't do this. Also some of the objects seem to look a bit different, and the
    # plugin is pernickety, so we have to jump through some hoops to get all the objects matching up as close
    # as we can.

    $SessionData = @{
        SessionId = $session.SessionID;
        StreamUrl = $session.StreamUrl;
        TokenValue = $session.TokenValue;
        ResponseMetadata = @{
            RequestId = $session.ResponseMetadata.RequestId;
            HTTPStatusCode = $session.HttpStatusCode;
            RetryAttempts = 0;
            HTTPHeaders = @{
                server = 'server';
                'content-type' = 'application/x-amz-json-1.1';
                'content-length' = $session.ContentLength;
                connection = 'keep-alive';
                'x-amzn-requestid' = $session.ResponseMetadata.RequestId;
            }
        }
    }

    $RequestData = @{
        Target = $InstanceId;
        DocumentName = 'AWS-StartPortForwardingSession';
        Parameters = $PortForwardParams
    }

    $Arguments = (
        (ConvertTo-Json $SessionData -Compress),
        $Region,
        'StartSession',
        '',
        (ConvertTo-Json $RequestData -Compress),
        "https://ssm.$($Region).amazonaws.com"
    )

    # Now we have to do some PowerShell hacking. Start-Process takes an array of arguments, which is great,
    # but it doesn't actually do what we expect it to - see https://github.com/PowerShell/PowerShell/issues/5576.
    # So instead we have to turn it into an escaped string ourselves...
    $EscapedArguments = $Arguments | ForEach-Object { $escaped = $_ -replace "`"", "\`""; "`"$($escaped)`"" }
    $ArgumentString = $EscapedArguments -join ' '

    # Start the Session Manager plugin:
    if ($PSCmdlet.ShouldProcess($session.SessionId, 'Start Session Manager plugin')) {
        try {
            $Process = Start-Process -FilePath 'session-manager-plugin.exe' -ArgumentList $ArgumentString -NoNewWindow -PassThru
        }
        catch {
            Write-Error 'Unable to start the process session-manager-plugin.exe. Have you installed the Session Manager Plugin as described in https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager-working-with-install-plugin.html#install-plugin-windows ?'
            exit
        }

        # Wait a moment for it to connect to the session and open up the local ports
        Start-Sleep -Seconds 1

        # The port should be open now - let's connect
        if ($PSCmdlet.ShouldProcess($InstanceId, 'Start SSH client')) {
            ssh "${SshUser}@127.0.0.1" -p $LocalPort -i $CertPath
        }

        # Once the ssh session has finished, kill the session manager plugin
        $Process.Kill()
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;aws ssm start-session&lt;/code&gt; だと &lt;code&gt;ssm-user&lt;/code&gt; でつなぐことになるが、自前で接続する場合このユーザの認証情報がわからなかった。
代わりに &lt;code&gt;ec2-user&lt;/code&gt; を使い、合わせて鍵も渡すようにした。
結果、当初の想定よりパラメータが増えてしまうが、致し方なし。&lt;/p&gt;&lt;p&gt;できたら試す。 IP 等の一部の情報は伏せ字とする。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; Get-EC2Instance -Filter @{
&amp;gt;     Name = 'tag:Name'
&amp;gt;     Values = 'instance-name'
&amp;gt; } | Select-Object -ExpandProperty Instances -First 1 | ForEach-Object {
&amp;gt;     Start-SSMSshSession -InstanceId $_.InstanceId -CertPath ~/.ssh/instance-name.pem
&amp;gt; }

Starting session with SessionId: krymtkts-031e957031cdcb25c
Port 10022 opened for sessionId krymtkts-031e957031cdcb25c.
Waiting for connections...

Connection accepted for session [krymtkts-031e957031cdcb25c]
Last login: Sun Feb 19 06:09:45 2023 from localhost

       __|  __|_  )
       _|  (     /   Amazon Linux 2 AMI
      ___|\___|___|

https://aws.amazon.com/amazon-linux-2/
22 package(s) needed for security, out of 22 available
Run "sudo yum update" to apply all updates.
[ec2-user@ip-xxx-xxx-xxx-xxx ~]$ exit
logout
Connection to 127.0.0.1 closed.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;見事つなげる事ができた。すーご。&lt;/p&gt;&lt;p&gt;非公式とはいえ、 AWS CLI だけでしかできかなったことが PowerShell でもできるというのがわかるのは、一ユーザとして喜ばしいこっちゃな。
&lt;a href="https://cloudsoft.io/blog/remote-access-to-windows-ec2-instances-the-easy-and-secure-way"&gt;元記事&lt;/a&gt; の Great work に感謝やな。&lt;/p&gt;&lt;div class="footnotes"&gt;&lt;hr /&gt;&lt;ol&gt;&lt;li id="fn-1"&gt;&lt;p&gt;&lt;a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager-working-with-install-plugin.html"&gt;(Optional) Install the Session Manager plugin for the AWS CLI - AWS Systems Manager&lt;/a&gt; 入れておけばというか入れてないと無理&lt;/p&gt;&lt;a href="#fnref-1" class="footnote-backref"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id="fn-2"&gt;&lt;p&gt;&lt;a href="https://github.com/aws/aws-tools-for-powershell/issues/283#issuecomment-1247377153"&gt;Support for interactive Start-SSMSession · Issue #283 · aws/aws-tools-for-powershell&lt;/a&gt; で(AWS Tools for PowerShell は)外部プログラムに依存できないし、 Session Manager plugin は AWS CLI 専用て言ってる&lt;/p&gt;&lt;a href="#fnref-2" class="footnote-backref"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description><pubDate>Sun, 19 Feb 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-02-12-change-display-langualge-completely-to-en</guid><link>https://krymtkts.github.io/posts/2023-02-12-change-display-langualge-completely-to-en</link><title>Windows 11 の表示言語を完全に英語にする</title><description>&lt;p&gt;Windows 10 からデフォルト言語が日本の状態の PC でも表示言語を変えられる。
極力英語 UI を使うようにしているのもあって、今の Razer Blade Stealth を買ったころから英語表示で利用している。 Windows 11 にアップグレードしてからも同じだ。&lt;/p&gt;&lt;p&gt;設定自体は、ここに書いてる方法で表示言語を日本語から英語に変えられる。
&lt;a href="https://support.microsoft.com/en-us/windows/manage-the-input-and-display-language-settings-in-windows-12a10cb4-8626-9b77-0ccb-5013e0c7c7a2#WindowsVersion=Windows_10"&gt;Manage the input and display language settings in Windows - Microsoft Support&lt;/a&gt;&lt;/p&gt;&lt;p&gt;あと重要なのが、 Time &amp;amp; Language → Language &amp;amp; region のところの Preferred languages の順番。ここでちゃんと先頭を英語にしておかないといけない。
例えば &lt;a href="https://github.com/microsoft/PowerToys"&gt;PowerToys&lt;/a&gt; や &lt;a href="https://github.com/microsoft/terminal"&gt;Windows Terminal&lt;/a&gt; といったツール。
これらは最優先される言語でコマンドパレットや UI を表示したりする仕組みになってるようで&lt;sup id="fnref-1"&gt;&lt;a class="footnote-ref" href="#fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt;、日本語を最優先にしていると部分的に表示言語が日本語になり、使いにくいことこの上なくなる。
これに従うとデフォルトのキーボードが英語になるデメリットがあるが、インスタントに切り替えられない UI の方を尊重して、 起動後は毎回 Win + Space で英語 → 日本語に切り替えている。&lt;/p&gt;&lt;p&gt;こんな感じでちまちま英語 UI を使えるように調整していたのだけど、最近困った事が起こった。
ここ数ヶ月のどっかの Windows Update のタイミング以降、ログイン画面やシャットダウン・再起動時の表示言語が日本語になる事象が発生した。
先述の表示言語の設定で、英語 → 日本語としたあとで再起動後また英語にするとか、色々やっても解消しないので何なんや...と思っていた。&lt;/p&gt;&lt;p&gt;ついに先日、その解消方法を見つけた。
しかも身近な Time &amp;amp; Language → Language &amp;amp; region の中にある。たまたまポチっては画面を眺めてを繰り返していたときに見つけた。&lt;/p&gt;&lt;p&gt;Administrative language settings だ。&lt;/p&gt;&lt;p&gt;キーワードさえわかればこのように類似ケースを探すのも容易い。でも Microsoft の文書がヒットしないのはなんでや...
&lt;a href="https://www.windowscentral.com/how-change-system-language-windows-10"&gt;How to change system language on Windows 11 | Windows Central&lt;/a&gt;&lt;/p&gt;&lt;p&gt;ここ 2 つのセクションがあって、両方を英語に変えた。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Welcome screen and new user accounts&lt;/li&gt;&lt;li&gt;Language for non-Unicode programs&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;1 では Current user から Welcome screen, New user accounts の 2 つの言語設定に設定をコピーできて、その内の Welcome screen の言語設定がログイン画面に効いた様子。
また英語表示が戻ってきて、うれしい。
更に、 Windows Update 後に足した覚えのないキーボードが復活する現象にも悩まされていた。
New user accounts にその足した覚えのないキーボードが割あたってたので、多分犯人はこいつ。
これも解消できそう。&lt;/p&gt;&lt;p&gt;2 の方は何に効いてるのかわからん。 non-Unicode なアプリがあったらわかるんかな。&lt;/p&gt;&lt;p&gt;手順がわかってしまえば、もしまた表示言語が日本語に戻ったとしても、この設定をやり直せば良いので安心できる。
理想はスクリプト化しておきたいが、まだ Registry の該当箇所を調べてない。&lt;/p&gt;&lt;p&gt;という具体で久しぶりのフル英語表示にできて満足した。&lt;/p&gt;&lt;div class="footnotes"&gt;&lt;hr /&gt;&lt;ol&gt;&lt;li id="fn-1"&gt;&lt;p&gt;要出典。昔 Windows Terminal にコマンドパレットが導入されたときにそんな Issue を見たが忘れた。&lt;/p&gt;&lt;a href="#fnref-1" class="footnote-backref"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description><pubDate>Sun, 12 Feb 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-02-05-writing-cmdlet-in-fsharp-pt12</guid><link>https://krymtkts.github.io/posts/2023-02-05-writing-cmdlet-in-fsharp-pt12</link><title>F#でコマンドレットを書いてる pt.12</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。&lt;/p&gt;&lt;p&gt;プロパティ指定検索をおおむね実装できて、バグ取りに勤しんでいる。バグ取りしたので割とまともに動いてるな～という感じ。&lt;/p&gt;&lt;p&gt;また、 &lt;code&gt;Ctrl+Space&lt;/code&gt; で入力候補の表示非表示切り替え、プロパティ名の自動補完もやりたいけど、 &lt;a href="https://github.com/krymtkts/pocof/pull/14"&gt;Pull Request&lt;/a&gt; がずっと開きっぱなしで締まりがないし別の Issue に切り分けた。 &lt;a href="https://github.com/krymtkts/pocof/issues/19"&gt;#19&lt;/a&gt;, &lt;a href="https://github.com/krymtkts/pocof/issues/20"&gt;#20&lt;/a&gt;&lt;/p&gt;&lt;p&gt;一旦プロパティ指定検索が完成したら &lt;code&gt;main&lt;/code&gt; branch に合流する。&lt;/p&gt;&lt;p&gt;手が空いた時しか趣味プロやらないので、小分けにして取り組まないと何やってたかわからなくなる。これは今回デカめの feature にしてしまったことで当初の予定より大幅に長く開発してる。もっと小気味好いリズムを刻みたいので反省点として次に活かす。&lt;/p&gt;&lt;p&gt;...という計画で進めているのでテストケースを書いてたら、エグいバグに気づいた。これ &lt;code&gt;PSCustomObject&lt;/code&gt; 利用した際に描画できないし、何なら戻り値が破壊される。やば。&lt;/p&gt;&lt;p&gt;ちょうどプロパティ指定検索でテストケースを書くときに &lt;code&gt;PSCustomObject&lt;/code&gt; 使ってたら、期待の通り動かず、気づいた。このままやとテスト書けへんやん。&lt;/p&gt;&lt;p&gt;ちょっとショッキングなバグだったので初めからか？いつからか？と混乱したが、よくよく考えると普段自分で作った &lt;code&gt;PSCustomObject&lt;/code&gt; に対してインタラクティブな絞り込みやってないわ...と気づいた。なんで使ってなかったのか？自分で定義するからインタラクティブに調べるほどでもなかったからか。
普段使ってない＆テストザルで見落としてたのか～かっこ悪う...&lt;/p&gt;&lt;p&gt;とりあえず最低限の原因調査として、PowerShell Gallery から &lt;code&gt;pocof&lt;/code&gt; の旧版をインストールしテストしたところ、 &lt;code&gt;hahstable&lt;/code&gt; をサポートした &lt;a href="https://www.powershellgallery.com/packages/pocof/0.2.0-alpha"&gt;pocof 0.2.0-alpha&lt;/a&gt; でぶっ壊れた模様。
&lt;code&gt;PSObject&lt;/code&gt; の wrapping を引き剥がすあたりでやってもーてそう。&lt;/p&gt;&lt;p&gt;再現コード。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$a = [pscustomobject]@{'a'=1;'b'=2}
$a

# a b
# - -
# 1 2

$b = $a | pocof -NonInteractive
$b

# 虚無が出力される。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;なんか &lt;code&gt;NoteProperty&lt;/code&gt; が吹っ飛んでるっぽいのよね。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$a.psobject.Members | ? -Property MemberType -eq NoteProperty | Format-list

# MemberType      : NoteProperty
# IsSettable      : True
# IsGettable      : True
# Value           : 1
# TypeNameOfValue : System.Int32
# Name            : a
# IsInstance      : True
#
# MemberType      : NoteProperty
# IsSettable      : True
# IsGettable      : True
# Value           : 2
# TypeNameOfValue : System.Int32
# Name            : b
# IsInstance      : True

$b.psobject.Members | ? -Property MemberType -eq NoteProperty | Format-list

# 無
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;このままだとプロパティ指定検索のテストが書けないので、この bugfix を優先する。
Issue 立てた。 &lt;a href="https://github.com/krymtkts/pocof/issues/21"&gt;not work with &lt;code&gt;PSCustomObject&lt;/code&gt; · Issue #21 · krymtkts/pocof&lt;/a&gt;&lt;/p&gt;&lt;p&gt;テストに関してももうちょい強化が必要かもな。今のところ &lt;a href="https://github.com/pester/Pester"&gt;Pester&lt;/a&gt; で書いてる E2E テストのみなのだけど、 &lt;code&gt;PSCustomObject&lt;/code&gt; 使ったケースなかったし。&lt;/p&gt;&lt;p&gt;コード自体もグチャァ...としてきたから &lt;a href="https://github.com/fsprojects/FsUnit"&gt;FsUnit&lt;/a&gt; 導入してもう少し丁寧にやったほうが良さげ。
&lt;a href="/posts/2022-05-07-start-to-write-cmdlet-by-fsharp"&gt;&lt;code&gt;pocof&lt;/code&gt; 書き始めた頃&lt;/a&gt;に「可能な限りテストを書きたい所存」て書いてたけど有言不実行になってて笑える(笑えない)。&lt;/p&gt;</description><pubDate>Sun, 05 Feb 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-01-29-things-related-to-cvs2git</guid><link>https://krymtkts.github.io/posts/2023-01-29-things-related-to-cvs2git</link><title>cvs2git にまつわるアレコレ</title><description>&lt;p&gt;ちょっとだけ CVS から Git に変換するときの事がわかった。&lt;/p&gt;&lt;p&gt;&lt;a href="/posts/2023-01-22-want-to-comvert-migu-cvs-to-git-and-failed"&gt;先日の日記&lt;/a&gt;にも追記したが、 remote repo の本体にファイルアクセスできないと使えない。それはつまり repo 所有者じゃないと git repo への変換ができないんだ。
もうこれだけで、自分で手を動かしてどうこうする計画は終了やなというところだが、なんか調べたことを供養するために記しておく。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;cvs2svn は今や GitHub repo を残すのみ。多くのドキュメントに参照されているであろう &lt;code&gt;http://cvs2svn.tigris.org/&lt;/code&gt; はもう閉鎖されている。
&lt;a href="https://github.com/mhagger/cvs2svn"&gt;mhagger/cvs2svn: Migrate CVS repositories to Subversion or Git. This site supersedes the old tigris.org site, which has shut down.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;で、この GitHub repo に cvs2git 含む cvs2svn を動かすための Dockerfile もある。
わたしはそれを知る前に、 Ubuntu 18 であればパッケージが提供されてるのを知ったのでとりあえずそれを使う Dockerfile を書いたのだけど、本家を使う方が良いだろう。&lt;/p&gt;&lt;p&gt;書いた Dockerfile の repo は供養のため public にした。&lt;a href="https://github.com/krymtkts/ubuntu-cvs2git"&gt;krymtkts/ubuntu-cvs2git&lt;/a&gt;&lt;/p&gt;&lt;p&gt;更に、 PowerShell でこの Docker image をビルドし実行するにあたって、どうでもいい気付きを得た。&lt;/p&gt;&lt;p&gt;PowerShell で Docker の &lt;code&gt;--mount&lt;/code&gt; オプションを使う場合は、オブションに渡すパラメータ全体を文字列にしてやる必要があった。
昔は &lt;code&gt;--volume&lt;/code&gt; 使ってたし、ビルド関係は &lt;code&gt;COPY&lt;/code&gt; で済ますし、何なら最近触ってなかったから気づきになって良かったわ。&lt;/p&gt;&lt;p&gt;&lt;a href="https://docs.docker.com/storage/bind-mounts/#start-a-container-with-a-bind-mount"&gt;Bind mounts | Docker Documentation&lt;/a&gt; には bash かなんかの shell の例があるが、これは PowerShell では NG 。&lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;&lt;code class="sh"&gt; docker run -d \
  -it \
  --name devtest \
  --mount type=bind,source="$(pwd)"/target,target=/app \
  nginx:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;PowerShell の流儀に従えばこうなる。&lt;/p&gt;&lt;pre&gt;&lt;code class="pwsh"&gt;docker run -d `
  -it `
  --name devtest `
  --mount "type=bind,source=$((pwd).Path)/target,target=/app" `
  nginx:latest
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因みに、 Windows の場合は Path の delimiter が &lt;code&gt;\&lt;/code&gt; なので &lt;code&gt;/&lt;/code&gt; に変換する必要がある、という情報を Web でよく見る。
のだけど、 &lt;code&gt;\&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; にかかわらずマウントできた(更新されて変わったのかな)。&lt;/p&gt;&lt;pre&gt;&lt;code class="pwsh"&gt;# こうしてもしなくてもどっちでもよい
docker run -d `
  -it `
  --name devtest `
  --mount "type=bind,source=$((pwd).Path -replace '\\','/')/target,target=/app" `
  nginx:latest
&lt;/code&gt;&lt;/pre&gt;&lt;hr /&gt;&lt;p&gt;今回調べたことで改めて知ったが、CVS/SVN -&amp;gt; Git の変換はもうみんな興味なく、情報は陳腐化してるしツールは放棄されかかってるようだった。
作ってる人含め誰も使わなくなったらまあそうなるわ、という感じ。
でもその変換の過渡期に行動を起こさなかった repo てまだありそう。頭の片隅においておこう。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;(2023-02-05 追記)&lt;/p&gt;&lt;p&gt;後でから気づいたが、この Docker の &lt;code&gt;--mount&lt;/code&gt; オプションみたいな回避方法って PowerShell で Maven のオプション使うときにも似たようなのあったわと思い出した。
最近出くわしてなくてすっかり忘れてたみたい(老化現象か)。&lt;/p&gt;</description><pubDate>Sun, 29 Jan 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-01-22-want-to-comvert-migu-cvs-to-git-and-failed</guid><link>https://krymtkts.github.io/posts/2023-01-22-want-to-comvert-migu-cvs-to-git-and-failed</link><title>Migu の CVS repo を Git repo に変換したい(そして失敗)</title><description>&lt;h3 id="2023-01-29-追記"&gt;2023-01-29 追記&lt;/h3&gt;&lt;p&gt;これ上手くいかないの当然で、サーバにある repo 本体に対してこれを実行しないといけない。
centralized VCS 久しぶりだったので、仕組みをすっかり忘れていた。
この日記は間違いの記録となった。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;Migu フォントが好きでずっと使っている。
それこそ &lt;a href="/posts/2021-05-30-maybe-completed-refining-migu-nerd-font"&gt;Migu で PowerLine を使うためにパッチスクリプトを改修する&lt;/a&gt;くらいには気に入っている。&lt;/p&gt;&lt;p&gt;&lt;a href="https://mix-mplus-ipa.osdn.jp/migu/"&gt;Migu フォント : M+と IPA の合成フォント&lt;/a&gt;&lt;/p&gt;&lt;p&gt;今後も使い続けるにあたって、この度 Migu のグリフやコードを読んでみたいと思ったのだけど、 Migu は OSDN の CVS で管理されているので、なかなか読み辛い。
自分が VCS を使い始めたのは SVN からだったりするので、 CVS わからない事が多い。
なのでこの度 Git の repo に変換しようと考えている。&lt;/p&gt;&lt;p&gt;方法を調べているが、もう時代的に cvs → git の変換なんてあまり行われてないようだ。
情報を調べてみても流石に最近のものはなく、いまんところ 2020 頃の記事が参考になるか。&lt;/p&gt;&lt;p&gt;&lt;a href="https://alpha3166.github.io/blog/20200523.html"&gt;CVS リポジトリを Git リポジトリに変換する | アルファのブログ&lt;/a&gt;&lt;/p&gt;&lt;p&gt;ひとまず &lt;a href="https://osdn.net/cvs/view/mix-mplus-ipa/"&gt;Index of /mix-mplus-ipa - mixfont-mplus-ipa - OSDN&lt;/a&gt; にアクセスし repo の tarball を download してある。&lt;/p&gt;&lt;p&gt;これに対して、 WSL の Ubuntu 20 で &lt;a href="https://gitlab.com/esr/cvs-fast-export"&gt;cvs-fast-export&lt;/a&gt; をインストールして &lt;code&gt;cvsconvert&lt;/code&gt; かけてみたのだけどエラーになってしまった。&lt;/p&gt;&lt;pre&gt;&lt;code class="shell"&gt;$ cvsconvert -pvn mix-mplus-ipa/mixfont-mplus-ipa
2023-01-22T07:25:17Z: Reading file list...done, 0.000KB in 0 files (0.581sec)
2023-01-22T07:25:17Z: Analyzing masters with 16 threads...done, 0 revisions (0.002sec)
2023-01-22T07:25:17Z: Make DAG branch heads...done  (0.000sec)
2023-01-22T07:25:17Z: Sorting...done        after parsing:      0.583   1456KB
after branch collation: 0.583   1456KB
               total:   0.583   1456KB
0 commits/0.000M text, 0 atoms at 0 commits/sec.
fatal: stream ends early
fast-import: dumping crash report to .git/fast_import_crash_50
cvsconvert: cat mix-mplus-ipa-mixfont-mplus-ipa.git.fi | (cd mix-mplus-ipa-mixfont-mplus-ipa-git &amp;gt;/dev/null; git fast-import --quiet --done &amp;amp;&amp;amp; git checkout) returned 128.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;さっぱりわからん。&lt;/p&gt;&lt;p&gt;他にもツールがあるのでを試してみたいが、 &lt;code&gt;cvs2git&lt;/code&gt; が同梱される &lt;a href="https://github.com/mhagger/cvs2svn"&gt;cvs2svn&lt;/a&gt; は Ubuntu 20 で提供されておらず。
&lt;a href="https://packages.ubuntu.com/search?keywords=cvs2svn"&gt;Ubuntu – Package Search Results -- cvs2svn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;また &lt;code&gt;git cvsimport&lt;/code&gt; はインストール済みの &lt;code&gt;git&lt;/code&gt; とバージョン競合してしまった。&lt;/p&gt;&lt;p&gt;こうなったら Dockerfile 書いて Ubuntu 18 で &lt;code&gt;cvs2git&lt;/code&gt; インストールする方が良いか？
ちゃっちゃと終えられるかと思ったけど全然そうじゃなかった。
どうでもいい系のタスクをまた積んでしまったけど、一度手を出したからには最後までやらないと気が済まない。&lt;/p&gt;</description><pubDate>Sun, 22 Jan 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-01-15-writing-cmdlet-in-fsharp-pt11</guid><link>https://krymtkts.github.io/posts/2023-01-15-writing-cmdlet-in-fsharp-pt11</link><title>F#でコマンドレットを書いてる pt.11</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。&lt;/p&gt;&lt;p&gt;年末年始思ったほど時間取れなかったが、 pocof のプロパティ指定検索はちょっとずつ進んでいる。&lt;/p&gt;&lt;p&gt;&lt;a href="/posts/2022-12-18-writing-cmdlet-in-fsharp-pt10"&gt;前&lt;/a&gt;は入力できるプロパティの候補が表示されるだけだったが、最近ようやく入力できるプロパティの絞り込みと、プロパティを指定した検索ができるようになった。&lt;/p&gt;&lt;p&gt;プロパティ名は case insensitive に指定できる。まだ複数条件入れたときが buggy でうまく動いてないけど、あとプロパティ入力候補の表示非表示と Ctrl+space での補完ができたら、
ほしいものが出揃うかなーというところだ。&lt;/p&gt;&lt;p&gt;F# でオブジェクトのプロパティを動的に取得する方法としては、リフレクションを利用した。
これが妥当な実装なのかわからないが、現時点では一番シンプルだ。
オブジェクトに &lt;code&gt;GetType().GetProperty()&lt;/code&gt; してプロパティを特定、 &lt;code&gt;PropertyInfo&lt;/code&gt; を介してクエリで指定されたプロパティ名の文字列を使ってプロパティの値を取得している。&lt;/p&gt;&lt;p&gt;元々 F# のシンボルには動的にプロパティを参照する &lt;code&gt;?&lt;/code&gt; が書いてある&lt;sup id="fnref-1"&gt;&lt;a class="footnote-ref" href="#fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt;けど実装は提供されてない。
そういうモジュール(&lt;a href="https://github.com/fsprojects/FSharp.Interop.Dynamic"&gt;fsprojects/FSharp.Interop.Dynamic&lt;/a&gt;)はある。
けど、依存を増やしたくないのと、利用する範囲のコードはすぐ書けるレベルなので自分で実装することにした(使えるか検証してないのもあるし)。&lt;/p&gt;&lt;p&gt;簡単なはずなんだが、結構自身の F# 力不足に起因して困る場面が多かったので、その内容を記す。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;結論からいうと、自前の &lt;code&gt;?&lt;/code&gt; 演算子を定義しようとしたところ、 &lt;code&gt;?&lt;/code&gt; 演算子を中置演算子として使ったときに想定外の挙動があったので、結局 &lt;code&gt;/?&lt;/code&gt; みたいな謎の組み合わせの演算子を自作した。&lt;/p&gt;&lt;p&gt;こういうコードがあるとする。&lt;/p&gt;&lt;pre&gt;&lt;code class="fsharp"&gt;let inline (?) (x: 'a) (prop: string) =
    try
        let propInfo = x.GetType().GetProperty(prop)
        Some(propInfo.GetValue(x, null) :?&amp;gt; 'b)
    with
    | _ -&amp;gt; None
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;先述のコードを利用した場合、プロパティ名の変数を中置演算子と共に利用すると、変数の名前が引き渡されたパラメータとして認識されてしまい、変数の値が展開されなかった。
通常の関数として呼び出すとこのようなことはないのだけど...
なんか言語仕様を読み落としてる気がする。もうちょっと真面目に追い込んでみる必要があるか。以下は REPL(&lt;code&gt;dotnet fsi&lt;/code&gt;) で試してみた結果。&lt;/p&gt;&lt;pre&gt;&lt;code class="fsharp"&gt;&amp;gt; let str = "hello";;
&amp;gt; let p = "Length";;

&amp;gt; let a: int option = str ? p;; // プロパティ p を探しに逝って無いから None
val a: int option = None

&amp;gt; let a: int option = (?) str p;; // ちゃんと変数 p の値である Length の値を取れる
val a: int option = Some 5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;結局これの解消ができないので &lt;code&gt;?&lt;/code&gt; を諦めて &lt;code&gt;/?&lt;/code&gt; としたのだが、その前に &lt;code&gt;!?&lt;/code&gt; とか使ってみても駄目だったので妥協してこうなった。
この場合はシンボルの組み合わせに何らかの制限があるようだが、確証を持てるドキュメントが見つけられず。&lt;/p&gt;&lt;pre&gt;&lt;code class="fsharp"&gt;&amp;gt; let inline (!?) (x: 'a) (prop: string) =
-     try
-         let propInfo = x.GetType().GetProperty(prop)
-         Some(propInfo.GetValue(x, null) :?&amp;gt; 'b)
-     with
-     | _ -&amp;gt; None
- ;;
val inline (!?) : x: 'a -&amp;gt; prop: string -&amp;gt; 'b option

&amp;gt; let a: int option = (!?) str p;;
val a: int option = Some 5

&amp;gt; let a: int option = str !? p;; // なんでエラーになるのかわかってない

  let a: int option = str !? p;;
  --------------------^^^

stdin(51,21): error FS0003: This value is not a function and cannot be applied.

&amp;gt; let inline (/?) (x: 'a) (prop: string) =
-     try
-         let propInfo = x.GetType().GetProperty(prop)
-         Some(propInfo.GetValue(x, null) :?&amp;gt; 'b)
-     with
-     | _ -&amp;gt; None
-
- ;;
val inline (/?) : x: 'a -&amp;gt; prop: string -&amp;gt; 'b option

&amp;gt; let a: int option = str /? p;; // こっちはいける
val a: int option = Some 5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;この辺を理解していってもうちょい pocof の開発をスムースに行いたいところやなー。&lt;/p&gt;&lt;div class="footnotes"&gt;&lt;hr /&gt;&lt;ol&gt;&lt;li id="fn-1"&gt;&lt;p&gt;&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/fsharp/language-reference/symbol-and-operator-reference/#dynamic-lookup-operators"&gt;シンボルと演算子のリファレンス - F# | Microsoft Learn&lt;/a&gt;&lt;/p&gt;&lt;a href="#fnref-1" class="footnote-backref"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description><pubDate>Sun, 15 Jan 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2023-01-08-planning</guid><link>https://krymtkts.github.io/posts/2023-01-08-planning</link><title>2023</title><description>&lt;p&gt;例年通り目標をたてる。&lt;/p&gt;&lt;h3 id="テーマ-不惑"&gt;テーマ: 不惑&lt;/h3&gt;&lt;p&gt;2023 年で遂に本物の四十不惑になる。
惑わずなので基本的に今までの方向性を維持したまま更に歩みを進めるのみ。&lt;/p&gt;&lt;p&gt;ただの予想だが、当面は腰を落ち着けて物事に取り組める年となるかな？という感じがしている。 2022 年までに続けていたことを深化させられるタイミングかなと。
例えば 2022 年から書き始めた F# はまだまだ書いてきた量が少なく手に馴染んでないので、もう少し書く量を増すとか。&lt;/p&gt;&lt;p&gt;あと人間四十ともなれば経年劣化がそこそこに出てきてるので、それのメンテナンスを本格に開始することに決めた。&lt;/p&gt;&lt;h3 id="2023-年の目標"&gt;2023 年の目標&lt;/h3&gt;&lt;p&gt;基本は継続するテーマ。
新しいテーマも去年中に思いついたもので、既に継続中だったりする。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;転居先を決める
&lt;ul&gt;&lt;li&gt;実家のアレコレがあったりしてやっぱ難しいかもなーというのもあるが、ちょっとずつ条件からでも調整する。もう数年もすれば固定資産の整理とか出てきてこれまた手が空かなそうやが&lt;/li&gt;&lt;li&gt;薪ストーブの生活に憧れてるんやけど薪の調達ルート開拓とか考えると結構重いのが悩み。人脈と軽トラは最低限必須ぽいからなあ...都市圏の場合は廃材をもらったり、田舎であれば森林組合に行く等&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;積読消化 2022 年 の実績 0.5 冊/月を超える
&lt;ul&gt;&lt;li&gt;2022 年末から(仕事上必要になった)全文検索の本を読んでるので、それを勢いづけに習慣化する&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;自作ツールの開発
&lt;ul&gt;&lt;li&gt;メインは &lt;a href="https://github.com/krymtkts/pocof"&gt;pocof&lt;/a&gt; 。 &lt;code&gt;prerelease&lt;/code&gt; を外す&lt;/li&gt;&lt;li&gt;他ネタは余力があればやる。&lt;a href="https://cloud.ouraring.com/v2/docs#section/Authentication"&gt;Oura API (2.0)&lt;/a&gt; で自分ダッシュボードを作るとか&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;F# を学ぶ
&lt;ul&gt;&lt;li&gt;pocof も F# だが他にも書く。ブログ乗せ替えたいなあという気持ちがふつふつとあるので &lt;a href="https://fable.io/"&gt;Fable&lt;/a&gt; 使えないかなーとか検討する&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;GitHub のストリークを継続する
&lt;ul&gt;&lt;li&gt;commit, issue 何でもいいので継続する。今のまま継続できれば 2023 年中に 180 日、 365 日のストリークを迎えることになるが、その先に何があるか知らん&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;毎週ブログを書く
&lt;ul&gt;&lt;li&gt;2022 は出来たので 2023 も無理やりにでも書く&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;ギター練習を 30 分/毎日&lt;/li&gt;&lt;li&gt;深酒で怪我をしない
&lt;ul&gt;&lt;li&gt;年々減らせてるが、 2022 は 1 回怪我した。今年 2023 は 0 にする&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;自分メンテナンス開始
&lt;ul&gt;&lt;li&gt;人生 100 年死ぬまで労働時代なので、メンテナンスする。まずは肌。ここ数年で顔にシミが目立ちだしたが、あるだけでめちゃくちゃ年老いて見える。これらを物理的に除去するのを考えている。金がかかるが身体の乗り捨てはまだできそうにないし、やむなし&lt;/li&gt;&lt;li&gt;神経を抜いた歯もどうにかしておきたいが、どうにかできるのかこれ...&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</description><pubDate>Sun, 08 Jan 2023 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-12-31-retrospective2022</guid><link>https://krymtkts.github.io/posts/2022-12-31-retrospective2022</link><title>振り返り 2022 年</title><description>&lt;p&gt;2022 年を振り返る。&lt;/p&gt;&lt;p&gt;&lt;a href="/posts/2022-01-09-planning"&gt;2022 年のテーマ&lt;/a&gt;は「自分の人生は自分で決める」だった。&lt;/p&gt;&lt;p&gt;手を放れかけた人生の制御権を自分に引き戻すのを目標にしていたところ、おおよそ手元に引き戻せてきたのではないかと感じる。
ここ数年は、年に 1 回は仕事上インパクトのあるネガティブイベントがあった。今年はそれ程のイベントはなかったので、それが起因しての結果だろう。&lt;/p&gt;&lt;h3 id="2022-年目標と成果"&gt;2022 年目標と成果&lt;/h3&gt;&lt;p&gt;今年も 50% 超えでぼちぼち。いい加減に完全勝利もほしい。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;❌ 住みたい場所を決める
&lt;ul&gt;&lt;li&gt;理想と利便性など意見が擦り合わず&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;❌ 積ん読の消化 1 冊/月
&lt;ul&gt;&lt;li&gt;多少ペースを上げたが 0.5 冊 / 月くらいで未達。おしいなあ&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;⭕ 自作ツールの更新
&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/mccall-bot"&gt;マッコールさん&lt;/a&gt;は使う機会がなくて放置してるが、新しく &lt;a href="https://github.com/krymtkts/pocof"&gt;pocof&lt;/a&gt; 、 &lt;a href="https://github.com/krymtkts/PSJobCanAttendance"&gt;PSJobCanAttendance&lt;/a&gt; が増えたので -1 + 2 = 1 だし ⭕ にする&lt;/li&gt;&lt;li&gt;自己満足だが PSJobCanAttendance でパイプラインに対応したことで月々の勤怠入力楽すぎてヤバかった(語彙力)&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;⭕ ギター練習を 30 分/毎日
&lt;ul&gt;&lt;li&gt;継続危うかったけど、土壇場で &lt;a href="/posts/2022-12-25-bought-ouraring-gen3"&gt;Oura Ring を購入した&lt;/a&gt;ことで習慣化に成功した&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;⭕ &lt;a href="https://krymtkts.github.io/"&gt;このブログ&lt;/a&gt;。毎月の更新リズムを維持する
&lt;ul&gt;&lt;li&gt;毎月どころかリズムを掴んで毎週に発展した&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;❌ 深酒で怪我をしない
&lt;ul&gt;&lt;li&gt;未達。夏に怪我をした&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;⭕ 知らない言語を学ぶ F#
&lt;ul&gt;&lt;li&gt;学んだ結果で &lt;a href="https://github.com/krymtkts/pocof"&gt;pocof&lt;/a&gt; を F# で書いてるので当初の目標は ⭕&lt;/li&gt;&lt;li&gt;踏み込んだ言語機能を使えてないのとスタイルもまだ身についていないので、今後も継続する&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以下、当初の予定になかったことのダイジェストだ。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;転職&lt;/li&gt;&lt;li&gt;週 1 ブログ&lt;/li&gt;&lt;li&gt;GitHub の草ストリーク 100 突破&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;大きな流れは去年から変わらなかったが、停滞しかけた良い流れを&lt;a href="/posts/2022-04-09-jobchange-2022"&gt;今年の 4 月に転職した&lt;/a&gt;ことで加速できたかなと感じている。今年の転職はほんと運が良かった。
GitHub の個人垢を使っていい会社なのもあり、活動を可視化しやすくなった。&lt;/p&gt;&lt;p&gt;基本的に、自分の目標のうち殆どは自身に制御権があるものだ。
自身の MP (気力とも) を如何に保ち適切なタイミングで呪文を唱えるか、にかかってる。
そういう目標は、自身のコンディションを維持さえできればどうにでもなるもんやなあと改めて理解した。
週 1 ブログ書いたり、毎日コミットしたり、多少 OSS へのコントリしたり、気持ちの余裕があればできるもんやなあというのが今年の大きな気付きだ。&lt;/p&gt;&lt;p&gt;そりゃ現職でも大変やな～というような仕事は多いが、基本的に自分でどうにかする仕事しかなく、そこが精神衛生上良く働いている気がする。
新しい何かを決める・調整する・理解するとかは、メンバに頼れるけど頼ったとてそのメンバの仕事が止まるので、結局自分がやるしか無い。腹をくくり自分が責任を持ってやるだけ。
それによって自分が誰かのボトルネックになることやその逆もないので、とてもシンプルだ。弊害として自分以上のパフォーマンスは望めないけど。&lt;/p&gt;&lt;p&gt;また現職は、振る舞いや能力のミスマッチに起因してチームメンバが飛ばされるとか「You're fired!」みたいな事故も起こってない。これとても重要。
去年・一昨年は年に 1 度はそういうのがあったから、それ相応に MP を消費していたのだろう。今年は MP 足りず ≒ 意欲が湧かず何も出来ないようなことが起こらなかった。&lt;/p&gt;&lt;p&gt;自身に制御権がある目標はこの通りだが、逆に自分だけで決められないこと、例えば家庭に関する目標なんかをうまく進められなかった。
ここ数年はタイミング的には相当転居やら移住し易いはずやけど、利便性、子供の養育環境、地理的な人間関係とか諸々、この地に縛り付けるものがあり、なかなか進められない。
座して待ったとしても、そのうち決断の時は必ず来る。それまでにはなんか方向性だけでも出したいなあ。&lt;/p&gt;&lt;p&gt;あと酒との付き合いは、コントロールが難しく失敗してる。飲酒で怪我をするの、今年は軽いものだったけどやっぱり怪我したので、いい歳だし楽し過ぎて暴走しないようより自制心を持とう。
健康面の訴求から平日の飲酒は控えめ或いはナシにできてるので、この流れで来年は怪我ゼロにつなげたい。&lt;/p&gt;&lt;p&gt;今年 Oura Ring を購入したこともあって、自身の身体的なコンディションを可視化するのが容易になった。先述の深酒が睡眠のスコアの低さで可視化されて注意しやすくなったり、また運動やギター練習がアクティビティとして見えるので実績回収的なノリで生活に取り入れやすくなる。意図せず好影響を得た形だ。来年はもしやクソチョロなのでは(油断は禁物)。&lt;/p&gt;&lt;p&gt;運動というか身体的なメンテナンスに関しては、齢四十を迎えるにあたりすごく重要になってきた。健康診断結果を見てガタが来てる部分を見つけたり「今年の冬は肌の乾燥がひどいな～いや歳やこれ」みたいな日々の気付きから、経年劣化を感じている。
日本の状況を鑑みるに今後の人生は甘くなくて、人生 100 年その終わりまで働き続けるのは目に見えてるからこそ、自身のハードウェアのメンテナンスも欠かさないのが重要なんやと今更気付いた。まだサイバーパンク的世界観でインスタントにパーツ交換出来ないので、壊れないように注意しないと(はよきて)。
これまでソフトウェア ≒ 精神の方は相応にメンテしてきてるから、その経験をハードウェア ≒ 肉体の方にも応用できると良いが。&lt;/p&gt;&lt;h3 id="まとめ"&gt;まとめ&lt;/h3&gt;&lt;p&gt;来年いよいよ本物の不惑なので、自己が揺らがないように集中していこう。
毎年なんか新しいチャレンジをするのがプログラマの嗜みだと思うけど、ネタをまだ考えついてないので、なんかひねり出したい。&lt;/p&gt;</description><pubDate>Sat, 31 Dec 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-12-25-bought-ouraring-gen3</guid><link>https://krymtkts.github.io/posts/2022-12-25-bought-ouraring-gen3</link><title>Oura Ring Gen3 を買った</title><description>&lt;p&gt;前から欲しかった &lt;a href="https://ouraring.com/"&gt;Oura Ring&lt;/a&gt; を購入した。 買ったのは第 3 世代(Gen3)だ。&lt;/p&gt;&lt;h3 id="事の起こりから購入まで"&gt;事の起こりから購入まで&lt;/h3&gt;&lt;p&gt;ほしいな～と思い出したのは大体 1 年くらい前。 &lt;a href="https://techcrunch.com/2021/12/02/oura-ring-3-review/"&gt;TechCrunch で Oura Ring 3 review&lt;/a&gt; を読んだらへん。
スマートリングにも色々あるが、 NFC がついたようなのはあまりに仰々しく邪魔そうでナシ。単純にバイタルデータを取るだけのために腕時計型のウェアラブルデバイスをつけるのも好きじゃない。 Oura Ring はちょうど良い感がある唯一のデバイスとして気になり始めた。&lt;/p&gt;&lt;p&gt;2022-04 から勤めている現職がヘルステックなのもあって、健康関連の経費補助(満額ではないが)があるので、転職を機にこれは買うしかあるまいなと心を決めた。
また、過去に Gen2 から Gen3 への転換期に&lt;a href="https://rcmdnk.com/blog/2021/11/01/computer-iot-shopping/"&gt;買い替えユーザのメンバーシップを無償にするオファーがあったらしい&lt;/a&gt;。
当面は経費補助で落とすにしても、いつかチャンスが来るかもということで更に背中を押してくれた。&lt;/p&gt;&lt;p&gt;ところが、 2022 年は記録的な円安になったこともあり、思い立った 5 月頃からずっと変えずにいた。もう仕方がないので 12 月になってやっと自分用のクリスマスプレゼントという建前で多少高くても買うことにした。&lt;/p&gt;&lt;p&gt;マットでシンプルな &lt;a href="https://ouraring.com/product/horizon-stealth"&gt;Horizon Stealth&lt;/a&gt; がいいかなーと思ったが、為替によるパンチ力を極力抑えるために、&lt;a href="https://ouraring.com/product/heritage-black"&gt;Heritage Black&lt;/a&gt; にした。&lt;/p&gt;&lt;p&gt;Oura Ring の購入は 12/05 。指輪のサイズなんかわからないので Sizing Kit ありで購入。購入時のコストは以下の通り。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;購入価格 43,200 JPY
&lt;ul&gt;&lt;li&gt;本体 299.00 USD&lt;/li&gt;&lt;li&gt;送料 15.00 USD&lt;/li&gt;&lt;li&gt;換算レートは 2022-12-06 で 1 USD = 137.581 JPY&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;プラス関税で DHL に 3,400.00 JPY&lt;/li&gt;&lt;li&gt;合計 46,600 JPY&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;決して安くない買い物だ。経費補助の残額的に 17,000 円位は補填できるが、自腹で 3 万かー。ちょうどこの時期日本ではソフトバンクでの取り扱いが始まったが、そっちよりは安い(ソフトバンクで買う意味あるんかが謎)。
このガジェットはゴリゴリに使い倒さねばなるまい。&lt;/p&gt;&lt;p&gt;因みに Heritage Black は、商品ページで見るよりもかなりメタリックだ。黒というよりもガンメタリックでちょっと想像よりもチャラかった。&lt;/p&gt;&lt;h3 id="購入から本体到着まで"&gt;購入から本体到着まで&lt;/h3&gt;&lt;p&gt;購入後の流れは非常にスムーズだった。概要は以下の通り。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;12/05 購入&lt;/li&gt;&lt;li&gt;12/07 Sizing Kit 到着。 9 で検証&lt;/li&gt;&lt;li&gt;12/08 8 で検証&lt;/li&gt;&lt;li&gt;12/09 8 で確定&lt;/li&gt;&lt;li&gt;12/12 本体到着&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;購入の 12/05 から 2 日後の 12/07 に Sizing Kit が届く。
Oura 推奨の利き手の逆の人差し指だとギターが弾けなくなるので、右手人差し指を基準をに考えて 9 で検証はじめた(実際に左手人差し指につけてギターを弾いたら指の腹でネックを握れないのでこの判断は正しい)。
ところが翌朝まで 1 日つけてみていまいちなのではと思い始めた。 9 は朝の時間帯でも少し緩い。&lt;/p&gt;&lt;p&gt;利手の右手だと、皿洗いや風呂洗い等あらゆる家事をする時にぶつかる、また食事の時は箸にぶつかるなど、大いに支障があるとわかってきた。左手だと皿洗い時に食器の底の凶悪なザラザラに接触する機会があるのだが、他はさして支障にならなかった。
(Oura Ring はチタン製らしい。モース硬度 4 と仮定すると茶碗などの磁器はモース硬度 7 相当であることを考えれば、皿洗いで Oura Ring が傷つくのは想像するに易い)&lt;/p&gt;&lt;p&gt;同時並行して、使用レビューを Web で漁り、体の変化等で人差し指が多少きつめになったときでも中指に逃げる運用があると知った。実際に自分の人差し指のサイズだと左右で結構差があるが、左手だと人差し指と中指は 8 で運用できるのがわかった。右手人差し指にずっと 8 をはめているのは窮屈だが、ギターを引くときだけはめるとかなら全然いける。
なのでサイズは 8 で決定した。&lt;/p&gt;&lt;p&gt;決めたのは 12/09 で、待ちに待った本体到着が 12/12 。普段海外のサプリ購入で感じてるリードタイムに比べると相当に早かった。&lt;/p&gt;&lt;h3 id="運用を始めてみた"&gt;運用を始めてみた&lt;/h3&gt;&lt;p&gt;12/12 の午後くらいから運用している。
つまり本日 12/25 時点で およそ 2 習慣運用した上での感想を記しておく。&lt;/p&gt;&lt;p&gt;選択している focus area ? は &lt;code&gt;Be productive and energetic&lt;/code&gt; 。なんとなく。これ他のも試してみたいがトレンド？のビューが変わる以外どこに影響あるかわかってない。&lt;/p&gt;&lt;p&gt;Readiness, Sleep, Activity いずれも概ね 90% 前後で推移しており、数値上は非常に健康であると言えるだろう。&lt;/p&gt;&lt;p&gt;というのも、 Oura アプリの Insight ？ 画面が非常によくできていて、スコアを落とすことに何らかの罪悪感のようなものを抱かせるようになっているからだ。
例えば、全体的に青い色調のビジュアルをしているが、スコアが低い要素は赤くなって不安感を煽られる(現に 「Pay attention」 と言われるし)。
また Activity が取れていないとアプリの通知で「足をストレッチする時間ちゃうか？」と ~&lt;del&gt;脅して&lt;/del&gt; 教えてくれるので、強制的に動くような生活リズムが形成されてくる。これが自身で設定した focus area に対応した &lt;del&gt;仕打ち&lt;/del&gt; アプローチなのかは不明だが。&lt;/p&gt;&lt;p&gt;先にアメとムチで言うところの鞭面について触れたが、アメ面でいえば Readiness, Sleep, Activity の各スコアで 85 以上を叩き出せばクラウンをもらうことができる。クラウンはスコアの横にちょこんと表示されるのだけでなく、カレンダーでそれまで得たクラウンを確認することもできる。
クラウンを得たとてどうということないのだが、ゲーマーなら一種のトロコンのような満足感を得られるだろう。現に 1 週目はクラウンが 1 つの日もあったが、 2 週目は最低でもクラウン 2 つ。来たる 3 週目は間違いなく全冠とれるだろう。&lt;del&gt;アプリに人間が操られていると言っても過言ではない。&lt;/del&gt;&lt;/p&gt;&lt;p&gt;お陰で装着 1 週目から、 Readiness と Sleep のスコアを改善するために夜更かしせず寝ると決めたら即寝る、 Activity のスコアを改善するために 1 時間毎にこまめに運動する等、生活習慣を改善し始めれた。このまま継続していけば、その手に勝利をつかむ日も遠くないだろう(何と戦ってる？)。&lt;/p&gt;&lt;p&gt;あと 3 週程で無料のメンバーシップ期間が切れてしまうのだけど、その時アプリがどれだけ使いにくくなるのか検証してみる。それでメンバーシップの継続をするか決めたらいい。現状のレポートに結構満足してるので、多分継続しそうやけど。&lt;/p&gt;&lt;p&gt;台座みたいな充電器は USB Type-C を接続するやつなのだけど、中の基盤が遊んでるっぽくてちょっとガタツキがある。 Oura Ring 自体はそうそう壊れそうに無いけど、充電器の方は丁寧に扱わないと割とすぐ逝ってしまわれるかも。&lt;/p&gt;&lt;h3 id="プログラマからみた-oura-ring-の楽しみ方"&gt;プログラマからみた Oura Ring の楽しみ方&lt;/h3&gt;&lt;p&gt;もう 1 つ Oura Ring の楽しめる点がある。それは API が充実している点だ。&lt;/p&gt;&lt;p&gt;ほんまか知らんがアプリで提供される数値は全て API で取ることができるらしい。名称の表記が Oura Cloud API だったり Oura API だったりどっちやねんというところではあるが、ここでは簡単のため Oura API と呼ぶことにする。
現状 Oura API には &lt;a href="https://cloud.ouraring.com/docs/"&gt;Oura API V1&lt;/a&gt; と &lt;a href="https://cloud.ouraring.com/v2/docs"&gt;Oura API V2&lt;/a&gt; が存在する。 V1 は 2023 年初頭に廃止されるらしい。もうすぐやないか。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The current timeline to sunset the Oura API V1 is early 2023. We are not planning any updates—outside of required maintenance—to the Oura API V1 moving forward. A migration guide for users to transition from V1 to V2 of the Oura API will be available in February 2022.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;API を利用するにあたり認証の手段は 2 つある。
1 つは Personal Access Token 、 もう 1 つは OAuth の API Application だ。
自分のデータにアクセスする場合は Personal Access Token で良いが、複数ユーザのデータを扱うような場合は API Application を使うらしい。でもデフォでは MAX 10 人しか扱えないようなので、より多くのユーザを扱う場合には審査を経て承認が必要だと。はいはい 〇〇 Ads とかの API 利用でもそういうのあったわ。&lt;/p&gt;&lt;p&gt;Oura API V2 では &lt;a href="https://cloud.ouraring.com/v2/static/json/openapi.json"&gt;OpenAPI spec&lt;/a&gt; が公開されているので、アプリに組み込むだとかのときも安心に使えそう。
Open API Generator とかで生成したやつが使いやすいかどうかは Schema が丁寧に作られてるか次第だったりするので、いつか試してみるのも良いだろう。&lt;/p&gt;&lt;p&gt;今日この記事を書くにあたり、 Personal Access Token を用いて自分のデータを取得してみた。&lt;/p&gt;&lt;p&gt;まずは &lt;a href="https://cloud.ouraring.com/personal-access-tokens"&gt;Personal Access Tokens - Oura Developer API&lt;/a&gt; で Personal Access Token を発行する。&lt;/p&gt;&lt;p&gt;疎通確認の為に、自分の Personal Info を取得してみる。 Oura API V2 は Stripe の API Document のように激イケではないものの、見た目はそこそこ親切で好感が持てる。
&lt;a href="https://cloud.ouraring.com/v2/docs#operation/personal_info_route_get"&gt;Get Personal Info&lt;/a&gt; に cURL の例があるのでそれをコピり、 PowerShell 用に書き換える。&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;curl --location --request GET 'https://api.ouraring.com/v2/usercollection/personal_info?start_date=2021-11-01&amp;amp;end_date=2021-12-01' \
--header 'Authorization: Bearer &amp;lt;token&amp;gt;'
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ドキュメントには書いてないクエリ文字列がついててなんか怪しい。
試しに今月始めから今までで取得する。といっても配列が得られるわけではないらしい。期間指定するのはなんでだ？まあいい。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$Token = ConvertTo-SecureString "!!!PERSONAL_ACCESS_TOKEN!!!" -AsPlainText
Invoke-RestMethod -Method Get -Uri "https://api.ouraring.com/v2/usercollection/personal_info?start_date=$((Get-Date -Day 1).ToString('yyyy-MM-dd'))&amp;amp;end_date=$((Get-Date).toString('yyyy-MM-dd'))" -Authentication Bearer -Token $Token

# こんなのが取れる
# age            : 39
# weight         : 61
# height         : 1.8
# biological_sex : male
# email          : メアド
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ドキュメントによると身長は 1m を 1 と扱う。体重は Kg らしい。ただ謎なのは 62 Kg で登録してるのに何故 61 ? 連携してるサービス由来か？と思ったが Google Fit も 62 、 Health Connect はどうかわからない。もしやゼロオリジン？わからん。今後調査を進めよう。&lt;/p&gt;&lt;p&gt;配列じゃないのになんで日を指定するんやろか、と思ってパラメータ削って実行してもデータ取れた。これドキュメントのサンプルコードが間違ってそうやな。ドキュメント自体はあってるので単にケアレスミスやろか。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Invoke-RestMethod -Method Get -Uri "https://api.ouraring.com/v2/usercollection/personal_info" -Authentication Bearer -Token $Token

# 取れるんかい！
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;認証できない時どうなるんだろうと思って &lt;code&gt;Authentication&lt;/code&gt; 外してみたら &lt;code&gt;Internal Server Error&lt;/code&gt; が帰ってきた。まじか。コレジャナイ感がある。試しに V1 で同じことをしてみたらちゃんと 401 が返ってくるので、 V2 まだ未完成なんかなって察する。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Invoke-RestMethod -Method Get -Uri "https://api.ouraring.com/v2/usercollection/personal_info"
# Invoke-RestMethod: Internal Server Error
$res = Invoke-WebRequest -Method Get -Uri "https://api.ouraring.com/v2/usercollection/personal_info" -SkipHttpErrorCheck
$res
# StatusCode        : 500
# StatusDescription : InternalServerError
# Content           : Internal Server Error
# ...
Invoke-RestMethod -Method Get -Uri "https://api.ouraring.com/v1/userinfo"
# Invoke-RestMethod: {"status": 401, "title": "Invalid Access Token", "detail": "The access token provided is expired, revoked, malformed, or invalid for other reasons.", "error": "invalid_token", "error_description": "The access token provided is expired, revoked, malformed, or invalid for other reasons."}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最後に Readiness, Sleep, Activity あたりのデータを取得してみる。期間なしで。アラフォーの赤裸々なバイタルデータだ。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Invoke-RestMethod -Method Get -Uri "https://api.ouraring.com/v2/usercollection/daily_readiness" -Authentication Bearer -Token $Token | ConvertTo-json -Depth 10
# {
#   "data": [
#     {
#       "contributors": {
#         "activity_balance": 84,
#         "body_temperature": 100,
#         "hrv_balance": 87,
#         "previous_day_activity": 81,
#         "previous_night": 96,
#         "recovery_index": 100,
#         "resting_heart_rate": 100,
#         "sleep_balance": 90
#       },
#       "day": "2022-12-24",
#       "score": 91,
#       "temperature_deviation": -0.08,
#       "temperature_trend_deviation": -0.02,
#       "timestamp": "2022-12-24T09:00:00+09:00"
#     },
#     {
#       "contributors": {
#         "activity_balance": 85,
#         "body_temperature": 96,
#         "hrv_balance": 85,
#         "previous_day_activity": 94,
#         "previous_night": 100,
#         "recovery_index": 96,
#         "resting_heart_rate": 76,
#         "sleep_balance": 92
#       },
#       "day": "2022-12-25",
#       "score": 90,
#       "temperature_deviation": 0.09,
#       "temperature_trend_deviation": 0.06,
#       "timestamp": "2022-12-25T09:00:00+09:00"
#     }
#   ],
#   "next_token": null
# }

Invoke-RestMethod -Method Get -Uri "https://api.ouraring.com/v2/usercollection/daily_sleep" -Authentication Bearer -Token $Token | ConvertTo-json -Depth 10
# {
#   "data": [
#     {
#       "contributors": {
#         "deep_sleep": 99,
#         "efficiency": 98,
#         "latency": 75,
#         "rem_sleep": 100,
#         "restfulness": 88,
#         "timing": 76,
#         "total_sleep": 94
#       },
#       "day": "2022-12-24",
#       "score": 91,
#       "timestamp": "2022-12-24T09:00:00+09:00"
#     },
#     {
#       "contributors": {
#         "deep_sleep": 100,
#         "efficiency": 93,
#         "latency": 91,
#         "rem_sleep": 100,
#         "restfulness": 88,
#         "timing": 83,
#         "total_sleep": 96
#       },
#       "day": "2022-12-25",
#       "score": 94,
#       "timestamp": "2022-12-25T09:00:00+09:00"
#     }
#   ],
#   "next_token": null
# }

Invoke-RestMethod -Method Get -Uri "https://api.ouraring.com/v2/usercollection/daily_activity" -Authentication Bearer -Token $Token | ConvertTo-json -Depth 10
# {
#   "data": [
#     {
#       "class_5_min": "1111111111111111111111111111111111111111111112211223333333323233333233333332222222211322222232222222232332322333234222223233223332222322222",
#       "score": 90,
#       "active_calories": 179,
#       "average_met_minutes": 1.46875,
#       "contributors": {
#         "meet_daily_targets": 78,
#         "move_every_hour": 100,
#         "recovery_time": 100,
#         "stay_active": 75,
#         "training_frequency": 100,
#         "training_volume": 97
#       },
#       "equivalent_walking_distance": 3621,
#       "high_activity_met_minutes": 0,
#       "high_activity_time": 0,
#       "inactivity_alerts": 0,
#       "low_activity_met_minutes": 119,
#       "low_activity_time": 10860,
#       "medium_activity_met_minutes": 37,
#       "medium_activity_time": 600,
#       "met": {
#         "interval": 60.0,
#         "items": [
#           1.1,
#           0.9,
#   長すぎ端折る
#           0.9,
#           0.9
#         ],
#         "timestamp": "2022-12-25T04:00:00+09:00"
#       },
#       "meters_to_target": 8000,
#       "non_wear_time": 0,
#       "resting_time": 15900,
#       "sedentary_met_minutes": 5,
#       "sedentary_time": 14340,
#       "steps": 3898,
#       "target_calories": 550,
#       "target_meters": 12000,
#       "total_calories": 1940,
#       "day": "2022-12-25",
#       "timestamp": "2022-12-25T04:00:00+09:00"
#     }
#   ],
#   "next_token": null
# }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Readiness, Sleep は 2 日分、 Activity は 1 日分取れた。日時で実行してデータストアに蓄積するような使い方なら、パラメータを指定する必要もなさそう。基本はデータストアに溜め込むようなことしないだろうし、期間指定してページネーションして利用してねってところか。&lt;/p&gt;&lt;p&gt;スコアはアプリ表示そのままだが、一部の小数位を含む数値はアプリで表示する精度以上に持っている様子。
また Activity は結構色々データを持っていて面白そう。 METs で 1 分刻みのデータ持ってるのかーとか、 &lt;code&gt;class_5_min&lt;/code&gt; に 5 分刻みのサマリを持ってんのかとか。この強烈なデータ表現はアプリ用なんかな？&lt;/p&gt;&lt;p&gt;単純にデータを見てもまだピンとこないので、更なる探索はアプリの利用も熟れてきてからが良いかも知れない。&lt;/p&gt;&lt;h3 id="おわりに"&gt;おわりに&lt;/h3&gt;&lt;p&gt;自分の体調を可視化できるのすごく良い。踊らされやすい人種なだけかも知れんがこうも行動を変容させられると、可能性を感じざるを得ない。実際にその変わった行動が健康に寄与してるかは健康診断とかの結果見なわからんけど。&lt;/p&gt;&lt;p&gt;アプリの継続に関しては、仮に自分ダッシュボードを作り上げれたら案外要らないのか？まだ装着期間が短いこともあり出ないレポートもあるみたいなので、その辺を拝ませてもらってからメンバーシップなしにするとかの判断もありか。&lt;/p&gt;</description><pubDate>Sun, 25 Dec 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-12-18-writing-cmdlet-in-fsharp-pt10</guid><link>https://krymtkts.github.io/posts/2022-12-18-writing-cmdlet-in-fsharp-pt10</link><title>F#でコマンドレットを書いてる pt.10</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。&lt;/p&gt;&lt;p&gt;少しだけ pocof のプロパティ指定検索対応を進めた。&lt;/p&gt;&lt;p&gt;&lt;code&gt;PSCmdlet.ProcessRecord&lt;/code&gt; のときに &lt;code&gt;PSObject.Properties&lt;/code&gt; から &lt;code&gt;PSPropertyInfo.Name&lt;/code&gt; を取り出して &lt;code&gt;Set&amp;lt;string&amp;gt;&lt;/code&gt; の変数に格納する。
その変数を画面の描画のときに通知領域のところに出すまでを実装した。うまく出てるのを見てみようということだ。&lt;/p&gt;&lt;p&gt;当然のごとく、常時プロパティの補完候補が出ているのはヘンなので、クエリの入力状況に応じた表示＆プロパティ候補表示 ON/OFF のオプションの追加が必要になる(のが見えてきた。行き当たりばったり)。&lt;/p&gt;&lt;p&gt;ここで「クエリの入力状況」と書いたが、「プロパティ指定子」(&lt;code&gt;poco&lt;/code&gt; に倣い既定で &lt;code&gt;:&lt;/code&gt; を検討している)が入力されていて、かつカーソルがその「プロパティ指定子」に連続する文字列のポジションにある時が、「プロパティ入力」。つまり入力中のクエリとカーソル位置でモードを切り替える必要がある。&lt;/p&gt;&lt;p&gt;これ結構めんどくて、クエリとか内部状態として持っているレコードにモードを足して、あとキー押下時やカーソル移動のそれぞれのアクションでモードの ON/OF をやらないといけない。&lt;/p&gt;&lt;p&gt;もう他にも面倒なやつらしかないんやけど、今とりあえずプロパティ指定検索では以下を実装しようとしている。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;オプションにプロパティ候補 ON/OFF を追加する&lt;/li&gt;&lt;li&gt;内部状態に入力モード(通常・プロパティ)を追加する&lt;/li&gt;&lt;li&gt;「プロパティ入力モード」のときに
&lt;ul&gt;&lt;li&gt;プロパティのタブ補完できるようにする&lt;/li&gt;&lt;li&gt;プロパティ名入力に合わせてプロパティ表示を絞り込み&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;InputObject&lt;/code&gt; のプロパティ指定検索対応&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;途中 &lt;code&gt;PSPropertyInfo&lt;/code&gt; の型に合わせて入力の検査をしたら...とか思い始めたが、これ今やるのは違うわ今はいいわと思って虚無に帰した。やったら楽しそうなので、そのうち復活してくるかも。
他にも湧いては消え × N するアイデアはポツポツあるので、プロパティの対応が終わったらボチボチ真面目に検討できるようになるかなー。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;試しに実装してみて、使い勝手を検証して、更に実装していく。&lt;/p&gt;&lt;p&gt;これまさにプロトタイピングなのだけど、それなら紙芝居でもいいのでは...という気はしなくもない。
が、紙芝居で作ったらすぐさま試用できるモノが手に入らないので、常に動くものを持てるこっちの方法が楽しい。仕事で気分任せに進めるとヤバい(終わりのないプロトタイピングで金食い潰すとかヤバい)けど趣味プロは誰にも邪魔されない。&lt;/p&gt;&lt;p&gt;とは言えこのアプローチは継ぎ足し〃の九龍城砦になりがちなので、都度再構築されて然るべきなんだろうとひしと感じている。出発点が PowerShell から F# への写経だったのもあって、当初から微妙と感じるところがいくつかあるのと、 F# の腕が悪いのもあってかっこよくないところとか。来年に持ち越しかなー。これも楽しいのでやりたいけど、先にプロパティを始末したい。&lt;/p&gt;</description><pubDate>Sun, 18 Dec 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-12-11-writing-cmdlet-in-fsharp-pt9</guid><link>https://krymtkts.github.io/posts/2022-12-11-writing-cmdlet-in-fsharp-pt9</link><title>F#でコマンドレットを書いてる pt.9</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。&lt;/p&gt;&lt;p&gt;師走は何かと忙しくて pocof のプロパティ指定検索対応に時間が割けていない。
あんまり手も動かせないので、プロパティ指定どうやったらいいかなーと思案している。
つまりこの記事は壁打ちだ。&lt;/p&gt;&lt;p&gt;どー考えても一番楽なのは、 &lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.management.automation.pscmdlet.invokecommand?view=powershellsdk-7.0.0"&gt;&lt;code&gt;PSCmdlet.InvokeCommand&lt;/code&gt;&lt;/a&gt; にクエリ文字列から組み立てた &lt;code&gt;FilterScript&lt;/code&gt; を渡す方法。
でもこのやり方でやったとして自分の知見が広がるわけでもないし、楽しくない。&lt;/p&gt;&lt;p&gt;ということでどうせなら F# の世界からどうにかしてやろうと思っている。
やはり正攻法なのは、&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.management.automation.psobject.properties?view=powershellsdk-7.3.0"&gt;&lt;code&gt;PSObject.Properties&lt;/code&gt;&lt;/a&gt;にアクセスする方法だろう。&lt;/p&gt;&lt;p&gt;難点は、 pocof の &lt;code&gt;InputObject&lt;/code&gt; を内部では &lt;code&gt;PSObject[]&lt;/code&gt; から &lt;code&gt;obj list&lt;/code&gt; に変えてしまってるので、それらを適宜補正してやる必要があるくらい(そもそもなんで &lt;code&gt;obj list&lt;/code&gt; にしたか覚えてない)。なんかできそうに思えてきた。&lt;/p&gt;&lt;p&gt;フィルタの方は、 &lt;code&gt;PSObject.Properties&lt;/code&gt; にクエリ文字列をパースして抜き出したプロパティ名で値を取れば、クエリ式内で &lt;code&gt;where&lt;/code&gt; に使うのは造作もないことだろう。
&lt;code&gt;hashtable&lt;/code&gt; のときだけ特別サポートしているので、そこと折り合いつけれれば困ること無いのでは(油断している)。&lt;/p&gt;&lt;p&gt;プロパティの入力候補出すやつは...どうかな。
パラメータ &lt;code&gt;InputObject&lt;/code&gt; に単一の型だけが含まれるのであれば、先頭の要素の &lt;code&gt;PSObject.Properties&lt;/code&gt; から候補を一覧するだけでいいのだけど、奇しくも pocof は複数の型も許容する包容力を持ってるから...&lt;/p&gt;&lt;p&gt;まー単純に考えて、全走査しているタイミングは 2 つあるので、そこで型情報も一緒に控えておくのが良かろう。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;PSCmdlet.ProcessRecord&lt;/code&gt; で &lt;code&gt;list&lt;/code&gt; に詰めてるのでその時に &lt;code&gt;GetType&lt;/code&gt; する&lt;/li&gt;&lt;li&gt;&lt;code&gt;List.rev&lt;/code&gt; してるときか(&lt;code&gt;ProcessRecord&lt;/code&gt; で計算量減らすため逆に詰めているから)&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;フツーに &lt;code&gt;PSCmdlet.ProcessRecord&lt;/code&gt; いいな。型情報取るだけならなんかこれもできそうな気配してきたな。&lt;/p&gt;&lt;p&gt;問題は取得したプロパティをどう表示するかやけど、スペース的に空いてるのは正規表現パターンのエラー表示するための行だけなので、そこに出そう。要素数が多い場合は水平方向のスクロール機能(！)を実装しないと使い物にならなさそう...全く実装イメージつかんなこれ。&lt;/p&gt;&lt;p&gt;会社の期末が 2023-01 なので、なんか来年頭は忙しくなりそうやな～と思うし、この年末年始のお休み期間で如何に F# と戯れることができるかが重要な気がする。 pocof の至らぬ点諸々の棚卸しもやっておきたいし。
それに今年の振り返りもボチボチやり始めとかないと...&lt;/p&gt;</description><pubDate>Sun, 11 Dec 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-12-04-often-forgotten-in-pwsh-part-1</guid><link>https://krymtkts.github.io/posts/2022-12-04-often-forgotten-in-pwsh-part-1</link><title>PowerShell で忘れがちなこと pt.1</title><description>&lt;p&gt;小ネタ。&lt;/p&gt;&lt;p&gt;&lt;code&gt;hashtable&lt;/code&gt; は PowerFighter(勝手に作った PowerShell 使いの呼び名) なら誰しも使いまくるに違いない。&lt;/p&gt;&lt;p&gt;リテラルが用意されており書きやすいから、ついつい適さない用途にふんだんに利用してしまい、たまにハマる(自分調べ)。
この度、仕事で使っている PowerShell で書いたスクリプトを久しぶりにメンテしたときハマったので、備忘のため記す。
ハマったのは次のような内容だ。&lt;/p&gt;&lt;p&gt;「複数の数値から重複を取り除く術として &lt;code&gt;hashtable&lt;/code&gt; を使ったが、&lt;code&gt;hashtable&lt;/code&gt; に重複が残った」&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; $hash

Name                           Value
----                           -----
1                              True
1                              True
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;なんだこりゃ。&lt;/p&gt;&lt;p&gt;コレが起こった理由は簡単。 1 つ目と 2 つ目の型が異なるからだ。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; $hash.Keys | % GetType

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     String                                   System.Object
True     True     Int32                                    System.ValueType
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;理由がわかれば簡単でまじでしょーもない内容だったが、本当にコレで小一時間ハマった。
異なる型が混在したのは単純に全ての分岐で同じ型になっていなかったバグなのだけど、REPL だと一見同じ値にしか見えないのでびっくりする。&lt;/p&gt;&lt;p&gt;こんなことにならないように、重複を除く用途では型を厳密にできる &lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.collections.generic?view=net-7.0"&gt;System.Collections.Generic 名前空間&lt;/a&gt;のコレクションを使うべきだろう。
型属性がクソ長くなるけど。&lt;/p&gt;&lt;p&gt;先述の、億劫して &lt;code&gt;hashtable&lt;/code&gt; を使った重複の除去は、 &lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.collections.generic.hashset-1?view=net-7.0"&gt;System.Collections.Generic.HashSet&lt;T&gt;&lt;/T&gt;&lt;/a&gt; を使えば以下のように安全だ。&lt;/p&gt;&lt;p&gt;ただ各メソッドに戻り値があるので PowerShell の戻り値と相性悪い。
そこが面倒なら &lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=net-7.0"&gt;System.Collections.Generic.Dictionary&amp;lt;TKey,TValue&amp;gt;&lt;/a&gt; かなあ...宣言がさらに長くなる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; $h1 = @{}
PS&amp;gt; $h1[1] = 1
PS&amp;gt; $h1['1'] = 2
PS&amp;gt; $h1

Name                           Value
----                           -----
1                              2
1                              1

PS&amp;gt; [System.Collections.Generic.HashSet[int]]$h2 = @{}
PS&amp;gt; $h2.add(1) | Out-Null # 戻り値を無に帰すのがメンドイ
PS&amp;gt; $h2.add('1') | Out-Null # 同上
PS&amp;gt; $h2

Key Value
--- -----
  1     2

PS&amp;gt; [System.Collections.Generic.Dictionary[int,int]]$h3 = @{} # 長いな...
PS&amp;gt; $h3[1] = 1
PS&amp;gt; $h3['1'] = 2
PS&amp;gt; $h3

Key Value
--- -----
  1     2

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;とはいえ、型属性の長さやメソッドの戻り値の取り回しにさえ目を瞑れれば、あとは提供される暗黙的変換ライフにより安全な生活が始まる。&lt;/p&gt;&lt;p&gt;簡潔な構文糖は手に入らないけど、「こんなに長いのタイプできないにょ...」となるときは、代わりの術はあるから...それで以て茶を濁す。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Terminal でなら &lt;code&gt;[hashset&lt;/code&gt; とタイプして TAB を押下すれば、あ～ら不思議、完全名称が自動補完される(これは速くてまじですごい)&lt;/li&gt;&lt;li&gt;VS Code であれば &lt;code&gt;[hashset&lt;/code&gt; とタイプして補完候補から選ぶ。Terminal と比較すると若干もっさり感じる&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;雑多に書きたいときに Generic Type を使うのはちょっと大げさかなという気がしないでもないが、安心安全の PowerLife を送るにはこういうのも必要ということで。
↓ に引用した通り Generics のサポートも手厚くなってるわけだし。&lt;/p&gt;&lt;p&gt;&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_calling_generic_methods?view=powershell-7.3"&gt;about Calling Generic Methods - PowerShell | Microsoft Learn&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Beginning with PowerShell 7.3, you can specify the types for a generic method.&lt;/p&gt;&lt;/blockquote&gt;</description><pubDate>Sun, 04 Dec 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-11-27-writing-cmdlet-in-fsharp-pt8</guid><link>https://krymtkts.github.io/posts/2022-11-27-writing-cmdlet-in-fsharp-pt8</link><title>F#でコマンドレットを書いてる pt.8</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。&lt;/p&gt;&lt;p&gt;前回書いた、 composite query の実装をした。 &lt;a href="https://github.com/krymtkts/pocof/issues/9"&gt;#9&lt;/a&gt;&lt;/p&gt;&lt;p&gt;デフォルトでは and で複数のクエリを合成するようにしてる。
一応理由がある。
最初から or だと絞り込む前の状態を覚えていて、追加でほしい候補のためにクエリを書くような使い方になる。
そういう使い方もできるが、ちょっと上級者感がするので、まずは見える範囲で徐々に候補を絞り込めるような and をデフォルトとすることにした。&lt;/p&gt;&lt;p&gt;そのうちショートカット含めた初期値の変更にも対応したいと思ってたし、起動時から or にしたい場合はそこに盛り込めたらいい。&lt;/p&gt;&lt;p&gt;ただこの and での合成は hashtable を絞り込むときに出来が悪くて、まだ思ったような絞り込みになっていない。現状 hashtable は or でのみ気持ちよく絞り込むのができなかった。&lt;/p&gt;&lt;p&gt;これは、 &lt;code&gt;List.allPairs&lt;/code&gt; した複合クエリの List × エントリの List に and の場合は &lt;code&gt;List.forall&lt;/code&gt; or の場合は &lt;code&gt;List.exists&lt;/code&gt; してることで、 hashtable はエントリ Key-Value の二要素あるので and だと両方に共通の文字がないと釣れない...となっているため。
正しくは、 エントリ内の検索候補プロパティは or で、各エントリ毎は and / or のモードを適用できるようにするのが良いか。
プロパティ指定の絞り込みするときにこの問題対処するの必須。&lt;/p&gt;&lt;p&gt;あと like matcher のときだけクエリが空の状態でもフィルタリングされて表示が 0 件になる挙動を直した。 &lt;a href="https://github.com/krymtkts/pocof/issues/10"&gt;#10&lt;/a&gt;&lt;/p&gt;&lt;p&gt;流石に初期表示が 0 件だとはじめ何で絞り込んだらいいんや...(wildcard 埋めたらいいだけやけど)と困惑するので、はじめは全件表示する。&lt;/p&gt;&lt;p&gt;最後に、今回 PowerShell Gallery に公開する時手間取ったのが、 &lt;a href="https://github.com/PowerShell/platyPS"&gt;platyPS&lt;/a&gt; 。&lt;/p&gt;&lt;p&gt;&lt;a href="/posts/2022-11-12-clean-up-pwsh-modules"&gt;前にモジュールの掃除した&lt;/a&gt;影響で &lt;a href="https://github.com/PowerShell/platyPS/tree/v2"&gt;platyPS&lt;/a&gt; の version 2 preview より前のモジュールを消し去ってた。
コレにより &lt;code&gt;New-ExternalHelp&lt;/code&gt; Cmdlet がなくなっていて、 psake のリリーススクリプトがエラーするようになってた。
全く想定外。 v2 で消えるのかこの Cmdlet ？？て感じ。
まだ &lt;a href="https://github.com/PowerShell/platyPS/blob/8ca28935c376ae8dc36ac142e4960fc6d3b725e5/README.md"&gt;README.md&lt;/a&gt; に消えるような話書いてないし、対応待ってたらいだけなんかな ↓↓&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Create external help xml files (MAML) from platyPS Markdown.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;とりあえず preview でない platyPS を使うことで回避した。
pocof に v1 刻むときにはヘルプファイルもきれいにする必要があるし、その時までに platyPS が v2 でほんとに Cmdlet 失われるのかとかチェックする必要が出てきた。&lt;/p&gt;</description><pubDate>Sun, 27 Nov 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-11-20-writing-cmdlet-in-fsharp-pt7</guid><link>https://krymtkts.github.io/posts/2022-11-20-writing-cmdlet-in-fsharp-pt7</link><title>F#でコマンドレットを書いてる pt.7</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。
プロパティ指定の検索に対応しようとしていて、今日のはその思考整理のようなもの。 &lt;a href="https://github.com/krymtkts/pocof/issues/2"&gt;Add a property support. · Issue #2 · krymtkts/pocof&lt;/a&gt;&lt;/p&gt;&lt;p&gt;実は？ &lt;a href="https://github.com/jasonmarcher/poco"&gt;jasonmarcher/poco&lt;/a&gt; を使ってたときから今に至るまで、プロパティ指定の検索をあまりやってこなかった。
可能性は感じていて何なら使いたかったけど、プロパティをいちいち覚えて打つとかできなくて、使いこなせなかった。
なので pocof でそれを実装するからには、障壁を取り除いて簡単に使える機能にしたい。
そのため、まず pocof が機能に対応したと仮定してどんな風に使うか手を動かすイメージをして、そのあと今の pocof との差を表出させるようなことをしている。&lt;/p&gt;&lt;p&gt;このアプローチだけでも色々足りないものが見えてきて面白い。
pocof の時から今の pocof に至るまでの自分の使い方が非常に限定的だったのがよく分かる。
今の自分のユースケースの殆どは、文字列化されたオブジェクトに対して正規表現でフィルタできたら、それで済んでしまうのがわかった。&lt;code&gt;Where-Object&lt;/code&gt; でフィルタするタイミングを、実行してデータがわかったその時まで遅延させる、そんな使い方しかしてない。
だから今の pocof はほんとにそれを満たすだけのミニマルさになってて、欲を言えばツールが使用者に違った視点を与えるとかのフィードバックするとか、そいういうモノがないんやなと改めて感じている。&lt;/p&gt;&lt;p&gt;例えば、 poco の頃にあったスペース区切りで複数の and filter できる機能は pocof にはない。自分が使ってこなかったから作ってなかった。
でもプロパティ指定の検索をするとしたら、これは絶対に使いたい。 1 つのプロパティで絞り込んだとて満足な結果を得られることはないだろう。なんならこれらの複数のプロパティの絞り込みは and だけじゃなくて or でも結合させたい場面が出てくるだろう。
他にも、いま正規表現で &lt;code&gt;.+dir/*+.js&lt;/code&gt; とか書いてるのもスペース区切りで置き換えて &lt;code&gt;dir js&lt;/code&gt; でできたらタイプ数も減って楽でいいよなとか。(正規表現は正規表現で使ったらいいけどほとんどはもっと少ないルールに従ってフィルタできるであろうから)。
こんな感じで、ある 1 つの使い方から芋づる的に派生していく。
確信はないけど、こういった派生が自分の普段の使い方に変化をもたらす気配がしてる。&lt;/p&gt;&lt;p&gt;とりあえずこの複数のフィルタは composite query と(若干中二病的に)名付けて Issue を起こした。&lt;a href="https://github.com/krymtkts/pocof/issues/9"&gt;Support composite query · Issue #9 · krymtkts/pocof&lt;/a&gt;
やることのイメージが膨れ上がりそうやし、プロパティ指定の検索に必要な最低限を細かく刻んで機能を追加して、その後の成長はまた別に考えるのが良さそうかと考えている。&lt;/p&gt;&lt;p&gt;はじめに述べたプロパティ指定の検索も、この「普段の使い方に変化をもたらす」気配がしてる。
例えば、わたしは仕事が AWS のリソースを探るのによく使う AWS Tools for PowerShell 。
Cmdlet の出力をフィルタするのやプロパティの確認なんかで、何度か結果を出力したり変数に格納したり、ステップを踏むことが多い。
でもこれが pocof のインタラクティブな検索で試行錯誤できるようになれば、何度もコマンドを実行しなくても粘土をこねるみたいに try &amp;amp; error しやすくなったりしないかな？とか。
選択したプロパティが列になって検索結果に表示されることでわかりやすさが向上しそうだな、とか。&lt;/p&gt;&lt;p&gt;個人開発では主にゴミスクリプトしか書かないのもあって、改めて自分用のツールを育てる面白さがわかりだした。
個人的な嗜好として、あまり長く同じやり方を続けることを良しとしないのだけど、自分で自分のツールを開発するのってコレとめちゃくちゃ相性良いのでは？と最近思ったりしてる。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;全然関係ないけど .NET 7 出たし、 pocof もさっさと乗り換えてしまのが良さそう(今 .NET 6)。 prerelease なので気兼ねなくやれる。 .NET 7 対応した PowerShell 7.3 かなり速くなった気がするのよな(気だけ？)。その恩恵にあやかりたい。&lt;/p&gt;</description><pubDate>Sun, 20 Nov 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-11-12-clean-up-pwsh-modules</guid><link>https://krymtkts.github.io/posts/2022-11-12-clean-up-pwsh-modules</link><title>師走に向けて PowerShell モジュールの大掃除</title><description>&lt;p&gt;PowerShell あるあるなのだけど、過去のモジュールが溜まってしまって自分で掃除しないといけない。
開発中でもない限りモジュールを切り戻することもないので、一気に消す。これが PowerFighter(勝手に作った PowerShell 使いの呼び名)の嗜み。&lt;/p&gt;&lt;p&gt;ゆーてもこしらえてあるスクリプトを流すだけ。以下の通り。個人的に &lt;code&gt;-Scope AllUsers&lt;/code&gt; でモジュールを入れてるからそれに合わせた形となっている。
簡単のため改行を入れている。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# $PSGetPath.AllUsersModules をロードするために一度流す。
Get-InstalledModule
# Uninstall 対象の取り方。 AllUser 向けに入れてる場合。
Get-Module -ListAvailable | Where-Object -Property Path -Like "$($PSGetPath.AllUsersModules)*" `
| Group-Object -Property Name | Where-Object -Property Count -GT 1 `
| ForEach-Object { $_.Group | Sort-Object -Descending -Property Version | Select-Object -Skip 1 } `
| ForEach-Object { [pscustomobject]@{
        Name = $_.Name;
        RequiredVersion = "$($_.Version)$(if ($_.PrivateData.Values.PreRelease) {'-'+$_.PrivateData.Values.PreRelease} else {''})"
    } }

# 心配なときは以下の出力の最新バージョンが Hit してないことを目検する。
# Get-Module -ListAvailable | ? -Property Path -like "$($PSGetPath.AllUsersModules)*"

# エグゼキューション。
# はじめは -WhatIf アリで流し、処理する時心配なら Confirm で一個ずつ確認する。
Get-Module -ListAvailable | Where-Object -Property Path -Like "$($PSGetPath.AllUsersModules)*" `
| Group-Object -Property Name | Where-Object -Property Count -GT 1 `
| ForEach-Object { $_.Group | Sort-Object -Descending -Property Version | Select-Object -Skip 1 } `
| ForEach-Object { [pscustomobject]@{
        Name = $_.Name
        RequiredVersion = "$($_.Version)$(if ($_.PrivateData.Values.PreRelease) {'-'+$_.PrivateData.Values.PreRelease} else {''})"
    } } | Uninstall-Module -AllowPrerelease
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;prerelease なモジュールの削除も一緒に含めるため、ごちゃごちゃしている。
&lt;code&gt;-Version&lt;/code&gt; の指定を楽にする場合は &lt;code&gt;Get-InstalledModule&lt;/code&gt; を使ったらいいけど、モジュールごとに実行すると遅いし...と思って使ってない。&lt;/p&gt;&lt;p&gt;これで消しきれるかなと思ったけど、依存関係を忘れてたことでいくつかエラーをもらった。 2 周したらきれいになるかなと思いきや、以下のモジュールに関しては消しきれなかった。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Metadata&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;PackageManagement&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;PowerShellGet&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;これらは &lt;code&gt;AWS.Tools.Installer&lt;/code&gt; と &lt;code&gt;PowerShellGet&lt;/code&gt; が依存しており消せないとのこと。
先述のスクリプトでは最新版は確保するようになってあるし、壊れても入れ直したらいから、古いものに関してはやや強引に &lt;code&gt;-Force&lt;/code&gt; を付与して消し去る。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Get-Module -ListAvailable | Where-Object -Property Path -Like "$($PSGetPath.AllUsersModules)*" `
| Group-Object -Property Name | Where-Object -Property Count -GT 1 `
| ForEach-Object { $_.Group | Sort-Object -Descending -Property Version | Select-Object -Skip 1 } `
| ForEach-Object { [pscustomobject]@{
        Name = $_.Name
        RequiredVersion = "$($_.Version)$(if ($_.PrivateData.Values.PreRelease) {'-'+$_.PrivateData.Values.PreRelease} else {''})"
    } } | Uninstall-Module -AllowPrerelease -Force
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;この如何にも PowerFighter な近距離パワー型アプローチ、まさに PowerShell って感じ(いいたいだけ)。
穢れたモジュールフォルダを綺麗にできた。&lt;/p&gt;</description><pubDate>Sat, 12 Nov 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-11-06-publish-psjobcanattendance</guid><link>https://krymtkts.github.io/posts/2022-11-06-publish-psjobcanattendance</link><title>PSJobCanAttendance の公開</title><description>&lt;p&gt;自分が使う機能はおおよそできたので、 &lt;a href="https://github.com/krymtkts/PSJobCanAttendance"&gt;krymtkts/PSJobCanAttendance&lt;/a&gt; を PowerShell Gallery に公開した。&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.powershellgallery.com/packages/PSJobCanAttendance/1.0.1"&gt;PowerShell Gallery | PSJobCanAttendance 1.0.1&lt;/a&gt;&lt;/p&gt;&lt;p&gt;デバッグプリント仕込んだまま publish してしまって速攻パッチが上がっている。これ過去に何度かやらかしたので防ぎたいけど防げてない。横着せずにログレベルちゃんと使ってやれよというところか...&lt;/p&gt;&lt;p&gt;公開のために、&lt;a href="/posts/2022-10-30-prepare-to-publish-psjobcanattendance"&gt;前回見つけた&lt;/a&gt; 勤怠の実績を一覧する機能のバグを修正した。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;休暇があると日付と実績がずれる&lt;/li&gt;&lt;li&gt;最終日の実績が欠落する&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;休暇の実績を含めるようになったので、稼働していない日もひと目で分かる。&lt;/p&gt;&lt;p&gt;動作確認を行うにあたり、指定した月の勤怠の実績を出力できる必要があったため、それも実装した。
ついでにパイプラインからパラメータを受けるようにしたことで、複数月の勤務実績を取得するのも容易だ。しかも期間が連続していない実績を引っこ抜くことができる。この挙動、画面ではできないはず(使い道が思い浮かばんけど)。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# 何故か 8 月を飛ばして 7,9 月の実績を一覧するムーブ
7,9 | % {Get-Date -Month $_} | Get-JobCanAttendance
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ただいまこれ書いてて、休日出勤の実績がある場合にちゃんと一覧できるかな？と思いついたので動作確認してみる必要がありそう。ダメそうなら Issue 行き。&lt;/p&gt;&lt;h3 id="今後やること"&gt;今後やること&lt;/h3&gt;&lt;p&gt;勤怠管理サービスを CLI で処理できるようにするの、非公開のものも含めたらこれで 3 個目になった。
私的用途だと、大抵の勤怠管理で以下の機能を作ってきた。自動打刻は作れるが作らないのが良心。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;出退勤のリアルタイム打刻&lt;/li&gt;&lt;li&gt;事後の打刻(編集機能)&lt;/li&gt;&lt;li&gt;実績の一覧&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;今回のケースでいうと、あとコレができたらいいなーというのに以下がある。いずれもジョブカン勤怠管理ローカルな使い勝手を改善するものだ。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;グループが 1 つの場合に group_id の入力を省略できるようにする&lt;/li&gt;&lt;li&gt;実績の削除&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;まず 1 からできたらいい。 大抵の場合入力パラメータを減らせるから、楽さが増す。
2 は画面での編集が面倒でなければ普段作らないのだけど、今回のケースではほしいかなと思っている。理想はインタラクティブに削除対象を選べるようにしたいけど、まずは指定のパラメータで消すとこからやるか。&lt;/p&gt;&lt;p&gt;あと krymtkts/PSJobCanAttendance 自体 &lt;a href="https://github.com/krymtkts/PSMFAttendance"&gt;krymtkts/PSMFAttendance&lt;/a&gt; のコピペで作ったのもあって、今見るとなんか至らないイマイチな箇所がチラホラある。
それらを直したい気持ちもあるが、直したとて勤怠入力体験が良くなるわけでもないので、あんま動機づけにならない。&lt;/p&gt;&lt;p&gt;個人的には、 &lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の方をいじれてないから、さっさと勤怠スクリプトは終えてしまいたい。でも、やり始めたら気になって止めにくいのもあって止まらない状態が続いてる。要は惰性だ。
なのでリストアップしたものの、やる気がわかない場合はやらないかも...これぞ趣味プロの醍醐味(しらんけど)。&lt;/p&gt;</description><pubDate>Sun, 06 Nov 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-10-30-prepare-to-publish-psjobcanattendance</guid><link>https://krymtkts.github.io/posts/2022-10-30-prepare-to-publish-psjobcanattendance</link><title>PSJobCanAttendance の公開準備</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/PSJobCanAttendance"&gt;krymtkts/PSJobCanAttendance&lt;/a&gt; を PowerShell Gallery に公開する準備をしている。
一括編集機能に若干の改善をした。&lt;/p&gt;&lt;p&gt;従来は、パイプラインを使った一括編集が可能だったが、出勤とか退勤とかの打刻イベント毎にパイプを分ける必要があった。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# 従来はこんなん
@(12..16;20..22) | %{get-date "2022-09-$($_) 08:15:00+0900"} | Edit-JobCanAttendance -TimeRecordEvent work_start -AditGroupId 10
@(12..16;20..22) | %{get-date "2022-09-$($_) 12:00:00+0900"} | Edit-JobCanAttendance -TimeRecordEvent rest_start -AditGroupId 10
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これ自分で使ってみて結構面倒に感じて、時刻と打刻イベントをパイプラインで渡せるように調整した。
この調整により、 1 ヶ月分の出勤・休憩の開始＆終了を一気に登録できる様になってしまった。怠惰が捗る(打刻を必要とする勤怠管理なのは触れてはならない)。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# 1 ~ 31 日の間で 7 日、 10 日、土日を除いた日に出勤と休憩開始・終了を一括登録する。
1..31 | ? {$_ -notin 7,10 } | % {get-date -Day $_} | ? -Property DayOfWeek -notin 0,6 | % {
    [PSCustomObject]@{
        TimeRecordEvent='work_start'
        RecordTime= Get-Date -Date $_ -Hour 8 -Minute 15 -Second 0
    }
    [PSCustomObject]@{
        TimeRecordEvent='rest_start'
        RecordTime= Get-Date -Date $_ -Hour 12 -Minute 0 -Second 0
    }
    [PSCustomObject]@{
        TimeRecordEvent='rest_end'
        RecordTime= Get-Date -Date $_ -Hour 13 -Minute 0 -Second 0
    }
} | Edit-JobCanAttendance -AditGroupId 10 -Verbose​
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これには &lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.management.automation.parameterattribute.valuefrompipelinebypropertyname?view=powershellsdk-1.1.0"&gt;ValueFromPipelineByPropertyName&lt;/a&gt; を使った。
Cmdlet のパラメータにパイプラインの入力オブジェクト(&lt;code&gt;hashtable&lt;/code&gt; は No)が持つ同名プロパティをマッピングできるので、複数のパラメータをバインドできる。
これ自分の書いた Cmdlet で使うことなかったので、いい勉強になった。&lt;/p&gt;&lt;p&gt;その後 PSScriptAnalyzer の指摘を修正して、さて公開しよう、というところで登録済みの勤怠を一覧するところにバグが見つかった。
登録した日と勤怠の実績がずれるバグで、これは直したいな～というやつなので、公開はまた先送り・未遂に終わった。&lt;/p&gt;&lt;p&gt;続く。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;あと別の文脈で、放置していた&lt;a href="https://github.com/krymtkts/PSMFAttendance"&gt;krymtkts/PSMFAttendance&lt;/a&gt;にメンテの予定がないよとアナウンスを追記した。これで Archive する準備も整った(まだしてない)。&lt;/p&gt;&lt;p&gt;これまた別の文脈で、現職では Slack に日報を投稿してから退勤するようにしてるので、そこから投稿時間を拾って退勤実績を作るようにしたいと考えている。
そのために Slack からメッセージの一覧を取得し、 PSJobCanAttendance での一括編集にもっていきたい。&lt;/p&gt;&lt;p&gt;過去に似たようなことをしたとき、 &lt;a href="https://github.com/RamblingCookieMonster/PSSlack"&gt;RamblingCookieMonster/PSSlack&lt;/a&gt; を使った。
しかし PSSlack は 2021 年頃の Slack API の変更に追いついてないので、使うには自力でパッチする必要がある。
(パッチは来てるが適用されていない &lt;a href="https://github.com/RamblingCookieMonster/PSSlack/pull/115"&gt;Fix API deprecation 2021-02-24 by simonfagerholm · Pull Request #115 · RamblingCookieMonster/PSSlack&lt;/a&gt;)。&lt;/p&gt;&lt;p&gt;以前使った時はそうしたが、面倒なので .NET の Slack のモジュールとか探してなんとかしたい。
でも、どのモジュールがいいんか...と調べるのも面倒なので、悩み中。&lt;/p&gt;</description><pubDate>Sun, 30 Oct 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-10-23-cleaning-my-pwsh-profile</guid><link>https://krymtkts.github.io/posts/2022-10-23-cleaning-my-pwsh-profile</link><title>PowerShell の My Profile を掃除する</title><description>&lt;p&gt;PowerShell の profile を Gist で管理してるのだけど、この度掃除をした。&lt;/p&gt;&lt;p&gt;&lt;a href="https://gist.github.com/krymtkts/f8af667c32b16fc28a815243b316c5be"&gt;My PowerShell profile.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;片手間にできる範囲しかやらなかったので、使ってないモジュールと関数の取り除きが主。あとは順番をちょっと入れ替えてみたり、把握してなかった全貌を眺めてみた。&lt;/p&gt;&lt;p&gt;これらの取り除きついでに、供養がてら何のためにつかってたのかとか振り返ってみる。&lt;/p&gt;&lt;h3 id="モジュール取り除き"&gt;モジュール取り除き&lt;/h3&gt;&lt;p&gt;&lt;a href="https://github.com/mklement0/ClipboardText"&gt;mklement0/ClipboardText: Universal clipboard text support for PowerShell, notably also in PowerShell Core (cross-platform) and Windows PowerShell v2-v4&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.powershellgallery.com/packages/ClipboardText/0.1.8"&gt;ClipboardText&lt;/a&gt; というモジュール。コレなんで使ってたのかすら忘れてしまったけど、結構使ってた記憶がある。
&lt;code&gt;Set-ClipboardText&lt;/code&gt; &lt;code&gt;Get-ClipboardText&lt;/code&gt; が使えるようになる。
PowerShell Core を使い始めた頃はクリップボード操作の Cmdlet がなくてできなかったとかそんな理由だったか？&lt;/p&gt;&lt;p&gt;今やフツーに &lt;code&gt;Set-Clipboard&lt;/code&gt; &lt;code&gt;Get-Clipboard&lt;/code&gt; 使ってるので不要になったけどずっと消してなかった。今までありがとう、消した。&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.powershellgallery.com/packages/poco/1.1.0"&gt;poco&lt;/a&gt;も残ってるかな？と思ったが、そうでもなかった。
(変え漏れを除けば)意外にも &lt;a href="https://www.powershellgallery.com/packages/pocof/0.2.0-alpha"&gt;pocof&lt;/a&gt; への変更は忘れてなかったらしい。&lt;/p&gt;&lt;p&gt;あとモジュールは跡形もなかったが、昔 &lt;a href="https://www.powershellgallery.com/packages/GoogleCloud/1.0.1.10"&gt;GoogleCloud&lt;/a&gt; を使って勉強してたときの名残があったのでそれも消した。
このモジュールもう 4 年くらいメンテされてない様子、残念やけど多分重要でないんだろうな。&lt;/p&gt;&lt;h3 id="関数取り除き"&gt;関数取り除き&lt;/h3&gt;&lt;h4 id="明らかな消し忘れ-virtualbox-関連"&gt;明らかな消し忘れ。 VirtualBox 関連&lt;/h4&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function Start-VBoxMachine() {
    vboxmanage list vms | Select-Pocof -CaseSensitive | Out-String -Stream | Select-String -Pattern '\{(.+)\}' | ForEach-Object { vboxmanage startvm ($_.Matches[0].Groups['1'].Value) --type headless }
}

function Stop-VBoxMachine() {
    vboxmanage list runningvms | Select-Pocof -CaseSensitive | Out-String -Stream | Select-String -Pattern '\{(.+)\}' | ForEach-Object { vboxmanage controlvm ($_.Matches[0].Groups['1'].Value) poweroff }
}

function Get-RunningVBoxMachines() {
    vboxmanage list runningvms
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;こんなのがあった。VirtualBox の GUI を介さずに VM の起動・停止をするための奴らだったか確か。
前々職でコンテナ移行しきれてない秘伝の開発環境 VM がチラホラあって、それで使ってた記憶がある。あの VM ちゃん達は今も元気に VM してるのだろうか。
もはや使うこともないので消す。でも供養がてら Gist に残しておいた。&lt;/p&gt;&lt;p&gt;&lt;a href="https://gist.github.com/krymtkts/47f70697cbe006e81d7fd801e1e3b351"&gt;krymtkts/scripts-for-virtualbox.ps1&lt;/a&gt;&lt;/p&gt;&lt;h4 id="なんだコレ-find-ぽいやつ"&gt;なんだコレ。 &lt;code&gt;find&lt;/code&gt; ぽい？やつ&lt;/h4&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function find {
    [CmdletBinding()]
    param(
        [string]$path = '.',
        [Parameter(Mandatory = $True,
            ValueFromPipeline = $True)]
        [string[]]$name,
        [switch]$delete
    )

    begin {
    }

    process {
        foreach ($n in $Name) {
            if ($delete) {
                Get-ChildItem -Recurse -Path $path | Where-Object -Property Name -Like $n | Remove-Item
            }
            else {
                Get-ChildItem -Recurse -Path $path | Where-Object -Property Name -Like $n
            }
        }
    }

    end {
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;なんか薄っすらと、 &lt;code&gt;Makefile&lt;/code&gt; から &lt;code&gt;find&lt;/code&gt; 呼ぶときに何のシェルか考えるの面倒で PowerShell で &lt;code&gt;find&lt;/code&gt; 作ろうとしてた覚えがあるのだけど、それをいつやってたのかわからない。いま使ってもないのでなんでここにあるのか不明。
消す。&lt;/p&gt;&lt;h4 id="何故-profile-に足したクソデカテキストファイルを作る関数"&gt;何故 profile に足した？クソデカテキストファイルを作る関数&lt;/h4&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function New-TextFile {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        [string]
        $Name,
        [Parameter()]
        [long]
        $Byte = [Math]::Pow(1024, 3),
        [Parameter()]
        [int]
        $Basis = [Math]::Pow(1024, 2)
    )
    begin {
        if (Test-Path $Name) {
            Write-Error 'overrides currently not supported.'
            return
        }
        $Remains = $Byte % $Basis
        $Per = $Byte / $Basis
    }
    process {
        1..$Per | ForEach-Object { 'x' * $Basis | Add-Content $Name -Encoding ascii -NoNewline }
        if ($Remains -ne 0) {
            'x' * $Remains | Add-Content $Name -Encoding ascii -NoNewline
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;前に書いた &lt;a href="/posts/2022-03-13-create-huge-text-file-in-pwsh"&gt;PowerShell でクソデカテキストファイルを作る&lt;/a&gt; の関数版だと思われる。
わざわざ profile に入れておいたのはなんでだろう。スクリプトにするだけで良いのでは...過去の自分に問いたい。消した。&lt;/p&gt;&lt;h4 id="psake-の-auto-completer-壊れてるで"&gt;&lt;code&gt;psake&lt;/code&gt; の auto completer 壊れてるで...&lt;/h4&gt;&lt;p&gt;あと今回の掃除を通して &lt;code&gt;psake&lt;/code&gt; の auto completer 壊れてるやんと言うのに気づいたので、直した。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Invoke-psake&lt;/code&gt; の存在チェックをしてあったら &lt;code&gt;Register-ArgumentCompleter&lt;/code&gt; するようにしてた。
けど、どっかのタイミングから &lt;code&gt;invoke-psake&lt;/code&gt; が &lt;code&gt;invoke-cpsake&lt;/code&gt; になってて、 auto completer が登録されなくなってた。&lt;/p&gt;&lt;p&gt;auto completer 周り、 &lt;code&gt;aws_completer&lt;/code&gt; で &lt;code&gt;Register-ArgumentCompleter&lt;/code&gt; 設定するとこも、 AWS CLI 1 の頃から使ってたのもあり AWS CLI 2 では要らなくなった部分がある(良くないけど PyPI からモジュール取ってたときの名残)。
今回は対応を先送りにした。&lt;/p&gt;&lt;h3 id="おわり"&gt;おわり&lt;/h3&gt;&lt;p&gt;そこまで消すものなかったな、というのが率直な感想だが、掃除してないな～という profile だった。&lt;/p&gt;&lt;p&gt;コマンドの存在をチェックしてから関数とか auto completer 登録するみたいなの増えてるので、この辺共通化したいなあ。
でも共通化しだすとファイル分割もしたくなり、結局のところ今の Gist から取ってくるの終焉に向かうのでは...と思った。&lt;/p&gt;&lt;p&gt;なんかより良い(楽な) PowerShell の Profile 管理手段ないかなー。&lt;/p&gt;</description><pubDate>Sun, 23 Oct 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-10-16-writing-cmdlet-in-fsharp-pt6</guid><link>https://krymtkts.github.io/posts/2022-10-16-writing-cmdlet-in-fsharp-pt6</link><title>F#でコマンドレットを書いてる pt.6</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。&lt;/p&gt;&lt;p&gt;&lt;code&gt;hashtable&lt;/code&gt; サポートした。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;やはり &lt;code&gt;IDictionary&lt;/code&gt; 実装用に特別処理みたいなのを書いてあげないといけないかなーという気が若干してる。コイツ以外にも色々出てきたら面倒なので気が向かないけど、特別扱いなのはたしかにそうなので。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;前回コメントしていた実装方針にした。先のことはわからないので、いま想定できない未来は未来の自分に託す。&lt;/p&gt;&lt;p&gt;これによって &lt;code&gt;pocof&lt;/code&gt; は &lt;code&gt;hashtable&lt;/code&gt; のエントリをフィルタできるようになった。 クエリは &lt;code&gt;hashtable&lt;/code&gt; の &lt;code&gt;Key&lt;/code&gt; / &lt;code&gt;Value&lt;/code&gt; それぞれに適用される。こんな感じ ↓。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;@{a='1';b='2';c='3';d='a1';e='b2'} | pocof -NonInteractive -Query a

# Name                           Value
# ----                           -----
# a                              1
# d                              a1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ただしフィルタして得られる値は &lt;code&gt;hashtable&lt;/code&gt; ではなく、 &lt;code&gt;Object[]&lt;/code&gt; (中身は &lt;code&gt;System.Collections.DictionaryEntry&lt;/code&gt;) になる。
一瞬 &lt;code&gt;hashtable&lt;/code&gt; に戻したいかな～と思ったが、色々使い道を模索しているときに以下のようなおもしろ利用法あるとわかったので、そのケースで不都合ありそうでやめた。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# 十把一絡げ
$misc = @(Get-Date; @{a=1;b=2;c=3}; (10..15))

# Sunday, 16 October, 2022 15:25:19
#
# Key   : c
# Value : 3
# Name  : c
#
#
# Key   : b
# Value : 2
# Name  : b
#
#
# Key   : a
# Value : 1
# Name  : a
#
# 10
# 11
# 12
# 13
# 14
# 15

$misc | pocof -NonInteractive -Query 15

# Sunday, 16 October, 2022 15:25:19
# 15
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因みにこういったケースの活用方法はまだ見出していない。ただなんかこのファジーな検索あると面白そうなので残している。例えば、色んなものを array に詰め込んでおいて後でから見ようってアプローチとかになるんではないかと。
仕事の製品コードにこういうの見つけたら卒倒しそうやけど、自分が terminal でなんかデータを捏ねくり回すときにあったら、新たな世界が開けるのでは？的な。しらんけど。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/PowerShell/GraphicalTools"&gt;&lt;code&gt;Out-ConsoleGridView&lt;/code&gt;&lt;/a&gt; はこういう事できなくて、同じ型が揃ってないとエラーになる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$misc | Out-ConsoleGridView
# Out-ConsoleGridView: Object reference not set to an instance of an object.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/where-object?view=powershell-7.2"&gt;&lt;code&gt;Where-Object&lt;/code&gt;&lt;/a&gt; は流石懐が深くて、 &lt;code&gt;-FilterScript&lt;/code&gt; を使えば同様のことができる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$misc | ? {$_ -match 15}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ひとまず &lt;code&gt;hashtable&lt;/code&gt; サポートも終えたので、 プロパティ指定でフィルタする機能を実装する気持ちが高まってきてる。
だけど、このファジーなフィルタの発見によって、フィルタ対象の array に登場する型をチェックしてプロパティを得て...みたいなことが必要になり、面倒さが増した。&lt;/p&gt;&lt;p&gt;率直に言ってコレだるいｗのだけど、こういう楽しみって趣味プロならではの醍醐味じゃないかな。第一ユーザが自分なので、自分が納得できないモノは許容し難いのよな。&lt;/p&gt;&lt;p&gt;まだまだゆるく長く楽しめそうな気配がしていて、良い。&lt;/p&gt;</description><pubDate>Sun, 16 Oct 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-10-09-replace-battery-of-razer-stealth</guid><link>https://krymtkts.github.io/posts/2022-10-09-replace-battery-of-razer-stealth</link><title>Razer Blade Stealth 13 (2017)のバッテリーを換装する</title><description>&lt;p&gt;My Laptop は Razer Blade Stealth 13 2017 モデルなのだが、流石に経年劣化が目立つようになってきた。
バッテリーの膨張だ。&lt;/p&gt;&lt;p&gt;Razer Blade Stealth 13 は美しいアルミ削り出しボティなのだけど、ここ 1 年くらいは底面が何か弧を描いてんな～と感じていたものの、実用上支障がなかったので放置していた。
ところが、夏を過ぎた頃になって蓋を締めたときにピッチリ閉まらなくなってきて「あ、これはヤバイな」と感じた。
早急に交換が必要だと(あんま放置すると筐体の歪みが戻らなくなる)。&lt;/p&gt;&lt;p&gt;もう 4,5 年ものなので CPU の遅さや RAM の少なさ(16GB)も目立つといえば目立つのだけど、 PC のスタートアップやソフトウェアのアップデートに時間がかかる以外ではまだ開発したりゲームする上で対して不満はない状態(仕事だとイライラしそうだが)なので、&lt;del&gt;円安世界で不要な出費を抑えるためにも&lt;/del&gt;バッテリーを交換して長く使おうと考えた。&lt;/p&gt;&lt;p&gt;参考にした記事 →&lt;a href="https://neareal.com/3353/"&gt;RazerBlade のバッテリーを換装する – NEAREAL&lt;/a&gt;&lt;/p&gt;&lt;p&gt;ホントのところは iFixit のリペアキット込み込みバッテリが欲しかったのだけど、おま国で購入できなかった(結果無駄にアカウントだけ作ってしまった)。&lt;/p&gt;&lt;p&gt;なもんで Razer Blade Stealth 13 2017 モデルの型番を Amazon.co.jp で調べて、交換バッテリーをサクッと見つけた。何個もあったので一番安いのを選ぶ。
&lt;a href="https://www.amazon.co.jp/gp/product/B0B6139PBJ"&gt;購入したバッテリ&lt;/a&gt;&lt;/p&gt;&lt;p&gt;この判断が良くなかったのか、発送から到着まで 1 ヶ月以上かかった。「コロナ禍の影響で香港で物流が滞っている」と聞いたけど果たして...&lt;/p&gt;&lt;p&gt;正規バッテリじゃないみたいなので心配といえば心配だったけど、届いた品を見たら &lt;strong&gt;デル(株)&lt;/strong&gt; て書いてたし、 PSE マークもあった。でも &lt;code&gt;㈱&lt;/code&gt; の印字がみょーにずれてる。やっぱ模造品かな。&lt;/p&gt;&lt;p&gt;このバッテリ到着までの長い待ち時間の間にもどんどん膨らみ続け(最近特に酷かった)、タッチパッドのところが一目でわかるくらいに弧を描くようになった。もう限界や...というところで先日バッテリが届いたのでようやく換装に着手できた。&lt;/p&gt;&lt;h3 id="換装する"&gt;換装する&lt;/h3&gt;&lt;p&gt;換装で触った範囲、バックパネルとバッテリの固定には 3 種類のネジが使われており、それぞれに対応するドライバが必要だった。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;バックパネル
&lt;ul&gt;&lt;li&gt;トルクス T6 x 8 箇所&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;バッテリ
&lt;ul&gt;&lt;li&gt;プラス #1 x 6 箇所&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;バッテリコネクタの蓋
&lt;ul&gt;&lt;li&gt;プラス #0 x 2 箇所&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;バックパネルのネジを外すと自然とバックパネルが浮き上がった。かなりのエネルギーが抑圧されていたらしい。恐ろしすぎる。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2022-10-09-laptop/floating-back-panel.jpg" alt="自動的に浮かび上がるバックパネル" /&gt;&lt;/p&gt;&lt;p&gt;先程 &lt;strong&gt;バッテリコネクタの蓋&lt;/strong&gt;と書いたけど、バッテリのコネクタを覆うようにプラ板がついてた。恐らく外れないようにするための固定器具だが、コイツが後で困る。&lt;/p&gt;&lt;p&gt;バッテリはめてみたら 1 箇所だけ 0.3 mm ほどネジ穴とずれてしまってバッチリはまらなかった。仕方ないのでその一箇所だけ無理やりネジ込んだ。&lt;/p&gt;&lt;p&gt;そしてバッテリのコネクタ、フラットケーブルが長過ぎる...折りたたまないと接続できない。ここで先程のバッテリコネクタの蓋が組み合わさり、うまくはめるためにピンセットで絶妙な畳み込みをする必要があった。&lt;/p&gt;&lt;p&gt;以下の写真で波打つフラットケーブルとビミョーにずれた &lt;code&gt;㈱&lt;/code&gt; が確認できる。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2022-10-09-laptop/waving-flat-cable.jpg" alt="長過ぎて接続すると波打つフラットケーブル" /&gt;&lt;/p&gt;&lt;p&gt;バッテリコネクタの蓋の隙間に畳み込まれたフラットケーブル。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2022-10-09-laptop/convoluted-flat-cable.jpg" alt="バッテリコネクタの蓋の隙間にねじ込まれるフラットケーブル" /&gt;&lt;/p&gt;&lt;p&gt;バッテリの新旧を見比べてみる。古い方(下)からははち切れんばかりのエネルギーを感じる。ほんまに危なっかしいな。爆発する前に新バッテリが届いてほんと良かった。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2022-10-09-laptop/before-after.jpg" alt="スマートな新バッテリ(上)とダイナマイトな旧バッテリ(下)" /&gt;&lt;/p&gt;&lt;h3 id="換装後"&gt;換装後&lt;/h3&gt;&lt;p&gt;換装前後で明らかに差を感じられる。異様に熱くならなくなってファンが回らなくなった。&lt;/p&gt;&lt;p&gt;ただ &lt;code&gt;powercfg.exe /BATTERYREPORT&lt;/code&gt; でバッテリ容量が取れない。 これってどうやったら解消されるんだろう？バッテリ残容量も 100% を指しててホンマか？というお気持ち。&lt;/p&gt;&lt;p&gt;&lt;code&gt;powercfg.exe /ENERGY&lt;/code&gt; したらバッテリの容量が取れないというエラーになった。&lt;/p&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;Battery:Battery Capacity Unknown
The battery capacity could not be determined. This may indicate a firmware (BIOS) problem.
Battery ID	RazerRazer Blade Stealth
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;バッテリ容量わからないと残容量もわからないのでは？再起動したら認識されるときもあって、その時は 41% だった。Razer Blade Stealth はバッテリ容量が少ないと赤いランプが灯るのだが、そこも真っ赤っ赤。試しに置きっぱなしにしてたら電力不足でシャットダウンしてた。&lt;/p&gt;&lt;p&gt;どうしたもんかと調査してみたところ、バッテリ交換後は使い切る → フル充電を数回繰り返すと良い、というような情報があったので参考にして 12,3 時間充電してみた。&lt;/p&gt;&lt;p&gt;よく見たら Amazon のバッテリのページにも同じようなことが書いてた。不自然な日本語でわからなかった。無理に日本語にせず英語にでもしたらいいのに。充電の部分がすっぱり抜けてて当初わからなかった。以下引用&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;''' 1.新しいバッテリを正常に使用する前に、容量を 10%程度に放電してからサイクルを 3 ～ 4 回満たしてください。0%まで放電しないように注意してください。そうすると、バッテリが壊れやすくなります。
'''&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;充電後、今朝改めて &lt;code&gt;powercfg.exe /BATTERYREPORT&lt;/code&gt; してみたところ、 98% 48,949 mWh まで表示されるようになった。規格は 53.6Wh なのでまだまだ上まで充電されるのかな。
&lt;code&gt;powercfg.exe /ENERGY&lt;/code&gt; のバッテリ容量のエラーも解消された。
あと何度か繰り返してみて状況見てみるつもり。&lt;/p&gt;&lt;p&gt;正直なところ筐体が歪んでしまったかもな～と思っていたが、換装後はバッチリ元の平坦さを取り戻せた。たとえ模造品であろうと今のところは満足度が高い。
放電充電繰り返して規格 MAX まで充電されるまでちょっと様子見。&lt;/p&gt;</description><pubDate>Sun, 09 Oct 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-10-02-writing-cmdlet-in-fsharp-pt5</guid><link>https://krymtkts.github.io/posts/2022-10-02-writing-cmdlet-in-fsharp-pt5</link><title>F#でコマンドレットを書いてる pt.5</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。ほぼ実装におけるメモ、壁打ち。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/PowerShell/GraphicalTools"&gt;Out-ConsoleGridView&lt;/a&gt;を見て &lt;code&gt;hashtable&lt;/code&gt; をフィルタできるのいいな～と思ったので、 &lt;code&gt;hashtable&lt;/code&gt; サポートを始めている。誰得な機能ではあれど、これがあると自分にとって利用の幅が広がる。&lt;/p&gt;&lt;p&gt;&lt;code&gt;ProcessRecord&lt;/code&gt; メソッドにおいて、 &lt;code&gt;IDictionary&lt;/code&gt; 実装の場合のみ展開した要素を内部で保持するようにしてみた。一見して煩雑なので、なんかマシにしたい。 &lt;code&gt;list&lt;/code&gt; にして &lt;code&gt;list&lt;/code&gt; 外すあたりがどーにも。&lt;/p&gt;&lt;pre&gt;&lt;code class="diff"&gt;     override __.ProcessRecord() =
-        input &amp;lt;- List.append input &amp;lt;| List.ofArray __.InputObject
+        let entries: list&amp;lt;obj&amp;gt; =
+            List.ofArray __.InputObject
+            |&amp;gt; List.collect (fun (o: PSObject) -&amp;gt;
+                match o.BaseObject with
+                | :? IDictionary as dct -&amp;gt;
+                    Seq.cast&amp;lt;DictionaryEntry&amp;gt; dct
+                    |&amp;gt; Seq.cast&amp;lt;obj&amp;gt;
+                    |&amp;gt; Seq.toList
+                | _ as o -&amp;gt; [ o ])
+
+        input &amp;lt;- List.append input entries
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;破壊的な操作ならすぐマシなのが思いつくが、ちょっと寝かせる。とはいえそっちでスッキリするならそっちがいいかな。
いや待て、ここまで書いて &lt;code&gt;fold&lt;/code&gt; の方がスッキリする気が...してきたので後でやってみる。&lt;/p&gt;&lt;h3 id="追記2022-10-03"&gt;追記(2022-10-03)&lt;/h3&gt;&lt;p&gt;要らんコードも取り除いてこうした。幾分マシかなあ。&lt;/p&gt;&lt;pre&gt;&lt;code class="diff"&gt;     override __.ProcessRecord() =
-        input &amp;lt;- List.append input &amp;lt;| List.ofArray __.InputObject
+        input &amp;lt;-
+            List.ofArray __.InputObject
+            |&amp;gt; List.fold
+                (fun acc o -&amp;gt;
+                    match o.BaseObject with
+                    | :? IDictionary as dct -&amp;gt;
+                        Seq.cast&amp;lt;obj&amp;gt; dct
+                        |&amp;gt; Seq.fold (fun a d -&amp;gt; d :: a) acc
+                    | _ as o -&amp;gt; o :: acc)
+                input

     override __.EndProcessing() =
+        input &amp;lt;- List.rev input
&lt;/code&gt;&lt;/pre&gt;&lt;hr /&gt;&lt;p&gt;この変更を加えることで &lt;code&gt;hashtable&lt;/code&gt; の各要素を扱えるようになるけど、依然フィルタした結果は得られない。&lt;/p&gt;&lt;p&gt;&lt;code&gt;pocof&lt;/code&gt; はいま内部的に各要素の &lt;code&gt;ToString&lt;/code&gt; メソッドの結果に対して LINQ のクエリをかけてる。
そのため &lt;code&gt;DictionaryEntry&lt;/code&gt; のような &lt;code&gt;ToString&lt;/code&gt; の結果が自身のクラスを示す文字列 &lt;code&gt;System.Collections.DictionaryEntry&lt;/code&gt; を返す場合、使い物にならない。&lt;/p&gt;&lt;p&gt;未実装のプロパティ指定可能にする機能があればまあ使えるので先にやるべきと考えるが、プロパティ未指定時の挙動が定義できてないといけない。
常時プロパティ指定なんてしないので、 &lt;code&gt;ToString&lt;/code&gt; に値が反映されないタイプのオブジェクトの場合に、デフォルトでフィルタ可能な挙動を定義する必要がある。あーこっちのが大事やわ。
やはり &lt;code&gt;IDictionary&lt;/code&gt; 実装用に特別処理みたいなのを書いてあげないといけないかなーという気が若干してる。コイツ以外にも色々出てきたら面倒なので気が向かないけど、特別扱いなのはたしかにそうなので。&lt;/p&gt;&lt;p&gt;つづく&lt;/p&gt;</description><pubDate>Sun, 02 Oct 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-09-24-psjobcanattendance</guid><link>https://krymtkts.github.io/posts/2022-09-24-psjobcanattendance</link><title>PowerShell でジョブカン勤怠管理を操作する</title><description>&lt;p&gt;現職について半年が経とうとしている。幸運なことに毎日忙しく過ごしており打刻もままならん(&lt;del&gt;単にいつも忘れてるだけ&lt;/del&gt;)。
なので、またアレを作った。打刻スクリプトだ。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/PSJobCanAttendance"&gt;krymtkts/PSJobCanAttendance&lt;/a&gt;&lt;/p&gt;&lt;p&gt;現職は&lt;a href="https://jobcan.ne.jp/"&gt;ジョブカン勤怠管理&lt;/a&gt;を使ってるので、また新しく作る必要があった。
とはいえ&lt;a href="https://github.com/krymtkts/PSMFAttendance"&gt;krymtkts/PSMFAttendance&lt;/a&gt;をベースに開発(コピペ)しているので、構造的には同じ。
異なるのはスクレイピングの部分だけといって過言ない。&lt;/p&gt;&lt;p&gt;個人的に考える目玉機能は以下の 2 つ。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;OTP 対応&lt;/li&gt;&lt;li&gt;一括編集&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;1 については、認証時に OTP を取得する &lt;code&gt;ScriptBlock&lt;/code&gt; 差し込めるようにしてある。現職では都合が良いことに 1Password を使わせえてもらえてるので、 &lt;a href="https://developer.1password.com/docs/cli/get-started/"&gt;op&lt;/a&gt; を使って取得した OTP が渡せるのだ。
&lt;code&gt;ScriptBlock&lt;/code&gt; がない場合は入力を求めるプロンプトになる。&lt;/p&gt;&lt;p&gt;2 については、自分の現職における勤務実績の入れ方を考えると、絶対必要だったものだ。
現職はフレックスでかなりゆるいのでほぼ勤怠管理無いに等しいが、打刻は求められている。ただ自身が怠惰なせいもあり、3 週間くらい打刻を忘れていて〆前に急いで入力するなんてことが多発している。これを楽にこなすためにも、今回は絶対に一括編集機能を作りたかった。休憩時間が自動入力の設定じゃないようなので、打刻漏れしたときの作業の重さは尚更だ。&lt;/p&gt;&lt;p&gt;以下のようにパイプを使った一括編集ができる。端的に言って、楽過ぎてヤバい(打刻しろ)。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;@(12..16;20..22) | %{get-date "2022-09-$($_) 08:15:00+0900"} | Edit-JobCanAttendances -TimeRecordEvent work_start -AditGroupId 10
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上記の様な感じで試しに 3 週ほどの実績をドバドバと書き込んでみたが、リクエストが拒否されることもなく使えて一安心だった。
今回の打刻スクリプトを作るにあたり、毎度のごとく利用規約はチェック済みだ。&lt;a href="https://jobcan.ne.jp/aup"&gt;利用規約｜ジョブカン勤怠管理&lt;/a&gt;を確認したが、こういうスクリプトを作ることに関し問題なさそうだった。&lt;/p&gt;&lt;p&gt;本当は 2022 年夏頃には一通り作ってたのだけど、その後 2 ヶ月位使わずに来てたので、この週末でまとめ上げた。来週から実際に使ってみて、熟れてきたら PowerShell Gallery に公開しようと考えている。&lt;/p&gt;&lt;p&gt;今回作ってみて気づいたこと。&lt;a href="https://github.com/krymtkts/PSMFAttendance"&gt;krymtkts/PSMFAttendance&lt;/a&gt; を作ったときは、同サービスの前例が 1 つくらいしかなかったのに、今回は前例を探せば結構ヒットした。
「No.1 勤怠管理」の名は伊達じゃないな！と思わせるものがあった(何様)。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;&lt;a href="/posts/2021-11-27-psmfattendance"&gt;前に作った Money Forward クラウド勤怠のやつ&lt;/a&gt;は、前職を離れて実行環境がないからもうメンテもできないし、そろそろ Archive してもイイ気がする。
バグ残ったママだけど直して動作確認できないからしゃーない。&lt;/p&gt;</description><pubDate>Sat, 24 Sep 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-09-18-data-ide-data-station-build-notes</guid><link>https://krymtkts.github.io/posts/2022-09-18-data-ide-data-station-build-notes</link><title>データ IDE DataStation のビルド関連メモ</title><description>&lt;p&gt;ちょっと前に &lt;a href="https://datastation.multiprocess.io/"&gt;DataStation&lt;/a&gt; という OSS の IDE を知った。
GitHub の repo はこちら。&lt;a href="https://github.com/multiprocessio/datastation"&gt;multiprocessio/datastation: App to easily query, script, and visualize data from every database, file, and API.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;データベース・ファイル・HTTP リクエストまで多様なデータソースへの接続をサポートしてたり、簡単にグラフ化、コードで加工したり、とにかく良い。 Notebook みたいといえばそんな感じ。&lt;/p&gt;&lt;p&gt;ちょっとコントリしたいネタがあり、その動作確認のためにビルドして実行する必要があった。その時の手順・つまづきポイントを備忘のために雑メモで記しておく。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;DataStation のアーキテクチャについてはこちらのメモにある。そんなに詳しくないので自力で色々読んだり試したりした方がイイか。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/multiprocessio/datastation/blob/66b77f0cfe41040c49fe1e42e6f267b59f45b5bf/ARCHITECTURE.md"&gt;datastation/ARCHITECTURE.md at main · multiprocessio/datastation&lt;/a&gt;&lt;/p&gt;&lt;h3 id="デスクトップアプリのビルドと実行"&gt;デスクトップアプリのビルドと実行&lt;/h3&gt;&lt;p&gt;&lt;a href="https://github.com/multiprocessio/datastation/blob/66b77f0cfe41040c49fe1e42e6f267b59f45b5bf/HACKING.md"&gt;datastation/HACKING.md at main · multiprocessio/datastation&lt;/a&gt;&lt;/p&gt;&lt;p&gt;手順はこれを参照した。でも試してる途中でよくわからなくなってくるので、&lt;a href="https://github.com/multiprocessio/datastation/blob/66b77f0cfe41040c49fe1e42e6f267b59f45b5bf/package.json"&gt;&lt;code&gt;package.json&lt;/code&gt;&lt;/a&gt; を読んで各スクリプトが何者かは読んだ方がイイかも(実際そうした)。&lt;/p&gt;&lt;p&gt;ビルドと実行には WSL2 を使う。 手順に記載のある通り Windows でもできるっぽい(&lt;a href="https://jmeubank.github.io/tdm-gcc/"&gt;tdm-gcc&lt;/a&gt;というのを使う)けど、なんか面倒な気配がしたので Linux で楽をする。いつかチャレンジしてもよいが今ではないと判断した。
GCC は Go の SQLite3 モジュールをビルドするので必要っぽい。&lt;/p&gt;&lt;p&gt;ビルドの事前準備には依存関係のインストールスクリプトが用意されてる(CI 用だけど)。それを使って楽をする。
&lt;a href="https://github.com/multiprocessio/datastation/blob/66b77f0cfe41040c49fe1e42e6f267b59f45b5bf/scripts/ci/prepare_linux.sh"&gt;datastation/prepare_linux.sh&lt;/a&gt;&lt;/p&gt;&lt;p&gt;DataStation のデスクトップアプリは Electron アプリの様子。
以下のビルド実行時に権限が必要だったのと、それによって &lt;code&gt;--no-sandbox&lt;/code&gt; が必要になった。&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;sudo yarn build-desktop --no-sandbox
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;このビルド実行でライブラリが不足しているのがわかり、以下を参考にパッケージをインストールした。なんのエラーが出たかはメモを失念したが、 lib* が足りない系。
足りない依存関係は皆 Electron のビルドに必要なものばかりだった。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://akinov.hatenablog.com/entry/2021/04/04/151851"&gt;Puppeteer でライブラリ不足 libraries: libatk-1.0.so.0 - ノンカフェインであなたにやさしい&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/electron/electron-quick-start/issues/486#issuecomment-1153535808"&gt;Missing shared libraries · Issue #486 · electron/electron-quick-start&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;この依存関係のインストール後にビルドが成功するようになったが、実行すると SQLite3 のエラーになった。
内容は SQLite3 が古いと言われるものだった(メモ失念)。エラーログを見る限りこれの解消には Electron の再ビルドが必要なようだった(これあとから見てもピンとくるのかわからん。エラーログをメモらなかったことが悔やまれる)。&lt;/p&gt;&lt;p&gt;↓ の記事を参考にした覚えあり。
&lt;a href="https://stackoverflow.com/questions/46384591/node-was-compiled-against-a-different-node-js-version-using-node-module-versio"&gt;npm - Node - was compiled against a different Node.js version using NODE_MODULE_VERSION 51 - Stack Overflow&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;./node_modules/.bin/electron-rebuild
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ここまでやって初めて ↓ のコマンドで Electron アプリを動かして動作確認できるようになった(理解のために結局 &lt;code&gt;package.json&lt;/code&gt; に書かれたスクリプトを直で叩くようになる)。&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;yarn electron --trace-warning --unhandled-rejection=warn build/desktop.js --no-sandbox
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="runner-の-ut"&gt;runner の UT&lt;/h3&gt;&lt;p&gt;DataStation のデスクトップアプリはいわばフロントエンドで、データソースとの接続やデータ読み取りは Go で書かれた &lt;a href="https://github.com/multiprocessio/datastation/tree/main/runner"&gt;datastation/runner&lt;/a&gt; で行われてるようだった。&lt;/p&gt;&lt;p&gt;なので UT の実行に関しては先述のディレクトリで &lt;code&gt;go test&lt;/code&gt; するだけで OK だった。とはいえ前の節で先述した通り、 GCC に依存したモジュールのビルドがあるので WSL2 でやるのが良かろう。&lt;/p&gt;&lt;p&gt;終。&lt;/p&gt;</description><pubDate>Sun, 18 Sep 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-09-10-writing-cmdlet-in-fsharp-pt4</guid><link>https://krymtkts.github.io/posts/2022-09-10-writing-cmdlet-in-fsharp-pt4</link><title>F#でコマンドレットを書いてる pt.4</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。&lt;/p&gt;&lt;p&gt;めちゃめちゃ放置してたのだけど、 8 月末くらいから触れるようになってきたので、気になる部分ですぐ変えられる部分を書き換えて、 PowerShell Gallery に公開した。 &lt;a href="/posts/2022-05-07-start-to-write-cmdlet-by-fsharp"&gt;はじめたころ&lt;/a&gt;から 4 ヶ月くらい経ったのか。&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.powershellgallery.com/packages/pocof/0.1.0-alpha"&gt;PowerShell Gallery | pocof 0.1.0-alpha&lt;/a&gt;&lt;/p&gt;&lt;p&gt;現時点に公開する動機としては、自分の普段遣いでは未だ &lt;code&gt;poco&lt;/code&gt; を使ってるというのもあって、折角なのでそれを &lt;code&gt;pocof&lt;/code&gt; に変えようと考えた次第だ。
一部機能に関しては未実装なので、オプションはコメントアウトして隠した形で公開している。&lt;/p&gt;&lt;p&gt;大きい変更としては、PowerShell オブジェクトを作成せずに &lt;code&gt;PSCmdlet&lt;/code&gt; のサブクラスの中で PowerShell の Cmdlet を呼び出す方法がわかったので、その辺を書き換えた。
これが非常に参考になった →&lt;a href="https://github.com/PowerShell/PowerShell/issues/12137"&gt;InvokeCommand.InvokeScript not returning Output · Issue #12137 · PowerShell/PowerShell&lt;/a&gt;&lt;/p&gt;&lt;p&gt;DLL の モジュールを公開するのは初めてだったので、これまた躓きつつも先達の知恵を借りて乗り越えられた。
これ → &lt;a href="https://webcoder.info/fspsmodule.html"&gt;Writing a PowerShell Core Module With F#, A Complete Guide | Brianary&lt;/a&gt;&lt;/p&gt;&lt;p&gt;結局始めた頃はフォルダ指定の公開でええんちゃうかと思ってたが、 &lt;code&gt;Import-Module&lt;/code&gt; してから公開する方がめっちゃ楽なので、参照元に従いそう変えちゃった(こだわり無し)。
そもそもこの記事がなかったら &lt;code&gt;pocof&lt;/code&gt; はサクッと始めてなかったので、感謝しかない。&lt;/p&gt;&lt;p&gt;それと特に意図があった訳ではないが、 &lt;a href="https://docs.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-module-manifest?view=powershell-7.2"&gt;PowerShell Module Manifest&lt;/a&gt; で使ったことがなかった &lt;code&gt;PreRelease&lt;/code&gt; を使ってみたりもした。&lt;/p&gt;&lt;p&gt;公開にあたっての目玉機能は何もない。何なら &lt;code&gt;poco&lt;/code&gt; の機能で未だ実装してないものもある。
ただいくつか自分が &lt;code&gt;poco&lt;/code&gt; を使っていて困ってたことは、これで解消される。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;正規表現パターンの記述中にエラーで落ちない&lt;/li&gt;&lt;li&gt;クエリ記述中に左右カーソル移動ができる(buggy な疑いアリ)&lt;/li&gt;&lt;li&gt;(あとテスト用の非対話モード ← 普段利用ではまじで意味ないけどテストが楽)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;今後欲しい機能としては、とりあえず自分の使い方だと、プロパティ周り。
プロパティ指定のフィルタとプロパティ入力の補完ができたら相当楽になる。表示するプロパティが選べたりしたら最高。&lt;/p&gt;&lt;p&gt;&lt;code&gt;pocof&lt;/code&gt; で印字されたアイコングリフが &lt;code&gt;??&lt;/code&gt; になってたり他にも色々未実装・直さないといけない点あれど、自分が普段使うツールを自分の手でコントロールできる(しかも学習まで兼ねて)というのは、イイことやなと改めて思った。&lt;/p&gt;</description><pubDate>Sat, 10 Sep 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-09-03-the-cui-ver-of-out-grid-view</guid><link>https://krymtkts.github.io/posts/2022-09-03-the-cui-ver-of-out-grid-view</link><title>Out-GridView の CUI 版 Out-ConsoleGridView</title><description>&lt;p&gt;最近知ったのだけど、 &lt;code&gt;Out-GridView&lt;/code&gt; の PowerShell Team 謹製 CUI 版 &lt;code&gt;Out-ConsoleGridView&lt;/code&gt; があったらしい。これが使えるヤツだったら &lt;code&gt;poco&lt;/code&gt; も今作ってる &lt;code&gt;pocof&lt;/code&gt; も要らんやん、と思った。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/PowerShell/GraphicalTools"&gt;PowerShell/GraphicalTools: Modules that mix PowerShell and GUIs/CUIs! - built on Avalonia and gui.cs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;元々 CUI 使ってるのに &lt;code&gt;Out-GridView&lt;/code&gt; で GUI 表示しないとインタラクティブな絞り込みできないのがイヤで &lt;a href="https://github.com/peco/peco"&gt;peco&lt;/a&gt; を使ってたってのがある。
&lt;code&gt;peco&lt;/code&gt; は PowerShell に最適化されてないから、その後オブジェクトのまま取り扱える &lt;a href="https://github.com/jasonmarcher/poco"&gt;jasonmarcher/poco&lt;/a&gt; にたどり着いた。
その後 &lt;code&gt;poco&lt;/code&gt; の独自実装を自分で始めたのが &lt;a href="https://github.com/krymtkts/pocof"&gt;&lt;code&gt;pocof&lt;/code&gt;&lt;/a&gt;(F# の練習がてら)。&lt;/p&gt;&lt;p&gt;なもんで、 &lt;code&gt;Out-GridView&lt;/code&gt; の CUI 版があってもしイイ感じに使えるのなら、この長年の変遷に終止符を打つんちゃうかな的な。&lt;/p&gt;&lt;p&gt;以下 &lt;code&gt;README.md&lt;/code&gt; に従い試す。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Install-Module Microsoft.PowerShell.ConsoleGuiTools -AllowPrerelease -Scope AllUsers
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Get-ChildItem | Out-ConsoleGridView
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src="/img/2022-09-03-capture/capture.png" alt="水色の背景に印字される ls の結果" /&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;space&lt;/code&gt; キーでオブジェクトを選択するか &lt;code&gt;Ctrl+A&lt;/code&gt; で全選択して、 &lt;code&gt;Enter&lt;/code&gt; で選択した結果を出力する。
&lt;code&gt;-Filter&lt;/code&gt; オプションに渡した値で初期表示がフィルタリングされた形になる。そのままタイプしてもフィルタ入力できない。&lt;code&gt;Tab&lt;/code&gt; キーを押してフィルタのテキストにフォーカスできる。
フィルタは正規表現のみみたい。不正なパターンを入れたらちゃんとエラー表示されてエライ。
必ず結果を洗濯した状態で&lt;code&gt;Enter&lt;/code&gt; 押さないと結果が得られないのはちょっとメンドイ。
わたしは使わないけどマウスコントロール(クリックどころかスクロールまで)できるのもすごいな。
背景変わるの好きになれないので、今後色とかキーとかのオプション充実したりするかなあ。
インクリメンタルサーチじゃないのも微妙に好みじゃない操作性だ。&lt;/p&gt;&lt;p&gt;&lt;code&gt;poco&lt;/code&gt;、 &lt;code&gt;pocof&lt;/code&gt; 共にバッファを元に戻すとレイアウトの崩れが起きるのだけど、 &lt;code&gt;Out-ConsoleGridView&lt;/code&gt; は崩れない。素晴らしい。
表示域にないスクロール可能な部分は吹っ飛んでしまうけど、崩れない方法は真似させてもらいたい(MIT ライセンスなので)。けど、コード読んだ感じどこかわからなかった。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Out-ConsoleGridView&lt;/code&gt; は CmdLet の出力に &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.formatviewdefinition?view=powershellsdk-7.0.0"&gt;FormatViewDefinition Class (System.Management.Automation) | Microsoft Docs&lt;/a&gt;を自前で作ってるみたい。
なので PowerShell で表示される内容とちょっと違う。
それ故か、例えば &lt;code&gt;Get-InstalledModule&lt;/code&gt; のような情報量の多い結果を表示するとちょっと悲しい感じになってしまった。 &lt;code&gt;format.ps1xml&lt;/code&gt; が利用されないせいかな。しかしこのクラス使い方がわからなかったので勉強になるわ。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Get-InstalledModule | Out-ConsoleGridView
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src="/img/2022-09-03-capture/jam-packed-capture.png" alt="すし詰めに印字される Get-InstalledModule の結果" /&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;pocof&lt;/code&gt; でやりたいことと方向性が違うなあという感じなので、作ってるものを今すぐブン投げ捨てる必要はなかったようだ。こちらの開発は趣味プロで続けようと思った。しかしコード参考にできるものが増えたのでとても助かるなぁ。&lt;/p&gt;</description><pubDate>Sat, 03 Sep 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-08-27-bump-bootstrap</guid><link>https://krymtkts.github.io/posts/2022-08-27-bump-bootstrap</link><title>Bootstrap のバージョンを上げる</title><description>&lt;p&gt;先週の記事を書いたあとで、何の気なしに &lt;a href="https://web.dev/measure/"&gt;Measure page quality - web.dev&lt;/a&gt; で当ブログの測定をした。
そこで既知の脆弱性があるライブラリ (&lt;code&gt;Bootstrap@3.3.0&lt;/code&gt; と &lt;code&gt;jQuery@1.11.0&lt;/code&gt;)使うなよ！みたいなレポートがでたので、 Bootstrap の更新を思い立った。&lt;/p&gt;&lt;p&gt;変更した内容 → &lt;a href="https://github.com/krymtkts/krymtkts.github.io/commit/c4adeacb06fe759b787646bba5fb698c1f688c94"&gt;Upgrade bootstrap from 3 to 5. · krymtkts/krymtkts.github.io@c4adeac&lt;/a&gt;&lt;/p&gt;&lt;p&gt;ブログ作成当時の記事(&lt;a href="/posts/2019-01-10-make-blog-with-clojure"&gt;Clojure でブログを作った&lt;/a&gt;)を見ると、このブログのテーマは Cryogen 備え付けのテーマである &lt;code&gt;blue_centered&lt;/code&gt; をコピって作ったものだった。
そのままずっと使ってるので、当然の如くテンプレで利用しているライブラリも古いままだったという訳だ。&lt;/p&gt;&lt;p&gt;さて、 Bootstrap のマイグレーションは当然ドキュメントがあるわけだが、&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://getbootstrap.com/docs/4.0/migration/"&gt;Migrating to v4 · Bootstrap&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://getbootstrap.com/docs/5.0/migration/"&gt;Migrating to v5 · Bootstrap v5.0&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;今回は&lt;del&gt;手抜きによる&lt;/del&gt; v3 → v5 という飛び級であるし、わたし自身は Bootstrap に慣れてないので、とりあえずマイグレーションで対応するのは目で見て影響がある範囲のみとした。マイグレーションとしては正攻法な感じじゃなくて、割りと雑な感じだ。&lt;/p&gt;&lt;p&gt;それらの変更は例えば CSS のセレクタの変更だったり、 &lt;code&gt;class&lt;/code&gt; 属性の変更だったりだ。一応レスポンシブなデザインなので PC とモバイル(ブラウザのエミュレータだけど)も見ている。ちょいちょい以前と違うデザインにした・或いは意図せず変わった箇所もある。&lt;/p&gt;&lt;p&gt;途中コンテンツを空で更新したままデプロイしてしまうしょーもないミスがあったが、再度コンテンツを生成して事なきを得た。
これ Cryogen の差分ビルドの影響でちょいちょいやらかすのだけど、普段は人間力でカバーしていたところを今回はできず、デプロイしてしまった次第。この記事の投稿時点で設定を見直した。&lt;/p&gt;&lt;p&gt;今回の VerUp により Best Practices は 92 -&amp;gt; 100 に、 あと Performance も 93 -&amp;gt; 94 と意図せず微妙な好影響があった。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;before
&lt;ul&gt;&lt;li&gt;&lt;img src="/img/2022-08-27-capture/before.png" alt="変更前は Performance 93 Accessibility 97 Best Practices 92 SEO 92" /&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;after
&lt;ul&gt;&lt;li&gt;&lt;img src="/img/2022-08-27-capture/after.png" alt="変更後は Performance 94 Accessibility 97 Best Practices 100 SEO 92" /&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Bootstrap 5 では CSS カスタムプロパティでフォントサイズとか色とか変えられるみたいなので、このブログ用に再定義してるスタイルのいくつかは不要になるんじゃないかな。
これを機にちょっと見直すのもありかも知れない。あるいは別の静的サイトジェネレータに乗り換えるとか。他にやることなくなったらそれも一興か。&lt;/p&gt;&lt;p&gt;終。&lt;/p&gt;</description><pubDate>Sat, 27 Aug 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-08-20-osc-133-in-win-term</guid><link>https://krymtkts.github.io/posts/2022-08-20-osc-133-in-win-term</link><title>Windows Terminal で OSC133 する</title><description>&lt;p&gt;先週は盆の関係で時間が取れず書くのをサボった。まあその前の日曜に余分に書いてたし相殺したことにしておく。&lt;/p&gt;&lt;p&gt;きょうは Windows Terminal でもシェル統合みたいなのができるらしいと気づいたので、それを試す。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;ちょっと古い Windows Terminal Preview のリリースノートを見てて気づいた。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/microsoft/terminal/releases/tag/v1.15.1862.0"&gt;Release Windows Terminal Preview v1.15.186 · microsoft/terminal&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;Get-GitHubRelease -OwnerName microsoft -RepositoryName terminal -Tag v1.15.1862.0 | select -ExpandProperty body | % {$_ -split "`n"} | sls -Pattern '\[Experimental\]' -Context 0,10&lt;/code&gt; で雑に抽出。&lt;/p&gt;&lt;blockquote&gt;&lt;ul&gt;&lt;li&gt;[Experimental] We now support scrollbar marks! (#12948) (#13163) (#13291) (#13414)
&lt;ul&gt;&lt;li&gt;Use the &lt;code&gt;addMark&lt;/code&gt; action to add a scrollbar mark
&lt;ul&gt;&lt;li&gt;The &lt;code&gt;color&lt;/code&gt; optional parameter can be used to specify a color&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Use the &lt;code&gt;scrollToMark&lt;/code&gt; action with a specified &lt;code&gt;direction&lt;/code&gt; parameter to scroll between the marks&lt;/li&gt;&lt;li&gt;Use the &lt;code&gt;clearMark&lt;/code&gt; action to remove a selected mark&lt;/li&gt;&lt;li&gt;Use the &lt;code&gt;clearAllMarks&lt;/code&gt; action to remove all scrollbar marks&lt;/li&gt;&lt;li&gt;The &lt;code&gt;experimental.autoMarkPrompts&lt;/code&gt; profile setting can be set to &lt;code&gt;true&lt;/code&gt; to automatically mark each prompt
&lt;ul&gt;&lt;li&gt;NOTE: This uses the FTCS_PROMPT sequence from FinalTerm, &lt;code&gt;OSC 133 ; A&lt;/code&gt;, which we now support! (#13163)&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;The &lt;code&gt;experimental.showMarksOnScrollbar&lt;/code&gt; profile setting can also be set to &lt;code&gt;true&lt;/code&gt; to display the marks on your scrollbar&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p&gt;ほう？
プロンプトに自動でマーカーを付けられる様になったらしい。&lt;/p&gt;&lt;p&gt;この機能使いたかったが、端末乗り換えて profile にシーケンス足して...みたいなのが必要っぽかったのでメンドイなーと思ってけど、端末だけで対応できるのなら非常に楽。&lt;/p&gt;&lt;p&gt;これはやりたい。試してみる。&lt;/p&gt;&lt;h3 id="windows-terminal-の設定"&gt;Windows Terminal の設定&lt;/h3&gt;&lt;p&gt;利用している Windows Terminal Preview のバージョンは Version: 1.15.2282.0 だった。&lt;/p&gt;&lt;p&gt;以下のような感じの設定で試す。実際の &lt;code&gt;settings.json&lt;/code&gt; は他の設定でゴチャついているので、要所だけ切り抜いた。&lt;/p&gt;&lt;pre&gt;&lt;code class="json"&gt;{
  "$help": "https://aka.ms/terminal-documentation",
  "$schema": "https://raw.githubusercontent.com/microsoft/terminal/main/doc/cascadia/profiles.schema.json",
  "actions": [
    {
      "command": {
        "action": "addMark",
        "color": "#CB4B16"
      },
      "keys": "ctrl+m"
    },
    {
      "command": {
        "action": "scrollToMark",
        "direction": "previous"
      },
      "keys": "ctrl+up"
    },
    {
      "command": {
        "action": "scrollToMark",
        "direction": "next"
      },
      "keys": "ctrl+down"
    },
    {
      "command": "clearAllMarks",
      "keys": "ctrl+d"
    }
  ],
  "profiles": {
    "defaults": {
      "experimental.autoMarkPrompts": true,
      "experimental.showMarksOnScrollbar": true
    },
  },
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;JSON Schema については、&lt;code&gt;https://aka.ms/terminal-profiles-schema&lt;/code&gt; の方はバージョンが古いので Preview 使ってると色々不都合がある。ので repo 直で見る。&lt;/p&gt;&lt;p&gt;試してみて、とりあえずすべて期待通りに動くのがわかった。&lt;/p&gt;&lt;p&gt;はじめスクロールバーに色がつかなくて、はて？だったけど、これは &lt;code&gt;settings.json&lt;/code&gt; の記述が間違ってたからだった。
&lt;code&gt;experimental.autoMarkPrompts&lt;/code&gt;, &lt;code&gt;experimental.showMarksOnScrollbar&lt;/code&gt; は &lt;code&gt;profiles&lt;/code&gt; 直下じゃない。
&lt;code&gt;profiles.defaults&lt;/code&gt; に書かないとダメ。&lt;/p&gt;&lt;p&gt;これに気づいたのは &lt;a href="https://github.com/microsoft/terminal/blob/c12987af415c5e0911d7a0a81b8494fbe6307328/doc/cascadia/profiles.schema.json#L2177-L2181"&gt;&lt;code&gt;settings.json&lt;/code&gt; の JSON Schema のここ&lt;/a&gt;見たら、 &lt;code&gt;Profile&lt;/code&gt; 毎の property であることがわかったから。&lt;/p&gt;&lt;p&gt;ドキュメントにもこの機能出てた。あとから気づいたわ。
&lt;a href="https://docs.microsoft.com/en-us/windows/terminal/customize-settings/profile-advanced#scroll-marks-preview"&gt;Scroll marks (Preview)- Windows Terminal Advanced Profile Settings | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;ドキュメントの方は、タイトルも「Advanced profile settings in Windows Terminal」 やし、こっちならパっと見で気づけたかな...まあよし。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;今回この件を調べてから、 &lt;a href="https://github.com/microsoft/terminal/issues/11000"&gt;megathread: Scrollbar Marks · Issue #11000 · microsoft/terminal&lt;/a&gt; という巨大な Issue を見つけた。
きょう試した experimental な feature もここ由来のもの。&lt;/p&gt;&lt;p&gt;まだ VS Code のそれに比べると相当しょぼい。
またコマンドの成功・失敗に対応してマーカーの色分けがつくとかもない。
けど、この Issue 見るにそれらはそのうちやるっぽい(&lt;code&gt;category&lt;/code&gt; というやつかな)。なので、 subscribe しておいて新しいのが来たら是非試したい。&lt;/p&gt;&lt;p&gt;普段仕事で使う標準出力が長い &lt;code&gt;cdk&lt;/code&gt; とか AWS Tools for PowerShell とかの実行結果を飛び回るのに、こんなに有効な機能が来たことは喜ばしい。
来週の仕事から早速使う。&lt;/p&gt;&lt;h3 id="余談"&gt;余談&lt;/h3&gt;&lt;p&gt;ついでに &lt;code&gt;useAcrylic = true&lt;/code&gt; じゃないとき、 &lt;code&gt;opacity&lt;/code&gt; だけで古き良き透過にできるのにも気づいた。
Windows 11 で ver1.12 から使えたらしい...気づくのに時間がかかったけど、これもやりたかったことのひとつなので、良い。&lt;/p&gt;&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/windows/terminal/customize-settings/profile-appearance#transparency"&gt;Opacity - Windows Terminal Appearance Profile Settings | Microsoft Docs&lt;/a&gt;&lt;/p&gt;</description><pubDate>Sat, 20 Aug 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-08-07-git-says-the-local-repo-is-not-yours</guid><link>https://krymtkts.github.io/posts/2022-08-07-git-says-the-local-repo-is-not-yours</link><title>git で local repo が自分のものじゃないとなったやつ</title><description>&lt;p&gt;今日はブログ書くつもり無かったけど、これまた起こったらなんかハマりそうやなーと思ったので、したためた。&lt;/p&gt;&lt;p&gt;何があったかわからんが、 git に local repo の所有権が自分にないと言われてエラーになった。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; git status
fatal: detected dubious ownership in repository at 'C:/Users/takatoshi/dev/github.com/krymtkts/Get-GzipContent'
To add an exception for this directory, call:

        git config --global --add safe.directory C:\Users\takatoshi\dev\github.com\krymtkts\Get-GzipContent
Set the environment variable GIT_TEST_DEBUG_UNSAFE_DIRECTORIES=true and run
again for more information.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;safe.directory&lt;/code&gt; が設定されているパスなのだけど。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; git config --list | ? {$_ -like 'safe*'}
safe.directory=C:/Users/takatoshi/dev/*
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;GIT_TEST_DEBUG_UNSAFE_DIRECTORIES&lt;/code&gt; でデバッグメッセージを有効化できるそうなのでしてみたところ、以下の様なのが出た。
最近使ってた local repo では出なくて、&lt;del&gt;放置してた&lt;/del&gt; 最近ご無沙汰だった repo で出ている。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; $env:GIT_TEST_DEBUG_UNSAFE_DIRECTORIES=$true
PS&amp;gt; git status
warning: 'C:/Users/takatoshi/dev/github.com/krymtkts/Get-GzipContent/.git' is owned by:
        'S-1-5-32-544'
but the current user is:
        'S-1-5-21-3808303910-2770483448-703627078-1001'
fatal: detected dubious ownership in repository at 'C:/Users/takatoshi/dev/github.com/krymtkts/Get-GzipContent'
To add an exception for this directory, call:

        git config --global --add safe.directory C:/Users/takatoshi/dev/github.com/krymtkts/Get-GzipContent
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;owner が違う...なんで owner 変わってしまってたんだろう。ユーザー 1 人しかいないのに。
あーハイハイ、と想像がついたので試したところ、管理者権限でならエラーが出ない。&lt;/p&gt;&lt;p&gt;どうも過去に管理者権限で作成した local repo の所有者が Administrator になってた模様。それが最近の Git for Windows の更新で検知されるようになったんだ。&lt;/p&gt;&lt;p&gt;Windows で所有者を変更する方法を調べてみて、それっぽい手順があったのでそれに倣う。
Windows のこの辺の昨日全然知らないので、どっかのタイミングで調べないといけないな。
&lt;a href="https://theitbros.com/using-takeown-exe-command-to-take-ownership-of-file-or-folder/#:~:text=You%20can%20change%20the%20owner,%3E%20Advanced%20%3E%20Owner%20%3E%20Change."&gt;Using Takeown.exe Command to Take Ownership of a File or Folder – TheITBros&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;takeown /F C:\Users\takatoshi\dev\github.com\krymtkts\Get-GzipContent /R
# SUCCESS: The file (or folder):  ....
# えげつない量の印字...
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; git status
On branch master
Your branch is up to date with 'origin/master'.

nothing to commit, working tree clean
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;イイね。直せた。
他のディレクトリも所有者を変えた。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;takeown.exe /f . /r | Out-Null
# えげつない量の印字を無に帰す...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;終。&lt;/p&gt;</description><pubDate>Sun, 07 Aug 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-08-06-usecase-of-get-gzipcontent</guid><link>https://krymtkts.github.io/posts/2022-08-06-usecase-of-get-gzipcontent</link><title>Get-GzipContent のユースケース</title><description>&lt;p&gt;以前 &lt;a href="https://github.com/krymtkts/Get-GzipContent"&gt;krymtkts/Get-GzipContent: Get-Content for gzip files.&lt;/a&gt; というのを作って &lt;a href="https://www.powershellgallery.com/packages/Get-GzipContent/0.1.2"&gt;PowerShell Gallery&lt;/a&gt; に公開した。&lt;/p&gt;&lt;p&gt;当時 gzip された JSON を扱う機会が多かった。
その時の職場は bash 文化だったのだけど、自分のローカルでは PowerShell を使うし...ということで、モジュールが欲しかった。
この PowerShell で gzip を展開するコード自体よく知られてるパターンらしかったけど、登録されてるモジュールがなかったので、自分で作った。ちゃんと探したら似たモジュールはあったのだろうけど、周辺モジュールもドカッと入るのは期待するところでないので、単機能のモジュールを作ったんだ確か。&lt;/p&gt;&lt;p&gt;最近になってまた gzip されたファイルを扱う機会が増えたので、改めて使う機会が来たのだけど...これちょっとイマイチやなーと思っている。&lt;/p&gt;&lt;p&gt;CloudFront のアクセスログで&lt;a href="https://docs.aws.amazon.com/ja_jp/AmazonCloudFront/latest/DeveloperGuide/AccessLogs.html#LogFileFormat"&gt;標準ログ&lt;/a&gt;というのがあるのだけど、こいつは gzip された TSV で、これを PowerShell で取り扱うのに以下の関数を作った。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function ConvertFrom-CloudFrontAccessLog {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true,
            Position = 0,
            ValueFromPipeline = $true,
            ValueFromPipelineByPropertyName = $true,
            HelpMessage = 'Path to one or more locations.')]
        [Alias('PSPath')]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Path
    )
    begin {
        $header = 'date', 'time', 'x-edge-location', 'sc-bytes', 'c-ip', 'cs-method', 'cs(Host)', 'cs-uri-stem', 'sc-status', 'cs(Referer)', 'cs(User-Agent)', 'cs-uri-query', 'cs(Cookie)', 'x-edge-result-type', 'x-edge-request-id', 'x-host-header', 'cs-protocol', 'cs-bytes', 'time-taken', 'x-forwarded-for', 'ssl-protocol', 'ssl-cipher', 'x-edge-response-result-type', 'cs-protocol-version', 'fle-status', 'fle-encrypted-fields', 'c-port', 'time-to-first-byte', 'x-edge-detailed-result-type', 'sc-content-type', 'sc-content-len', 'sc-range-start', 'sc-range-end'
    }
    process {
        $Path | ForEach-Object { (zcat $_) -split "`n" } | ConvertFrom-Csv -Delimiter "`t" -Header $header
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;ForEach-Object { (zcat $_) -split "`n" }&lt;/code&gt; ここがイケてない。まじで使いにくい。
改行コードずつ &lt;code&gt;Write-Object&lt;/code&gt; するようにしてないから、自分で分割しないといけなくなってしまっている。当時は改行なし JSON ばかり取り扱ってたので、全く気づかなかったのかなと思っている(しらん)。&lt;/p&gt;&lt;p&gt;↓ こうできたらすごくイイ気がする。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$Path | zcat | ConvertFrom-Csv -Delimiter "`t" -Header $header
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;breaking change なのもあるしバージョン 1 にするかーとか思っている。後方互換のスイッチ要るかな？とか分割単位を指定できるのが良いのかな？とか考え出すと、やる気が...
ま、 &lt;code&gt;Get-Content&lt;/code&gt; と似た動きにしたいってのがあるので、 &lt;code&gt;-Delimiter&lt;/code&gt; かなー。&lt;/p&gt;&lt;p&gt;でも、とりあえず数年後し？のセルフ使用レビューを経てツールを改善しよ...という気になったので、自分のために書いたモジュールでもあるし自分が必要な範囲で直そ。使ってる人がおこになったらちょっと考える。&lt;/p&gt;&lt;p&gt;さっさと直したらいいのだけど、動機づけとしてこの記事をしたためた。
あとはやるだけ... &lt;a href="https://github.com/krymtkts/Get-GzipContent/issues/3"&gt;Add the &lt;code&gt;-Delimiter&lt;/code&gt; option like &lt;code&gt;Get-Content&lt;/code&gt;. · Issue #3 · krymtkts/Get-GzipContent&lt;/a&gt;&lt;/p&gt;</description><pubDate>Sat, 06 Aug 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-07-30-practice-build-aws-tools-for-powrshell</guid><link>https://krymtkts.github.io/posts/2022-07-30-practice-build-aws-tools-for-powrshell</link><title>AWS Tools for PowerShell のビルド素振り</title><description>&lt;p&gt;今年は積極的に？ AWS Tools for PowerShell を使ってることもあって、また Issue 書くことあるかなー、なんなら PR 書いて貢献した方がいいよなと考えるに至り、 &lt;a href="https://github.com/aws/aws-tools-for-powershell"&gt;aws/aws-tools-for-powershell&lt;/a&gt; のビルドを素振りしてみた。
残念ながら、 contribution 関連でビルドの方法がレクチュアされてる文書とかなかったので、手探りでやってる。&lt;/p&gt;&lt;p&gt;まず、サービス毎の膨大なプロジェクトがあるし、試しに単体のプロジェクトをビルドしたかったのだけど、関連付く DLL が無くてビルドできなかった。 &lt;code&gt;Amazon.Runtime&lt;/code&gt; とかいうやつ？ この repo 内のどれかのプロジェクトでビルドされるんだろうけど。&lt;/p&gt;&lt;p&gt;&lt;code&gt;buildtools/&lt;/code&gt; 配下を見ると、どうも CI が CodeBuild らしい(当然のごとく)。この &lt;code&gt;buildtools/ci.buildspec.yml&lt;/code&gt; の中に記載されている全体のビルドで使ってるプロジェクトなら上手くいきそうな雰囲気がしたので、これでフルビルドを試した。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;dotnet --version
# 6.0.302
dotnet build .\buildtools\build.proj
# めちゃくちゃ大量のビルドログが出力される...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ところがこのフルビルドしだしたらクッソ重い...ビルドが終わらない。
わたしの Razer blade stealth 2018 モデルだと CPU 使用率が天井に貼り付いて、過去にない位にヒートアップしてて心配な気持ちにさせてくれた。&lt;/p&gt;&lt;p&gt;結果、 41 分かかってなんとかビルドに成功した。&lt;/p&gt;&lt;p&gt;で、出力結果を見たら改行コードが変わってしまったみたいでエグい差分が発生してしまった。
元コードは全部 &lt;code&gt;LF&lt;/code&gt; なのだけど、 Windows でのビルドによって &lt;code&gt;CRLF&lt;/code&gt; になってしまったみたい。CodeBuild では .NET Core 3.1 でビルドしてるから .NET の関連ツールを使ってても &lt;code&gt;LF&lt;/code&gt; になるんやろが、こちとら Windows 。
どこで変わったか調査して再発を防ぎたいけど、別の機会にする。&lt;/p&gt;&lt;p&gt;これで基盤的な DLL は生成されたであろうし、サービス個別のプロジェクトのビルドを試すと、うまくいった。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;dotnet build .\modules\AWSPowerShell\Cmdlets\Lambda\AWS.Tools.Lambda.csproj
# ...中略...
#
# Build succeeded.
#     0 Warning(s)
#     0 Error(s)
#
# Time Elapsed 00:00:01.81
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;テストは PowerShell で Cmdlet に対して行う Pester のやつがあるのみで、かつこれらの内容を見てると当然のごとく AWS リソースがある前提。なので、多分個人では金がかかってできないやつ。デプロイ用の CFn とかもないし。
PR のワークフローで対処してんのかなー。&lt;/p&gt;&lt;p&gt;想定以上に時間がかかったけど、とりあえずなんか修正したいときに手元でビルドするための知識は貯まった。
フルビルドで改行コードが書き換わってしまう、サービス単体のビルドに必要な最小限の依存関係を理解する、辺りが宿題かな。&lt;/p&gt;</description><pubDate>Sat, 30 Jul 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-07-23-glue-tagging-cmdlet-not-used-by-anyone-in-the-world</guid><link>https://krymtkts.github.io/posts/2022-07-23-glue-tagging-cmdlet-not-used-by-anyone-in-the-world</link><title>世界中の誰にも使われていない？ Glue のタグ付け Cmdlet</title><description>&lt;p&gt;現職にて AWS のコストを可視化すべく、既存の AWS リソースにひたすらコスト配分タグを付与していく作業をしている(勝手に)。
Cost Explorer を眺めてコストのかかり具合を見るのは、 AWS の醍醐味というか楽しみだと思ってるのだけど、あんまり共感を得られたことがない。&lt;/p&gt;&lt;p&gt;タグ付けには&lt;a href="https://docs.aws.amazon.com/ARG/latest/userguide/tag-editor.html"&gt;タグエディタ&lt;/a&gt;を使ってしまっても良いのだけど、折角なので、何を実行したかを形に残せしたい。
そこで &lt;a href="https://aws.amazon.com/powershell/"&gt;AWS Tools for PowerShell&lt;/a&gt; でやってる&lt;sup id="fnref-1"&gt;&lt;a class="footnote-ref" href="#fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt;のだけど、とあるサービスだけなんか他のサービスのタグ付け Cmdlet は作法が違ってた。&lt;/p&gt;&lt;p&gt;Glue 君のことね。 &lt;a href="https://docs.aws.amazon.com/powershell/latest/reference/items/Add-GLUEResourceTag.html"&gt;Glue: Add-GLUEResourceTag Cmdlet | AWS Tools for PowerShell&lt;/a&gt;&lt;/p&gt;&lt;p&gt;この御方なんか知らんけど &lt;code&gt;Tag[]&lt;/code&gt; じゃなくて &lt;code&gt;hashtable&lt;/code&gt; を受けつける。コレまた当然のごとく Reference にはサンプルコード載ってないので、念のためググるかーと思いググったところ...&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2022-07-23-capture/aws-tools-for-pwsh.png" alt="9 件しかヒットしない Add-GLUEResourceTag" /&gt;&lt;/p&gt;&lt;p&gt;9 件しかヒットしなかった(2022-07-22 時点)。マジで？
世界中で誰も使ってないのか、はたまたショボ過ぎて誰も記事にしないのか。&lt;/p&gt;&lt;p&gt;因みに使い方には困ることもなく、実行した結果も期待通り、ちゃんとタグが付いてた。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$AccountId = Get-STSCallerIdentity | Select-Object -ExpandProperty Account
$Region = Get-DefaultAWSRegion | Select-Object -ExpandProperty Region
$Tag = @{
    'service' = 'my-service'
    'stage' = 'dev'
    'cost' = 'my-service-dev'
}
Get-GLUECrawlerList | ForEach-Object {
    # Glue Crawler の ARN が `Get-GLUECrawler` から持ってこれなくて、みすぼらしく手で組んでる。
    Add-GLUEResourceTag -ResourceArn "arn:aws:glue:${Region}:${AccountId}:crawler/$($_.Name)" -TagsToAdd $Tag
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href="https://aws.amazon.com/jp/about-aws/whats-new/2019/03/aws-glue-now-supports-resource-tagging/"&gt;AWS Glue でリソースタグがサポートされて 3 年ばかり経ってる&lt;/a&gt;けどみんな使ってないのかなーとか、他にも使われてない Cmdlet があるんやろなーと、思いを馳せた。&lt;/p&gt;&lt;p&gt;AWS CLI の方はというと &lt;code&gt;"aws glue tag-resource"&lt;/code&gt; で 3 件しかヒットしなかった。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2022-07-23-capture/aws-cli.png" alt="3 件しかヒットしない &amp;quot;aws glue tag-resource&amp;quot;" /&gt;&lt;/p&gt;&lt;p&gt;しかしながらヒットした記事は実行例が分かるものになってて、こう...なんか AWS Tools for PowerShell の人気の無さが際立つなーと感じた。&lt;/p&gt;&lt;h3 id="他を見る"&gt;他を見る&lt;/h3&gt;&lt;p&gt;雑だが、 AWS Tools for PowerShell のリソースタグ関連の Cmdlet で、タグのパラメータの型が何か調べるスクリプトを書いた。 CRUD 全部の Cmdlet が含まれるのであまり正確ではない。&lt;/p&gt;&lt;p&gt;わたしは AWS Tools for PowerShell の特定のモジュールしか入れてないから全体はわからんけど、傾向は見られる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# AWS.Tools.* modules must be imported first to get all property information.
Get-Module -Name *AWS* | Import-Module
Get-Command *Tag* | Where-Object -Property Source -Like '*aws*' | ForEach-Object {
    [pscustomobject]@{
        Name = $_.Name
        TagParameterType = $_.Parameters.Values | Where-Object -Property Name -Like '*tag*' | Select-Object -ExpandProperty ParameterType
    }
} | Where-Object -Property TagParameterType -NE $Null | Group-Object TagParameterType

# Count Name
# ----- ----
#    31 System.String[]
#     8 Amazon.IdentityManagement.Model.Tag[]
#     4 System.Collections.Hashtable
#     3 {System.String[], System.String[]}
#     3 Amazon.CodeDeploy.Model.Tag[]
#     3 System.String
#     2 Amazon.OpenSearchService.Model.Tag[]
#     2 Amazon.AutoScaling.Model.Tag[]
#     2 Amazon.EC2.Model.Tag[]
#     2 Amazon.S3.Model.Tag[]
#     2 Amazon.Redshift.Model.Tag[]
#     2 Amazon.CertificateManager.Model.Tag[]
#     1 Amazon.ECS.Model.Tag[]
#     1 Amazon.CloudWatch.Model.Tag[]
#     1 Amazon.SimpleNotificationService.Model.Tag[]
#     1 Amazon.StepFunctions.Model.Tag[]
#     1 Amazon.SecretsManager.Model.Tag[]
#     1 Amazon.ECR.Model.Tag[]
#     1 Amazon.RDS.Model.Tag[]
#     1 Amazon.KeyManagementService.Model.Tag[]
#     1 Amazon.KinesisFirehose.Model.Tag[]
#     1 Amazon.DynamoDBv2.Model.Tag[]
#     1 Amazon.ECR.ImageTagMutability
#     1 Amazon.ElasticLoadBalancingV2.Model.Tag[]
#     1 Amazon.ElastiCache.Model.Tag[]
#     1 Amazon.QuickSight.Model.Tag[]
#     1 Amazon.EventBridge.Model.Tag[]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;*.Tag[]&lt;/code&gt; が多数派かなーと。 &lt;code&gt;31 System.String[]&lt;/code&gt; これは多分削除とか取得かな。
ただしこいつら &lt;code&gt;*.Tag[]&lt;/code&gt; グループの中でも、 プロパティが &lt;code&gt;Key&lt;/code&gt; だったり &lt;code&gt;TagKey&lt;/code&gt; だったりの派閥があるので、ほんま「みんな違ってみんないい」的状態。&lt;/p&gt;&lt;p&gt;おわり。&lt;/p&gt;&lt;div class="footnotes"&gt;&lt;hr /&gt;&lt;ol&gt;&lt;li id="fn-1"&gt;&lt;p&gt;既存リソースは IaC じゃないので、コマンドでタグ付けするため。&lt;/p&gt;&lt;a href="#fnref-1" class="footnote-backref"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description><pubDate>Sat, 23 Jul 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-07-16-aws-cdk-with-fsharp-pt2</guid><link>https://krymtkts.github.io/posts/2022-07-16-aws-cdk-with-fsharp-pt2</link><title>F# の AWS CDK で EventPattern の記述を無理やり通す</title><description>&lt;p&gt;&lt;a href="/posts/2022-07-03-aws-cdk-with-fsharp"&gt;前&lt;/a&gt;に書いた、 F# の AWS CDK で EventRule のパターンが正しいのにエラーとなるやつ。&lt;/p&gt;&lt;p&gt;こういうのをしたいところ、&lt;/p&gt;&lt;pre&gt;&lt;code class="yaml"&gt;EventPattern:
  source:
    - aws.s3
  detail-type:
    - Object Created
  detail:
    bucket:
      name:
        - Ref: バケツ
    object:
      key:
        - prefix: test/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以下の記述だとエラーになる。&lt;/p&gt;&lt;pre&gt;&lt;code class="fsharp"&gt;EventPattern =
    EventPattern(
        Source = [| "aws.s3" |],
        DetailType = [| "Object Created" |],
        Detail =
            dict [ ("bucket", dict [ ("name", [| bucket.BucketName |]) ])
                    ("object", dict [ ("key", [| dict [ ("prefix", "test/") ] |]) ]) ]
    )
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;Unhandled exception. System.ArgumentException: Could not infer JSII type for .NET type 'IDictionary`2' (Parameter 'type')
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;この Issue っぽい。
&lt;a href="https://github.com/aws/jsii/issues/1044"&gt;DotNet: Unable to pass interface instance through in a Dictionary&amp;lt;string, object&amp;gt; · Issue #1044 · aws/jsii&lt;/a&gt;&lt;/p&gt;&lt;p&gt;けど、 &lt;code&gt;IDictionary&amp;lt;string,obj&amp;gt;&lt;/code&gt; は使えてる部分もあって微妙に違うしなー。
より詳細な型がここ(&lt;code&gt;EventPattern&lt;/code&gt;)にはないし、どないすりゃいいんじゃ。&lt;/p&gt;&lt;p&gt;色々とこねくり回した末に、 CFn のリソースを直接上書きすることで回避できるのがわかった。
&lt;a href="https://docs.aws.amazon.com/cdk/v2/guide/cfn_layer.html#cfn_layer_raw"&gt;Escape hatches - AWS Cloud Development Kit (CDK) v2&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/aws-cdk-fsharp-trial"&gt;krymtkts/aws-cdk-fsharp-trial&lt;/a&gt; からコードを抜粋する。&lt;/p&gt;&lt;p&gt;配列内に &lt;code&gt;IDictionary&amp;lt;string,obj&amp;gt;&lt;/code&gt; がいると型が解決できなようだったので、空の配列で定義しておき、後でから &lt;code&gt;IDictionary&amp;lt;string,obj&amp;gt;&lt;/code&gt; 要素を差し込む！野蛮過ぎる...&lt;/p&gt;&lt;pre&gt;&lt;code class="fsharp"&gt;    let rule =
        Rule(
            this,
            "bucket-event",
            RuleProps(
                RuleName = "buckt-event",
                Description = "bucket event.",
                EventPattern =
                    EventPattern(
                        Source = [| "aws.s3" |],
                        DetailType = [| "Object Created" |],
                        // NOTE: cannot write like below because JSII is unable to use `IDictionary&amp;lt;string, object&amp;gt;` inside the array.
                        // Detail =
                        //     dict [ ("bucket", dict [ ("name", [| bucket.BucketName |]) ])
                        //            ("object", dict [ ("key", [| dict [ ("prefix", "test/") ] |]) ]) ]
                        Detail =
                            dict [ ("bucket", dict [ ("name", [| bucket.BucketName |]) ])
                                   ("object", dict [ ("key", [||]) ]) ]
                    )
            )
        )

    // NOTE: the escape hatch for IDictionary&amp;lt;string, object&amp;gt;` inside the array is raw overrides.
    do
        match rule.Node.DefaultChild with
        | :? CfnRule as ep -&amp;gt; ep.AddPropertyOverride("EventPattern.detail.object.key.0", dict [ "prefix", "test/" ])
        | _ -&amp;gt; failwith "You passed a wrong variable that is not of type CfnRule!"

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;cdk synth&lt;/code&gt; でエラーせずに、以下の出力が得られるようになった。&lt;/p&gt;&lt;pre&gt;&lt;code class="yaml"&gt;bucketeventF2FCD38A:
  Type: AWS::Events::Rule
  Properties:
    Description: bucket event.
    EventPattern:
      detail:
        bucket:
          name:
            - Ref: sourcebucketE323AAE3
        object:
          key:
            - prefix: test/
      detail-type:
        - Object Created
      source:
        - aws.s3
    Name: buckt-event
    State: ENABLED
    Targets:
      - Arn:
          Fn::GetAtt:
            - samplefunctionAA39FD5B
            - Arn
        Id: Target0
  Metadata:
    aws:cdk:path: AwsCdkFsharpStack/bucket-event/Resource
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;宣言的に書きたいのにこんなツギハギが要るとか、めちゃくちゃ不便極まりない。&lt;/p&gt;&lt;p&gt;これは F# のせいじゃないけど、この .NET の不便な側面を許容してまで F# で CDK したいかというと、まずないな...と思った。これに関連して AWS CDK の Issue をちょいちょい調べたが、 .NET や Java で CDK するの辛そうやな..とうっすら思えた。茨の道を突き進むなりの良さがあるのだろうか。&lt;/p&gt;&lt;p&gt;改めて、仕事は素直に TypeScript を採用して良かったと実感した。&lt;/p&gt;</description><pubDate>Sat, 16 Jul 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-07-09-tips-for-sending-http-requests-pwsh</guid><link>https://krymtkts.github.io/posts/2022-07-09-tips-for-sending-http-requests-pwsh</link><title>PowerShell で大量の HTTP リクエストを送る場合の Tips</title><description>&lt;p&gt;大量のアクセスログがほしい事情で、テスト環境に大量のリクエストを送りつける必要があった。&lt;/p&gt;&lt;p&gt;JMeter とか Gatling 使えば済む話なのだけど、すぐに使い回せるものがなかったし、パパっとやってしまいたかったので PowerShell を使ってみたら、エラーになった。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$requests = 'aaa=10&amp;amp;bbb=20', 'aaa=11&amp;amp;bbb=21', 'aaa=12&amp;amp;bbb=22'
$requests * 100000 | ForEach-Object -Parallel {
    Invoke-WebRequest -Method Get -Uri "https://$using:testDomaain?$_"
    $jitter = Get-Random -Minimum 3 -Maximum 23
    Start-Sleep -Milliseconds (95 + $jitter) # 待ち
} -ThrottleLimit 100 | ConvertTo-Json | Set-Content ./responses.json
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;こういうのでタコ殴りにすると...&lt;/p&gt;&lt;p&gt;&lt;code&gt;Only one usage of each socket address (protocol/network address/port) is normally permitted&lt;/code&gt;&lt;/p&gt;&lt;p&gt;15000 件を超えた辺りでこうなった。なんだ？ググる。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://social.msdn.microsoft.com/Forums/aspnet/en-US/ab5e4f6d-e96a-4bef-bba2-870eda412ea3/systemnetsocketssocketexception-only-one-usage-of-each-socket-address-protocolnetwork?forum=AzureFunctions"&gt;System.Net.Sockets.SocketException: Only one usage of each socket address (protocol/network address/port) is normally permitted&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;ポートが枯渇するんだと。 PowerShell の実装を見た訳じゃないけど、 大量に実行された &lt;code&gt;Invoke-WebRequest&lt;/code&gt; で &lt;code&gt;HttpClient&lt;/code&gt; を大量作成したのであろうことは、想像するに易い。&lt;/p&gt;&lt;p&gt;同じ &lt;code&gt;HttpClient&lt;/code&gt; を使い回せば良いらしいので、そうした。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$requests = 'aaa=10&amp;amp;bbb=20', 'aaa=11&amp;amp;bbb=21', 'aaa=12&amp;amp;bbb=22'
$h = New-Object System.Net.Http.HttpClient
$requests * 100000 | ForEach-Object -Parallel {
    ($using:h).GetAsync("https://$using:testDomaain?$_").GetAwaiter()
    $jitter = Get-Random -Minimum 3 -Maximum 23
    Start-Sleep -Milliseconds (95 + $jitter) # 待ち
} -ThrottleLimit 100 | ForEach-Object {$_.GetResult()} | ConvertTo-Json | Set-Content ./responses.json
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;そんだけ。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;参照
&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/Azure/azure-functions-host/issues/1806"&gt;Need Official Guidance On using HttpClient in Functions · Issue #1806 · Azure/azure-functions-host&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://blog.ironmansoftware.com/powershell-async-method/"&gt;Calling Async .NET Methods from PowerShell&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</description><pubDate>Sat, 09 Jul 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-07-03-aws-cdk-with-fsharp</guid><link>https://krymtkts.github.io/posts/2022-07-03-aws-cdk-with-fsharp</link><title>F# で AWS CDK して躓いてる</title><description>&lt;p&gt;最近仕事で AWS CDK を使ってみたが、非常に良い感触だった。
仕事では TypeScript を採用したが、テンプレートが提供されている言語を見るとなんと F# がいるではないか。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; cdk init --list
Available templates:
* app: Template for a CDK Application
   └─ cdk init app --language=[csharp|fsharp|go|java|javascript|python|typescript]
* lib: Template for a CDK Construct Library
   └─ cdk init lib --language=typescript
* sample-app: Example CDK Application with some constructs
   └─ cdk init sample-app --language=[csharp|fsharp|go|java|javascript|python|typescript]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;単に「C# のクラス用意したから継承して使ってや～」的なもので F# 向けに調整されてないだろうが、コレ誰が使うねんという気がしたので、試してみた。&lt;/p&gt;&lt;p&gt;参考にした前例たち。非常に参考にさせてもらった。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://awsmaniac.com/functional-programming-with-aws-cdk/"&gt;Functional Programming with AWS CDK | AWS Maniac&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://cloudgnosis.org/fsharp/fsharp-for-the-cloud-worker/part5.html"&gt;Part 5 - AWS Cloud Development Kit (CDK) — Cloudgnosis collection 0.1 documentation&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr /&gt;&lt;p&gt;まずテンプレからプロジェクトを生成した素の状態で CFn を作成してみる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;cdk init sample-app --language=fsharp
cdk synth
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ちゃんと CFn をビルドできた。 どんなコードが出るか知りたかったので &lt;code&gt;sample-app&lt;/code&gt; を使ったが、ここで &lt;code&gt;app&lt;/code&gt; テンプレを使うと、利用されない &lt;code&gt;this&lt;/code&gt; が残ってるので警告が出る。でも勿論 CFn をビルドできる。&lt;/p&gt;&lt;p&gt;記述に関しては TypeScript など他の言語と大差なさそう。ただ予想通り C# との相互運用は前提になってる。
宣言的に記述する箇所については &lt;code&gt;let&lt;/code&gt; バインディングして、 リソースに手続き的に何かすると &lt;code&gt;do&lt;/code&gt; バインディングみたい。&lt;/p&gt;&lt;p&gt;試しに S3 と Lambda を EventBridge で繋いでみたい。&lt;/p&gt;&lt;p&gt;F# の CDK では &lt;code&gt;Amazon.CDK&lt;/code&gt; に必要な Construct が全部入りしてるみたい。なので &lt;code&gt;Amazon.CDK.xxx&lt;/code&gt; みたいな感じでポチポチ &lt;code&gt;.&lt;/code&gt; を刻んでいけば、ドキュメントがなくてもそれなりに探せる。&lt;/p&gt;&lt;p&gt;F# は言語固有モジュールが無いので、ここに例えば Lambda を足すとすると、個別にビルドする感じになる。あれめちゃくちゃ楽で好きなんやけど、 .Net 向けにはない。
プロジェクトを別途足す方向で作るらしい。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# テンプレなかったので探してインストール
dotnet new lambda.EmptyFunction --search
dotnet new --install Amazon.Lambda.Templates

dotnet new lambda.S3 --output . --name api --language "F#"

cd src
dotnet sln add api
&lt;/code&gt;&lt;/pre&gt;&lt;hr /&gt;&lt;p&gt;stack をザーッと書いてみたが、めちゃくちゃつまづきどころがある。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;open System.Collections&lt;/code&gt; したら &lt;code&gt;Stack&lt;/code&gt; が競合するので注意&lt;/li&gt;&lt;li&gt;&lt;code&gt;MemorySize&lt;/code&gt;に&lt;code&gt;128&lt;/code&gt; を渡してたら Ionide や &lt;code&gt;dotnet build&lt;/code&gt; ではエラー検知できなかったが、 &lt;code&gt;cdk synth&lt;/code&gt; でエラー(めんどくせ)
&lt;ul&gt;&lt;li&gt;&lt;code&gt;MemorySize&lt;/code&gt;を&lt;code&gt;128&lt;/code&gt;から&lt;code&gt;(Some 128.0 |&amp;gt; Option.toNullable)&lt;/code&gt;に&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;必須プロパティがビルドまでわからないのつらい&lt;/li&gt;&lt;li&gt;&lt;code&gt;EventPattern&lt;/code&gt; の &lt;code&gt;IDictionary&amp;lt;string,obj&amp;gt;&lt;/code&gt;を一息で書くのかなりキツイ(まじでめんどい)
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Value&lt;/code&gt; の型が揃わないところは個別に &lt;code&gt;let&lt;/code&gt; してあとで組み合わせたり&lt;/li&gt;&lt;li&gt;&lt;code&gt;dict&lt;/code&gt; に食わせる &lt;code&gt;tuple&lt;/code&gt; はきっちりカッコで囲むと先述の &lt;code&gt;let&lt;/code&gt; が不要になった&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;EventPattern&lt;/code&gt; の &lt;code&gt;Detail&lt;/code&gt; が &lt;code&gt;cdk synth&lt;/code&gt; でエラーになる&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Prefix のパターンをやりたいのだけど、 &lt;a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-patterns-content-based-filtering.html#eb-filtering-prefix-matching"&gt;Content filtering in Amazon EventBridge event patterns - Amazon EventBridge&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="yaml"&gt;EventPattern:
  source:
    - aws.s3
  detail-type:
    - Object Created
  detail:
    bucket:
      name:
        - Ref: バケツ
    object:
      key:
        - prefix: test/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以下の記述だとエラーになる。&lt;/p&gt;&lt;pre&gt;&lt;code class="fsharp"&gt;EventPattern =
    EventPattern(
        Source = [| "aws.s3" |],
        DetailType = [| "Object Created" |],
        Detail =
            dict [ ("bucket", dict [ ("name", [| bucket.BucketName |]) ])
                    ("object", dict [ ("key", [| dict [ ("prefix", "test/") ] |]) ]) ]
    )
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;Unhandled exception. System.ArgumentException: Could not infer JSII type for .NET type 'IDictionary`2' (Parameter 'type')
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;dict [ ("prefix", "test/") ]&lt;/code&gt; の代わりに文字列を渡してると問題なくなるけど、それってスキーマ違反なんですけど。
この辺 TypeScript は困った記憶ないので、参ったなという感じ。&lt;/p&gt;&lt;p&gt;この辺の回答が出たら割りと参考になるかもなーと思って見ている。&lt;a href="https://github.com/aws/aws-cdk/discussions/20894"&gt;How to set detail on an eventpattern in java · Discussion #20894 · aws/aws-cdk&lt;/a&gt;
単純に F# 力の低さに起因して記述できないだけだといいけど。&lt;/p&gt;&lt;p&gt;もうちょっと深掘したいが今週はここまで。
とりあえず repo は作った。 &lt;a href="https://github.com/krymtkts/aws-cdk-fsharp-trial"&gt;krymtkts/aws-cdk-fsharp-trial&lt;/a&gt;&lt;/p&gt;</description><pubDate>Sun, 03 Jul 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-06-26-writing-cmdlet-in-fsharp-pt3</guid><link>https://krymtkts.github.io/posts/2022-06-26-writing-cmdlet-in-fsharp-pt3</link><title>F#でコマンドレットを書いてる pt.3</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。&lt;/p&gt;&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.powershell?view=powershellsdk-7.0.0"&gt;PowerShell Class&lt;/a&gt; を使って、現在の runspace を引き継がせるとかはちょっとわかりまして、 (F# というか .NET)の世界で PowerShell の表示文字列を取り回すには PowerShell Class を使い最後に &lt;code&gt;Out-String&lt;/code&gt; した結果を取り回すのが典型っぽいのはわかった。&lt;/p&gt;&lt;p&gt;ただやっぱり PowerShell の力を借りない方法を諦めきれずにいた。
また今後プロパティ指定での検索を実装していったときに、指定したプロパティはなんか色付けするとかしようとしたらこっちの方が絶対やりやすいだろうというのを感じてたので、&lt;a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/composite-formatting"&gt;Composite formatting&lt;/a&gt; を使ってどうにかできないものか考えていた。&lt;/p&gt;&lt;p&gt;が、結論としては PowerShell の力を借りるのが良いのでは～...というところまできた。&lt;/p&gt;&lt;p&gt;結局のところ &lt;code&gt;format.ps1xml&lt;/code&gt; に従って PowerShell で表示が制御されるので、 F# の中で &lt;code&gt;PSObject.Properties&lt;/code&gt; を見たとてどいつを優先表示したらいいかわからん。またこの &lt;code&gt;Properties&lt;/code&gt; から表示するテーブルを作るのは &lt;code&gt;hashtable&lt;/code&gt; や &lt;code&gt;array&lt;/code&gt; が引数の場合には適応したくないし、となると型でパターンマッチして～となる。
考えるとここにこだわるのはもっとプロパティでの絞り込みとかの他の機能を実装したあとでいいかなーという気になってきた。&lt;/p&gt;&lt;p&gt;&lt;code&gt;format.ps1xml&lt;/code&gt; もそうだけど PowerShell 内部実装に対する基礎知識(&lt;code&gt;PSPropertyInfo&lt;/code&gt;とかまじで情報ない)がやっぱ圧倒的に不足してるから、蓄積されるまでは黙って PowerShell に従うが良いかと考えを改めた。
であれば、もう PowerShell Class を使う方向に倒して、検索中のプロパティを &lt;code&gt;Format-Table&lt;/code&gt; の &lt;code&gt;-Properties&lt;/code&gt; で表示するようにしようかな、という選択肢もありかなと。&lt;/p&gt;&lt;p&gt;いったんこの形で検索中の表示を進めれば、他に組み込んでおきたい機能、例えばプロパティ指定の検索とかに取りかかれる。
週末の 1,2 時間が主な開発時間なので、亀な進捗の中でも実装を進められる判断が必要かなー。それもまた一興。&lt;/p&gt;</description><pubDate>Sun, 26 Jun 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-06-19-belatedly-parallel-foreach-object</guid><link>https://krymtkts.github.io/posts/2022-06-19-belatedly-parallel-foreach-object</link><title>今更 ForEach-Object -Parallel</title><description>&lt;p&gt;今更だが、直列だと長時間かかる処理を分散させるために &lt;code&gt;ForEach-Object -Parallel&lt;/code&gt; を使う必要があった。
困ったというほどでもないけど、真面目に使ったことなかったので、今回学んだ気をつけポイントをまとめる。
(毎度の如く PowerShell でそれをやる必要は全くなかったが、ぱっと手を動かしたくてついやってしまった)&lt;/p&gt;&lt;ul&gt;&lt;li&gt;参照
&lt;ul&gt;&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/powershell/powershell-foreach-object-parallel-feature/"&gt;PowerShell ForEach-Object Parallel Feature - PowerShell Team&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/powershell/module/psworkflow/about/about_foreach-parallel?view=powershell-5.1"&gt;about Foreach-Parallel - PowerShell | Microsoft Docs&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/61273189/how-to-pass-a-custom-function-inside-a-foreach-object-parallel/61273544#61273544"&gt;powershell - How to pass a custom function inside a ForEach-Object -Parallel - Stack Overflow&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr /&gt;&lt;h3 id="並列数の制御"&gt;並列数の制御&lt;/h3&gt;&lt;p&gt;&lt;code&gt;-Parallel&lt;/code&gt; はとにかく遅い。異なる runspace が作成されそこで実行されるからだ。
なのでとにかく計算時間がかかるんやというような処理だけ渡すようにした方がいい。&lt;/p&gt;&lt;p&gt;今回は、あらかじめ &lt;code&gt;ThrottleLimit&lt;/code&gt; と同じ数の &lt;code&gt;InputObject&lt;/code&gt; に調整して重いコマンドを打つ方針を使った。
消えては立ち上がり x2 するような書き方をした方ではやはり runspace 作成のオーバーヘッドが、処理時間という形で顕著に見られた。
スクリプトブロックが消えては立ち上がり x2 しないように、スクリプトブロック内で重い 1 処理を実行する方が良かった(AWS のリソースを一括操作するやつだからできたことだけど)。&lt;/p&gt;&lt;p&gt;1 ヵ月分のデータを加工する必要があって、対象日毎に 1 処理にすることができたので、それを約 30 並列でやった。
イメージ ↓&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$begin = (Get-Date -Day 1 -Hour 0 -Minute 0 -Second 0 -Millisecond 0)
$end = $begin.AddMonths(1).AddDays(-1)
$dateRange = @()
while ($begin -le $end) {
    $dateRange += $begin
    $begin = $begin.AddDays(1)
}
$dateRange | ForEach-Object -ThrottleLimit $dateRange.Length -Parallel {
    # 長時間かかる処理.
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="スクリプトブロック外のリソース参照"&gt;スクリプトブロック外のリソース参照&lt;/h3&gt;&lt;p&gt;&lt;code&gt;$using:&lt;/code&gt; 修飾子をつけたら変数を参照できる。
ただしスクリプトブロックや関数には使えない。&lt;/p&gt;&lt;p&gt;関数をどうしても使いまわしたいときは、文字列に変換した上で取り込む技もある。 &lt;a href="https://stackoverflow.com/questions/61273189/how-to-pass-a-custom-function-inside-a-foreach-object-parallel/61273544#61273544"&gt;powershell - How to pass a custom function inside a ForEach-Object -Parallel - Stack Overflow&lt;/a&gt;&lt;/p&gt;&lt;p&gt;が、スクリプトブロック内でしか使わないのであればその中に関数を定義してしまったほうが楽か。
&lt;a href="https://devblogs.microsoft.com/powershell/powershell-foreach-object-parallel-feature/#comment-171"&gt;最もクリーンな方法でオススメらしいし&lt;/a&gt;、実際にそうした。&lt;/p&gt;&lt;p&gt;(&lt;code&gt;Import-Module&lt;/code&gt; すればいいのだけどいちいちモジュールを作らないこともあろう)&lt;/p&gt;&lt;p&gt;技を使うとこうなる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function Get-Identity {
    param (
        [Parameter(Mandatory,
            Position = 0,
            ValueFromPipeline
        )]
        [PSObject]
        $Value
    )
    process {
        $Value
    }
}

$funcDef = ${function:Get-Identity}.ToString()

function Test-UsingFuncInParallel {
    [CmdletBinding()]
    param ()

    1..30 | ForEach-Object -Parallel {
        ${function:Get-Identity} = $using:funcDef
        $_ | Get-Identity | Write-Host
    } -ThrottleLimit 30
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;技を使わない版。当然ながらスクリプトブロックは間延びする。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function Test-UsingFuncInParallel {
    [CmdletBinding()]
    param ()

    1..30 | ForEach-Object -Parallel {
        function Get-Identity {
            param (
                [Parameter(Mandatory,
                    Position = 0,
                    ValueFromPipeline
                )]
                [PSObject]
                $Value
            )
            process {
                $Value
            }
        }

        $_ | Get-Identity | Write-Host
    } -ThrottleLimit 30
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使う関数が多いとスクリプトブロックも伸びがちなので、使い分けを検討した方が良かろう。
用途次第だが、わたしの場合は先述の通り並列数 MAX ピッタリに調整した &lt;code&gt;InputObject&lt;/code&gt; を使て長時間の処理を流すだろうから、 runspace の作成のコストはそれほど気にならない。スクリプトブロックの中がごちゃごちゃしないことのメリットがあるかも知れん。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;あと微妙にハマったのが &lt;code&gt;$PSCmdlet&lt;/code&gt; の参照。&lt;/p&gt;&lt;p&gt;&lt;code&gt;$using:&lt;/code&gt; つけ忘れてると単に &lt;code&gt;$null&lt;/code&gt; なだけなのでエラーメッセージ見てもピンときにくい。&lt;/p&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;Line |
   2 |          if ($PSCmdlet.ShouldProcess($_, 'Write-Host')) {
     |              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     | You cannot call a method on a null-valued expression.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;さらに関数の呼び出し時はカッコで囲む必要がある。カッコがないと Parse Error。&lt;/p&gt;&lt;pre&gt;&lt;code class="diff"&gt; function Test-ShouldProcessInParallel {
     [CmdletBinding(SupportsShouldProcess)]
     param ()

     1..30 | ForEach-Object -Parallel {
-        if ($using:PSCmdlet.ShouldProcess($_, 'Write-Host')) {
+        if (($using:PSCmdlet).ShouldProcess($_, 'Write-Host')) {
             $_ | Write-Host
         }
     } -ThrottleLimit 30
 }
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;ParserError:
Line |
   6 |          if ($using:PSCmdlet.ShouldProcess($_, 'Write-Host')) {
     |              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     | Expression is not allowed in a Using expression.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;あとなんか見慣れぬエラーになる時があったが忘れた。再現できたら追記したい。&lt;/p&gt;</description><pubDate>Sun, 19 Jun 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-06-12-writing-cmdlet-in-fsharp-pt2</guid><link>https://krymtkts.github.io/posts/2022-06-12-writing-cmdlet-in-fsharp-pt2</link><title>F#でコマンドレットを書いてる pt.2</title><description>&lt;p&gt;&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt; の話。&lt;/p&gt;&lt;p&gt;平日仕事の方ばっかりやってるので亀な進捗だ。
ひとまず&lt;a href="/posts/2022-06-05-whitespace-comparison-in-pwsh"&gt;&lt;code&gt;System.Management.Automation.WildcardPattern&lt;/code&gt; の使い方がわかった&lt;/a&gt; のを皮切りに、 &lt;code&gt;-like&lt;/code&gt;,&lt;code&gt;-match&lt;/code&gt;,&lt;code&gt;-eq&lt;/code&gt; あたりのフィルタを実装した。&lt;/p&gt;&lt;p&gt;あとプロパティを指定しての絞り込みとかを実装してないが、これは &lt;code&gt;PSObject&lt;/code&gt; から目当てのプロパティを拾ってマッチするだけなので、多分むずくないだろう。&lt;/p&gt;&lt;p&gt;いま一番頭を悩ませている課題は、絞り込みを確定するまでの間印字する内容についてだ。
やはり PowerShell でインタラクティブなフィルタリングをするのであれば、印字する内容も PowerShell の &lt;code&gt;Format-Table&lt;/code&gt; ライクな印字をしたい。
例えば &lt;a href="https://github.com/devblackops/Terminal-Icons"&gt;Terminal-Icons&lt;/a&gt; を使っていたら、カラフルな &lt;code&gt;Get-ChildItem&lt;/code&gt; の結果のママ絞り込みしたい。ただそのやり方がさっぱり分からない。&lt;/p&gt;&lt;p&gt;全くわからんなりに、とりあえず F# 内から PowerShell を実行する練習として、 &lt;code&gt;PowerShell.Create&lt;/code&gt; でコマンドレットを動かしてみただけというコードは動かしてみた。&lt;/p&gt;&lt;pre&gt;&lt;code class="fsharp"&gt;[&amp;lt;Cmdlet(VerbsDiagnostic.Test, "Pocof")&amp;gt;]
[&amp;lt;OutputType(typeof&amp;lt;PSObject&amp;gt;)&amp;gt;]
type TestPocofCommand() =
    inherit PSCmdlet()

    override __.EndProcessing() =
        __.WriteObject
        &amp;lt;| PowerShell
            .Create()
            .AddCommand("Get-ChildItem")
            .AddCommand("Format-Table")
            .Invoke() // まじで意味ない
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;このへんまだ調査不足のため、以下に記すのはメモ書きレベル。つか &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.powershell?view=powershellsdk-7.0.0"&gt;PowerShell Class&lt;/a&gt; だけでなく PowerShell SDK のドキュメントむずくない？
全体的に読んでてもよくわからん(愚痴)。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;これをやろうとしたら &lt;a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_format.ps1xml?view=powershell-7.2"&gt;Format.ps1xml&lt;/a&gt; が反映された状態の文字列を F# 内で作らないといけないが、 F# 内で &lt;code&gt;PowerShell.Create&lt;/code&gt; したとてセッションの引き継ぎができるのかがわからん
&lt;ul&gt;&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.powershell.create?view=powershellsdk-7.0.0#system-management-automation-powershell-create(system-management-automation-runspacemode)"&gt;PowerShell.Create&lt;/a&gt; あたりでどうにかなりそうに見えるけど試せてない&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;PowerShell SDK の中には &lt;code&gt;FormatTableCommand&lt;/code&gt; という名のまさに &lt;code&gt;Format-Table&lt;/code&gt; そのものがあるが、こいつの Input に &lt;code&gt;SelectPocofCommand&lt;/code&gt; からデータを食わす方法がわからん
&lt;ul&gt;&lt;li&gt;これも多分実行時に引数で渡せるようにみえるけど(略) &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.powershell.invoke?view=powershellsdk-7.0.0#system-management-automation-powershell-invoke-1(system-collections-ienumerable)"&gt;PowerShell.Invoke Method&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;これらが想定通りで期待の Output が得られたとて、正直な気持ちは F# 内で PowerShell の実行エンジン作ってまでやりたくないなー(なんか重そう)、もっと簡単に &lt;code&gt;Format-Table&lt;/code&gt; の出力を得る方法はないんかいな、というお気持ち&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;code&gt;System.Management.Automation.WildcardPattern&lt;/code&gt; みたいな外部から見える場所に PowerShell 内部で使ってる機能がいい感じに提供されてたらいいのだけど、そんな感じではなさそう。&lt;/p&gt;&lt;p&gt;見た目に動きのある機能実装ができたときの嬉しさはやっぱひとしおなので、取り組みたい、けどまだ情報＆能力的に不足してるなーというところ。何やるにしても手を動かせるまでに異様に時間がかかる。
ひとまずは調査継続しつつ他の課題潰していくか。&lt;/p&gt;&lt;p&gt;ほんま仕事とは一切接点無くて趣味プロとして最高のテーマになってる。&lt;/p&gt;</description><pubDate>Sun, 12 Jun 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-06-05-whitespace-comparison-in-pwsh</guid><link>https://krymtkts.github.io/posts/2022-06-05-whitespace-comparison-in-pwsh</link><title>PoweShell で半角スペース(U+0020) -eq 全角スペース(U+3000) が True となる</title><description>&lt;p&gt;転職して 3 ヶ月目を迎えた。
入社以降は何の因果か CRM の導入をやることになり、既存データ(スプレッドシート)の以降のために PowerShell を駆使している。&lt;/p&gt;&lt;p&gt;そんな中で今まで知らなかった PowerShell の表情をいくつも知ることができ(例えばコレとか)、なんやかんやで楽しんでいる。&lt;/p&gt;&lt;p&gt;その中で度肝を抜かれたのが、今日のテーマ。&lt;/p&gt;&lt;p&gt;&lt;code&gt;' '&lt;/code&gt;(U+0020) &lt;code&gt;-eq&lt;/code&gt; &lt;code&gt;' '&lt;/code&gt;(U+3000) が &lt;code&gt;True&lt;/code&gt; となる。&lt;/p&gt;&lt;p&gt;PowerShell 7 と Windows PowerShell 5.1 で試した。&lt;/p&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;Name                           Value
----                           -----
PSVersion                      7.2.4
PSEdition                      Core
GitCommitId                    7.2.4
OS                             Microsoft Windows 10.0.22000
Platform                       Win32NT
PSCompatibleVersions           {1.0, 2.0, 3.0, 4.0…}
PSRemotingProtocolVersion      2.3
SerializationVersion           1.1.0.1
WSManStackVersion              3.0
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;Name                           Value
----                           -----
PSVersion                      5.1.22000.653
PSEdition                      Desktop
PSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}
BuildVersion                   10.0.22000.653
CLRVersion                     4.0.30319.42000
WSManStackVersion              3.0
PSRemotingProtocolVersion      2.3
SerializationVersion           1.1.0.1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;7 だと &lt;code&gt;True&lt;/code&gt; 、 5.1 だと &lt;code&gt;False&lt;/code&gt; だ。
&lt;code&gt;-ceq&lt;/code&gt; だと 7 でも &lt;code&gt;False&lt;/code&gt; を返すので &lt;code&gt;-ieq&lt;/code&gt; の判定が違うのだけど、 PowerShell Core からこうなんだろうか？
PowerShell の実装を追ってみたが、追いきれなかった。 めちゃくちゃ&lt;a href="https://github.com/PowerShell/PowerShell/blob/87f621eb1fa94f1d114b0cc4a5fb7aab5d3133c9/src/System.Management.Automation/engine/parser/Compiler.cs#L5804%E3%83%BCL5806"&gt;ココ&lt;/a&gt;っぽいのだけど、 LINQ に由来するクラス &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.expressions.dynamicexpression.dynamic?view=net-6.0#system-linq-expressions-dynamicexpression-dynamic(system-runtime-compilerservices-callsitebinder-system-type-system-linq-expressions-expression-system-linq-expressions-expression)"&gt;DynamicExpression&lt;/a&gt; とかの知識がないのでまだ調査中。&lt;/p&gt;&lt;p&gt;どう説明したらいいか悩むのが、いくつか試してみていてわかってきたのは、 &lt;code&gt;String&lt;/code&gt; の &lt;code&gt;-ieq&lt;/code&gt; でこの事象が見られること。 &lt;code&gt;Char&lt;/code&gt; だと起こらない。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;' ' -ieq '　' # True
([char][int]'0x20') -ieq ([char][int]'0x3000')  # Char だと False
([string][char][int]'0x20') -ieq ([string][char][int]'0x3000') # String だと True
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;そしてもう 1 つ、 Unicode で General category が Separator, space と定義されているものが等値と判定されること。&lt;/p&gt;&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Whitespace_character#Unicode"&gt;Whitespace character - Wikipedia&lt;/a&gt; の表が非常にわかりやすい。ここから以下のテストコードを作成し、先述の事実を導いた。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;'0x0009', '0x000A', '0x000B', '0x000C', '0x000D', '0x0020', '0x0085', '0x00A0', '0x1680', '0x2000', '0x2001', '0x2002', '0x2003', '0x2004', '0x2005', '0x2006', '0x2007', '0x2008', '0x2009', '0x200A', '0x2028', '0x2029', '0x202F', '0x205F', '0x3000' | % { [PSCustomObject]@{
    CodePoint = $_
    isEquals = ([string][char][int]$_) -eq ' '
}}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;CodePoint isEquals
--------- --------
0x0009       False
0x000A       False
0x000B       False
0x000C       False
0x000D       False
0x0020        True
0x0085       False
0x00A0        True
0x1680        True
0x2000        True
0x2001        True
0x2002        True
0x2003        True
0x2004        True
0x2005        True
0x2006        True
0x2007        True
0x2008        True
0x2009        True
0x200A        True
0x2028       False
0x2029       False
0x202F        True
0x205F        True
0x3000        True
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;あーココまで来ると、意図的な挙動 ≒ 仕様というのに当たりがつく。
なので .NET の String クラスの挙動を見てみると...&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;' '.Equals('　', [StringComparison]::CurrentCultureIgnoreCase) # True

'0x0009', '0x000A', '0x000B', '0x000C', '0x000D', '0x0020', '0x0085', '0x00A0', '0x1680', '0x2000', '0x2001', '0x2002', '0x2003', '0x2004', '0x2005', '0x2006', '0x2007', '0x2008', '0x2009', '0x200A', '0x2028', '0x2029', '0x202F', '0x205F', '0x3000' | % { [PSCustomObject]@{
&amp;gt;     CodePoint = $_
&amp;gt;     isEquals = ([string][char][int]$_).Equals(' ', [StringComparison]::CurrentCultureIgnoreCase)
&amp;gt; }}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;CodePoint isEquals
--------- --------
0x0009       False
0x000A       False
0x000B       False
0x000C       False
0x000D       False
0x0020        True
0x0085       False
0x00A0        True
0x1680        True
0x2000        True
0x2001        True
0x2002        True
0x2003        True
0x2004        True
0x2005        True
0x2006        True
0x2007        True
0x2008        True
0x2009        True
0x200A        True
0x2028       False
0x2029       False
0x202F        True
0x205F        True
0x3000        True
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;StringComparison.InvariantCultureIgnoreCase&lt;/code&gt; は同じ結果。 &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; は違う結果となった。&lt;/p&gt;&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.stringcomparison?view=net-6.0"&gt;StringComparison Enum (System) | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;全然知らんかった...また世の中に恥を晒してしまったと共に、1 つ学んだわ。
まだ確かな情報源を得たわけじゃないけど、きっと世の中のﾄﾞｯﾄﾈｯﾀｰにとっては常識なんやろなあ。
手始めに ↓ コレちゃんと読むようにしよう...&lt;/p&gt;&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/best-practices-strings"&gt;Best Practices for Comparing Strings in .NET | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;ちなみにこの調査において、 &lt;code&gt;-like&lt;/code&gt; には &lt;code&gt;System.Management.Automation.WildcardPattern&lt;/code&gt; が使われていて、しかも公開されてるクラスというのがわかった。こんなのがあるの知らなかったわ。&lt;/p&gt;&lt;p&gt;そのまま &lt;a href="https://github.com/krymtkts/pocof#readme"&gt;pocof&lt;/a&gt; のワイルドカード検索で利用することにした。↓ こういう使い方。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;([System.Management.Automation.WildcardPattern]"*ui*").IsMatch('kouiuno')
&lt;/code&gt;&lt;/pre&gt;</description><pubDate>Sun, 05 Jun 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-05-28-writing-cmdlet-in-fsharp</guid><link>https://krymtkts.github.io/posts/2022-05-28-writing-cmdlet-in-fsharp</link><title>F#でコマンドレットを書いてる</title><description>&lt;p&gt;&lt;a href="/posts/2022-05-07-start-to-write-cmdlet-by-fsharp"&gt;以前 F# で PowerShell コマンドレットを書き始めた&lt;/a&gt;と書いた。&lt;/p&gt;&lt;p&gt;ひと月くらいかけて主に休みの日にちょいちょい書き進めてきて、最近最低限動くようになったので public repo にした。
&lt;a href="https://github.com/krymtkts/pocof"&gt;krymtkts/pocof&lt;/a&gt;&lt;/p&gt;&lt;p&gt;まだ激ショボな機能しかない。
プロパティを指定してフィルタリングするとか、フィルタリングした見た目をこれまたテーブルフォーマットにするとか、 PowerShell ならではの良さをまだ全然作り込めてない。&lt;/p&gt;&lt;p&gt;さっぱり作り方がわからん &lt;code&gt;Format-Table&lt;/code&gt; とか &lt;code&gt;-like&lt;/code&gt; とか PowerShell のクラスをそのまま使いたい気分。無理やったら組むねんけど。&lt;/p&gt;&lt;p&gt;&lt;code&gt;ls | pocof&lt;/code&gt; したら Terminal Icons で鮮やかになったままフィルタリングされてほしいのよなー。
この辺が組み込めたら、 PowerShell Gallery で公開したい。&lt;/p&gt;&lt;p&gt;現状正規表現でのフィルタリングくらいしかまともに使えるものがなく亀速な進捗だけど、Cmdlet を書いたり F# で書いたのも初めてだったから、楽しく取り組めた。&lt;/p&gt;&lt;p&gt;前にも書いた通り、これは poco の多言語フォークなんやけど、その動機としては poco の未実装だったり使いにくいところが起因してツール自体をあまり使いこなせてなかったところがある。
自分自身あまりツールの使い込みは得意じゃなくて、なんなら自分流にアレンジできるタイプのツールしか使いこなせない。&lt;/p&gt;&lt;p&gt;DIY キーボードとかまさにその典型例なんやけど、キーバインディングが自分の制御下に置かれた途端ブラインドタッチができるようになったりしたので、何かと自分用に手を加えないといけないんだろう。&lt;/p&gt;&lt;p&gt;でもこれで poco というか pocof は自分の制御下に置いたのでなんか色々試してみたいお気持ち。&lt;/p&gt;&lt;p&gt;F# の書き心地に関しては、まだ慣れない点もあれど結構気に入ってる。 &lt;code&gt;else&lt;/code&gt; は矯正してほしいところやけど。&lt;/p&gt;&lt;p&gt;着手前は試しにコンピュート式書いてみたいなーとか考えてたが、いまんとこ使おうと思えば使えるけど敢えて使うほどでもない感じで、使い所ない。
大したことやってないからパターンマッチや高階関数使ってるだけでもサクサクできる。
.NET 自体かなり久しぶりなこと(PowerShell つかってるけど全然 .NET に踏み込んでない...)と、 .NET と F# の世界の境界がまだ自分の中で曖昧で、そのへんは書きながら学んでいきたいなーという感じ。&lt;/p&gt;&lt;p&gt;何にせよ趣味プロのちょうどいいネタを見つけた。当分はこれで遊ぶ。&lt;/p&gt;</description><pubDate>Sat, 28 May 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-05-22-customize-my-worn-out-705</guid><link>https://krymtkts.github.io/posts/2022-05-22-customize-my-worn-out-705</link><title>使い古しの Logicool M 705 をカスタマイズする</title><description>&lt;p&gt;もう 15 年くらい使っている Logicool の M705 がある。&lt;/p&gt;&lt;h3 id="この-m705-について"&gt;この M705 について&lt;/h3&gt;&lt;p&gt;この M705 は、昔ロジクールに勤めていた友人からもらったものだ。
現行モデルは多分これ → &lt;a href="https://www.logicool.co.jp/ja-jp/products/mice/m705m-wireless-mouse.910-005303.html"&gt;3 年の電池寿命を提供するロジクール M705m マラソン ワイヤレスマウス&lt;/a&gt;&lt;/p&gt;&lt;p&gt;もらってから数年の間はそんなに使ってなかったが、尋常でない電池寿命とハードデューティさに気づき、以降メインとして使っている。&lt;/p&gt;&lt;p&gt;わたしはマウスを「つまみ持ち」する。この M705 はわたしの持ち方に、クリックの押し込みの深さとか、軽く指を曲げた状態での親指と小指の間隔がバッチリハマっていて、同じマウスをずっと使っている。&lt;/p&gt;&lt;p&gt;トラッキングの位置が他のマウスとは結構違っていて、若干操作に癖を感じていたが、そこは慣れだったような記憶がある。&lt;/p&gt;&lt;p&gt;一時期左クリックがチャタリングを起こしたことがあって、数週間別のマウスに乗り換えて使わない時期があったのだが、放置中に直って以降はチャタリングも起こらなくなった(何故)。&lt;/p&gt;&lt;h3 id="異変"&gt;異変&lt;/h3&gt;&lt;p&gt;この M705 だが、グリップ力強化かなんかの理由で、マウスの両サイドがラバーというかやわらかい合成樹脂でできている。
これが利用から 10 年も経った頃から異変を感じるようになった。ボコボコしてきたり擦れるだけでラバーが削れたり。&lt;/p&gt;&lt;p&gt;最近知ったが、これは合成樹脂のブリーディングとかブリードアウトという現象のようだ。合成樹脂の成分自体が分離しだしてるから、拭き取ったりしてどうにかなるものでないということだった。&lt;/p&gt;&lt;p&gt;ここ数年は症状の進行も激しく、指で押すだけで指紋がつくくらいにラバーが劣化していた。&lt;/p&gt;&lt;p&gt;マウスを買い替えることも検討したが、まだメカニカルな部分は動くし、新しいマウスを選ぶのも結構労力がかかるよなーというのが悩みだった。
そこで思い切って、このベタベタボロボロラバーを取り除こうと考えた。&lt;/p&gt;&lt;h3 id="カスタマイズする"&gt;カスタマイズする&lt;/h3&gt;&lt;p&gt;M705 のベタベタボロボロラバーを取り除き、手元にあった黒のテーピングを重ねて貼ることにした。テーピングならラバー部分の形状に合わせることも簡単だし、親指＆小指の接触部分が汚れたとしてもまた貼り直せばいいだけなので、我ながら良いアイデアだ。&lt;/p&gt;&lt;p&gt;ベタボロラバーを取り除くのには、大型刃のカッターナイフと、細かい部分にはデザインナイフを利用した。いずれもオルファだ。&lt;/p&gt;&lt;p&gt;分解してみてわかったが、ラバーのボコボコしていた部分には溶け出した液状の謎成分が溜まっており、中々グロテスクだった。
このマウスはプラスチックの骨格みたいなところにラバーをはめ込み＆貼り付けしてるような構造をしていて、プラスチック部分を極力傷つけないようにした。&lt;/p&gt;&lt;p&gt;小指側のラバーを取り除くのは非常に簡単だった。単にプラウチック部分の弧に合わせてカッターをすべらせるだけでスイスイ剥がせた。&lt;/p&gt;&lt;p&gt;親指側は形状的に窪んでいるので結構難しく、デザインナイフを使ってできるだけ細やかに処理した。特に親指部分のスイッチ(旧モデルにのみあるやつ。進む・戻るボタンじゃなく親指の位置にある)は可動部のラバーを取り除くと空洞になる。配線にカッターのはが届くので慎重に作業する必要があった。&lt;/p&gt;&lt;p&gt;分解を進めると、樹脂の劣化の進行具合が、指に触れる箇所とそうでない箇所で大きく異なるのが見て取れた。
劣化が進んだ箇所はグズグズで、刃を滑らせるのも簡単だったが、親指側の指が触れない部分等は結構元のママの硬度のようで、ちょっと力が必要だった。&lt;/p&gt;&lt;p&gt;ベタボロラバーを取り除いたあとにはテーピングを施す。&lt;/p&gt;&lt;p&gt;曲面へ一枚で貼り付けるのは面倒なので、いくつかの面でテーピングを区切りそれを組み合わせて貼り付けた。
やはり強度面で元のベタボロラバーに大きく劣るので、少なくても二重、親指ん可動部は三重にテーピングすることで強度を持たせてみた。&lt;/p&gt;&lt;h3 id="感想"&gt;感想&lt;/h3&gt;&lt;p&gt;アイデアができてからは、作業に対した時間もかからなかったし、中々やってみてよかった。&lt;/p&gt;&lt;p&gt;結構長い期間をベタボロラバーの状態で触ってきたので、テーピングのサラサラした手触りになって中々新鮮味がある。&lt;/p&gt;&lt;p&gt;まだ使ってみて一週間程度なので、この後どの程度テーピング部分に汚れが蓄積していくかは見えていないが、まあ半年とかのスパンで交換できれば良いか。&lt;/p&gt;&lt;p&gt;お気に入りのマウスをより良い状態に改善し、継続して使い続ける術を新たに身に着けた。&lt;/p&gt;</description><pubDate>Sun, 22 May 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-05-14-think-about-alignment-of-full-width-chars</guid><link>https://krymtkts.github.io/posts/2022-05-14-think-about-alignment-of-full-width-chars</link><title>East Asian な全角文字をキーに使った場合のアラインメントについて考える</title><description>&lt;p&gt;掲題のとおりである。
ここでいうアラインメントはメモリの話じゃなくて、字面上の整列のことを指す。&lt;/p&gt;&lt;p&gt;自分の中でもどうあるべきかまだ結論が出せてないので、考えをまとめるために書く。&lt;/p&gt;&lt;h3 id="問題"&gt;問題&lt;/h3&gt;&lt;p&gt;いま、 &lt;a href="https://github.com/PowerShell/PSScriptAnalyzer"&gt;PSScriptAnalyzer&lt;/a&gt; で全角文字をキーに持つ hashtable を整形したとき期待どおりにならなのだけど、どう解決するのがいいのだろう？と悩んでる。&lt;/p&gt;&lt;p&gt;一応弁解しておくと、わたしの気持ちとしては「そんなところに全角文字使うとか危なげなことやめようや」だ。&lt;/p&gt;&lt;p&gt;ところが、今やってる仕事でスプレッドシートのデータをシステムに取り込むにあたり、それらをいくつかの CSV に分解・再構築する必要があって、その中でこのテーマに直面した。 PSCustomObject を CSV に変換する形でスクリプトを作ってるので、全角文字が識別子になるのだ。&lt;/p&gt;&lt;p&gt;普通に自分が書く範囲だとこんなの書かないので、最近まで気づかなかった。&lt;/p&gt;&lt;p&gt;VS Code で PowerShell を書くと、自動整形には &lt;a href="https://github.com/PowerShell/PSScriptAnalyzer"&gt;PSScriptAnalyzer&lt;/a&gt; の &lt;code&gt;Invoke-Formatter&lt;/code&gt; が使われる。この戻り値が整形後のコードになるのだけど、ここで今回のテーマに直面する。&lt;/p&gt;&lt;p&gt;問題は以下のコードで再現できる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$settings = @{
    IncludeRules = @(
        'PSAlignAssignmentStatement'
    )

    Rules = @{
        PSAlignAssignmentStatement = @{
            Enable = $true
            # PSAlignAssignmentStatement.CheckHashtable が真だと、
            # hashtable の要素の並びを整形してくれる。
            CheckHashtable = $true
        }
    }
}

$script = @'
$test = @{
    A = 0
    ABC = 0
    ABCDE = 0
    Ａ = 0
    ＡＢＣ = 0
    ＡＢＣＤＥ = 0
}
'@
Invoke-Formatter -ScriptDefinition $script -Settings $settings
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;出力はこうなる。これは期待のとおりではない。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$test = @{
    A     = 0
    ABC   = 0
    ABCDE = 0
    Ａ     = 0
    ＡＢＣ   = 0
    ＡＢＣＤＥ = 0
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;わたしはこうなってほしいと考える。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$test = @{
    A          = 0
    ABC        = 0
    ABCDE      = 0
    Ａ         = 0
    ＡＢＣ     = 0
    ＡＢＣＤＥ = 0
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;PSScriptAnalyzer のコードを調べて、 PSScriptAnalyzer 的には PowerShell のパーサが返した列番号(&lt;code&gt;EndColumnNumber&lt;/code&gt;)の通りに整形してるのがわかった。
&lt;a href="https://github.com/PowerShell/PSScriptAnalyzer/blob/58c44234d44dfd0db35bb532906963e08fde8621/Rules/AlignAssignmentStatement.cs#L194"&gt;PSScriptAnalyzer/AlignAssignmentStatement.cs GetHashtableCorrections の L194&lt;/a&gt;&lt;/p&gt;&lt;p&gt;次に PowerShell のパーサを直接調べる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$script = @'
$test = @{
    A = 0
    ABC = 0
    ABCDE = 0
    Ａ = 0
    ＡＢＣ = 0
    ＡＢＣＤＥ = 0
}
'@

function getColumnNumberString {
    param (
        $Extent
    )
    "start $($Extent.StartColumnNumber.ToString().PadLeft(2)) end $($Extent.EndColumnNumber.ToString().PadLeft(2))"
}

$ast = [System.Management.Automation.Language.Parser]::ParseInput($script, [ref]$null, [ref]$null)
$hashAst = $ast.FindAll({ $args[0] -is [System.Management.Automation.Language.HashtableAst] }, $true)
$hashAst.KeyValuePairs | ForEach-Object {
    # Item1 がキーの情報、 Item2 は '=' の情報
    $e1, $e2 = $_.Item1.Extent, $_.Item2.Extent
    "key $(getColumnNumberString($e1)) | '=' $(getColumnNumberString($e2))"
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;出力はこうなって、全角文字の表示幅は考慮されてないのがわかる。&lt;/p&gt;&lt;pre&gt;&lt;code class="txt"&gt;key start  5 end  6 | '=' start  9 end 10
key start  5 end  8 | '=' start 11 end 12
key start  5 end 10 | '=' start 13 end 14
key start  5 end  6 | '=' start  9 end 10
key start  5 end  8 | '=' start 11 end 12
key start  5 end 10 | '=' start 13 end 14
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;じゃあこれは PowerShell のバグなのか？とまで考えを至らせると、いやパーサは表示する文字の幅を意識する必要あるか？と思えるので、これは誰が解決する問題なんや...と思っているのが、今の状況。&lt;/p&gt;&lt;h3 id="他の言語を調べる"&gt;他の言語を調べる&lt;/h3&gt;&lt;p&gt;他の事例を調べて、全角文字を含むキーや識別子をアラインメントするとどうなるか比べてみる。&lt;/p&gt;&lt;p&gt;とはいえ、他の言語でアラインメントするようなフォーマットかける言語何があったっけ？
少なくとも Python は違ったし、思いついたのは Go だけ。
Go 以外にも思いついたら追加したい。&lt;/p&gt;&lt;h4 id="go"&gt;Go&lt;/h4&gt;&lt;p&gt;こんな中身の &lt;code&gt;test.go&lt;/code&gt; があるとする。&lt;/p&gt;&lt;pre&gt;&lt;code class="go"&gt;package main

type person struct {
	A int
	ABC int
	ABCDE int
	Ａ int
	ＡＢＣ int
	ＡＢＣＤＥ int
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これに &lt;code&gt;gofmt ./test.go&lt;/code&gt; すると次の通り。&lt;/p&gt;&lt;pre&gt;&lt;code class="go"&gt;package main

type person struct {
        A     int
        ABC   int
        ABCDE int
        Ａ     int
        ＡＢＣ   int
        ＡＢＣＤＥ int
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;やっぱり！ PowerShell の結果と同じ。&lt;/p&gt;&lt;h3 id="現時点の理解"&gt;現時点の理解&lt;/h3&gt;&lt;p&gt;現実的には、パーサやフォーマッタがフォントの文字幅を考慮しないし、アラインメントしないのが妥当な落とし所なのかな。
気持ちとしては、全角文字を含んだとしても綺麗にアラインメントしてほしいが、それもエッジケースなのでそんなに困ることがない。&lt;/p&gt;&lt;p&gt;とはいえ Unicode 文字の演算子とかポツポツあるし、幅の規定が厳格であればフォーマッタあたりで解消したいテーマではある気がする。&lt;/p&gt;&lt;p&gt;なんか締まらない締めになった。&lt;/p&gt;&lt;p&gt;とりあえず自分用の覚書としては、 PSScriptAnalyzer は &lt;code&gt;PSAlignAssignmentStatement.CheckHashtable=$false&lt;/code&gt; で利用すればこの問題に悩まされることもないので、オススメする。&lt;/p&gt;</description><pubDate>Sat, 14 May 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-05-07-start-to-write-cmdlet-by-fsharp</guid><link>https://krymtkts.github.io/posts/2022-05-07-start-to-write-cmdlet-by-fsharp</link><title>F#で PowerShell コマンドレットを書き始めた</title><description>&lt;p&gt;勉強がてら、F# で PowerShell のコマンドレットを書きはじめる。
↓ を参考にやる。ただし .NET 6.0 を対象にする。&lt;/p&gt;&lt;p&gt;&lt;a href="https://webcoder.info/fspsmodule.html"&gt;Writing a PowerShell Core Module With F#, A Complete Guide | Brianary&lt;/a&gt;&lt;/p&gt;&lt;p&gt;初めての要素が多いので、ゆっくり進める。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;F# でアプリ書くのが初&lt;/li&gt;&lt;li&gt;コマンドレットを書くのが初&lt;/li&gt;&lt;li&gt;dotnet CLI を使った開発が初&lt;/li&gt;&lt;li&gt;その他 PowerShell 系のツール(&lt;a href="https://github.com/pester/Pester"&gt;Pester&lt;/a&gt;,&lt;a href="https://github.com/PowerShell/platyPS"&gt;platyPS&lt;/a&gt;)をちゃんと使うのが初
&lt;ul&gt;&lt;li&gt;参考にする記事にはないが、ビルドスクリプトも &lt;a href="https://github.com/psake/psake"&gt;psake&lt;/a&gt; で書く&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;題材としては、&lt;a href="https://github.com/jasonmarcher/poco"&gt;poco&lt;/a&gt; の再実装をしてみるつもり。&lt;/p&gt;&lt;p&gt;諸々のツールが出てくるので一覧しておく。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;GitHub の Repo の作成に &lt;a href="https://github.com/microsoft/PowerShellForGitHub"&gt;PowerShellForGitHub&lt;/a&gt;&lt;/li&gt;&lt;li&gt;remote repo の管理に &lt;a href="https://github.com/x-motemen/ghq"&gt;ghq&lt;/a&gt;&lt;/li&gt;&lt;li&gt;コミット署名のために &lt;a href="https://community.chocolatey.org/packages/Gpg4win"&gt;Gpg4win&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="repo-とプロジェクトを作成する"&gt;repo とプロジェクトを作成する&lt;/h3&gt;&lt;p&gt;動くものになるまでは private repo で運用する。動かないなら公開しても意味がないからね。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# private repo を作成する。
$owner = 'krymtkts'
$module = 'pocof'
New-GitHubRepository -RepositoryName 'pocof' -Private

# remote repo を clone する。
ghq get -p (Get-GitHubRepository -OwnerName $owner -RepositoryName $module | Select-Object -ExpandProperty ssh_url)
cd "$(ghq root)/$(ghq list $module)"

# initial commit を刻む。
gpg-connect-agent reloadagent /bye # &amp;lt;- gpg-agent が立ち上がってこないので先に起こす。
git commit --allow-empty -m 'Initial commit.'
dotnet new sln

# 空のプロジェクトを作成。
dotnet new classlib --language 'F#' --framework net6.0 -o src/$module
dotnet sln add src/$module/$module.fsproj
cd src/$module
# PowerShell 開発の依存関係を追加。
dotnet add package PowerShellStandard.Library
New-ModuleManifest "$module.psd1"
'&amp;lt;helpItems schema="maml" xmlns="http://msh" /&amp;gt;' | Set-Content "$module.dll-Help.xml" -Encoding utf8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これで repo と空の F# プロジェクト &lt;code&gt;pocof.fsproj&lt;/code&gt; ができた。
次に、記事に記載の通り、 &lt;code&gt;pocof.fsproj&lt;/code&gt; に必要な情報を加筆する。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;PropertyGroup&lt;/code&gt; に &lt;code&gt;Version&lt;/code&gt; 属性を追加&lt;/li&gt;&lt;li&gt;&lt;code&gt;ItemGroup&lt;/code&gt; 属性を追加して、コピーするファイルを記載する&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;また PowerShell のモジュール情報を &lt;code&gt;pocof.psd1&lt;/code&gt; 書き込む。
コマンドレットなので、 &lt;code&gt;RootModule&lt;/code&gt; を書き忘れるとコマンドがインポートできないのでご注意(書き忘れてて &lt;code&gt;Import-Module&lt;/code&gt; しても使えない！となった)。&lt;/p&gt;&lt;p&gt;あと作成後に気づいたのだが、 作成された &lt;code&gt;*.sln&lt;/code&gt; 等のエンコーディングが UTF8 with BOM だったり改行が CRLF だったりするので、それらを UTF8 と LF に手で補正した。&lt;/p&gt;&lt;p&gt;最後に 空の XML-based help file を作成しているが、これは &lt;code&gt;Get-Help&lt;/code&gt; で使うヘルプファイルで、後で PlatyPS で上書きされるやつ。
&lt;a href="https://docs.microsoft.com/en-us/powershell/scripting/developer/help/naming-help-files?view=powershell-7.2"&gt;Naming Help Files - PowerShell | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;h3 id="f-開発環境を準備する"&gt;F# 開発環境を準備する&lt;/h3&gt;&lt;p&gt;わたしは VS Code を使っているので、F# 用の拡張機能を入れる。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://marketplace.visualstudio.com/items?itemName=Ionide.Ionide-fsharp"&gt;Ionide for F# - Visual Studio Marketplace&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;F# でフォーマッタといえば &lt;code&gt;fantomas&lt;/code&gt; のようなのだけど、個別に入れなくても Ionide がうまく拾えるらしい。 &lt;a href="https://github.com/ionide/ionide-vscode-fsharp/issues/1346"&gt;Formatting Settings · Issue #1346 · ionide/ionide-vscode-fsharp&lt;/a&gt;&lt;/p&gt;&lt;h3 id="コードを編集する"&gt;コードを編集する&lt;/h3&gt;&lt;p&gt;自動生成されたコードを編集する。
記事に記載のものだとパラメータに &lt;code&gt;Position&lt;/code&gt; がなくて Pester こけそうなのと、自分のやりたいことに合わせた引数を書くなど諸々の調整をする。&lt;/p&gt;&lt;p&gt;Pester のテストコードも作成する。テストコードは &lt;code&gt;tests&lt;/code&gt; ディレクトリ配下に配置した。&lt;/p&gt;&lt;h3 id="ビルドテスト実行"&gt;ビルド＆テスト実行&lt;/h3&gt;&lt;p&gt;記事に記載の通りだと typo があったり &lt;code&gt;Import-Module&lt;/code&gt; 前に削除があって消えてしまう等ある。
編集して実行した。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ModuleName = Resolve-Path ./src/* | Split-Path -Leaf
Import-LocalizedData -BindingVariable module -BaseDirectory (Resolve-Path ./src/*) -FileName "$ModuleName.psd1"
if ($module.ModuleVersion -ne (Resolve-Path ./src/*/*.fsproj | Select-Xml '//Version/text()').Node.Value) {
    throw 'Module manifest (.psd1) version does not match project (.fsproj) version.'
}
dotnet publish
cp (Resolve-Path ./src/*/bin/Debug/*/publish/FSharp.Core.dll) (Resolve-Path ./src/*/bin/Debug/*/) -Verbose

# import して Pester 実行。
# モジュールのバージョンであったり export される Cmdlet が正しいかなど見る。
Import-Module (Resolve-Path ./src/*/bin/Debug/*/publish/*.psd1) -Force
Invoke-Pester
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;あとこれらを &lt;code&gt;psake&lt;/code&gt; で実行できるように &lt;code&gt;psakefile.ps1&lt;/code&gt; に記載した。&lt;/p&gt;&lt;p&gt;F# のプロジェクトだったら &lt;a href="https://github.com/fsprojects/FAKE"&gt;FAKE&lt;/a&gt; を使った方がいいのかなーと考えていた。となると、依存する &lt;a href="https://fsprojects.github.io/Paket/"&gt;Paket&lt;/a&gt; も入れないといけない。いま &lt;code&gt;dotnet&lt;/code&gt; CLI で管理してたのでいらないかなーと思った。
また、今回作りたいのは PowerShell のコマンドレットなので、 周辺のツールも PowerShell だ。これをいちいち &lt;code&gt;fake.cmd&lt;/code&gt; や &lt;code&gt;dotnet fake build&lt;/code&gt;を介して実行するのなんかダルいな...と億劫だったので、 FAKE の導入は見送ることにした。&lt;/p&gt;&lt;h3 id="ドキュメントを生成する"&gt;ドキュメントを生成する&lt;/h3&gt;&lt;p&gt;記事では &lt;a href="https://github.com/PowerShell/platyPS"&gt;platyPS&lt;/a&gt; を使っているのでそれに従う。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# 事前にビルドしたモジュールを Import-Module しておく。
New-MarkdownHelp -Module pocof -OutputFolder ./docs -ErrorAction SilentlyContinue
# dll-Help.xml を作るときに実行する。
New-ExternalHelp docs -OutputPath (Resolve-Path ./src/*/) -Force
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;コメントに記した通り、他のタスクと依存関係にある。こういうのは &lt;code&gt;psakefile.ps1&lt;/code&gt; にまとめる。&lt;/p&gt;&lt;p&gt;ヘルプの作成元は Markdown をオリジナルとする方針。&lt;/p&gt;&lt;h3 id="powershell-gallery-へのリリース"&gt;PowerShell Gallery へのリリース&lt;/h3&gt;&lt;p&gt;まだやらないけど手順だけ確立しておく。&lt;/p&gt;&lt;p&gt;記事に記載のものだと、ビルドコンフィグレーションを Release にして Import、その後 Import したモジュールを公開、という手順になっている。&lt;/p&gt;&lt;p&gt;個人的にやったことがあるのはフォルダを指定して公開する方だけなので、どっちにするかなーと悩んでいる。間違って古い Import 済みモジュールを公開するミスとかないのかな、というのが疑問。&lt;/p&gt;&lt;p&gt;ま、勉強のためのものであるし、やったことない方を接客的に選んでみるのも一興か。コマンドレットが正しくエクスポートできているか、リリース前にテストするにもこの方法を取るのが良さそうだし。&lt;/p&gt;&lt;p&gt;とはいえ記事に記載の通りやると、自分が普段利用している PowerShell Module のパスに直でリリース前のモジュールを打ち込んでしまう。
これはちょっと実用始めたら困りそうなので、ディレクトリを変える必要がある。
となると結局いつものパス指定でのリリース方式でええんちゃうか...&lt;/p&gt;&lt;p&gt;いずれを選択するかはまた検討したい。&lt;/p&gt;&lt;p&gt;また、これらのリリースタスクも &lt;code&gt;psakefile.ps1&lt;/code&gt; に定義するものとする。&lt;/p&gt;&lt;h3 id="おわりに"&gt;おわりに&lt;/h3&gt;&lt;p&gt;これでひとまず準備完了。
ほぼ記事に記載のとおりやってきたけど、ちょいちょい自分用に変えたり、新しい要素については色々調べながらやってるので、進捗は亀のスピードだった。
動くものをこしらえれたら public repo にしよう。&lt;/p&gt;&lt;p&gt;現時点で不足しているとわかっている点もある。
今回書きたいコマンドレットはインタラクティブなものなので、きっと Pester でテストできない点が出てくる。
それらは &lt;a href="https://fsprojects.github.io/FsUnit/"&gt;FsUnit&lt;/a&gt; を使って可能な限りテストを書きたい所存。&lt;/p&gt;&lt;p&gt;あと困っているのが、参考にしている記事にも記載があったが、 DLL への参照が切れなくてファイルを消したりできなくなる(&lt;code&gt;Remove-Module&lt;/code&gt; 忘れとかでなく)。いまは都度 PowerShell のセッションを作り直してるけど相当に面倒なので、原因を突き止めてどうにかしたいな。&lt;/p&gt;&lt;p&gt;未経験のものに触れるのは普段得られない刺激があって良い。&lt;/p&gt;</description><pubDate>Sat, 07 May 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-04-29-good-bye-omp-module</guid><link>https://krymtkts.github.io/posts/2022-04-29-good-bye-omp-module</link><title>さよなら oh-my-posh モジュール</title><description>&lt;p&gt;いつものように PowerShell Module を更新して PowerShell を立ち上げると次のようなメッセージが表示された。&lt;/p&gt;&lt;pre&gt;&lt;code class="txt"&gt;Hey friend

In an effort to grow oh-my-posh, the decision was made to no
longer support the PowerShell module. Over the past year, the
added benefit of the module disappeared, while the burden of
maintaining it increased.

However, this doesn't mean oh-my-posh disappears from your
terminal, it just means that you'll have to use a different
tool to install it.

All you need to do, is follow the migration guide here:

https://ohmyposh.dev/docs/migrating
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;あら... oh-my-posh 3 から Go で実装されて、マルチプラットフォームなプロンプトテーマエンジンになってたけど、ついにその時が来たか...という感じ。&lt;/p&gt;&lt;p&gt;とりあえず使えなくなる(というか更新できなくなる)と困るので、&lt;a href="https://ohmyposh.dev/docs/migrating"&gt;移行手順&lt;/a&gt; に記載された移行手順を行うことにした。&lt;/p&gt;&lt;h3 id="わたしの移行手順"&gt;わたしの移行手順&lt;/h3&gt;&lt;p&gt;記載の順番にやってもいいけど、慎重を期すため順番を変えた。&lt;/p&gt;&lt;p&gt;まず &lt;code&gt;oh-my-posh&lt;/code&gt; が &lt;code&gt;PATH&lt;/code&gt; にある状態で、 &lt;code&gt;Set-PoshPrompt&lt;/code&gt; を &lt;code&gt;oh-my-posh init pwsh&lt;/code&gt; に変え、プロンプトの表示をチェックした。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# Set-PoshPrompt -Theme ~/.oh-my-posh.omp.json
oh-my-posh init pwsh --config ~/.custom.omp.json | Invoke-Expression
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然のごとくきれいに出力されるので、 PowerShell Module から置き換える。&lt;/p&gt;&lt;p&gt;&lt;a href="https://ohmyposh.dev/docs/installation/windows"&gt;Windows 向けの公式なインストール手順&lt;/a&gt;では &lt;code&gt;winget&lt;/code&gt;, &lt;code&gt;scoop&lt;/code&gt; それか手動での更新になっている。&lt;/p&gt;&lt;p&gt;でもわたしは永らく &lt;code&gt;chocolatey&lt;/code&gt; を使っていることもあり、有志が公開してくれているパッケージを利用する。見たところバージョンも最新に追随していていい感じ。
&lt;a href="https://community.chocolatey.org/packages/oh-my-posh#versionhistory"&gt;Chocolatey Software | Oh-My-Posh 7.74.3&lt;/a&gt;&lt;/p&gt;&lt;p&gt;管理者権限で &lt;code&gt;cmd&lt;/code&gt; を開き、インストールする。補足：PowerShell でもインストールできるが、PowerShell 自体を &lt;code&gt;chocolatey&lt;/code&gt; でインストールしているのもあり &lt;code&gt;chocolatey&lt;/code&gt; でのインストールは &lt;code&gt;cmd&lt;/code&gt; で行うようにしている。&lt;/p&gt;&lt;pre&gt;&lt;code class="cmd"&gt;choco install oh-my-posh -y
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;このインストールの最後に、&lt;/p&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;PROFILE: C:\Users\takatoshi\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1
oh-my-posh has been added to your profile. You may wish to append 'Set-PoshPrompt paradox' to set a theme
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;と言われたが、 Windows PowerShell のプロファイルはおろかどこにも加筆されてないようだった。&lt;/p&gt;&lt;p&gt;管理者権限で PowerShell を起動し、 oh-my-posh の Powershell Module を削除する。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Uninstall-Module oh-my-posh -AllVersions
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Import-Module oh-my-posh&lt;/code&gt; は元々書いてなかったので削除なし。代わりにプロファイルの中でインストール・更新するモジュール名を管理しているので、そこから取り除いた。&lt;/p&gt;&lt;p&gt;以上。&lt;/p&gt;&lt;h3 id="感想"&gt;感想&lt;/h3&gt;&lt;p&gt;何事もなく移行できて良かった。&lt;/p&gt;&lt;p&gt;ただこれを機に、もう oh-my-posh にこだわらず、 &lt;a href="https://starship.rs/"&gt;Starship&lt;/a&gt; みたいなもっとイケてるプロンプトテーマエンジンに積極的に乗り換えてもいいかなーと思えてきた。&lt;/p&gt;&lt;p&gt;元々 oh-my-posh を使ってたのは、 2018 年頃の PowerShell でいい感じの Powerline ができる唯一のツールだったからだ(わたしの観測範囲では。もう一つその名の通り Powerline というモジュールがあったが満足の行くカスタマイズができなかった&lt;sup id="fnref-1"&gt;&lt;a class="footnote-ref" href="#fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt;)。
テーマを PowerShell で書けて、PowerShellGet からインストールできるのも楽だった。&lt;/p&gt;&lt;p&gt;とはいえ、それがマルチプラットフォームに対応した oh-my-posh の足枷になったみたいやけど。&lt;/p&gt;&lt;p&gt;逆に利用者の立場からいえば、 oh-my-posh が明確に PowerShell に特化しなくなったということ。
これは、わたしが Power Fighter(勝手に作った PowerShell 使いの呼び名)であるから oh-my-posh を使い続けていたという理由もなくなったことになる。&lt;/p&gt;&lt;p&gt;oh-my-posh が Go で書き換わったときに一番気に入らなかったのは &lt;em&gt;&lt;strong&gt;設定ファイルが JSON&lt;/strong&gt;&lt;/em&gt; なとこなので、そのフラストレーションを解消するいい機会をもらったのかも知れない。&lt;/p&gt;&lt;div class="footnotes"&gt;&lt;hr /&gt;&lt;ol&gt;&lt;li id="fn-1"&gt;&lt;p&gt;まだあったわ →&lt;a href="https://www.powershellgallery.com/packages/PowerLine/3.4.0"&gt;PowerShell Gallery | PowerLine 3.4.0&lt;/a&gt;&lt;/p&gt;&lt;a href="#fnref-1" class="footnote-backref"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description><pubDate>Fri, 29 Apr 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-04-23-aws-rehabilitation</guid><link>https://krymtkts.github.io/posts/2022-04-23-aws-rehabilitation</link><title>AWS リハビリのハマり集</title><description>&lt;p&gt;現職は半年ぶりの AWS ということで、ちまちまリハビリをしている。
諸々忘れてたりものによってはハマっている現状。記憶に定着させるため、ハマったところを記す。&lt;/p&gt;&lt;h3 id="hello-world-以外の-sam-init-できません"&gt;Hello World 以外の &lt;code&gt;sam init&lt;/code&gt; できません&lt;/h3&gt;&lt;p&gt;AWS SAM は前職でも使っていたが、久しぶりに触ったら詰まるところがあったので書いておく。&lt;/p&gt;&lt;p&gt;久しぶりに &lt;code&gt;sam init&lt;/code&gt; すると 100%エラーで終わる。端末は Windows 11。
こんな風に ↓。&lt;/p&gt;&lt;pre&gt;&lt;code class="log"&gt;Cloning from https://github.com/aws/aws-sam-cli-app-templates (process may take a moment)
Error: Can't find application template quick-start-web - check valid values in interactive init.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href="https://github.com/aws/aws-sam-cli/issues/3692#issuecomment-1070222512"&gt;Unable to create Serverless API using SAM v1.40.0 · Issue #3692 · aws/aws-sam-cli&lt;/a&gt;&lt;/p&gt;&lt;p&gt;どうも Windows 限定の問題らしい。 &lt;code&gt;sam&lt;/code&gt; が使う template repository を &lt;code&gt;git clone&lt;/code&gt; できないという深刻なやつ。
AWS SAM の一時ディレクトリを消して、手動で &lt;code&gt;git clone&lt;/code&gt; したら解消する。これは Issue は Closed になっているものの、中々気付かんし原因を究明したい気がする。&lt;/p&gt;&lt;h3 id="mfa-有効化されたアクセスキーの使い方忘れた"&gt;MFA 有効化されたアクセスキーの使い方忘れた&lt;/h3&gt;&lt;p&gt;タイトルの通り。&lt;/p&gt;&lt;p&gt;そのまま使うとワンタイムパスの入力を求められないが、一時クリデンシャルを発行するときに出る。&lt;/p&gt;&lt;p&gt;昔は MFA が必要な switch role するときに aws-mfa を使っていたが、 この度 AWS Tools for PowerShell で自分の利用ケースのみシンプルにこしらえた。
ワンタイムパスワードの入力には 1Password の CLI である &lt;a href="https://developer.1password.com/docs/cli/get-started"&gt;&lt;code&gt;op&lt;/code&gt;&lt;/a&gt; を使うと究極に楽。現職で 1Password を使ってるので導入したみた。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$env:AWS_REGION = 'ap-northeast-1'
$user = 'krymtkts'
$AWSLogin = 'AWS'
$c = Get-STSSessionToken -SerialNumber (Get-IAMMFADevice -UserName $user).SerialNumber -TokenCode (op item get $AWSLogin --otp) -ProfileName $user
$env:AWS_ACCESS_KEY_ID = $c.AccessKeyId
$env:AWS_SECRET_ACCESS_KEY = $c.SecretAccessKey
$env:AWS_SESSION_TOKEN = $c.SessionToken
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;楽～。これは PowerShell の profile に関数書いておいた。&lt;/p&gt;&lt;h3 id="aws-tools-for-powershell-は自動補完で一覧する-profile-を絞り込んでる"&gt;AWS Tools for PowerShell は自動補完で一覧する profile を絞り込んでる&lt;/h3&gt;&lt;p&gt;&lt;code&gt;.aws/credentials&lt;/code&gt; にこういう profile があるとする。これ、 &lt;code&gt;mfa_serial&lt;/code&gt; が紛れ込んでる。&lt;/p&gt;&lt;pre&gt;&lt;code class="ini"&gt;[profile]
aws_access_key_id = XXXXXXXXXXXXXXXXXXXX
aws_secret_access_key = XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
mfa_serial = xxx
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;AWS CLI のタブ補完コマンド &lt;code&gt;aws_completer&lt;/code&gt; はこういうのがあっても問題なく profile を一覧できるが、 AWS Tools for PowerShell では一覧されなくなる。 &lt;code&gt;mfa_serial&lt;/code&gt; 以外には &lt;code&gt;role_arn&lt;/code&gt;, &lt;code&gt;source_profile&lt;/code&gt; があると一覧されなくなる。&lt;/p&gt;&lt;p&gt;これ初めて知った。今後は、書き間違ってるから一覧されないんだ～と思いつくことができるが、一発目だったのでとても時間がかかった。ドキュメントに書いてる挙動なんかな～しらんけど。今度調べたい(いつ)。&lt;/p&gt;&lt;p&gt;続くかも。&lt;/p&gt;</description><pubDate>Sat, 23 Apr 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-04-16-convert-hatena-xml-to-md</guid><link>https://krymtkts.github.io/posts/2022-04-16-convert-hatena-xml-to-md</link><title>古のはてなダイアリー XML を Markdwon に変換する(いい感じに)</title><description>&lt;p&gt;先日 Google ドライブの中に眠っていた XML を発掘した。古のはてなダイアリーからエクスポートされたやつだこれ。&lt;/p&gt;&lt;p&gt;昔、プレーンテキストで日記をつけ始める前に、誰に見せるでもないブログを書いていた。何度かブログサービスに書いては止めるを繰り返していた。
そのうち最も最近までやってたのがはてなダイアリーで、そのバックアップがこれっぽい。
178 記事、2009 ~ 2011 の 3 年間もあるのに、すっかり忘れていた。&lt;/p&gt;&lt;p&gt;これはぜひ今の日記に統合したい。ということではてなダイアリーの XML を Markdown に変換して取り込むことにした。&lt;/p&gt;&lt;h3 id="変換する"&gt;変換する&lt;/h3&gt;&lt;p&gt;今回は Pandoc を使わず純粋に PowerShell だけで処理する。
Pandoc で&lt;a href="https://help.hatenablog.com/entry/text-hatena-list"&gt;はてな記法&lt;/a&gt;から Markdown に変換できるが、ごく一部の記事は既に日記があって追記しないといけないこともあり、PowerShell だけでやる方が融通が利く。&lt;/p&gt;&lt;p&gt;XML なら PowerShell の主戦場なので、何をするにも楽だ。
使っているはてな記法もおおよそパターンマッチで置換できる(鬼の連続置換)。&lt;/p&gt;&lt;p&gt;引用だけ正規表現での変換がわからんけど、一桁件数しかなかったので、手で書き換える。&lt;/p&gt;&lt;p&gt;以下変換スクリプト。 &lt;code&gt;hatena2md.ps1&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;[CmdletBinding()]
param (
    [Parameter(
        Mandatory,
        HelpMessage = "XML Path of hatena diary.")]
    [ValidateScript({
            if (-Not ($_ | Test-Path) -or ($_ -notmatch "\.xml")) {
                throw "The file specified in the XmlPath argument must be XML."
            }
            return $True
        })]
    [System.IO.FileInfo]
    $XmlPath,
    [Parameter(
        Mandatory,
        HelpMessage = "Output Path of Markdown diaries.")]
    [ValidateScript({
            if (-Not (Test-Path $_ ) -or -not (Test-Path $_ -PathType Container)) {
                throw "The BlogPath argument must be a folder."
            }
            return $True
        })]
    [System.IO.FileInfo]
    $BlogPath
)

$xml = [XML](Get-Content $XmlPath)
Write-Host "Convert $($xml.diary.day.Length) hatena XML to Markdown."

$xml.diary.day | ForEach-Object {
    $date = Get-Date $_.date -ErrorAction SilentlyContinue
    if (-not $?) {
        Write-Error "Cannot convert diary of $($_.date)"
        return
    }
    $diaryPath = "$BlogPath/$($date.Year)/$($date.ToString('yyyy-MM'))/$($date.toString('dd')).md"
    Get-ChildItem $diaryPath -ErrorAction SilentlyContinue | Out-Null
    if ($?) {
        Write-Host "Add Content to exists diary of $($_.date)"
        $InvokeContent = 'Add-Content'
        $content = @"

## はてなの日記

"@
    }
    else {
        Write-Host "Create new diary of $($_.date)"
        $InvokeContent = 'Set-Content'
        mkdir -Force (Split-Path $diaryPath -Parent) | Out-Null
        $content = @"
# $($date.ToString('yyyy-MM/dd (ddd)'))

## はてなの日記

"@
    }
    $content += (
        $_.body -split "`n" | ForEach-Object {
            $_ `
                -replace '^\*\d+\*(.+)$', "### `$1`n" `
                -replace '^=+$', "`n---`n" `
                -replace '^--(.+)', '    - $1' `
                -replace '^-(.+)', '- $1' `
                -replace '^\+\+(.+)', '    1. $1' `
                -replace '^\+(.+)', '1. $1' `
                -replace '\&amp;gt;\|(\w+)\|', "`n```````$1" `
                -replace '(\&amp;gt;\|\||\&amp;gt;\|)', "`n``````" `
                -replace '(\|\|\&amp;lt;|\|\&amp;lt;)', "```````n" `
                -replace '\[(.+?)\:title=(.+?)]', '[$2]($1)'
        }) -join "`n"
    $content | &amp;amp; $InvokeContent -Path $diaryPath -Encoding utf8 -NoNewline | Out-Null
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;はてなダイアリーの XML から、自分の日記の構造に変換している。
はてなダイアリーの記事にはわかりやすく「はてなの日記」というセクションを設ける。&lt;/p&gt;&lt;p&gt;基本ファイルを作成するが、既存のファイルが存在する場合は、追記する。
先述の通りセクションがあるので追記しても自然だ。&lt;/p&gt;&lt;p&gt;ディレクトリ構造は&lt;a href="/posts/2022-04-02-convert-textile-to-md"&gt;前回の Textile → Markdown 変換&lt;/a&gt; で記した通り ↓ 。 1 つの XML からこの形にファイルを出力する。&lt;/p&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;+---2013
|   +---2013-01
|   |       17.textile
|   ︙      ︙
︙
\---2022
   +---2022-01
   ︙
   \---2022-03
            01.md
            ︙
            31.md
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;実行する。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;. .\hatena2md.ps1 -XmlPath $XmlPath -BlogPath $BlogPath
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="変換後の処理"&gt;変換後の処理&lt;/h3&gt;&lt;p&gt;変換後のファイルから&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; で検索して該当するものを一覧し、書き換える。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;ls -File -Recurse | ? {cat $_ | % {$_ -split "`n"} | ? {$_ -match '^&amp;gt;&amp;gt;'}} | select -Property FullName
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ココに来て順序付きリストの数字をやっぱりインクリメントしたい(前のステップでは&lt;code&gt;1.&lt;/code&gt;固定でいいかと思ってた)...ということで一部書き直した。&lt;/p&gt;&lt;p&gt;最後に全体を &lt;a href="https://prettier.io/"&gt;Prettier&lt;/a&gt; で清書する。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;prettier --write .
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最終チェックをして完了。&lt;/p&gt;&lt;h3 id="まとめ"&gt;まとめ&lt;/h3&gt;&lt;p&gt;Textile からの変換よりも、量が 1/10 程度と少なかったこともあり、簡単にできた。&lt;/p&gt;&lt;p&gt;コンテンツそれ自体は中々に青臭く、読んでると「わー！！！」と声を上げたくなるところもある。
ただ人生の転機が集中した期間だったこともあって、興味深い内容だった。貴重なログなので、これまた自己分析に使いたい。&lt;/p&gt;</description><pubDate>Sat, 16 Apr 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-04-09-jobchange-2022</guid><link>https://krymtkts.github.io/posts/2022-04-09-jobchange-2022</link><title>転職した 2022</title><description>&lt;p&gt;また転職した。&lt;a href="/posts/2021-09-28-jobchange-2021"&gt;前回の転職&lt;/a&gt;から半年しか経ってないけど。&lt;/p&gt;&lt;p&gt;退職前に諸々の誓約書に署名してるので諸々の守秘義務があり、多くを語ることはできない。
結構高く評価してもらってたのに辞めた理由を語るとすれば、ただひとえに「音楽性の違い」が原因かな。
あ、入社して知り合った 1 ヶ月パイセンが信頼のおける人だったのは良かった。&lt;/p&gt;&lt;p&gt;幸運にも、より良い条件で次のご縁があったので、これは自分の真摯な姿勢が信頼を紡いできたおかげなんかなーと自分自身を讃えてみる。讃えてみるテスト。&lt;/p&gt;&lt;p&gt;結果的にジョブホッパーみたいになってしまったから、ヘッドハンター()とかには「キャリアに傷がついてる」とかいちびられそうだが、こちとら仕事はちゃんと納めたからええのよ。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;この半年の間で伸びたところもなくはないけど、結構停滞感みたいなのを感じていた。
結局半年の間、技術情報を交換したり意見することもないし、あらゆる権限がなくて何なら自分の Google アカウントのアバターを変更する権限もなかった。全然人に会うこともなくコミュニケーションは週 1 回くらいとかだったので、初対面の人と会話したり、単に送るメッセージ考えるのも疲れるというのが現状。&lt;/p&gt;&lt;p&gt;自分の職掌にはクラウドの「ク」もなく、全く触ることがなかったので、使っていない筋肉が随分衰えてしまった。
細かいことを忘れてるので、現職でしょーもないことであっても「アレ？どうやっけ？」となったりする。まだリハビリ中。&lt;/p&gt;&lt;p&gt;また、ビジネスサイドの声から遠ざかっていたことで、言葉の理解力とか肌感覚が鈍った気がする。ここもリハビリ中。&lt;/p&gt;&lt;p&gt;たった 1 週間程働いてみこの感覚なので、これからも他の衰えに気づくことが度々あるだろう。&lt;/p&gt;&lt;p&gt;いずれの衰えも「強くてニューゲーム」できると嬉しいけど、そこはやってみないとわからんから、ただただ真摯に取り組むのみやな。自分の変化に気づけてるだけでアドバンテージかな。&lt;/p&gt;&lt;p&gt;それにしても久しぶりに「仕事してる！」という実感があって良い。これはまさに「音楽性」が一致した結果なんかな。しらんけど。&lt;/p&gt;&lt;p&gt;ただのポエムになった。&lt;/p&gt;</description><pubDate>Sat, 09 Apr 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-04-02-convert-textile-to-md</guid><link>https://krymtkts.github.io/posts/2022-04-02-convert-textile-to-md</link><title>Textile を Markdown に変換する(いい感じに)</title><description>&lt;p&gt;プレーンテキストで日記をつけ始めて今年で 9 年目になったぽい。
その日記だが、昔 Redmine を使ってたこともあって、最初の 5 年位の間 &lt;a href="https://textile-lang.com/"&gt;Textile&lt;/a&gt; で日記を書いていた時期がある。
この頃の文書を Markdown に変換したいと度々思っていたが、最近重い腰を上げて取り組み始めた。&lt;/p&gt;&lt;p&gt;マークアップ言語の相互変換といえば、やはり Haskell で書かれた &lt;a href="https://pandoc.org/"&gt;Pandoc&lt;/a&gt; やろーというのが個人的なイメージ。簡単なケースで永らく使ってきたが、今回は困ったというか一筋縄ではいかない点が出てきた。&lt;/p&gt;&lt;p&gt;例えば、 Pandoc で過去の日記を Textile から Markdown に変換するとしたらこんな感じのコマンドになる。&lt;/p&gt;&lt;p&gt;(以降は視認性を確保するため、実際に実行したコマンドに改行を含めて記載する)&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;pandoc --from=textile --to=gfm+east_asian_line_breaks `
       --shift-heading-level-by=-4 --eol=lf --wrap=preserve `
       ./diary.textile --output=./diary.md
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参照 &lt;a href="https://pandoc.org/MANUAL.html"&gt;Pandoc - Pandoc User’s Guide&lt;/a&gt;&lt;/p&gt;&lt;p&gt;結構いい感じの結果を導くオプションの組み合わせに手間取った。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;改行に半角スペース 2 つを使い、表の syntax も使うので &lt;code&gt;gfm+east_asian_line_breaks&lt;/code&gt;&lt;/li&gt;&lt;li&gt;見出しのレベルを変えるための &lt;code&gt;shift-heading-level-by=-4&lt;/code&gt; を指定
&lt;ul&gt;&lt;li&gt;Redmine の見た目上 &lt;code&gt;h5.&lt;/code&gt; にしてた(確か)&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;改行コードは LF で統一する &lt;code&gt;--eol=lf&lt;/code&gt;&lt;/li&gt;&lt;li&gt;長い行に空白があると折り返そうとするので &lt;code&gt;--wrap=preserve&lt;/code&gt; 原文を維持する&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;仮に日記が以下のような記述とする。&lt;/p&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;h5. 見出し

# 順序付きリスト1
** 箇条書きリスト1-1
# 順序付きリスト2
** bullet listアイテム2-1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
* 箇条書きリスト3
## 箇条書きリスト3-1
箇条書きリスト3-1の 改行したコンテンツ

* *箇条書きリスト2*
箇条書きリスト2。
|_.行1|1|
|_.行2|20|

* *箇条書きリスト3*
&amp;lt;pre&amp;gt;
コード
&amp;lt;/pre&amp;gt;
テキスト

|_.行1|1|
|_.行2|20|

    |_.行1|1|
    |_.行2|20|

&amp;lt;pre&amp;gt;&amp;lt;code class='sh'&amp;gt;
コード
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これを先述のコマンドで Textile から Markdown に変換すると...&lt;/p&gt;&lt;pre&gt;&lt;code class="md"&gt;# 見出し

\# 順序付きリスト1

箇条書きリスト1-1

\# 順序付きリスト2

bullet listアイテム2-1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

-   箇条書きリスト3
    1.  箇条書きリスト3-1  
        箇条書きリスト3-1の 改行したコンテンツ

&amp;lt;!-- --&amp;gt;

-   **箇条書きリスト2**  
    箇条書きリスト2。  
    \|\_.行1\|1\|  
    \|\_.行2\|20\|

&amp;lt;!-- --&amp;gt;

-   **箇条書きリスト3**
        コード

      
    テキスト

| 行1 | 1   |
|-----|-----|
| 行2 | 20  |

\|\_.行1\|1\|  
\|\_.行2\|20\|

    &amp;lt;code class='sh'&amp;gt;
    コード
    &amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;このように、おもしろいことになる。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;順序付きリストと箇条書きリストが同じレベルに存在すると、後ろの方(この場合箇条書きリスト)しか変換できない
&lt;ul&gt;&lt;li&gt;これは事前に混在するリストを Textile から取り除くしかないか&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;リストと文の間の過剰な空白が気持ち悪い
&lt;ul&gt;&lt;li&gt;まだどうにかできそうなオプションを見つけられていないので、これは Textile -&amp;gt; Markdown 変換後に Prettier で変換する必要があるか&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;新たに挿入された謎の HTML コメントの行は、以下の Pandoc の仕様によるらしい
&lt;ul&gt;&lt;li&gt;&lt;a href="https://pandoc.org/MANUAL.html#ending-a-list"&gt;Ending a list | Pandoc - Pandoc User’s Guide&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;blockquote&gt;&lt;p&gt;To “cut off” the list after item two, you can insert some non-indented content, like an HTML comment, which won’t produce visible output in any format:&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;表の変換は、箇条書きに連続しない＆インデントされていない箇所に限り、 Markdown の Table Syntax に変換される&lt;/li&gt;&lt;li&gt;当時の Redmine で使えなかったこともあり、コードブロックを &lt;code&gt;&amp;lt;pre&amp;gt;&amp;lt;code class='lang'&amp;gt;&lt;/code&gt; で表現していた。これが Markdown に変換したとき &lt;code&gt;pre&lt;/code&gt; 要素だけ解釈されてしまう&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;1,4 は Pandoc で変換をかける前に手で直さざるを得ないので、正規表現に引っかかる範囲は一括変換をかける。1000 超える Textile ファイルがあるので流石に手作業は無理、可能な限り一括変換や。&lt;/p&gt;&lt;p&gt;2, 3, 5 は変換後に対処する。これも機械的にどうにでもできそうか。&lt;/p&gt;&lt;p&gt;日記のディレクトリ構造はこのような形になっており、変換作業はルートディレクトリから行う。&lt;/p&gt;&lt;pre&gt;&lt;code class="plaintext"&gt;+---2013
|   +---2013-01
|   |       17.textile
|   |       18.textile
|   ︙      ︙
|   \---2013-12
︙
\---2022
   +---2022-01
   ︙
   \---2022-03
            01.md
            ︙
            31.md
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(色々 try &amp;amp; error して変換していたので、 入力の手間を省く目的でわかりきったコマンドはエイリアスを多用している)&lt;/p&gt;&lt;h3 id="4-の解消"&gt;4 の解消&lt;/h3&gt;&lt;p&gt;インデントされている表はなかったが、箇条書きの後に表が記載されているパターンがあり、そのうち、以下の 2 パターンがあった。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;箇条書き直後に表がある&lt;/li&gt;&lt;li&gt;箇条書きの後、更に文を挟んだ後に表がある&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;この 2 を引っ掛けるパターンを書くのに難儀した。
何故なら、表の syntax の行末に余分に空白や不要な文字がついていて、どうにもわたしの正規表現力では引っ掛けられない。&lt;/p&gt;&lt;p&gt;どうにもうまくできないので妥協して、 2 回に分けて変換する。&lt;/p&gt;&lt;p&gt;1 については雑ながらも一括変換可能。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;ls -Recurse -File *.textile |
? {(cat $_.FullName ) -join "`n" | sls -Pattern '(\*|#).+\n\|'} |
%{
    $file = $_.FullName
    ((cat $file) -join "`n") -replace '((\*|#).+\n)(\|)',"`$1`n`$3" |
        Set-Content $file -NoNewline
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;改行コードは LF を使うので &lt;code&gt;-NoNewLine&lt;/code&gt; だ。&lt;/p&gt;&lt;p&gt;2 はリストアップして清書がてら手メンテ...&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# ファイル一覧をクリップボードへ
ls -Recurse -File *.textile | ? {
    (cat $_.FullName ) -join "`n" | sls -Pattern '\n[^\*#\|].+\n\|'
} | select -ExpandProperty FullName | Set-Clipboard
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="1-の解消"&gt;1 の解消&lt;/h3&gt;&lt;p&gt;Textile を見るに、箇条書きの後に太字 &lt;code&gt;*〇〇*&lt;/code&gt; を書いて見出しの代わりにしたかったような気配がするので、それを除外した順序づき/箇条書きリストを変換の対象にする。&lt;/p&gt;&lt;p&gt;番号を参照していたりすると文脈が失われるので、一括変換できるか対象 23 件を目検したところ、レベル誤りだったり単に順序付きリストにし忘れているだけの箇所だったり。
それぞれに対処の仕方が異なるので、仕方ないがリストアップした対象を清書がてら手メンテ(2 回目)...&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# ファイル一覧をクリップボードへ
ls -Recurse -File *.textile | ? {
    (cat $_.FullName | ? {$_ -match '(^\*\s[^\*]|^#\s[^\*])'}) -join "`n" |
        sls -Pattern '(\*.+\n#|#.+\n\*)'
} | select -ExpandProperty FullName | Set-Clipboard
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="textile---markdown-の変換"&gt;Textile -&amp;gt; Markdown の変換&lt;/h3&gt;&lt;p&gt;先述の通りのオプションで Pandoc を実行する。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;ls -Recurse -File *.textile | %{
    pandoc `
        --from=textile --to=gfm+east_asian_line_breaks `
        --shift-heading-level-by=-4 --eol=lf `
        $_.FullName --output="$($_.Directory)\$($_.Name -replace 'textile','md')"
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="3-の解消"&gt;3 の解消&lt;/h3&gt;&lt;p&gt;変換後、まず最初に &lt;code&gt;&amp;lt;!-- --&amp;gt;&lt;/code&gt; を取り除く。最後に Prettier を実行してきれいな状態にしたいからだ。&lt;/p&gt;&lt;p&gt;置換対象が Pandoc によって追加されたコメントだけなのか調べる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; ls -Recurse -File *.md | % {cat $_.FullName | sls -Pattern '^&amp;lt;!--.+--&amp;gt;'} | group

Count Name                      Group
----- ----                      -----
 2275 &amp;lt;!-- --&amp;gt;                  {&amp;lt;!-- --&amp;gt;, &amp;lt;!-- --&amp;gt;, &amp;lt;!-- --&amp;gt;, &amp;lt;!-- --&amp;gt;…}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;問題ないようなので一括置換する。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;ls -Recurse -File *.md | ? {sls -Path $_.FullName -Pattern '^&amp;lt;!--.+--&amp;gt;'} | %{
    $file = $_.FullName
    (cat $file | ? {$_ -notmatch '^&amp;lt;!--.+--&amp;gt;'}) -join "`n" |
        Set-Content $file -NoNewline
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;この一括変換結果、1000 超のファイルの差分に問題ないか &lt;code&gt;git diff --word-diff&lt;/code&gt; で見る。流石に多いので変更をグルーピングして見た。全部同じ変換結果なら1つにまとまる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;git diff --word-diff | ? {$_ -match '\[(\+|-)'} | group
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;この置換により HTML コメント削除後は空行が 2 行になり、かつ文末の改行が消えてしまうが、後に行う Prettier で補修される(はず)。&lt;/p&gt;&lt;h3 id="5-の解消"&gt;5 の解消&lt;/h3&gt;&lt;p&gt;幸い、&lt;code&gt;class&lt;/code&gt; 属性なしの &lt;code&gt;code&lt;/code&gt; タグはなかった。&lt;/p&gt;&lt;p&gt;&lt;code&gt;&amp;lt;code class="${language}"&lt;/code&gt; → &lt;code&gt;```${language}&lt;/code&gt; 、 &lt;code&gt;&amp;lt;/code&amp;gt;&lt;/code&gt; → &lt;code&gt;```&lt;/code&gt; へ変換する。一緒にやるイメージがなかったので 2 回置換する。
同時に、&lt;code&gt;pre&lt;/code&gt; タグが変換されたことによる半角スペース 4 個 があると文章のインデントと合わず正しくレンダリングできないので、取り除く。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;ls -Recurse -File *.md | ? {sls -Path $_.FullName -Pattern '&amp;lt;code class='} | % {
    $file = $_.FullName
    (cat $file | % {
        $_ -replace '\s{0,4}&amp;lt;code class="(\w+)"&amp;gt;','```$1' `
           -replace '\s{0,4}&amp;lt;/code&amp;gt;','```'
    }) -join "`n" | Set-Content $file -NoNewline
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="2-の解消"&gt;2 の解消&lt;/h3&gt;&lt;p&gt;&lt;a href="https://prettier.io/"&gt;Prettier&lt;/a&gt; を使う。数年前から Markdown の整形に使っているのでそれに合わせる。&lt;/p&gt;&lt;p&gt;&lt;code&gt;ForEach-Object&lt;/code&gt; して 1 ファイルずつ &lt;code&gt;prettier&lt;/code&gt; を実行するとそこそこに遅い。 &lt;a href="https://en.wikipedia.org/wiki/Glob_(programming)"&gt;glob&lt;/a&gt; にまとめた方が速く実行できるので、ちょっとパターンが雑だがそのようにする。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;prettier --write "**/{$((
    ls -Recurse -File *.textile | select -ExpandProperty DirectoryName |
    Split-Path -Leaf | group | select -ExpandProperty Name ) -join ',')}/*.md"
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;が、先述のコマンドを実行したあとでPrettier 導入前から Markdown で書いていた古い日記もあまり綺麗でないことが判明した。
なので、全体的に整形してしまう。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;prettier --write .
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;このとき箇条書きの書き忘れが見つかった。後述するような箇条書きがあると、 &lt;code&gt;prettier&lt;/code&gt; に見出しと判断されてレイアウトが崩れるので、事前に手で取り除く。&lt;/p&gt;&lt;pre&gt;&lt;code class="txt"&gt;- Bad な bullet list
  -
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="最終チェック"&gt;最終チェック&lt;/h3&gt;&lt;p&gt;ココまで来たらもう大丈夫やろう、という感じで最終チェックしてたら、ココに来て痛恨のミス。
どうも箇条書き/順序付きリストの階層を誤っていると変換に失敗するようだった。
1 の解消のときに回収しきれていないかった。&lt;/p&gt;&lt;p&gt;before.&lt;/p&gt;&lt;pre&gt;&lt;code class="textile"&gt;** 壊れる箇条書きリスト
#### 壊れる順序付きリスト
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;after.&lt;/p&gt;&lt;pre&gt;&lt;code class="textile"&gt;壊れる箇条書きリスト

\#### 壊れる順序付きリスト
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;調べてみたら 50 ファイルくらい結構派手にぶち壊れている部分があった。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;ls -Recurse -File *.md | ? {sls -Path $_.FullName -Pattern '\\(\*|#)\s'} |
    select -ExpandProperty FullName
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これらは textile の段階から手直しし、 Textile → Markdown の変換からやり直す。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;ls -Recurse -File *.md | ? {sls -Path $_.FullName -Pattern '\\(\*|#)\s'} | % {
    pandoc `
        --from=textile --to=gfm+east_asian_line_breaks `
        --shift-heading-level-by=-4 --eol=lf `
        ($_.FullName -replace '.md','.textile') --output="$($_.FullName)"
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;この後で先に行っていた 2,3,5 の変換をすれば、期待の変換結果が得られた。&lt;/p&gt;&lt;h3 id="後始末"&gt;後始末&lt;/h3&gt;&lt;p&gt;最後に、残しておいた Textile を全て削除する。当然、削除対象が正しいことを確認した後に消す。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# Dry run.
rm * -Include *.textile -Recurse -WhatIf
# Execution.
rm * -Include *.textile -Recurse
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="まとめ"&gt;まとめ&lt;/h3&gt;&lt;p&gt;なかなか手間がかかったが、うまくできた。
今回の移行作業の中で、検知していない見落としもあるはずなので、そういうものは見つけたときに対処するものとする。&lt;/p&gt;&lt;p&gt;以下気づき。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Pandoc のオプションが大量にあり選ぶのが大変だが、おかげで期待する変換がしやすい
&lt;ul&gt;&lt;li&gt;2013 年位からちょくちょく使うがこんなにゴテゴテとオプションをつけたのは初めて&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;「息の長くなりそうなドキュメント」は事前にわからないので、普段からきれいなフォーマットにすれば、後々変換する機会があっても手間が省ける&lt;/li&gt;&lt;li&gt;プレーンテキストは正義&lt;/li&gt;&lt;li&gt;複数行またがるタイプの正規表現のパターン記述力が足りない&lt;/li&gt;&lt;li&gt;日記に事象と感情の変化をセットで書いていたので、あとから見ても面白い。自己分析に使えそう&lt;/li&gt;&lt;/ul&gt;</description><pubDate>Sat, 02 Apr 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-03-26-merge-blog-repo</guid><link>https://krymtkts.github.io/posts/2022-03-26-merge-blog-repo</link><title>Blog 用 Git repositories のマージ</title><description>&lt;p&gt;&lt;a href="/posts/2022-03-05-customize-cryogen"&gt;Cryogen の更新&lt;/a&gt; で 2 つに別れていた repo を統合できるようになったので、した。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/krymtkts.github.io"&gt;krymtkts/krymtkts.github.io&lt;/a&gt; に &lt;a href="https://github.com/krymtkts/blog-cryogen"&gt;krymtkts/blog-cryogen&lt;/a&gt; の歴史をすべて引き込む。&lt;/p&gt;&lt;p&gt;元は 1 つのコンテンツを 2 つに分けてるだけなので、統合は簡単だった。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;git switch --create feature/merge-repo

# Move existing blog contents.
mkdir docs
ls -Exclude docs | %{mv $_.Name ./docs }
git add .
git commit -m "Move blog files to 'docs'."
# Merge generator repo.
git remote add upstream ssh://git@krymtkts.github.com:krymtkts/blog-cryogen.git
git fetch upstream
git merge --allow-unrelated-histories upstream/master
# miscellaneous work.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;次に GitHub Pages の Source を &lt;code&gt;/docs&lt;/code&gt; に変えて表示確認する。
PR 作成後、GitHub Pages の対象 branch をマージ用の branch に向けて、 GitHub Actions による deploy を確認した。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;GitHub Pages の Source を &lt;code&gt;master&lt;/code&gt; の &lt;code&gt;/(root)&lt;/code&gt;-&amp;gt; &lt;code&gt;feature/merge-repo&lt;/code&gt; の &lt;code&gt;/docs&lt;/code&gt; に変えて deploy 確認&lt;/li&gt;&lt;li&gt;PR をマージ＆ branch を残す&lt;/li&gt;&lt;li&gt;GitHub Pages の Source を &lt;code&gt;feature/merge-repo&lt;/code&gt; の &lt;code&gt;/docs&lt;/code&gt; -&amp;gt; &lt;code&gt;master&lt;/code&gt; の &lt;code&gt;/docs&lt;/code&gt; に変えて deploy 確認&lt;/li&gt;&lt;li&gt;&lt;code&gt;feature/merge-repo&lt;/code&gt; を消す&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;branch を消したときに自動で Source を追随してくれんのかも知れんが、 壊れたら面倒なので 1 手順ずつ確認した。&lt;/p&gt;&lt;p&gt;スッキリした。&lt;/p&gt;</description><pubDate>Sat, 26 Mar 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-03-19-useful-usafe-of-gist-permalink</guid><link>https://krymtkts.github.io/posts/2022-03-19-useful-usafe-of-gist-permalink</link><title>Gist の便利な使い方 ~ Permalink</title><description>&lt;p&gt;今更ながら最近知った。 Gist の Raw コンテンツの URL からコミットハッシュを取り除けば常に最新のリビジョンへの Permalink になる。&lt;/p&gt;&lt;p&gt;&lt;a href="https://stackoverflow.com/questions/16589511/how-do-i-get-the-raw-version-of-a-gist-from-github/16589638#16589638"&gt;How do I get the raw version of a gist from github? - Stack Overflow&lt;/a&gt;&lt;/p&gt;&lt;p&gt;これを使えば、ローカルで patch を当てるのにめちゃくちゃ役に立つと気づいた。
ダウンロードの保存先を patch したいコード直にしたらそれで終わり。
patch を当てたいファイルの数だけ Gist 作らなあかんやんけ、というのはあれど、あまりに多い場合は Gist の中に複数ファイル置くとかかな。まだその規模まで届いてないのでそこはまあよい。&lt;/p&gt;&lt;p&gt;これとか。 &lt;a href="https://krymtkts.github.io/posts/2021-08-30-patch-to-vscode-extension"&gt;VS Code の拡張機能に ローカル patch する&lt;/a&gt;&lt;/p&gt;&lt;p&gt;メンテナがもう活動してないっぽくて PR がマージされることもないので、ローカル patch するのが手っ取り早い。&lt;/p&gt;&lt;p&gt;Gist に変更対象のコードを置いて、こういう関数を作りまして、実行すればパッチが完了する。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function Edit-EverMonkey {
    $evermonkey = '~\.vscode\extensions\michalyao.evermonkey-2.4.5'
    if (-not $evermonkey) {
        Write-Verbose 'There is no evermonkey.'
        return
    }
    $params = @{
        Uri     = 'https://gist.githubusercontent.com/krymtkts/8a5a3a5a7e1efe9db7f2c6bbda337571/raw/converterplus.js'
        OutFile = "$evermonkey\out\src\converterplus.js"
    }
    Invoke-WebRequest @params
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;あとこれ。&lt;a href="/posts/2021-07-11-my-terminal-icons"&gt;Terminal-Icons のアイコングリフのコードポイントを変えたい&lt;/a&gt;&lt;/p&gt;&lt;p&gt;version up の度にいっつも自分用グリフを上書きしてるけど、それが楽になる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function Edit-TerminalIcons {
    $ti = Get-Module Terminal-Icons -ErrorAction SilentlyContinue
    if (-not $ti) {
        Write-Error 'Terminal-Icons not found. install it!'
        return
    }
    $params = @{
        Uri     = 'https://gist.githubusercontent.com/krymtkts/4457a23124b2db860a6b32eba6490b03/raw/glyphs.ps1'
        OutFile = "$(Split-Path $ti.Path -Parent)\Data\glyphs.ps1"
    }
    Invoke-WebRequest @params
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;他に PowerShell の profile も Gist で管理しているので、複数の端末間で共有するのに使っている。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function Update-Profile {
    $profilehome = ($PROFILE | Split-Path -Parent)
    $params = @{
        Uri     = 'https://gist.githubusercontent.com/krymtkts/f8af667c32b16fc28a815243b316c5be/raw/Microsoft.PowerShell_profile.ps1'
        OutFile = "$profilehome/Microsoft.PowerShell_profile.ps1"
    }
    Invoke-WebRequest @params

    if (-not (Test-Path "$profilehome\Microsoft.VSCode_profile.ps1")) {
        New-Item -ItemType HardLink -Path $profilehome -Name 'Microsoft.VSCode_profile.ps1' -Value "$profilehome\Microsoft.PowerShell_profile.ps1"
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;便利だ。&lt;/p&gt;</description><pubDate>Sat, 19 Mar 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-03-13-create-huge-text-file-in-pwsh</guid><link>https://krymtkts.github.io/posts/2022-03-13-create-huge-text-file-in-pwsh</link><title>PowerShell でクソデカテキストファイルを作る</title><description>&lt;p&gt;先日、クソデカテキストファイルを作成しなければならない場面があり、以下のスクリプトをしたためた。
Windows なので単にサイズが大きいだけのファイルなら &lt;code&gt;fsutil createnew&lt;/code&gt; を使えるけど、クソデカテキストファイルを作る手段は知らなかったからだ。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Set-Content kusodeka.txt -Encoding ascii -NoNewline -Value ('x' * [Math]::Pow(1024, 3))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;このスクリプト、 Out of Memory でエラー終了する。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; Set-Content kusodeka.txt -Encoding ascii -NoNewline -Value ('x' * [Math]::Pow(1024, 3))
OperationStopped: Exception of type 'System.OutOfMemoryException' was thrown.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;どうも文字列の確保できる最大サイズの制限みたい。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; 'x' * [Math]::Pow(1024, 3) | Out-Null
OperationStopped: Exception of type 'System.OutOfMemoryException' was thrown.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;↓ のサイズならいける。 1GB - 32B からはエラーになる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;'x' * ([Math]::Pow(1024, 3)-33) | Out-Null
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;答えは.NET の&lt;code&gt;String&lt;/code&gt;クラスのドキュメントに書いてた →&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.string?redirectedfrom=MSDN&amp;amp;view=net-6.0"&gt;String Class (System) | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The maximum size of a String object in memory is 2-GB, or about 1 billion characters.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;2GB には到底届いてないし、今回引っかかってるのは後者か。
ほーん、という感じ。最大の文字列長とか考えたこともなかったわ。&lt;/p&gt;&lt;p&gt;因みにこの最大文字数の超過エラーを回避してクソデカテキストファイルを作るには、以下のようにデータを分割して小分けに書き込みする必要がある。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;1..1024 | Add-Content kusodeka.txt -Encoding ascii -NoNewline -Value ('x' * [Math]::Pow(1024, 2))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ついでに調べた PowerShell の配列の上限は、添字の型であろう &lt;code&gt;int&lt;/code&gt; の範囲っぽいがドキュメントは見当たらなかった。これはまた PowerShell のソースコードでも読むか。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# いける
[int]::MinValue..[int]::MaxValue | Out-Null

# いけない(int の演算エラーかこれ)
[int]::MinValue..([int]::MaxValue + 1) | Out-Null
# &amp;gt; OperationStopped: Value was either too large or too small for an Int32.

# いけない(カッコで評価されちゃい overflow か)
([int]::MinValue..[int]::MaxValue) | Out-Null
# OperationStopped: Arithmetic operation resulted in an overflow.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;世の中まだ知らないことがいっぱいあるもんやなあ。&lt;/p&gt;&lt;h3 id="2022-03-15-追記"&gt;2022-03-15 追記&lt;/h3&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# これが限界ぽい。
(1..2147483591) | Out-Null

(1..2147483592) | Out-Null
# OperationStopped: Array dimensions exceeded supported range.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;でエラー。この場合ちゃんと Array の range の問題だとエラーに出る。
カッコを入れてなかったら評価が端折られて期待の振る舞いをしていなかった。&lt;/p&gt;&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.array?view=net-6.0#remarks"&gt;Array Class (System) | Microsoft Docs&lt;/a&gt; に記載のカッコの中に該当するわけやな。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The array size is limited to a total of 4 billion elements, and to a maximum index of 0X7FEFFFFF in any given dimension (0X7FFFFFC7 for byte arrays and arrays of single-byte structures).&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code class="powershell"&gt;[long]::Parse('7FFFFFC7',[System.Globalization.NumberStyles]::HexNumber)
# 2147483591
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;いやー、スッキリした！&lt;/p&gt;</description><pubDate>Sun, 13 Mar 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-03-05-customize-cryogen</guid><link>https://krymtkts.github.io/posts/2022-03-05-customize-cryogen</link><title>Cryogen のカスタマイズ</title><description>&lt;p&gt;&lt;a href="/posts/2022-02-27-issue-with-cryogen-version-bump"&gt;前回の投稿&lt;/a&gt;で、 &lt;a href="https://cryogenweb.org/"&gt;Cryogen&lt;/a&gt; のバージョンアップに伴い Cryogen 自体のカスタマイズが必要だとを書いた。&lt;/p&gt;&lt;p&gt;カスタマイズ自体はかなり簡単にできたのだが、 Clojure 経験不足だからか正直なところドキュメントの記載だけではピンと来なかった。
ということで、またわからなくなること必至のため記しておく。&lt;/p&gt;&lt;p&gt;&lt;code&gt;cryogen-core&lt;/code&gt; のバージョンは &lt;code&gt;0.4.1&lt;/code&gt; だ。&lt;/p&gt;&lt;p&gt;対象のドキュメント &lt;a href="https://cryogenweb.org/docs/customizing-cryogen.html#customizing-the-code"&gt;Cryogen: Customizing/Extending Cryogen&lt;/a&gt; を以下に全文引用する。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;You can copy the &lt;code&gt;cryogen-core.compiler&lt;/code&gt; namespace directly into your project (where it will override the one from the cryogen-core.jar) and modify it to your liking. It is not very long or complicated and is quite easy to modify. That is &lt;a href="https://github.com/cryogen-project/cryogen-docs/blob/fd601c857cc88f7cb633a41c47b4c692e1522ed8/src/cryogen/compiler.clj"&gt;what we did for this site&lt;/a&gt; (although it uses a much older version of cryogen-core, you may still use the same strategy today).&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;機械翻訳にリンクを添えた ↓&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;cryogen-core.compiler&lt;/code&gt; 名前空間をプロジェクトに直接コピーし（cryogen-core.jar のものを上書きします）、好みに応じて変更することができます。これはそれほど長くもなく、複雑でもなく、非常に簡単に修正することができます。このサイトでは、&lt;a href="https://github.com/cryogen-project/cryogen-docs/blob/fd601c857cc88f7cb633a41c47b4c692e1522ed8/src/cryogen/compiler.clj"&gt;このような方法&lt;/a&gt;をとっています（かなり古いバージョンの cryogen-core を使用していますが、現在でも同じ方法をとることができます）。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;早い話が「Cryogen の公式ページのコードを真似ろ」。&lt;/p&gt;&lt;p&gt;はじめはナンノコッチャと思ったのだけど、Cryogen の repo のコードを眺めて「&lt;a href="https://github.com/cryogen-project/cryogen-core/blob/31bcbfdad59e8eaed4a6d417682e51ef1e90982c/src/cryogen_core/compiler.clj"&gt;&lt;code&gt;cryogen_core/compiler.clj&lt;/code&gt;&lt;/a&gt;をコピって自分でサイトジェネレータを書いたらええんやで？」だと理解した。&lt;/p&gt;&lt;p&gt;Cryogen のエントリポイントは &lt;code&gt;cryogen/core.clj&lt;/code&gt; と &lt;code&gt;cryogen/server.clj&lt;/code&gt; があるが、いずれもサイトジェネレータは &lt;code&gt;cryogen-core.compiler&lt;/code&gt; 名前空間の &lt;code&gt;compile-assets-timed&lt;/code&gt; を呼び出してるだけなので、これを &lt;code&gt;cryogen_core/compiler.clj&lt;/code&gt; からコピった自分用ジェネレータに変える、という趣旨らしい。&lt;/p&gt;&lt;p&gt;とった手順は以下の通り。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href="https://github.com/cryogen-project/cryogen-core/blob/31bcbfdad59e8eaed4a6d417682e51ef1e90982c/src/cryogen_core/compiler.clj"&gt;&lt;code&gt;cryogen_core/compiler.clj&lt;/code&gt;&lt;/a&gt; をコピって自分のサイトのコードに &lt;code&gt;src/cryogen/compiler.clj&lt;/code&gt; として配置する&lt;/li&gt;&lt;li&gt;&lt;code&gt;src/cryogen/compiler.clj&lt;/code&gt; を自分の必要な形に書き換える
&lt;ul&gt;&lt;li&gt;今回デフォルトの Cryogen から変えたかったのは、 RSS フィードの要約機能を取り除いて HTML 全文載せるようにすることだった&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/cryogen-project/cryogen-core/blob/31bcbfdad59e8eaed4a6d417682e51ef1e90982c/src/cryogen_core/compiler.clj#L474-L487"&gt;&lt;code&gt;add-description&lt;/code&gt;&lt;/a&gt; 関数の中で利用されている &lt;code&gt;util/enlive-&amp;gt;plain-text&lt;/code&gt; を &lt;code&gt;util/enlive-&amp;gt;html-text&lt;/code&gt; に変更、&lt;code&gt;add-description&lt;/code&gt; に依存する関数 &lt;code&gt;compile-assets&lt;/code&gt;, &lt;code&gt;compile-assets-timed&lt;/code&gt; を &lt;code&gt;cryogen.compiler&lt;/code&gt; に定義した&lt;/li&gt;&lt;li&gt;それ以外の関数は &lt;code&gt;cryogen-core.compiler&lt;/code&gt; を参照する&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;cryogen/core.clj&lt;/code&gt; と &lt;code&gt;cryogen/server.clj&lt;/code&gt; で、 &lt;code&gt;compile-assets-timed&lt;/code&gt; の名前空間を &lt;code&gt;cryogen-core.compiler&lt;/code&gt; → &lt;code&gt;cryogen.compiler&lt;/code&gt; に変える&lt;/li&gt;&lt;li&gt;&lt;code&gt;lein serve&lt;/code&gt; してエラーがない＆期待の出力になっていれば完了&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;これで概ね自分が期待する出力を得られるようになった(はず)。
気付かないところで破壊的な変更をしているかも知れないので、それは経過観測していく。この投稿をした後で RSS フィードが本当に届くか心配だ。&lt;/p&gt;&lt;p&gt;あと既知の問題として、新たに追加された &lt;code&gt;lein serve:fast&lt;/code&gt; がちゃんと動いてんのかこれ？ であったり、 Markdown 保存時の再生成が怪しかったりする。
これらは、ちまちま直していきたい。&lt;/p&gt;&lt;p&gt;これで repo の統合だったり GitHub Action 化が見えてきた。&lt;/p&gt;</description><pubDate>Sat, 05 Mar 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-02-27-issue-with-cryogen-version-bump</guid><link>https://krymtkts.github.io/posts/2022-02-27-issue-with-cryogen-version-bump</link><title>Cryogen バージョンアップに伴う困りごと</title><description>&lt;p&gt;このブログを作るのに &lt;a href="https://github.com/cryogen-project/cryogen"&gt;Cryogen&lt;/a&gt; を利用している。
作った当初から一切のバージョンアップをしていなかったのだが、先週からちまちま手を動かし始めた。&lt;/p&gt;&lt;p&gt;最近の Cryogen では出力先のディレクトリを指定できる様になっているので、 &lt;code&gt;docs&lt;/code&gt; 出力するようにすれば今 &lt;a href="https://github.com/krymtkts/blog-cryogen"&gt;krymtkts/blog-cryogen&lt;/a&gt; と &lt;a href="https://github.com/krymtkts/krymtkts.github.io"&gt;krymtkts/krymtkts.github.io&lt;/a&gt; の 2 つに別れている repo を統合できる。
そも、出力結果を repo の管理下に置かず Github Actions で済ます選択もできるようになるんじゃないかな。&lt;/p&gt;&lt;p&gt;新しい Cryogen では雛形のディレクトリ構造が変わっているのだが、このバージョンアップによるマイグレーション自体は大したことはない。雑に言えば以下のタスクがあるだけだ。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;新しい Cryogen で雛形を作成する
&lt;ul&gt;&lt;li&gt;雛形に含まれるポストや利用しないテーマ等を取り除いておく&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;既存のコンテンツとテーマを 1 に移動する
&lt;ul&gt;&lt;li&gt;&lt;code&gt;resources\templates\themes&lt;/code&gt; -&amp;gt; &lt;code&gt;themes&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;resources\templates\img&lt;/code&gt; -&amp;gt; &lt;code&gt;content\img&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;resources\templates\md&lt;/code&gt; -&amp;gt; &lt;code&gt;content\md&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;config.edn&lt;/code&gt; 新しいパラメータに書き換える&lt;/li&gt;&lt;li&gt;&lt;code&gt;lein serve&lt;/code&gt; で出力して確認&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;一通り手を動かしてみて、tag へのリンクが壊れたりの細かいバグはあったが、概ね破壊的な変更なく OK やなというところまではできた。&lt;/p&gt;&lt;p&gt;ところが困ったことに、RSS Feed の出力だけは大きく変わってしまうのを避けられなかった。どうも新しい Cryogen では RSS Feed への出力は要約だけにする仕様に変わったらしい。
ワークアラウンドとして、&lt;code&gt;config.edn&lt;/code&gt; の &lt;code&gt;blocks-per-preview&lt;/code&gt; の数値を大きくすれば要約に全文を含めることはできる。でもそれまで可能だった HTML での埋め込みはできなくなってしまった。
&lt;a href="https://github.com/cryogen-project/cryogen/issues/241"&gt;RSS feed: only publishes article's "summary" · Issue #241 · cryogen-project/cryogen&lt;/a&gt;&lt;/p&gt;&lt;p&gt;コード的にこの辺。 ページの &lt;code&gt;description&lt;/code&gt; が Feed に出力されるのだが、 plain text 以外の選択肢がない。なんでや。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/cryogen-project/cryogen-core/blob/31bcbfdad59e8eaed4a6d417682e51ef1e90982c/src/cryogen_core/compiler.clj#L474-L487"&gt;cryogen-core/compiler.clj at 31bcbfdad59e8eaed4a6d417682e51ef1e90982c · cryogen-project/cryogen-core&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;(defn add-description
  "Add plain text `:description` to the page/post for use in meta description etc."
  [{:keys [blocks-per-preview description-include-elements]
    :or   {description-include-elements #{:p :h1 :h2 :h3 :h4 :h5 :h6}}}
   page]
  (update
    page :description
    #(cond
       (false? %) nil  ;; if set via page meta to false, do not set
       % %    ;; if set via page meta, use it
       :else (-&amp;gt;&amp;gt; (enlive/select
                    (preview-dom blocks-per-preview (:content-dom page))
                    [(set description-include-elements)])
                  (util/enlive-&amp;gt;plain-text)))))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href="https://github.com/cryogen-project/cryogen-core/blob/31bcbfdad59e8eaed4a6d417682e51ef1e90982c/src/cryogen_core/util.clj#L38-L41"&gt;cryogen-core/util.clj at 31bcbfdad59e8eaed4a6d417682e51ef1e90982c · cryogen-project/cryogen-core&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;(defn enlive-&amp;gt;plain-text [node-or-nodes]
  (-&amp;gt;&amp;gt; node-or-nodes
       (enlive/texts)
       (apply str)))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;RSS リーダー利用者としての個人的な意見だが、正直なところ技術ブログなんかであれば全文マークアップ可能な状態で配信してほしい。割と RSS リーダーだけ読んで済ませることも多い。
最近はフィードに全文載っけないのが主流ぽくはあるが、これは多分広告表示とかアクセス解析のためにサイトを訪れてほしいからであって、そういう動機がないのであれば全文配信しない理由がない。&lt;/p&gt;&lt;p&gt;なのでわたしのブログもそのようにしていたのだけど、このバージョンアップでそれができなくなるのは個人的にちょっと受け入れられないと判断した。
RSS リーダーでこのブログを購読する最有力ユーザはわたし自身なので、自分の意見が一番えらい。&lt;/p&gt;&lt;p&gt;現状だとどうしようないのだが、 Cryogen 自体に手を入れることができるのでそれをやってみようとしている。&lt;/p&gt;&lt;p&gt;&lt;a href="https://cryogenweb.org/docs/customizing-cryogen.html#customizing-the-code"&gt;Cryogen: Customizing/Extending Cryogen - Customizing the code&lt;/a&gt;&lt;/p&gt;&lt;p&gt;続く。&lt;/p&gt;</description><pubDate>Sun, 27 Feb 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-02-19-i-cant-graduate-from-tortoise-git</guid><link>https://krymtkts.github.io/posts/2022-02-19-i-cant-graduate-from-tortoise-git</link><title>Tortoise Git から卒業できない</title><description>&lt;p&gt;今どきの Git の使い手は、 「CLI で使ってない奴はニワカ」みたいな硬派な人とか、&lt;a href="https://www.gitkraken.com/"&gt;GitKraken&lt;/a&gt; とかのイケてる Git クライアントや VS Code で &lt;a href="https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens"&gt;GitLens&lt;/a&gt; やら &lt;a href="https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph"&gt;Git Graph&lt;/a&gt; 使ってる勢なんじゃないだろうか。&lt;/p&gt;&lt;p&gt;わたしは長らく &lt;a href="https://tortoisegit.org/"&gt;TortoiseGit&lt;/a&gt; から卒業できないでいる。&lt;/p&gt;&lt;p&gt;コミットやログ、ブランチやリセットやマージ等諸々の基本的な操作は全部 CLI でやるが、ある操作だけは TortoiseGit でやるのが楽過ぎて手放せないでいる。それは歴史の改竄だ。&lt;/p&gt;&lt;p&gt;わたしも VS Code ユーザなので、勿論 GitLens やら Git Graph を使ったことはある。
だが、殊この歴史の改竄については Tortoise Git を超えてない(機能を知らんだけかも知らんが)。
&lt;a href="https://github.com/jesseduffield/lazygit"&gt;jesseduffield/lazygit&lt;/a&gt; だけはわたしの要求を満たせそうな素晴らしいツールに感じたのだが、 &lt;a href="https://github.com/microsoft/terminal"&gt;Windows Terminal&lt;/a&gt; で利用すると&lt;code&gt;┐&lt;/code&gt;とかの描画幅がワイド判定されて画面がクチャクチャになってしまう(わたしが pwsher でなくコマンドプロンプターならバッチリはまったであろうツールだ)。&lt;/p&gt;&lt;p&gt;具体的に言うと、 &lt;a href="https://tortoisegit.org/docs/tortoisegit/tgit-dug-cherrypick.html"&gt;Cherry picking&lt;/a&gt; がめちゃくちゃ便利でずっと使ってるのだけど、みんな歴史を改竄しないのだろうか。
わたしが歴史を改竄するのは、まだ一度もリモートに push していないローカルで育てたブランチを、デビュー前に清書するためだ。ローカルで思いのままに吐き散らしたコミット粒度及びログを、push 前に整えるのはプログラマの嗜みだ。&lt;/p&gt;&lt;p&gt;使用例は以下の通り。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;思いのままにコミットを積み上げる&lt;/li&gt;&lt;li&gt;リセット前にタグを打つ&lt;/li&gt;&lt;li&gt;push 用のブランチをベースブランチにリセットする&lt;/li&gt;&lt;li&gt;思いのままに積み上げたコミットを丁寧に cherry pick し、公開するに適切なコミット粒度・コミットログへ書き換える&lt;/li&gt;&lt;li&gt;タグを打った元の状態と差分がないことを確認した後でめでたく push&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;重要なのは 3、ここでコミットの順番を入れ替えたりまとめたり分割したりという操作をするが、Tortoise Git 以外ではこういうことができないように見える。流行り？の GitKraken でさえこの有様 → &lt;a href="https://feedback.gitkraken.com/suggestions/191932/add-support-for-splitting-an-existing-commit"&gt;Add support for splitting an existing commit - GitKraken&lt;/a&gt;
え、分割できへんの！？的な。&lt;/p&gt;&lt;p&gt;最近見た限りだと、GitLens や Git Graph では reset したコミット以降の変更を 1 コミットにまとめるとかはできるっぽかった。でもそういうのがしたいわけじゃない。もっと派手にやりたいんじゃ！&lt;/p&gt;&lt;p&gt;1 で思いのままにコミットを積み上げる等言語道断という意見もあろうが、都度〃やった内容をペコペココミットするリズム感がほしいので結局こうやってしまう。みんないちいちコミットの粒度を頭に入れた上で、アソコを直してココを直して...とかやってるのだろうか。多分やってないでしょう。&lt;/p&gt;&lt;p&gt;より良い歴史改竄体験を求めて別のツールを探してみたいが、ググった感じだと派手な歴史改竄機能がみられず、あんまりみんなやらないっぽいのではと思っている。みんな素直に &lt;code&gt;git rebase --interactive&lt;/code&gt;(Interactive Rebasing) してるんだろうきっと。&lt;/p&gt;&lt;p&gt;あーあとひとつ重要な機能を忘れていた。 &lt;a href="https://github.com/dahlbyk/posh-git"&gt;dahlbyk/posh-git&lt;/a&gt; を使っていると &lt;a href="https://github.com/dahlbyk/posh-git/wiki/Posh--Git-Module-Functions"&gt;&lt;code&gt;tgit&lt;/code&gt;&lt;/a&gt; という素敵な関数が提供されることでより一層 Tortoise Git から離れにくくなる。 &lt;code&gt;tgit&lt;/code&gt; は Tortoise Git の任意の機能を召喚する魔法の関数なのだ。
この珍妙な関数を使うせいで、ペアプロ時に「あ！コマンド間違ってますよ！」と言われたこともあるが、便利なんだから仕方がない。勿論 Tab 補完もついている。&lt;/p&gt;&lt;p&gt;もうここまで沼に飲まれていると使い続ければ良いのでは...という気もしないではないが、より良いツールが出てきたらぜひ乗り換えたい。あるいは全部 CLI に寄せるか。
未来の自分に託した。&lt;/p&gt;</description><pubDate>Sat, 19 Feb 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-02-12-publish-to-powershell-gallery-etc</guid><link>https://krymtkts.github.io/posts/2022-02-12-publish-to-powershell-gallery-etc</link><title>PoweShell Gallery へ公開するためのステップ覚書</title><description>&lt;p&gt;タイトルの通り。これは未来の自分へのバトンだ。&lt;/p&gt;&lt;p&gt;毎回 PoweShell Gallery への公開方法を忘れたりする。 &lt;a href="/tags/powershellgallery"&gt;弊ブログの&lt;code&gt;powershellgallery&lt;/code&gt;タグ&lt;/a&gt;を参照すればどれだけ同じミスを繰り返してるかアホさがわかる。
加えて &lt;a href="https://github.com/microsoft/PowerShellForGitHub"&gt;microsoft/PowerShellForGitHub&lt;/a&gt; で repo を作るのもしょっちゅう忘れる。
こちらに関してはもうそろそろ &lt;a href="https://github.com/cli/cli"&gt;&lt;code&gt;gh&lt;/code&gt;&lt;/a&gt;に乗り換えた方がいいのかも知れん。(けど、そうすると PowerShell の旨味であるオブジェクトでゴニョゴニョやりやすい世界がなくなってしまうのは困る)&lt;/p&gt;&lt;p&gt;なのでこれらを定型化して &lt;code&gt;psake&lt;/code&gt; タスクに落とし込む等したいな～と考えている(今度はその&lt;code&gt;psake&lt;/code&gt;タスクが秘伝のソース化するかも知れんがそれはそれ)。
そのためにいつも何をやっているかを以下にリストアップする。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;前提。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;PSMFAttendance&lt;/code&gt; の作成時にやったことを踏まえている&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/x-motemen/ghq"&gt;ghq&lt;/a&gt; を使っている前提&lt;/li&gt;&lt;li&gt;MS 公式文書はこちら &lt;a href="https://docs.microsoft.com/en-us/powershell/scripting/gallery/concepts/publishing-guidelines?view=powershell-7.2"&gt;PowerShell Gallery Publishing Guidelines and Best Practices - PowerShell | Microsoft Docs&lt;/a&gt;&lt;ul&gt;&lt;li&gt;残念ながら過去のメモ(&lt;a href="https://github.com/krymtkts/Get-GzipContent"&gt;krymtkts/Get-GzipContent&lt;/a&gt;を公開したとき)からは URL が変わっていた。今回はどうかな。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="step-1-repo-とモジュールマニフェストの作成"&gt;Step 1. repo とモジュールマニフェストの作成&lt;/h3&gt;&lt;p&gt;まず最初のステップはモジュールの雛形作成。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# create repo.
$owner = 'krymtkts'
$module = 'PSMFAttendance'
New-GitHubRepository -RepositoryName $module -Private -LicenseTemplate MIT
ghq get -p (Get-GitHubRepository -OwnerName krymtkts -RepositoryName $module | Select-Object -ExpandProperty ssh_url)
cd "$(ghq root)/$(ghq list $module)"

# create module manifest.
mkdir $module
$author = 'Takatoshi Kuriyama'
New-ModuleManifest -Path "./$module/$module.psd1" -ModuleVersion 1.0 -Author $author -Copyright "(c) $((get-date).Year) $author. All rights reserved."
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;PowerShell Gallery への公開コマンド &lt;a href="https://docs.microsoft.com/en-us/powershell/module/powershellget/publish-module?view=powershell-7.2"&gt;&lt;code&gt;Publish-Module&lt;/code&gt; (PowerShellGet)&lt;/a&gt; は、指定したディレクトリの中身を全部 PowerShell Gallery にぶち上げるため、モジュール以外のファイルを配置していても全て雲の上に持っていかれてしまう(除外設定がないのだ)。
そういう事故を起こさないためにも、モジュールリリース用のディレクトリを作成することをおすすめする。
そこでモジュールを開発するか、リリース対象のコードをそこにコピーした上で公開する、というのに限るのではないだろうか。わたしはコピーしたあとの掃除とか考えるのが面倒なので前者。&lt;/p&gt;&lt;p&gt;先にモジュールマニフェストを作るのは、動作確認なんかで関数がエクスポートできているか見るのに使うからだ。&lt;/p&gt;&lt;h3 id="step-2-モジュールマニフェストの更新"&gt;Step 2. モジュールマニフェストの更新&lt;/h3&gt;&lt;p&gt;次は実装して、マニフェストの更新。
マニフェストに記すべき内容については公式のドキュメントを読むのが良い。&lt;/p&gt;&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/powershell/scripting/gallery/how-to/publishing-packages/publishing-a-package?view=powershell-7.2#required-metadata-for-items-published-to-the-powershell-gallery"&gt;Creating and publishing an item - PowerShell | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;とはいえわたしは大したモジュールを作らないのもあり、いつも更新するのは限られたフィールドだけだ。主に以下。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;Description&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;PowerShellVersion&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;*ToExport&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;PrivateData.PSData.Tags&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;PrivateData.PSData.LicenseUri&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;PrivateData.PSData.ProjectUri&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;この中でわかりにくいのが、互換性のあるプラットフォームの指定。これは &lt;code&gt;Tags&lt;/code&gt; で表す。
&lt;a href="https://docs.microsoft.com/en-us/powershell/scripting/gallery/concepts/publishing-guidelines?view=powershell-7.2#tag-your-package-with-the-compatible-pseditions-and-platforms"&gt;PowerShell Gallery Publishing Guidelines and Best Practices - PowerShell | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;マニフェストの更新は手で書いてもよいが、&lt;code&gt;Update-ModuleManifest&lt;/code&gt; も使える。
ただし &lt;code&gt;New-ModuleManifest&lt;/code&gt; と &lt;code&gt;Update-ModuleManifest&lt;/code&gt; で出力結果のフォーマットが異なる(後者はインデントされない)のがイライラするので、手でやることが多いか。
ただ自動化していくとすれば、ここは &lt;code&gt;Update-ModuleManifest&lt;/code&gt; に従うところか(こいつインデントしてくれへんのだが)。&lt;/p&gt;&lt;h3 id="last-step-powershell-gallery-公開"&gt;Last Step. PowerShell Gallery 公開&lt;/h3&gt;&lt;p&gt;最後は PowerShell Gallery への公開だ。&lt;/p&gt;&lt;p&gt;PowerShell Gallery への公開を実施する前に、API キーの期限が切れていないか必ずチェックしておく。
キーの有効期限が切れている場合のエラーが非常にわかりにくいので、無駄にトラシューに時間を費やさずに済ますためにも公開前にチェック兼ねて毎回キーを更新するのが妥当では？
API キーの有効期限は最長 1 年しかないので、しょっちゅう切らしている。むしろ公開前に更新するフローであれば、期限も最短にできるのでよりセキュアかも知れない。&lt;/p&gt;&lt;p&gt;API キー はモジュール名に対して &lt;a href="https://en.wikipedia.org/wiki/Glob_(programming)"&gt;glob パターン&lt;/a&gt;でスコープを切れる。過去には面倒を回避するために&lt;code&gt;*&lt;/code&gt;パターンを使ったりしていたが、今はパッケージ名の完全一致を利用していて、パッケージ毎に API キーを分けるようにしている。&lt;/p&gt;&lt;p&gt;公開の手順は &lt;a href="https://github.com/krymtkts/Get-GzipContent"&gt;krymtkts/Get-GzipContent&lt;/a&gt;を公開したときスクリプトを使う。&lt;/p&gt;&lt;p&gt;このスクリプトでは &lt;code&gt;PSScriptAnalyzer&lt;/code&gt; を使ったチェックが成功した後に公開する。
また、&lt;code&gt;WhatIf&lt;/code&gt; は Dry Run として置き換えた上で使うようにしていた。
&lt;code&gt;WhatIf&lt;/code&gt; を使わないことで覚えることが増えて面倒な気もするが、とにかく間違って公開すると面倒なので、初期値を Dry Run にしたいという意図だった(多分)。この辺は &lt;a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-shouldprocess?view=powershell-7.2"&gt;&lt;code&gt;ShouldProcess&lt;/code&gt;&lt;/a&gt; の勉強をしたらより良い案があるかも知れん。&lt;/p&gt;&lt;p&gt;PowerShell Gallery でのバージョニングは基本的に Semantic Versioning なので、何かしらミスったらモジュールの非公開はできるけど、同じバージョンへの更新はできない。パッチバージョンを上げて再公開とかしかできない。これはミスったら恥ずかしいしやり直しがきかないから、 Dry Run しまくる。この「何かしらミスったら」を Pester とかで事前チェックできると良いのだろうけど。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Param (
    [String]$ApiKey,
    [ValidateSet('Publish', 'DryRun')]$Mode = 'DryRun'
)

$ModuleName = Get-ChildItem -File -Path ./ -Recurse -Name '*.psd1' | Split-Path -Parent
$ArtifactPath = ".\$ModuleName\"
Write-Host "Check modules under $ArtifactPath."

$report = Invoke-ScriptAnalyzer -Path "$ArtifactPath" -Recurse -Settings PSGallery
if ($report) {
    Write-Host "Violation found."
    $report
    exit
}
Write-Host "Check passed."

switch ($Mode) {
    'Publish' {
        Write-Host "Publishing module: $ModuleName"
        Publish-Module -Path $ArtifactPath -NugetAPIKey $ApiKey -Verbose
    }
    'DryRun' {
        Write-Host "[DRY-RUN]Publishing module: $ModuleName"
        Publish-Module -Path $ArtifactPath -NugetAPIKey $ApiKey -Verbose -WhatIf
    }
}
if ($?) {
    Write-Host 'Successfully published.'
}
else {
    Write-Error 'Failed to publish.'
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;今改めて見るとこのスクリプト、API キーは Credential に変更した方がマトモだ。ぜひ対応したい。&lt;/p&gt;&lt;p&gt;このように使う。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;.\publish.ps1 -Mode DryRun -ApiKey xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

.\publish.ps1 -Mode Publish -ApiKey xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;公開後は最終チェック、自端末へモジュールをインストールして一通り使えるか見ている。何しかちゃんと出来てるか不安。&lt;/p&gt;&lt;p&gt;公開できたら、 repo の&lt;code&gt;README.md&lt;/code&gt; に以下を加筆する。これは流石に自動化無理なのでいいや。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;PowerShell Gallery からのインストール方法&lt;/li&gt;&lt;li&gt;&lt;a href="https://shields.io/category/downloads"&gt;Shields.io&lt;/a&gt; の PowerShell Gallery のダウンロード&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;終。&lt;/p&gt;&lt;hr /&gt;&lt;h3 id="おわりに"&gt;おわりに&lt;/h3&gt;&lt;p&gt;手順起こしてみてあれやけど、これもうすぐにでも &lt;code&gt;psake&lt;/code&gt; タスク化できそう。単にサボってただけだったか...&lt;/p&gt;</description><pubDate>Sat, 12 Feb 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-02-06-back-to-old-context-menu-in-win-11-pwsh</guid><link>https://krymtkts.github.io/posts/2022-02-06-back-to-old-context-menu-in-win-11-pwsh</link><title>Windows11 のコンテキストメニューを前のんに戻す(PowerShell で)</title><description>&lt;p&gt;Windows11 にてコンテキストメニューの UI が変わった。
しかし自身は普段コンテキストメニューを使わないのであまり気にならなかった。&lt;/p&gt;&lt;p&gt;のだが、たまたま 7z 圧縮されたファイルを渡されたことで、右クリックで 7zip で開けないのクソめんどい...と気になり始めた。
なので前のコンテキストメニューに戻す。PowerShell で。&lt;/p&gt;&lt;p&gt;レジストリを編集する必要があるらしい。情報元 ↓
&lt;a href="https://www.tomshardware.com/how-to/windows-11-classic-context-menus"&gt;How to Get Full Context Menus in Windows 11 | Tom's Hardware&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$path = 'HKCU:\Software\Classes\CLSID\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\InprocServer32'
New-Item -Path $path -Force
Split-Path $path -Parent | Get-ChildItem
Set-ItemProperty -Path $path -Name '(Default)' -Value ''
Get-ItemProperty $path

Stop-Process -Name explorer -Force
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Gist → &lt;a href="https://gist.github.com/krymtkts/30af31454d510ce0c34cfeb2fefec072"&gt;Return to the previous context menu in Windows 11.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;↓ キーの名前は case insensitive なのかーい！&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; Get-ItemProperty $path

(default)    :
PSPath       : Microsoft.PowerShell.Core\Registry::HKEY_CURRENT_USER\Software\Classes\CLSID\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\In
               procServer32
PSParentPath : Microsoft.PowerShell.Core\Registry::HKEY_CURRENT_USER\Software\Classes\CLSID\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}
PSChildName  : InprocServer32
PSDrive      : HKCU
PSProvider   : Microsoft.PowerShell.Core\Registry
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;終わり。&lt;/p&gt;</description><pubDate>Sun, 06 Feb 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-02-05-build-pwsh-2022</guid><link>https://krymtkts.github.io/posts/2022-02-05-build-pwsh-2022</link><title>2022-02 版 PowerShell のビルド</title><description>&lt;p&gt;PowerShell のパラメータバインディングについて調べていてコードに潜る時に、やっぱりローカルでビルドしたいよな！と思ったので、試してみた。
結果、副産物的に PowerShell 自体のコードをいじれる環境ができた。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;PC は Razer Blade Stealth 2018、Windows 11 Home 21H2 22000.469 だ。&lt;/p&gt;&lt;p&gt;まず ビルドの方法を探す。&lt;/p&gt;&lt;p&gt;&lt;code&gt;README.md&lt;/code&gt;から辿って&lt;a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/windows-core.md"&gt;Build PowerShell on Windows for .NET Core&lt;/a&gt;に辿り着いた。
わたしは &lt;code&gt;dotnet&lt;/code&gt; を使った CLI ビルドがしたいので &lt;a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/windows-core.md#net-cli"&gt;.NET CLI&lt;/a&gt; のやり方を使う。
ゆーても惚れ惚れするくらい簡単。以下だけ。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Import-Module ./build.psm1
Start-PSBootstrap
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ビルドに使うのは &lt;code&gt;Start-PSBuild&lt;/code&gt; らしい。&lt;code&gt;build.psm1&lt;/code&gt; を見たらわかるが、多くの関数が定義されてる。今回使うのはそのうちの 3 つだけだ。
これらの関数が何を行うためのものかのコメントがあまりないので、それぞれドキュメントからタグルなり使いみちを調べるのも一興か。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;&amp;gt; Get-Command -ListImported | Where-Object -Property Source -eq build

CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Function        Clear-PSRepo                                       0.0        build
# ︙
Function        Start-PSBootstrap                                  0.0        build
Function        Start-PSBuild                                      0.0        build
# ︙
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;PC にインストール済みの &lt;code&gt;dotnet&lt;/code&gt; が &lt;code&gt;6.0.101&lt;/code&gt; だったので、試しに &lt;code&gt;6.0.101&lt;/code&gt; でビルドする。
&lt;code&gt;global.json&lt;/code&gt;内の&lt;code&gt;sdk.version&lt;/code&gt;という属性がある。このときは&lt;code&gt;6.0.100&lt;/code&gt;がデフォルト値になってたので、使いたいバージョンに変える。&lt;/p&gt;&lt;pre&gt;&lt;code class="diff"&gt;PS&amp;gt; git diff
diff --git a/global.json b/global.json
index 047020849..e52d340bc 100644
--- a/global.json
+++ b/global.json
@@ -1,5 +1,5 @@
 {
   "sdk": {
-    "version": "6.0.100"
+    "version": "6.0.101"
   }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Start-PSBuild&lt;/code&gt; を実行することでビルドできる。
Razer Blade Stealth 2018 だとビルドに 2 分近くかかった。
ビルド物はドキュメントに記載の通り &lt;code&gt;./src/powershell-win-core/bin/Debug/net6.0/win7-x64/publish/pwsh.exe&lt;/code&gt; に出力された。
普通に起動すると実行時エラーで死んだけど、プロファイル読み込みを外せば起動した。ﾔｯﾀﾈ！&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; ./src/powershell-win-core/bin/Debug/net6.0/win7-x64/publish/pwsh.exe # 死
PowerShell 7.2.0-preview.10-222-g0ef30e54c70b9d5d69a35d1aeecdf2820cc1ab3b
Process terminated. Assertion failed.
No locals tuple should have been created yet.
   at System.Management.Automation.Diagnostics.Assert(Boolean condition, String whyThisShouldNeverHappen, String detailMessage) in C:\Users\takatoshi\dev\github.com\PowerShell\PowerShell\src\System.Management.Automation\utils\assert.cs:line 202
   at System.Management.Automation.Diagnostics.Assert(Boolean condition, String whyThisShouldNeverHappen) in C:\Users\takatoshi\dev\github.com\PowerShell\PowerShell\src\System.Management.Automation\utils\assert.cs:line 134
# ... スタックトレースは続く

PS&amp;gt; ./src/powershell-win-core/bin/Debug/net6.0/win7-x64/publish/pwsh.exe -NoProfile # Good!
PowerShell 7.2.0-preview.10-222-g0ef30e54c70b9d5d69a35d1aeecdf2820cc1ab3b
PS C:\Users\takatoshi\dev\github.com\PowerShell\PowerShell\src\powershell-win-core\bin\Debug\net6.0\win7-x64\publish&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最後にビルド生成物などを掃除するには &lt;code&gt;Clear-PSRepo&lt;/code&gt; を実行すれば良い。&lt;/p&gt;&lt;p&gt;終。&lt;/p&gt;</description><pubDate>Sat, 05 Feb 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-01-30-pwsh-parameter-binding-parse-datetime</guid><link>https://krymtkts.github.io/posts/2022-01-30-pwsh-parameter-binding-parse-datetime</link><title>PowerShell のパラメータバインディングは "3 時" を Datetime 型にパースする</title><description>&lt;h3 id="いきなりまとめ"&gt;いきなりまとめ&lt;/h3&gt;&lt;p&gt;PowerShell の関数なりコマンドレットがパラメータを受け取る場合、パラメータバインディングの仕組みで型ごとの変換処理をしており、日付型のパラメータでは&lt;code&gt;DateTime.Parse&lt;/code&gt; しているのがわかった。&lt;/p&gt;&lt;hr /&gt;&lt;h3 id="経緯"&gt;経緯&lt;/h3&gt;&lt;p&gt;先日 &lt;a href="/posts/2022-01-23-scheduled-task-in-powershell"&gt;ScheduledTask を設定した&lt;/a&gt;くだりで初めて知った。&lt;/p&gt;&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/powershell/module/scheduledtasks/new-scheduledtasktrigger?view=windowsserver2022-ps#example-1--register-a-scheduled-task-that-starts-a-task-once"&gt;New-ScheduledTaskTrigger (ScheduledTasks) | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;を見ていて、 &lt;code&gt;-At 3pm&lt;/code&gt; て何これ？と思って日本語も試した。
使い所がわかりかねるが、以下のようなジャパナイズされた入力でも OK!
ただし漢数字、曜日や午前/午後は &lt;code&gt;Parse&lt;/code&gt; できないので無理な。&lt;/p&gt;&lt;p&gt;参照: &lt;a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/parsing-datetime"&gt;Convert strings to DateTime | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; Get-Date 15時

Wednesday, January 16, 2022 03:00:00

PS&amp;gt; Get-Date 6年6月6日

Monday, June 6, 2006 00:00:00

PS&amp;gt; Get-Date 3じ
Get-Date: Cannot bind parameter 'Date'. Cannot convert value "3じ" to type "System.DateTime". Error: "The string '3じ' was not recognized as a valid DateTime. There is an unknown word starting at index '1'."
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;どういう仕組や。&lt;/p&gt;&lt;h4 id="大まかな予測"&gt;大まかな予測&lt;/h4&gt;&lt;p&gt;コマンドレットや関数に渡す前、引数の型 &lt;code&gt;DateTime&lt;/code&gt; の時点で捏ねくっている様子。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function hiduke() {
  param(
    [datetime]
    $d
  )
  $d
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; hiduke -d 3時

Wednesday, January 16, 2022 03:00:00
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;キャストとパースの違いを見る。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; [DateTime]::Parse('3時')

Wednesday, January 16, 2022 03:00:00

PS&amp;gt; [DateTime]::Parse('3じ')
MethodInvocationException: Exception calling "Parse" with "1" argument(s): "The string '3じ' was not recognized as a valid DateTime. There is an unknown word starting at index '1'."

PS&amp;gt; [DateTime]'3時'

Wednesday, January 16, 2022 03:00:00

PS&amp;gt; [DateTime]'3じ'
InvalidArgument: Cannot convert value "3じ" to type "System.DateTime". Error: "The string '3じ' was not recognized as a valid DateTime. There is an unknown word starting at index '1'."
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同じエラーメッセージ出てるので、 PowerShell が指定の型に評価するのに &lt;code&gt;DateTime.Parse&lt;/code&gt; を呼んでる。
真面目に考えたことなかったが、PowerShell 自体の機能でパラメーターバインディングというらしい。
&lt;a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_parameters?view=powershell-7.2"&gt;about Parameters - PowerShell | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;(今更ながら)また一つ学んでしまったようだな...&lt;/p&gt;&lt;p&gt;パラメーターバインディングの処理内容を知るには &lt;code&gt;Trace-Command&lt;/code&gt; が使える。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; Trace-Command -PSHost -Name ParameterBinding {Get-Date 3じ}
DEBUG: 2022-01-30 14:47:05.5488 ParameterBinding Information: 0 : BIND NAMED cmd line args [Get-Date]
DEBUG: 2022-01-30 14:47:05.5491 ParameterBinding Information: 0 : BIND POSITIONAL cmd line args [Get-Date]
DEBUG: 2022-01-30 14:47:05.5493 ParameterBinding Information: 0 :     BIND arg [3じ] to parameter [Date]
DEBUG: 2022-01-30 14:47:05.5495 ParameterBinding Information: 0 :         BIND arg [3じ] to param [Date] SKIPPED
DEBUG: 2022-01-30 14:47:05.5496 ParameterBinding Information: 0 :     BIND arg [3じ] to parameter [Date]
DEBUG: 2022-01-30 14:47:05.5497 ParameterBinding Information: 0 :         BIND arg [3じ] to param [Date] SKIPPED
DEBUG: 2022-01-30 14:47:05.5499 ParameterBinding Information: 0 :     BIND arg [3じ] to parameter [Date]
DEBUG: 2022-01-30 14:47:05.5501 ParameterBinding Information: 0 :         BIND arg [3じ] to param [Date] SKIPPED
DEBUG: 2022-01-30 14:47:05.5503 ParameterBinding Information: 0 :     BIND arg [3じ] to parameter [Date]
DEBUG: 2022-01-30 14:47:05.5504 ParameterBinding Information: 0 :         COERCE arg to [System.DateTime]
DEBUG: 2022-01-30 14:47:05.5506 ParameterBinding Information: 0 :             Trying to convert argument value from System.String to System.DateTime
DEBUG: 2022-01-30 14:47:05.5509 ParameterBinding Information: 0 :             CONVERT arg type to param type using LanguagePrimitives.ConvertTo
DEBUG: 2022-01-30 14:47:05.5519 ParameterBinding Information: 0 :             ERROR: ERROR: COERCE FAILED: arg [3じ] could not be converted to the parameter type [System.DateTime]
(...端折る...)
Get-Date: Cannot bind parameter 'Date'. Cannot convert value "3じ" to type "System.DateTime". Error: "The string '3じ' was not recognized as a valid DateTime. There is an unknown word starting at index '1'."
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;パラメータバインディング時によしなにしてるのがわかってきたところで、力尽きた。
PowerShell のパラメータバインディングの仕組みに関しては宿題やな。気長に見ていくしかない。&lt;/p&gt;&lt;h4 id="潜る"&gt;潜る&lt;/h4&gt;&lt;p&gt;ここまで来れたので、次は PowerShell のパラメータバインディングのコードに潜り込む。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Trace-Command&lt;/code&gt; の ParameterBinding Information に出てた&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;"COERCE FAILED: arg .+ could not be converted to the parameter type "&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;"CONVERT arg type to param type using LanguagePrimitives.ConvertTo"&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;から、 &lt;a href="https://github.com/PowerShell/PowerShell/blob/master/src/System.Management.Automation/engine/ParameterBinderBase.cs#L1262"&gt;&lt;code&gt;ParameterBinderBase.cs&lt;/code&gt;&lt;/a&gt;にたどり着いた。&lt;/p&gt;&lt;p&gt;例外がスローされたのがどこか &lt;code&gt;LanguagePrimitives.ConvertTo&lt;/code&gt; から先を探るのにはちょっと情報が足りなかったので、&lt;code&gt;Trace-Command&lt;/code&gt; に TypeConversion を足して出力した。&lt;/p&gt;&lt;p&gt;TypeConversion が有用なのがわかったのは、&lt;a href="https://github.com/PowerShell/PowerShell/blob/0ef30e54c70b9d5d69a35d1aeecdf2820cc1ab3b/src/System.Management.Automation/engine/LanguagePrimitives.cs#L4837"&gt;&lt;code&gt;LanguagePrimitives.cs&lt;/code&gt; 内の &lt;code&gt;ConvertTo&lt;/code&gt;&lt;/a&gt;を追ってたらトレース情報にまんまその名前が出てきたから。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; Trace-Command -PSHost -Name ParameterBinding,TypeConversion {Get-Date 3じ}
DEBUG: 2022-01-30 15:36:52.2304 ParameterBinding Information: 0 : BIND NAMED cmd line args [Get-Date]
DEBUG: 2022-01-30 15:36:52.2309 ParameterBinding Information: 0 : BIND POSITIONAL cmd line args [Get-Date]
DEBUG: 2022-01-30 15:36:52.2312 ParameterBinding Information: 0 :     BIND arg [3じ] to parameter [Date]
DEBUG: 2022-01-30 15:36:52.2314 ParameterBinding Information: 0 :         BIND arg [3じ] to param [Date] SKIPPED
DEBUG: 2022-01-30 15:36:52.2315 ParameterBinding Information: 0 :     BIND arg [3じ] to parameter [Date]
DEBUG: 2022-01-30 15:36:52.2318 ParameterBinding Information: 0 :         BIND arg [3じ] to param [Date] SKIPPED
DEBUG: 2022-01-30 15:36:52.2320 ParameterBinding Information: 0 :     BIND arg [3じ] to parameter [Date]
DEBUG: 2022-01-30 15:36:52.2322 ParameterBinding Information: 0 :         BIND arg [3じ] to param [Date] SKIPPED
DEBUG: 2022-01-30 15:36:52.2325 ParameterBinding Information: 0 :     BIND arg [3じ] to parameter [Date]
DEBUG: 2022-01-30 15:36:52.2326 ParameterBinding Information: 0 :         COERCE arg to [System.DateTime]
DEBUG: 2022-01-30 15:36:52.2329 ParameterBinding Information: 0 :             Trying to convert argument value from System.String to System.DateTime
DEBUG: 2022-01-30 15:36:52.2331 ParameterBinding Information: 0 :             CONVERT arg type to param type using LanguagePrimitives.ConvertTo
DEBUG: 2022-01-30 15:36:52.2336 TypeConversion Information: 0 :             Converting "3じ" to "System.DateTime".
DEBUG: 2022-01-30 15:36:52.2346 TypeConversion Information: 0 :                 Exception calling Parse method with CultureInfo: "The string '3じ' was not recognized as a valid DateTime. There is an unknown word starting at index '1'.".
DEBUG: 2022-01-30 15:36:52.2350 ParameterBinding Information: 0 :             ERROR: ERROR: COERCE FAILED: arg [3じ] could not be converted to the parameter type [System.DateTime]
(...端折る...)
Get-Date: Cannot bind parameter 'Date'. Cannot convert value "3じ" to type "System.DateTime". Error: "The string '3じ' was not recognized as a valid DateTime. There is an unknown word starting at index '1'."
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ParameterBinding Information のエラー出力までに TypeConversion Information が足されたのがわかる。いい感じじゃないか。&lt;/p&gt;&lt;p&gt;このキーワードを元にコードを探ると、&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/PowerShell/PowerShell/blob/0ef30e54c70b9d5d69a35d1aeecdf2820cc1ab3b/src/System.Management.Automation/engine/LanguagePrimitives.cs#L5226-L5287"&gt;&lt;code&gt;LanguagePrimitives.cs&lt;/code&gt; 内の &lt;code&gt;FigureParseConversion&lt;/code&gt;&lt;/a&gt; でパースに使うメソッドをリフレクションで取得している&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/PowerShell/PowerShell/blob/0ef30e54c70b9d5d69a35d1aeecdf2820cc1ab3b/src/System.Management.Automation/engine/LanguagePrimitives.cs#L3747-L3780"&gt;&lt;code&gt;LanguagePrimitives.cs&lt;/code&gt; 内の &lt;code&gt;ConvertViaParseMethod&lt;/code&gt;&lt;/a&gt; で取得したメソッドを使ったパースが行われてる&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;というのがわかった。&lt;/p&gt;&lt;p&gt;やっぱり &lt;code&gt;Datetime.Parse&lt;/code&gt; を使ってたんや。あー、スッキリした！&lt;/p&gt;&lt;p&gt;というか PowerShell 使ってる割にちゃんと勉強してないから、せなあかんな。&lt;/p&gt;</description><pubDate>Sun, 30 Jan 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-01-23-scheduled-task-in-powershell</guid><link>https://krymtkts.github.io/posts/2022-01-23-scheduled-task-in-powershell</link><title>Windows のタスクを操作する(PowerShell で)</title><description>&lt;p&gt;決まった時間までにやらなければいけないことがあるとする。それを人間力でカバーするのは、それなりに資源の浪費になるので自動化したいとする。
最近の Windows ならタスクスケジューラで直に書いてもいいけど、操作めんどすぎるので普通に考えたらスクリプトにするでしょう。
これを Windows 11 と PowerShell 7.2.1 でやる。&lt;/p&gt;&lt;p&gt;それでは &lt;a href="https://docs.microsoft.com/en-us/powershell/module/scheduledtasks/?view=windowsserver2019-ps"&gt;ScheduledTasks Module&lt;/a&gt; を使う。
このモジュールは Window なら以下のシステムフォルダにひっそりと存在する。令和のこの時代になんつー古い(v1)話なんや、とは思う。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Get-Module -Name ScheduledTasks -ListAvailable

    Directory: C:\WINDOWS\system32\WindowsPowerShell\v1.0\Modules

ModuleType Version    PreRelease Name                                PSEdition ExportedCommands
---------- -------    ---------- ----                                --------- ----------------
Manifest   1.0.0.0               ScheduledTasks                      Core,Desk {Get-ScheduledTask, Set-ScheduledTask, Register-Sche…
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;WindowsPowerShell(v5.1)なら &lt;a href="https://docs.microsoft.com/en-us/powershell/module/psscheduledjob/?view=powershell-5.1"&gt;PSScheduledJob Module&lt;/a&gt; が使えるが、 PowerShell 7 では使えない(&lt;code&gt;Import-Module&lt;/code&gt; もできない)ので、 &lt;code&gt;ScheduledTask&lt;/code&gt; 一択かと。&lt;/p&gt;&lt;p&gt;ではいくつかのレシピを以下に記す。&lt;/p&gt;&lt;h3 id="日次で指定時間に実行人間味のあるズレを添えて"&gt;日次で指定時間に実行(人間味のあるズレを添えて)&lt;/h3&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$pwsh = (get-command pwsh).Source
$action = New-ScheduledTaskAction -Execute $pwsh -Argument '-NonInteractive -Command "Invoke-MyCommand"'
$trigger = New-ScheduledTaskTrigger -Daily -At 7:46 -RandomDelay 00:10
$task = New-ScheduledTask -Action $action -Trigger $trigger
Register-ScheduledTask -InputObject $task -TaskName 'morning-action'
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="指定時間に起動して実行待ちするタスク--実行許諾の通知的なもの"&gt;指定時間に起動して実行待ちするタスク ≒ 実行許諾の通知的なもの&lt;/h3&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$pwsh = (get-command pwsh).Source
$action = New-ScheduledTaskAction -Execute $pwsh -Argument '-Command "{Read-Host `"press key`" | Out-Null; Invoke-MyCommand}.Invoke()"'
$trigger = New-ScheduledTaskTrigger -Daily -At 17:00
$task = New-ScheduledTask -Action $action -Trigger $trigger
Register-ScheduledTask -InputObject $task -TaskName 'evening-action'
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="単発で指定時間に実行人間味のあるズレを添えて"&gt;単発で指定時間に実行(人間味のあるズレを添えて)&lt;/h3&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$pwsh = (get-command pwsh).Source
$action = New-ScheduledTaskAction -Execute $pwsh -Argument '-NonInteractive -Command "Invoke-MyCommand"'
$jitter = (Get-Random -Minimum 30 -Maximum (60*5))
$timing = (Get-Date '2022-01-30 17:05').AddSeconds($jitter)
$trigger = New-ScheduledTaskTrigger -At $timing -Once
$setting = New-ScheduledTaskSettingsSet -DeleteExpiredTaskAfter 00:00:10
$task = New-ScheduledTask -Action $action -Trigger $trigger -Settings $setting | `
    %{ $_.Triggers[0].EndBoundary = $timing.AddMinutes(1).ToString('s'); $_}
Register-ScheduledTask -InputObject $task -TaskName 'single-action'
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;このレシピではズレの算出は自前で行っている。&lt;code&gt;New-ScheduledTaskTrigger&lt;/code&gt; に &lt;code&gt;-RandomDelay&lt;/code&gt; を指定しておくのもアリだが、単発であるし具体的にいつ実行されるかがわかる方が好ましいかと考えた。&lt;/p&gt;&lt;p&gt;単発タスクなので、実行後にタスクを廃棄したいとする。その場合は例のように &lt;code&gt;-Settings&lt;/code&gt; で自動削除の設定を有効にする必要がある。
同時に、タスクの期限切れの日時も指定する必要があるが、これはコマンドレットのオプションでは設定できない。直接オブジェクトに代入することで設定する(各 &lt;code&gt;Triggers&lt;/code&gt; で &lt;code&gt;EndBoundary&lt;/code&gt; を設定)。&lt;/p&gt;&lt;p&gt;参照: &lt;a href="https://stackoverflow.com/questions/29337135/powershell-v4-create-remote-task-scheduler-task-set-to-expire-and-delete/35777432#35777432"&gt;Powershell v4. Create remote task scheduler task set to expire and delete - Stack Overflow&lt;/a&gt;&lt;/p&gt;&lt;h3 id="注意"&gt;注意&lt;/h3&gt;&lt;p&gt;いくつかの注意点がある。&lt;/p&gt;&lt;h4 id="実行ファイルは絶対パス指定"&gt;実行ファイルは絶対パス指定&lt;/h4&gt;&lt;p&gt;実行ファイルは絶パス(絶対パスのわかりにくい略称)指定じゃないといけない。コマンドプロンプトでパスを通していたとしても、 &lt;code&gt;pwsh&lt;/code&gt; とかだとタスクスケジューラちゃんは実行ファイルを見つけられない。&lt;/p&gt;&lt;h4 id="pwsh-の引数-command-はダブルクォートで書く"&gt;&lt;code&gt;pwsh&lt;/code&gt; の引数 &lt;code&gt;Command&lt;/code&gt; はダブルクォートで書く&lt;/h4&gt;&lt;p&gt;&lt;code&gt;New-ScheduledTaskAction&lt;/code&gt; の引数 &lt;code&gt;Argument&lt;/code&gt; に、 &lt;code&gt;pwsh&lt;/code&gt; に渡す引数を定義する。
この時、引数 &lt;code&gt;Command&lt;/code&gt; に渡す文字列はダブルクォートで書くこと。
コマンドプロンプトで試せばわかるが、ダブルクォートはコマンドプロンプトで文字列として解釈され &lt;code&gt;pwsh&lt;/code&gt; に渡るのに対し、シングルクォートは文字列と解釈されないそのままが渡されている様子。&lt;/p&gt;&lt;pre&gt;&lt;code class="cmd"&gt;C:\Windows\system32&amp;gt;pwsh -NonInteractive -Command "Write-Host 123"
123

C:\Windows\system32&amp;gt;pwsh -NonInteractive -Command 'Write-Host 123'
Write-Host 123
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;この挙動のソースはコレ ↓ くらいしか見つからんかった。オフィシャルな情報はないのかな。あったら是非引用したい。(コマンドプロンプト界の常識過ぎるテーマなのか？)&lt;/p&gt;&lt;p&gt;&lt;a href="https://stackoverflow.com/questions/24173825/what-does-single-quoting-do-in-windows-batch-files/24181667#24181667"&gt;cmd - What does single-quoting do in Windows batch files? - Stack Overflow&lt;/a&gt;&lt;/p&gt;&lt;h3 id="read-host-するからにゃぁ-interactive-で-pwsh-を起動しろよな"&gt;&lt;code&gt;Read-Host&lt;/code&gt; するからにゃぁ Interactive で &lt;code&gt;pwsh&lt;/code&gt; を起動しろよな&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Read-Host&lt;/code&gt; する例なのに、間違って &lt;code&gt;-NoInteractive&lt;/code&gt; をつけてしまうと、このようにおもしろエラーを頂戴するのでご注意。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;C:\Windows\system32&amp;gt;pwsh -NonInteractive -Command "{Read-Host `"press key`" | Out-Null; Invoke-MyCommand}.Invoke()"
MethodInvocationException: Exception calling "Invoke" with "0" argument(s): "PowerShell is in NonInteractive mode. Read and Prompt functionality is not available."
&lt;/code&gt;&lt;/pre&gt;</description><pubDate>Sun, 23 Jan 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-01-15-move-taskbar-to-the-top-in-win11-pwsh</guid><link>https://krymtkts.github.io/posts/2022-01-15-move-taskbar-to-the-top-in-win11-pwsh</link><title>Windows 11 のタスクバーを天に(PowerShell で)</title><description>&lt;p&gt;Windows11 ではメニューからタスクバーを天に持ち上げれなくなったので、みんなレジストリを操作して実現している。手順はどこでも手に入るが、以下のページを参照した。&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.tomshardware.com/how-to/windows-11-taskbar-move-to-top"&gt;How to Move the Taskbar to the Top in Windows 11 | Tom's Hardware&lt;/a&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;regedit&lt;/code&gt; を開く&lt;/li&gt;&lt;li&gt;&lt;code&gt;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\StuckRects3&lt;/code&gt; を開く&lt;/li&gt;&lt;li&gt;&lt;code&gt;Settings&lt;/code&gt; を編集し保存する
&lt;ul&gt;&lt;li&gt;2 行目を &lt;code&gt;7A F4 00 00 03 00 00 00&lt;/code&gt; -&amp;gt; &lt;code&gt;7A F4 00 00 01 00 00 00&lt;/code&gt;にする
&lt;ul&gt;&lt;li&gt;デフォルトの&lt;code&gt;03&lt;/code&gt;が下、&lt;code&gt;01&lt;/code&gt;が上というわけ&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;explorer&lt;/code&gt; を再起動する
&lt;ul&gt;&lt;li&gt;コマンドプロンプトで
&lt;ol&gt;&lt;li&gt;&lt;code&gt;taskkill /f /im explorer.exe&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;start explorer.exe&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;これが PC 変わる度にやるのクソめんどいので、PowerShell でスクリプト化した。
そんなに機会はないけど一々覚えてないので先程のページを見にったりと、とにかくめんどい。&lt;/p&gt;&lt;p&gt;PowerShell 7.2.1 でやった。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ShowHex = {param ([array]$arr) ($arr | %{[System.Convert]::ToHexString($_)}) -join ' '}
$path = 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\StuckRects3'
$key = 'Settings'
$org = Get-ItemProperty $path | Select-Object -ExpandProperty $key
$ShowHex.Invoke((,$org))

$new = @() + $org
$new[12] = 0x01
$ShowHex.Invoke((,$new))
Compare-Object $org $new

Set-ItemProperty $path -name $key -Value $new

Stop-Process -Name explorer -Force
## if explorer doesn't restart, start explorer manually.
# Start-Process -Name explorer
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;万が一失敗してたら &lt;code&gt;$org&lt;/code&gt; で &lt;code&gt;Set-ItemProperty&lt;/code&gt; して戻す必要があるので、成功(≒ 天にタスクバー)を確認するまで窓を閉じない方が良かろう。
ちゃんと期待の更新ができているか確認するために、レジストリの値を 16 進数に変換して標準出力までしちゃう。&lt;/p&gt;&lt;p&gt;&lt;a href="https://gist.github.com/krymtkts/ba83a0612bba84b5e8229d64e9d8681a"&gt;Gist はこちら&lt;/a&gt;。&lt;/p&gt;&lt;h3 id="おまけ"&gt;おまけ&lt;/h3&gt;&lt;p&gt;&lt;code&gt;taskkill&lt;/code&gt; は PowerShell で言うところの何か調べたときのページ ↓&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.pdq.com/blog/what-is-the-powershell-equivalent-of-taskkill/"&gt;What Is The PowerShell Equivalent Of Taskkill | PDQ.com&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Okay, I'll be the first to admit it; the name is a little lackluster. Especially when compared to &lt;strong&gt;TASKKILL!!!!!!&lt;/strong&gt; &lt;strong&gt;Stop-Process&lt;/strong&gt; just doesn't carry the same hostile undertones Thankfully, Microsoft at least gave us &lt;strong&gt;kill&lt;/strong&gt; as an alias, so we've got that going for us. Regardless, let's see if it still packs the same task-killing punch.&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;さて、最初に断っておきますが、このネーミングは少し物足りないですね。特に&lt;strong&gt;TASKKILL!!!!!!&lt;strong&gt;と比較するとね。 ありがたいことに、Microsoft は少なくとも&lt;/strong&gt;kill&lt;/strong&gt;という別名をつけてくれました。 ともかく、同じようにタスクを殺すパンチをパックしているかどうか見てみましょう。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;こんなん笑うわｗ&lt;/p&gt;</description><pubDate>Sat, 15 Jan 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2022-01-09-planning</guid><link>https://krymtkts.github.io/posts/2022-01-09-planning</link><title>2022</title><description>&lt;p&gt;できたら or できなかったらどうなるというのがないが、例年通り目標をたてる。&lt;/p&gt;&lt;h4 id="テーマ-自分の人生は自分で決める"&gt;テーマ: 自分の人生は自分で決める&lt;/h4&gt;&lt;p&gt;これは自分の中でずっと言い聞かせていることなのだけど、去年一昨年は外的要因によって見失いがちだった。改めて見つめ直したいテーマにした。&lt;/p&gt;&lt;p&gt;単になんでもかんでも自分で決めたいわけじゃなくて、意見を持ってこうなのだと考えているところに、決断の資源を割く様にする。&lt;/p&gt;&lt;h3 id="2021-年の目標"&gt;2021 年の目標&lt;/h3&gt;&lt;p&gt;継続する目標。前年未達だった目標は基本継続としたいが、OSS への貢献については保留とする。&lt;/p&gt;&lt;p&gt;なんでかというとわたし自身が積極的でなくて「バグ見っけたら起票しよう」くらいのアクションしか例年やってないから、個別に項を設けて書いても意味がない。
AWS Tools for PowerShell のくだりで実感したが、やるんだったら Pull Request をマージしてくらいまでドライブしないと、如何なる小規模プロジェクトでもメンテナの負荷になり得る。結局コードで殴りつけてあげないと誰のためにもならない。とはいえ貢献したいプロジェクトを探して～とかやるのはなんか違う。
自作ツールの更新周りで既存のツールを色々見ていくだろうから、その流れで貢献することがあればできたらいいかなくらいにする。なんか無責任な感じもするけど、わたしの資源はわたしが思った(というか期待した)ほど多くなくて、やりたいことができないってのが常なので。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;住みたい場所を決める
&lt;ul&gt;&lt;li&gt;わたしは田舎に住み(薪ストーブやり)たいが、妻は車でなくても生活圏内を移動できることを重視してるので、落とし所を探す。なんか良い選択肢ないかなー&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;積ん読の消化 1 冊/月
&lt;ul&gt;&lt;li&gt;前年からペースを上げて、読書習慣を改善する&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;自作ツールの更新
&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/PSMFAttendance"&gt;PSMFAttendance&lt;/a&gt;&lt;ul&gt;&lt;li&gt;はよ Gallery に登録しろ&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/mccall-bot"&gt;mccall-bot&lt;/a&gt;&lt;ul&gt;&lt;li&gt;現職は Slack 文化がないため使い所が自分のチャンネルしかなく持て余している。放置したままだとマッコールさんにも申し訳ないので、なんか行く末を決めて差し上げたほうが良いのかもと考えている&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;ギター練習を 30 分/毎日
&lt;ul&gt;&lt;li&gt;たまにはバンド練習やりたいけど、世情を見つつ判断する&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://krymtkts.github.io/"&gt;このブログ&lt;/a&gt;&lt;ul&gt;&lt;li&gt;毎月の更新リズムを維持する&lt;/li&gt;&lt;li&gt;&lt;code&gt;todo.txt&lt;/code&gt; に放置テーマが結構溜まってきていることも鑑み、粛々と消化したい&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;追加する目標。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;深酒で怪我をしない
&lt;ul&gt;&lt;li&gt;寄る年波もあり怪我の治りが遅いので超重要課題&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;知らない言語を学ぶ F#
&lt;ul&gt;&lt;li&gt;PowerShell で面倒なスクリプトを書くとき、代わりに F#で書こうという気になったので今勉強している&lt;/li&gt;&lt;li&gt;なんかツールを書いたらゴールとしよう&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</description><pubDate>Sun, 09 Jan 2022 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-12-31-retrospective2021</guid><link>https://krymtkts.github.io/posts/2021-12-31-retrospective2021</link><title>振り返り 2021 年</title><description>&lt;p&gt;2021 年を振り返る。&lt;/p&gt;&lt;p&gt;2021 年のテーマは「自分を大事に」だった。肉体・精神共に大事にできてへんのちゃうん？という上半期から、大事にするための判断に絡んだ下半期。&lt;/p&gt;&lt;p&gt;決して悪い方向には向かっていないが、2021 年は迷いの多い年だった。判断としては信念に沿ったモノだったはずなのだが、外的要因や体力不足による判断低下から自分自身の判断とその結果に相当の迷いがあった。&lt;/p&gt;&lt;p&gt;大きな出来事は 2 個だけか。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;働きすぎた&lt;/li&gt;&lt;li&gt;転職&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="働きすぎた"&gt;働きすぎた&lt;/h3&gt;&lt;p&gt;2020 年末から 2021 年始は殆ど休みもなく「2020 年秋の新機能開発」に奔走していた。冬やけどな。
これはチーム総力戦の鬼の休日出勤によってなんとか本番へリリースされたのだけど敗戦処理は 2021 年 2 月頃まであったような感じやったな～、もはや懐かしい景色。&lt;/p&gt;&lt;p&gt;その新機能開発によって圧迫されてしまった機能もちょいちょいバグはあれど重大な問題なく本番へリリースできた(奇跡的に)。またリリース後の残作業に 1 年目の若手とおよそ 2week のスクラムもどきで敗戦処理をできたのはよかった。前職の若手教育は OJT が主なのだが、リスキーな案件ばかりで開発やらせてあげられないので、こういった場を設けられるのはやはりリードエンジニアたる所以だったなと感じる(これは自画自賛)。
この辺はまだ限界突破してなかったが、休日出勤を繰り返したことで感覚がおかしくなって、3 月以降徐々に稼働時間がかさんでいった。&lt;/p&gt;&lt;p&gt;3 月頃から入ったプロジェクトは、開発も始めていないのに締切だけあり、割り振られたリソースではどうあがいても足りないくらいだった。外向けのコミットメントもされてたせいで誰も止められない暴走列車と化したプロジェクト。今思い出してもドキドキするな～。プログラマなら感覚的に WBS とか見て「あ、やばいな」という肌感触があると思うが、まさにあれだった。打開策ないかスケジュール見直し頼んでみたりとか人足し依頼してみたような記憶もあるけど抜本的な解決に至らず。&lt;/p&gt;&lt;p&gt;どうにもできなかったので、人身御供的にリードエンジニアが全てを背負うしかあるまいなとわたしも暴走し、 SES やってた時以来の過重労働で 36 協定の制限突破する勢い出してた。万が一法律に触れそうなら会社も動くやろ的な。いやーほんまに良くない判断ね。まさにアドレナリンジャンキーと化していた。
結局スケジュールに決定的に間に合わないと判断してもらえたことで、わたしからいくつかのしごとが引き剥がしてもらい、エンジニアがドカドカ投入されてメチャクチャ綱渡り的に開発・リリースしていった形だったような気がする。
正直なところ肉体・精神共に不調だったので、細かく覚えてない。これも日記見ながら書いたくらいや。ある種、燃え尽き症候群的な状態に陥ってたのだろう。&lt;/p&gt;&lt;h3 id="転職"&gt;転職&lt;/h3&gt;&lt;p&gt;そしてこの過重労働の間に、ヘッドハンター()からオファーをもらって、転職することにした。&lt;/p&gt;&lt;p&gt;当時の判断は&lt;a href="/posts/2021-09-28-jobchange-2021"&gt;過去の日記&lt;/a&gt;に書いてあるが、この振り返りの文脈でいうとまた思うところがある。プロジェクトの悪いところ全部盛りみたいな状況から「こんなに苦しいならもうチーム開発などいらぬ！」みたいな聖帝的感覚に陥ってただろうなと改めて感じる(現職はほぼ一人ひとり働く感じ)。わたしの中では前職の元同僚達と働くのは楽しいことだったので転職するのに相当の迷いがあった。一緒に飲んだらかなりの確率でわたしが酔っ払って負傷するので危険な仲間。&lt;/p&gt;&lt;p&gt;この転職、入社前から諸々のトラブルはあったものの、辛うじてまだ生き残ってる。直前にヘッドハンター()に手のひら返されたり、ヘッド(略)が先に入れた社員が即辞めてたり、1 ヶ月パイセンが左遷(とわたしは表現している)されたりして、あんま精神衛生の環境は良くない。&lt;/p&gt;&lt;p&gt;ただ悪いことばかりではない。リモート慣れしていない会社にフルリモートで参画しても、関係者と意見交換しつつ一人で仕事を進められる自信ができた。また最近仕事で深く踏み込んでなかったフロントエンド開発(TypeScript + React.js で Atomic Components する)をやってフロントエンド戦国時代を肌で感じたりできたのは良。
入社前からやりたかったところは未だやれてない状況なので煮え切らないが、これまた期待値だけで報酬は上がったりしてるので、筋は悪くないのかなと。&lt;/p&gt;&lt;p&gt;やっぱどこでもそれなりに動けるな、という自信が確たるもんになった。&lt;/p&gt;&lt;h3 id="2021-年目標と成果"&gt;2021 年目標と成果&lt;/h3&gt;&lt;p&gt;年初に以下の目標を設定した。50%超えたしぼちぼちということにする。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;❌ 住みたい場所を決める
&lt;ul&gt;&lt;li&gt;意見のすり合わせが進んでいない&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;⭕️ 仕事上の掃除
&lt;ul&gt;&lt;li&gt;掃除の仕方が転職って形になったが、引き継ぎも最低限やったので良しとしてくれ...&lt;/li&gt;&lt;li&gt;のちの調査によると、引き継いだ仕事の 33% だけがわたしのシナリオ通り進めて、他は放置されているらしい。ショッキングな結果やがそこは残された者共や前職が決めるとこやからな、何も言うまい&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;⭕️ 昇給
&lt;ul&gt;&lt;li&gt;前職の昇給は満足じゃなかったが、転職して上がった&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;🔺 積ん読の消化
&lt;ul&gt;&lt;li&gt;技術書以外含めて 1 冊/2 ヵ月&lt;/li&gt;&lt;li&gt;ライフハックや書評とかのライトな本から再開し、今は技術書も読めるようになってきた。転職後少しずつ習慣を取り戻せている&lt;/li&gt;&lt;li&gt;やはり読書のためには疲労感の改善が重要やな&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;❌ OSS へのコントリビューション
&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/aws/aws-tools-for-powershell/issues/225"&gt;&lt;code&gt;aws/aws-tools-for-powershell&lt;/code&gt; のバグレポート&lt;/a&gt;しただけ
&lt;ul&gt;&lt;li&gt;なんか忙しそうで進展ないし、修正試みた方が良かったな&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;あとは自作のツールか。まだ PSGallery に登録してないけど。 &lt;a href="https://github.com/krymtkts/PSMFAttendance"&gt;krymtkts/PSMFAttendance&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;🔺 自作ツールの更新
&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/Get-GzipContent"&gt;krymtkts/Get-GzipContent: Get-Content for gzip files.&lt;/a&gt;&lt;ul&gt;&lt;li&gt;ちょっとだけやった&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/mccall-bot"&gt;mccall-bot&lt;/a&gt;&lt;ul&gt;&lt;li&gt;やってない&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;⭕️ ギター練習を 30 分/週 3 回
&lt;ul&gt;&lt;li&gt;割と出来てる。耳コピ少し/songsterr で曲覚えたり&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;⭕️ &lt;a href="https://krymtkts.github.io/"&gt;このブログ&lt;/a&gt;を毎月更新する
&lt;ul&gt;&lt;li&gt;6 月ズルしたけどコンスタントにかけるようになったかな&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;⭕️ 日頃使ってるスニペット的なのを Gist に登録していく
&lt;ul&gt;&lt;li&gt;&lt;a href="https://gist.github.com/krymtkts"&gt;krymtkts’s gists&lt;/a&gt; みたら月 1 個くらいで数少ないけどぼちぼちやっとるな&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;やっぱ転職の判断した頃から制御を自分に戻せてるのか、自分向けの目標は簡単なところからできるようになったんじゃないかな。
ここから大きく変化を～とか欲張らず、ちまちま積み重ねれたらいいな。&lt;/p&gt;&lt;p&gt;おわり。&lt;/p&gt;</description><pubDate>Fri, 31 Dec 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-12-26-fnm-tips-with-ccleaner</guid><link>https://krymtkts.github.io/posts/2021-12-26-fnm-tips-with-ccleaner</link><title>fnm でインストールした処理系は Temp フォルダからシンボリックリンクされるので ccleaner で消える話(当然)</title><description>&lt;p&gt;最近、 Node.js 処理系のバージョン管理に fnm を使っている。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/Schniz/fnm"&gt;Schniz/fnm: 🚀 Fast and simple Node.js version manager, built in Rust&lt;/a&gt;&lt;/p&gt;&lt;p&gt;お仕事 PC(Windows) では Yarn を使うのだが、 それまで使っていた Nodist だとどうにも Yarn が内部的に参照する npx が新しいバージョンに変わらなくてエラーが解消できなかった。&lt;/p&gt;&lt;p&gt;これが fnm なら何の問題もなくサクサク動く。&lt;a href="https://community.chocolatey.org/packages/fnm"&gt;chocolatey&lt;/a&gt; でインストールできるし、&lt;code&gt;.node-version&lt;/code&gt;, &lt;code&gt;.nvmrc&lt;/code&gt; をうまく使える点でも良、重宝している。&lt;/p&gt;&lt;p&gt;&lt;code&gt;fnm env&lt;/code&gt; で使う処理系を指定した環境変数を生成＆利用したいツールに反映させる必要があるため、 VS Code なんかは terminal 経由で起動する必要があるのだけど(それしか方法を知らん)、これは元々わたしの作業スタイルだったので特に問題ない。&lt;/p&gt;&lt;h3 id="事件は突然に"&gt;事件は突然に&lt;/h3&gt;&lt;p&gt;ある日、怪現象に悩まされた。&lt;/p&gt;&lt;p&gt;何気なく VS Code を立ち上げると、 &lt;code&gt;textlint&lt;/code&gt; が見つからないというエラーが出力されていた。&lt;code&gt;textlint&lt;/code&gt; だけでなく、 &lt;code&gt;npm&lt;/code&gt; も &lt;code&gt;node&lt;/code&gt; も消え去っていたのだ。その時はさっさと作業を始めたかったので、処理系やモジュールを再インストールすることで現状復帰した。これが最も手っ取り早い。&lt;/p&gt;&lt;p&gt;この原因は後でからわかったのだが非常に単純な話であって、Temp フォルダの中身を再帰的に消したことで fnm がインストールした処理系全ても無に帰したのだ。&lt;/p&gt;&lt;p&gt;わたしは Temp フォルダやその他のゴミ掃除目的に ccleaner を長らく使っている。ccleaner は Temp フォルダの中身を一覧して消す。&lt;/p&gt;&lt;p&gt;&lt;code&gt;fnm&lt;/code&gt; がインストールした処理系自体は &lt;code&gt;$env:FNM_DIR&lt;/code&gt; に配置される。
&lt;code&gt;fnm env&lt;/code&gt; を実行すると、Temp フォルダ内に &lt;code&gt;$env:FNM_DIR&lt;/code&gt; 配下の特定バージョンへ向けたシンボリックリンクを作成する。そのシンボリックリンクのパスは &lt;code&gt;$env:FNM_MULTICHELL_PATH&lt;/code&gt; に格納されている。&lt;/p&gt;&lt;p&gt;おわかりいただけただろうか。&lt;/p&gt;&lt;p&gt;ccleaner のように Temp フォルダを探索的に掃除するなら、以下のコマンドで事前に削除されるファイルが何処のものか知ると良い。こんなの事故るまで頭が回らんわ。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Get-ChildItem $env:FNM_MULTISHELL_PATH/../ | Select-Object -Property LinkTarget
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="対策"&gt;対策&lt;/h3&gt;&lt;p&gt;現状、ccleaner 等の Temp フォルダを掃除するアプリで、 &lt;code&gt;fnm&lt;/code&gt; のフォルダを除外するしかないか。
しかしそうなると、使われなくなった &lt;code&gt;$env:FNM_MULTISHELL_PATH&lt;/code&gt; の掃除を自力でする必要が出てくる。
&lt;code&gt;fnm env&lt;/code&gt; の度に処理系へのシンボリックリンクが作成されるので、掃除はこまめに行う必要がある(だからこそ Temp フォルダに作成しているのだろうけど)。&lt;/p&gt;&lt;p&gt;&lt;code&gt;fnm&lt;/code&gt; 自体には手動でこのシンボリックリンクを消すコマンドもないみたいなので、とりあえずは PowerShell の Profile で古いやつを消す様にするのが妥当なラインかな。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# てきとーにこんなのを想像
Get-ChildItem $env:FNM_MULTISHELL_PATH/../ | Where-Object -Property CreationTime -LE (Get-Date).AddDays(-1) | Remove-Item
&lt;/code&gt;&lt;/pre&gt;</description><pubDate>Sun, 26 Dec 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-12-04-pyenv-win</guid><link>https://krymtkts.github.io/posts/2021-12-04-pyenv-win</link><title>pyenv-win</title><description>&lt;p&gt;Python の処理系をローカルに直で入れることに抵抗はなかったのだが、chocolatey で Python3 を入れていると pin でもしない限りバージョンが進んでいって処理系が乱雑に配置されるので、Python 自体のバージョン管理をすることにした。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/pyenv-win/pyenv-win"&gt;pyenv-win/pyenv-win: pyenv for Windows. pyenv is a simple python version management tool. It lets you easily switch between multiple versions of Python. It's simple, unobtrusive, and follows the UNIX tradition of single-purpose tools that do one thing well.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;事前に Windows が Microsoft Store アプリの Python を使わないようにしておく必要がある。これがクソめんどい。以下は &lt;code&gt;README.md&lt;/code&gt; からの引用。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;NOTE: If you are running Windows 10 1905 or newer, you might need to disable the built-in Python launcher via Start &amp;gt; "Manage App Execution Aliases" and turning off the "App Installer" aliases for Python&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Win キーを押下して "Manage App Execution Aliases" をタイプするのが現状の最速と思うが、できたら &lt;code&gt;ms-settings&lt;/code&gt; スキームで一発で飛べたら良いのに(&lt;code&gt;ms-settings:appsfeatures&lt;/code&gt;で手前まで行くのが精一杯)。&lt;/p&gt;&lt;p&gt;わたしは chocolatey ユーザなので、 chocolatey でこの pyenv をインストールした。この場合環境変数の設定が chocolatey により行われるので幾分サボれる。&lt;/p&gt;&lt;p&gt;&lt;a href="https://community.chocolatey.org/packages/pyenv-win#psdsc"&gt;Chocolatey Software | pyenv-win 2.64.11&lt;/a&gt;&lt;/p&gt;&lt;p&gt;わたしの場合は chocolatey 操作とゴミを消すのだけ管理者権限が必要なようにしてるのでそうしたが、それ以外は普通で行った。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;(pip freeze | ConvertFrom-StringData).Keys | Set-Content requirements.txt # モジュールを控える

choco uninstall python3 -y
rm C:/Python* -recurse -force # ゴミを消す
choco install pyenv-win -y

pyenv install 3.9.6 # まだ 3.10.0 がリリースキャンディデートしかなかったので
pyenv global 3.9.6
pyenv rehash # バージョン切り替え後に必要

pip --version # 確認
python -m pip install --upgrade pip # 更新してって出たので更新
pip install -r requirements.txt # モジュール復元
# done.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="バージョン移行時の-requirementstxt"&gt;バージョン移行時の &lt;code&gt;requirements.txt&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;バージョン乗り換え時の &lt;code&gt;requirements.txt&lt;/code&gt; の作成だが、単純に &lt;code&gt;pip freeze&lt;/code&gt; の出力を使うとバージョン不整合で取り込めないことがある。
なのでわたしの場合は雑にモジュール名だけにフィルタリングしたものを使う。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;(pip freeze | ConvertFrom-StringData).Keys | Set-Content requirements.txt
&lt;/code&gt;&lt;/pre&gt;</description><pubDate>Sat, 04 Dec 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-11-27-psmfattendance</guid><link>https://krymtkts.github.io/posts/2021-11-27-psmfattendance</link><title>PowerShell で Money Forward クラウド勤怠を操作する</title><description>&lt;p&gt;現職について 2 ヶ月が経とうとしているが、まだ爆殺されてない。ので馴染んできているのかも知れない。コミュニケーションが少なくても(定例を除き、最少 DM1 通/週とか)何とかやっていけるものだなという気づきを得た。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;現職では勤怠の管理に Money Forward クラウド勤怠を利用している(時間管理なのだ)。
始めに書いておくと、勤怠管理システムはなんでか知らんがそれぞれに特色があって、どのツールを使っても一癖あるモノだというのがわたしの見解。その中でも Money Forward クラウド勤怠は悪くない印象だ。&lt;/p&gt;&lt;p&gt;しかし、わたしという人間がどうにもこうにも打刻という行為が大の苦手で、非常に億劫だ(労務管理の上で必要なんはわかるけど仕事の前後で打刻しないといけないとかワシら機械か、人間のやることじゃないと。某筋肉番組のショットガンタッチならいざ知らず)。&lt;/p&gt;&lt;p&gt;プログラマというのは怠惰なので、ブラウザで一々アクセスして打刻ボタンを押すのも苦痛なのであって、即ち半自動化に至るのは自然なことだ。
自動化じゃなく半自動化なのがポイント。自動化したら勤務してないのに勤務してるみたいなやばいことになりかねへん。自動化できるケーパビリティを持ちつつも半自動で使うのが職業プログラマの倫理？&lt;/p&gt;&lt;p&gt;そこでまず自分で作りたくないので誰かが書いたツールを探すと、&lt;a href="https://github.com/puhitaku/mfpy"&gt;puhitaku/mfpy: MoneyForward クラウド勤怠といい感じに通信していい感じに打刻するやつ&lt;/a&gt; が見つかった。良さそう。&lt;/p&gt;&lt;p&gt;でも PowerShell でどうしてもやりたかった。なので PowerShell で作った ↓&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/PSMFAttendance"&gt;krymtkts/PSMFAttendance&lt;/a&gt;&lt;/p&gt;&lt;p&gt;今は出退勤のリアルタイム打刻しかできない。今後、わたしがグータラできる水準まで高めるには次の機能が必要かなーと考えている。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;二重打刻防止
&lt;ul&gt;&lt;li&gt;なんと出勤や退勤が無限多重打刻できる仕様なので、これを防止したい
&lt;ul&gt;&lt;li&gt;そのためには勤怠実績の一覧を取得する機能が必要になる&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;打刻のリマインド機能
&lt;ul&gt;&lt;li&gt;これは &lt;code&gt;*-ScheduledTask&lt;/code&gt; でなんとかでけへんかなと考えているが...やったことない
&lt;ul&gt;&lt;li&gt;過去にタスクスケジューラでスケジュール実行をしてたけど PowerShell でやりたいし&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;勤務実績の入力
&lt;ul&gt;&lt;li&gt;打刻忘れの場合この作業が必要なので&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;あと、PowerShell Gallery の登録まだなのでしないと。アレのやり方毎回忘れるし簡単な方法ないんかというのも悩みどころ。あの工程を&lt;code&gt;psake&lt;/code&gt; のタスクにまとめるのはなんかで見たことあるけど、初回は手でやるか。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;因みに自動化について利用規約に触れないか気になったのだが、見た感じ問題なさそうだった。
&lt;a href="https://biz.moneyforward.com/agreement/"&gt;利用規約 | 会計ソフト マネーフォワード クラウド&lt;/a&gt;&lt;/p&gt;</description><pubDate>Sat, 27 Nov 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-10-30-toolchain-of-powershell</guid><link>https://krymtkts.github.io/posts/2021-10-30-toolchain-of-powershell</link><title>PowerShell のツールチェーン</title><description>&lt;p&gt;今更読んだ ↓&lt;/p&gt;&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/powershell/powershellget-3-0-preview-11-release/#features-to-expect-in-coming-preview-releases"&gt;PowerShellGet 3.0 Preview 11 Release - PowerShell Team&lt;/a&gt;&lt;/p&gt;&lt;p&gt;モジュールの依存性管理がくるっぽ。&lt;/p&gt;&lt;p&gt;これを機に NuGet のバージョンレンジ記法を学ばないといけないかな。PowerShell 使うけど NuGet と直接的な縁ないので触れずに来た。
&lt;a href="https://docs.microsoft.com/en-us/nuget/concepts/package-versioning#version-ranges-and-wildcards"&gt;NuGet Package Version Reference | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;それはさておき、先述の PowerShellGet のネタはまだ正式なものでもなく、プレビュー機能が来てるわけでもない。だから今はまだ従来の術を使うのが良いだろうと考えている。
真面目に PowerShell 開発したことがないので、その辺の知ってるモジュールを棚卸しし、調べ直した。&lt;/p&gt;&lt;p&gt;ここに書いたあるような内容は、PowerShell で書かれているアプリの GitHub repo を見たらだいたい出てくるのじゃないだろうか。
わたしの場合は、&lt;a href="https://github.com/jasonmarcher/poco"&gt;jasonmarcher/poco&lt;/a&gt;で初めて&lt;code&gt;psakefile.ps1&lt;/code&gt;を見つけてそこから世界へ踏み入れた感じ。&lt;/p&gt;&lt;p&gt;そして、この記事をまとめているときに「ああそういえば Awesome 〇〇ってあったなー」と思いググると、PowerShell 版も見つかったので置いておく。この記事に書いたツールチェーンは全部 Awesome の方に載ってた...&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/janikvonrotz/awesome-powershell"&gt;janikvonrotz/awesome-powershell: A curated list of delightful PowerShell modules and resources&lt;/a&gt;&lt;/p&gt;&lt;hr /&gt;&lt;h3 id="ビルド"&gt;ビルド&lt;/h3&gt;&lt;p&gt;PowerShell はスクリプトなのでコンパイルはないが、静的解析・テスト・パッケージング等のことをひっくるめて、ここではビルドと呼ぶことにする。&lt;/p&gt;&lt;p&gt;やはり&lt;a href="https://github.com/psake"&gt;psake&lt;/a&gt; が有名でしょう。&lt;sup id="fnref-1"&gt;&lt;a class="footnote-ref" href="#fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/psake/psake"&gt;psake/psake&lt;/a&gt; は基盤のようなもので、汎用的なビルドタスクなんかは&lt;a href="https://github.com/psake/PowerShellBuild"&gt;psake/PowerShellBuild&lt;/a&gt;に定義されている。
肝心の&lt;a href="https://github.com/psake/psake"&gt;psake/psake&lt;/a&gt;のビルドには自身ではなく&lt;a href="https://github.com/RamblingCookieMonster/BuildHelpers"&gt;RamblingCookieMonster/BuildHelpers&lt;/a&gt;が使われているというのがこれまたややこしい。
&lt;a href="https://github.com/RamblingCookieMonster/BuildHelpers"&gt;RamblingCookieMonster/BuildHelpers&lt;/a&gt;それ自身は、CI/CD シナリオで使えるヘルパーだぜ？と自称しているだけあり、その用途(GitHub Actions)で使われている&lt;/p&gt;&lt;p&gt;因みに&lt;a href="https://github.com/nightroman/Invoke-Build"&gt;Invoke-Build&lt;/a&gt;なんていうのもいて、これは使ったことない。GitHub のグラフはこちらの方が比較的アクティブかな。
README.md 見る限り&lt;a href="https://github.com/psake/psake"&gt;psake&lt;/a&gt;よりも使いやすいぜ！って書いてあるので、何か大変なことでもあったのかなと勘ぐってしまう。
わたしはまだ真面目に使い込めていないこともあり、&lt;a href="https://github.com/psake/psake"&gt;psake&lt;/a&gt;の闇を知らないだけかも知れない。&lt;/p&gt;&lt;h3 id="依存性管理"&gt;依存性管理&lt;/h3&gt;&lt;p&gt;モジュールあるところに依存性管理あり。PowerShell も例に漏れずある。
&lt;a href="https://github.com/RamblingCookieMonster/PSDepend"&gt;RamblingCookieMonster/PSDepend&lt;/a&gt;&lt;/p&gt;&lt;p&gt;話は変わるが、&lt;a href="https://github.com/RamblingCookieMonster"&gt;RamblingCookieMonster (Warren Frame)&lt;/a&gt;さんは他にも PowerShell のツールを色々書かれている。
&lt;a href="https://github.com/RamblingCookieMonster/PSDeploy"&gt;RamblingCookieMonster/PSDeploy&lt;/a&gt;だったり、わたしも最近所用で使った&lt;a href="https://github.com/RamblingCookieMonster/PSSlack"&gt;RamblingCookieMonster/PSSlack&lt;/a&gt;だったり(最新の API に対応してないけど)。&lt;/p&gt;&lt;h3 id="テスト静的解析"&gt;テスト/静的解析&lt;/h3&gt;&lt;p&gt;&lt;a href="https://github.com/pester/Pester"&gt;pester/Pester&lt;/a&gt; しか知らん。BDD スタイルでクールよね。
&lt;a href="https://github.com/PowerShell/PSScriptAnalyzer"&gt;PowerShell/PSScriptAnalyzer&lt;/a&gt; しか知らん。
いずれも開発もアクティブだし唯一無二か？&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;Awesome ~ を見つけたことだし、他にも色々見てみるか。&lt;/p&gt;&lt;div class="footnotes"&gt;&lt;hr /&gt;&lt;ol&gt;&lt;li id="fn-1"&gt;&lt;p&gt;と書いたがどう考えても有名じゃない。わたしも知ったの 2,3 年くらい前。最近は repo のグラフもほとんど息してなく見える。「枯れてる」のかも知れんけど。&lt;/p&gt;&lt;a href="#fnref-1" class="footnote-backref"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description><pubDate>Sat, 30 Oct 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-09-28-jobchange-2021</guid><link>https://krymtkts.github.io/posts/2021-09-28-jobchange-2021</link><title>転職する</title><description>&lt;p&gt;転職する。2021-10-01 から新しい会社だ。&lt;/p&gt;&lt;p&gt;前職(まだ退職日を迎えていないが便宜上こう呼ぶ)に決定的な不満があったわけではなく、諸々の条件で現状を上回るオファーをもらったのが大きい。
以下に判断時の Good/Bad を一覧す。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Good
&lt;ul&gt;&lt;li&gt;いま GCP、そのうち Azure を加えてマルチクラウド&lt;/li&gt;&lt;li&gt;GitHub&lt;/li&gt;&lt;li&gt;少人数チームでの開発&lt;/li&gt;&lt;li&gt;額面年収 3 桁万 UP&lt;/li&gt;&lt;li&gt;みなし残業の上限が下がる&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Bad
&lt;ul&gt;&lt;li&gt;確定拠出年金がない&lt;/li&gt;&lt;li&gt;超成果主義&lt;/li&gt;&lt;li&gt;レッドオーシャン？&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;お話を伺った限り、自分が貢献できそうなテーマも色々ある感じだったし、「やってみたいこと」のような挑戦に対する Welcome な姿勢がとても印象的だった。
正直なところ選考らしい選考された覚えなく、「一緒に働いてみないとわからない」という CTO の観点のもと採用判断されている。そのため入ってからパフォ出せなかったら多分盛大に爆死するんだろうなと。そこだけは不安なのだが、それこそ「働いてみないとわからない」。
とはいえ、自分も地べた這いずる中の下のエンジニアとはいえ 15 年以上の経験があるので、貢献できることがあるだろうという前向きな姿勢ではある。
(全く手も足も出せずに爆殺されるかも知れんけど。)&lt;/p&gt;&lt;p&gt;やるのは久しぶりの通信系アプリ。dotnet も仕事で使うのは 10 年ぶりか。
なんでもやりたいマンなので、入社後じわじわ守備範囲を広めていくイメージをしている。&lt;/p&gt;&lt;p&gt;今回で 4 回目の転職だが、えんじにゃー転職はリモートワークの普及で大きく景色を変えたような印象があった。どこも DX()で人手がほしいことも重なってか。事実今回の転職は大阪の人材を買い叩く流れで採用いただいたわけである。&lt;/p&gt;&lt;p&gt;心残りがなかったわけではない。前職の辞め方、個人的には引き継ぎは最低限やったけど、あまりいい辞め方ではなかったなと思っている。自分がやり始めてとっちらかっていることが多い状態で、今やめるのもなーと考えていた。
とはいえ自分の人生をより良くできるのは自分自身だ。そのためには今いる環境に変化をもたらすか、あるいは環境を別の環境に変えてしまうかしかない。
2 年ちょっとの在籍期間は前者の行動をしてたが、今回は後者を選択したと。&lt;/p&gt;&lt;p&gt;この日記は、入社半年とか 1 年後、または爆死時とかの区切りで読み返そうと思う。
わたし自身も、このうねり狂う変化の波を乗りこなせるかのチャレンジ一年生なのである。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;休みの間に、積んでた HADES をやり始めた。死にゲーで最高。時間が溶ける...&lt;/p&gt;</description><pubDate>Tue, 28 Sep 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-08-30-patch-to-vscode-extension</guid><link>https://krymtkts.github.io/posts/2021-08-30-patch-to-vscode-extension</link><title>VS Code の拡張機能に ローカル patch する</title><description>&lt;p&gt;VS Code の拡張機能にバグがある場合、メンテナが Marketplace に修正版を公開するのを待つ以外にも、自力で修正する方法がある。
ちょうどよく使っている&lt;a href="https://github.com/michalyao/evermonkey"&gt;michalyao/evermonkey&lt;/a&gt;が、壊れてしまってから 3 週間程経っても一向に対応されないので、その方法で一時的に回避した。&lt;/p&gt;&lt;p&gt;Issue は以下の通り。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/michalyao/evermonkey/issues/161"&gt;Evernote Error: 11 - Illegal to contain comments in ENML · Issue #161 · michalyao/evermonkey&lt;/a&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;エラーの原因は&lt;a href="https://dev.evernote.com/doc/articles/enml.php"&gt;ENML&lt;/a&gt;が HTML コメントを許容しなくなったことで、 これにより upload できなくなってしまった。コメントを許容しないって記述は一見なさそうだが、Upload 時のエラーになってる。&lt;/p&gt;&lt;p&gt;この&lt;a href="https://dev.evernote.com/doc/articles/enml.php"&gt;ENML&lt;/a&gt;の変更に対する Pull Request は&lt;a href="https://github.com/michalyao/evermonkey/pull/162"&gt;ある&lt;/a&gt;のだが、どうでもいいところでコンフリクトしていたり、メンテナが忙しいのかチェックされていない状態にある。
すぐに修正を適用するには、この PR の patch を自分の VS Code に適用すればいい。&lt;/p&gt;&lt;p&gt;VS Code の拡張機能は &lt;code&gt;~/.vscode/extensions&lt;/code&gt; にある&lt;sup id="fnref-1"&gt;&lt;a class="footnote-ref" href="#fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt;。今回の対象となるファイルは&lt;code&gt;converterplus.js&lt;/code&gt;。
PowerShell には&lt;code&gt;patch&lt;/code&gt;コマンドが無いので今回は手で patch した。
元は TypeScript で記述されているが、&lt;a href="https://github.com/cancastilho/evermonkey/commit/70991c155f08101d14a4ab4c64ad36d66f9850a3?branch=70991c155f08101d14a4ab4c64ad36d66f9850a3&amp;amp;diff=split"&gt;変更内容&lt;/a&gt;は素の JavaScript と同じなのでそのままコピペできる。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;code $(Get-ChildItem ~\.vscode\extensions\michalyao.evermonkey-2.4.5\out\src\converterplus.js).FullName
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;↑ クソどうでもいいコードスニペット。
でも知らなかった点として、&lt;code&gt;~&lt;/code&gt;は PowerShell がユーザーディレクトリに評価するのでそのままだと VS Code に渡せなかった、というのがわかった記念に。&lt;/p&gt;&lt;p&gt;変更が終わったら、 VS Code で&lt;code&gt;Developer: Reload Windows&lt;/code&gt;すれば拡張機能に施した変更が VS Code に取り込まれる。
因みにここでは&lt;code&gt;Developer: Restart Extension Host&lt;/code&gt;で良いはずだが、割と Extension Host を起動できない Notification が表示される。
それが面倒なので&lt;code&gt;Developer: Reload Windows&lt;/code&gt;で丸ごと再起動している。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;これで無事に Evernote を利用できる状況まで戻った。でもこのままメンテナが音信不通だとこの拡張機能を VS Code で使い続けることも難しくなりそう。こりゃ参ったね。&lt;/p&gt;&lt;div class="footnotes"&gt;&lt;hr /&gt;&lt;ol&gt;&lt;li id="fn-1"&gt;&lt;p&gt;&lt;a href="https://vscode-docs.readthedocs.io/en/stable/extensions/install-extension/"&gt;Install extension - vscode-docs&lt;/a&gt;&lt;/p&gt;&lt;a href="#fnref-1" class="footnote-backref"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description><pubDate>Mon, 30 Aug 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-07-18-psake-completion</guid><link>https://krymtkts.github.io/posts/2021-07-18-psake-completion</link><title>psake の Task 名を自動補完する</title><description>&lt;p&gt;ほぼ趣味レベルなのだが、所謂タスクランナーとして&lt;a href="https://github.com/psake/psake"&gt;psake&lt;/a&gt;を使っている。趣味レベルなのは、Go とか Python とかでは &lt;code&gt;make&lt;/code&gt; を使うので &lt;code&gt;psake&lt;/code&gt; を製品コードでは使ったことなくて、自分の細々とした面倒な処理をスクリプト化してまとめるのに &lt;code&gt;psake&lt;/code&gt; を使ってるからだ。&lt;/p&gt;&lt;p&gt;そんな訳で利用頻度も高くなかったのだが、なんか最近は AWS のリソースを操作するニッチなスクリプト(例えば開発環境とかステージング環境だけに使うようなやつ)が大量にあって、それをまとめるのに使い出した。
その御蔭で利用頻度が高まり、いやーよくできたツールやな～などと改めて思っていたが、今まで不満に感じなかった自動補完がないことがストレスになってきた。タスクが増え過ぎて名前が覚えられないのだ。&lt;/p&gt;&lt;p&gt;ｷﾞｯﾊﾌﾞの repo を確認すると、古の&lt;code&gt;TabExpansion&lt;/code&gt;版はあれど、今どきの&lt;code&gt;Register-ArgumentCompleter&lt;/code&gt;版がない。
&lt;a href="https://github.com/psake/psake/blob/master/tabexpansion/PsakeTabExpansion.ps1"&gt;psake/PsakeTabExpansion.ps1 at master · psake/psake&lt;/a&gt;&lt;/p&gt;&lt;p&gt;今更&lt;code&gt;TabExpansion&lt;/code&gt;使いたくないので、&lt;code&gt;Register-ArgumentCompleter&lt;/code&gt;用に合わせてこしらえた。&lt;/p&gt;&lt;p&gt;&lt;a href="https://gist.github.com/krymtkts/b2e6742691fdca6ca09567ca146063df"&gt;This is Register-ArgumentCompleter version of https://github.com/psake/psake/blob/master/tabexpansion/PsakeTabExpansion.ps1.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;使ってみていまんとこ良さそうな感じ。問題なさそうなら本家に PRO ぶん投げてみてもいいかもね。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;以下は&lt;code&gt;Register-ArgumentCompleter&lt;/code&gt;のスクリプトブロックをデバッグするときの個人的メモ。&lt;/p&gt;&lt;p&gt;その時の入力でトリガーされたスクリプトブロックの引数を確認するのに &lt;code&gt;Write-Host&lt;/code&gt; とか使うと厄介だと思うので、ログファイル的なものをこしらえておき、別窓で&lt;code&gt;tail&lt;/code&gt;してあげると見易くなる(と思っている)。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Register-ArgumentCompleter -CommandName Invoke-Psake -ParameterName taskList -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
    "$commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters" &amp;gt;&amp;gt; test.log
    if ($commandAst -match '(?&amp;lt;file&amp;gt;[^\.]*\.ps1)') {
        $file = $Matches.file
        "YEAH" &amp;gt;&amp;gt; test.log
    }
    else {
        $file = 'psakefile.ps1'
        "DEFAULT" &amp;gt;&amp;gt; test.log
    }
    &amp;amp; $commandName -buildFile $file -docs -nologo | Out-String -Stream | ForEach-Object { if ($_ -match "^[^ ]*") { $matches[0] } } | `
        Where-Object { $_ -notin ('Name', '----', '') } | Where-Object { !$wordToComplete -or $_ -like "$wordToComplete*" }
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Get-Content .\test.log -Wait -Tail 10
# Invoke-psake, taskList, I, invoke-psake -buildFile .\psakefile.ps1 -taskList I, System.Collections.Hashtable
# Invoke-psake, taskList, In, invoke-psake -taskList In, System.Collections.Hashtable
# DEFAULT
# Invoke-psake, taskList, I, invoke-psake -buildFile .\psakefile.ps1 -taskList I, System.Collections.Hashtable
# YEAH
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;どーでもいーけどこの日記の deploy をｷﾞｯﾊﾌﾞｱｸｼｮﾝ化したい。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;追記。&lt;/p&gt;&lt;p&gt;デバッグ中に気づいたのだが、プロファイル内で &lt;code&gt;$psake&lt;/code&gt; という変数を作ると &lt;code&gt;Invoke-psake&lt;/code&gt; が壊れるという事に気づいた。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;🤖 takatoshi  invoke-psake -nologo
Test-Path: C:\Program Files\PowerShell\Modules\psake\4.9.0\private\Get-DefaultBuildFile.ps1:9
Line |
   9 |      if (test-path $psake.config_default.buildFileName -pathType Leaf) …
     |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     | Value cannot be null. (Parameter 'The provided Path argument was null or an empty collection.')

Test-Path: C:\Program Files\PowerShell\Modules\psake\4.9.0\private\Get-DefaultBuildFile.ps1:11
Line |
  11 |  …   } elseif (test-path $psake.config_default.legacyBuildFileName -path …
     |                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     | Value cannot be null. (Parameter 'The provided Path argument was null or an empty collection.')

InvalidOperation: C:\Program Files\PowerShell\Modules\psake\4.9.0\public\Invoke-psake.ps1:327
Line |
 327 |          $psake.build_success = $false
     |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     | The property 'build_success' cannot be found on this object. Verify that the property exists and can be set.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;罠すぎる...&lt;/p&gt;</description><pubDate>Sun, 18 Jul 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-07-11-my-terminal-icons</guid><link>https://krymtkts.github.io/posts/2021-07-11-my-terminal-icons</link><title>Terminal-Icons のアイコングリフのコードポイントを変えたい</title><description>&lt;p&gt;先日、&lt;a href="/posts/2021-07-01-i-want-to-change-codepoint"&gt;わたしの改造 Migu で Terminal-Icons の見栄えが悪い話&lt;/a&gt;を書いた。
あの後、チマチマ作業を行い、ある程度納得の行くものが出来上がったのでまとめておく。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;まず、先日の記事に書いていた豆腐は、ありゃー Material Design Icons を改造 Migu に組み込んでいないからであった。無知蒙昧。
あと Weather Icons もいらねーだろと思ってたしてなかったが、この際なので打ち込んじまえ！と意気込み処置を行うた。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/fontmerger/commit/81681e6de10149ed34dda60e9b6b806374efa472"&gt;Add fonts. · krymtkts/fontmerger@81681e6&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/fontmerger/commit/44c72fc3cc6cbabb44d25c3268d4191f81c78fed"&gt;Update font settings. · krymtkts/fontmerger@44c72fc&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Weather Icons は、なんか知らんがサイズを調整してパッチすると結構縦長になってしまってた。
が、ちょっと前に足しといた縦比/横比だけ調整するパラメータがいい感じに使え、我ながら先見の明を感じた(何&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/fontmerger/commit/7653e06d1f106b8dbcc01f30dc9ea25c175a3916"&gt;Split scale option to x and y scale. Add force_narrow option that for… · krymtkts/fontmerger@7653e06&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;こうしてまたさらにイイカンジの Migu になったところで、Terminal-Icons の&lt;code&gt;glyphs.ps1&lt;/code&gt;を上書きするモンをこしらえて完成とした。
ブツは Gist に上げた → &lt;a href="https://gist.github.com/krymtkts/4457a23124b2db860a6b32eba6490b03"&gt;my Terminal-Icons glyphs.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Material Design Icons はコードポイントがわかりやすくずれるだけなので機械的にずらすだけで OK だった。
Weather Icons と Octicons あたりは Nerd Fonts ではよくわからん順番に組み替えてるようだった。
コード読むのめんどかったので、モウ泥臭くヒューマンマニピュレーションにて処置...気が遠くなるかと思いきや割とすぐできた感じではある。
あと&lt;code&gt;glyphs.ps1&lt;/code&gt;を直接上書きするパワースタイルなので、なんか後から差し込めるようにしたい気はする。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2021-07-11-terminal/icons.png" alt="きれいなアイコンたち" /&gt;&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;全く関係ないが最近マイ Iris がやたらとチャタリングするようになてムカつくぜぇぇぇ...
ホコリが接点に侵入してるんやと思うんやけど、掃除しても掃除しても数日で再発する。
でもファミコンのカートリッジスタイルでフーッ！！すると割と改善する...そんな日々。&lt;/p&gt;</description><pubDate>Sun, 11 Jul 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-07-01-i-want-to-change-codepoint</guid><link>https://krymtkts.github.io/posts/2021-07-01-i-want-to-change-codepoint</link><title>Terminal-Icons のアイコングリフのコードポイントを変えたい</title><description>&lt;p&gt;2021 年 5 月から、法律による上限スレスレの時間外＆休日労働だったため、すっかりブログを認めるのを忘れていた。
なのでこの記事は 6 月分のつもりで書いている(言い訳)。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;さて、先月に現時点自分史上最高の Migu フォントを生み出したわけだが、実用において完全に気になるポイントがないわけではない。
その実、前から抱えていた幾つかの課題がそれなのだけど。&lt;/p&gt;&lt;p&gt;fontmerger を使って日本語フォントにパッチする場合、漢字が割り当てられているコードポイントにアイコングリフが割り当てられないように、コードポイントをずらす機能がついている。
当然の如く、わたしの Migu を作るためのパッチでもコードポイントをずらしている。&lt;/p&gt;&lt;p&gt;するとですね、&lt;a href="https://github.com/devblackops/Terminal-Icons/"&gt;devblackops/Terminal-Icons&lt;/a&gt;は &lt;a href="https://github.com/devblackops/Terminal-Icons/blob/eeb5ce85d4a1882b5155bd6f06859a4b6f4b44d8/psakeFile.ps1#L28"&gt;https://www.nerdfonts.com/cheat-sheet から自動生成した標準のコードポイント&lt;/a&gt; で以てフィアルやディレクトリのアイコンを表示するので...わたしの Migu だと豆腐になるアイコンがちらほらいるわけですね。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2021-07-01-terminal/icon-tofu.png" alt="豆腐アイコン" /&gt;&lt;/p&gt;&lt;p&gt;偶然にも、「栗」がアイコンに割り当てられてしまっているところもあったり。この動機づけはシンクロニシティやろ！&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2021-07-01-terminal/stop-is-chestnut.png" alt="停止は栗" /&gt;&lt;/p&gt;&lt;p&gt;前まではアイコンがぶっ壊れ気味の Migu を使っていたので、割れ窓理論的に気にならなかった豆腐が、最近妙に気になってきたわけだ。&lt;/p&gt;&lt;p&gt;Terminal-Icons のドキュメントやコードを見ても、先述の自動生成したコードポイント表(&lt;a href="https://github.com/devblackops/Terminal-Icons/blob/main/Terminal-Icons/Data/glyphs.ps1"&gt;Terminal-Icons/glyphs.ps1&lt;/a&gt;)を差し替えたりできるような仕組みはないようなので、一旦はこのスクリプト自体にパッチを当てる方向で考えよかなと考え中。&lt;/p&gt;&lt;p&gt;4000 行近くあるとはいえ、その中から普段使うアイコンに絞れば数は少ないと思うから、とりま手でﾎﾟﾘﾎﾟﾘコードポイントを変えようかなと(さっきのキャプチャだけでも 3 つ豆腐並んでてヒット率高すぎ感はあるが)。&lt;/p&gt;&lt;p&gt;とはいえ英語圏じゃない人のフォントはわたしと同じ問題を抱えてるかもしれないので、なんかグリフのコードポイント変えさせてくれや～、という機能をプルリしてもいいかもしれない。&lt;/p&gt;</description><pubDate>Thu, 01 Jul 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-05-30-maybe-completed-refining-migu-nerd-font</guid><link>https://krymtkts.github.io/posts/2021-05-30-maybe-completed-refining-migu-nerd-font</link><title>Migu Nerd Font の改善が完了したっぽい</title><description>&lt;p&gt;(2021-05-16 に書いたまま投稿するのを忘れていた)&lt;/p&gt;&lt;p&gt;&lt;a href="/posts/2021-05-07-i-want-to-resize-migu-icon"&gt;以前&lt;/a&gt;の続き。まだやってる。&lt;/p&gt;&lt;p&gt;横も縦も微妙にサイズが合わないのであれば、強制的に矯正するしかない！ということでまた fontmerger に機能追加した。&lt;a href="https://fontforge.org/docs/scripting/python/fontforge.html#fontforge.contour.boundingBox"&gt;contour.boundingBox&lt;/a&gt;は結局やめた。今のコードでもフォント設定を分ければ実現が容易だったからだ。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;フォントごとの &lt;code&gt;scale&lt;/code&gt; オプションを x,y 軸で 2 つのオプション(&lt;code&gt;scale_x&lt;/code&gt;, &lt;code&gt;scale_y&lt;/code&gt;)に分割&lt;/li&gt;&lt;li&gt;narrow 幅に矯正する &lt;code&gt;force_narrow&lt;/code&gt; オプションを追加&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/fontmerger/commit/690830d0842a21445d7ca4e3aa367e1bbf859c31"&gt;Split scale option to x and y scale. Add force_narrow option that for… · krymtkts/fontmerger@690830d&lt;/a&gt;&lt;/p&gt;&lt;p&gt;コードは愚直に書いただけで Cognitive Complexy が 16 を突破してしまったが、期待の通りのフォント変換ができた模様。
これにより残念だった Powerline の隙間・見切れ問題が解決したものと思う。これで現時点では完璧や...という Migu になったので当分は使用を確かめてみようと思う。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2021-05-16-terminal/mypowerline.png" alt="現在のpowerline" /&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;[x] お亡くなりになられた fontmerger を Python3 化して動かす&lt;/li&gt;&lt;li&gt;[x] 最新の Migu に対して fontmerger で Nerd font patch する&lt;/li&gt;&lt;li&gt;[x] &lt;code&gt;0xE0B0&lt;/code&gt; を始めとした Cascadia でだけうまく表示されるグリフを Migu に移植する
&lt;ul&gt;&lt;li&gt;そして効果なし！&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;[x] Nerd Fonts の font-patcher で Migu にパッチしてみる
&lt;ul&gt;&lt;li&gt;フォントが使い物にならなくなった&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;[x] Migu のチャーミングな部分を M+に移植
&lt;ul&gt;&lt;li&gt;縦横比の違いから縦長に...&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;[x] font-merger がパッチするグリフのみ narrow 幅にしてみる
&lt;ul&gt;&lt;li&gt;おしい！右よりフォントが残念&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;[x] font-merger の scale オプションを x,y で分割、強制 narrow 幅オプション追加&lt;/li&gt;&lt;li&gt;[x] 完璧な Migu の完成！&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;完&lt;/p&gt;</description><pubDate>Sun, 30 May 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-05-07-i-want-to-resize-migu-icon</guid><link>https://krymtkts.github.io/posts/2021-05-07-i-want-to-resize-migu-icon</link><title>Migu Nerd Font のアイコンフォントを narrow にしたい</title><description>&lt;p&gt;&lt;a href="/posts/2021-04-11-consideration-of-difference-between-cascadia-and-migu"&gt;以前&lt;/a&gt;、Nerd Fonts の&lt;code&gt;font-patcher&lt;/code&gt;で Migu に Narrow サイズの Symbol グリフぶちこみゃええやんけ、まで来てた。
その後を記す。&lt;/p&gt;&lt;h3 id="nerd-fonts"&gt;Nerd Fonts&lt;/h3&gt;&lt;p&gt;Nerd Font の font-patcher を試す。事前にパッチ済みの M+を見ると完璧なので期待に胸が高ぶる。実行してみると Python モジュールに Windows のライブラリが含まれていたので WSL2 内の Ubuntu では実行できなかった。Windows で実行する。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;fontforge -script font-patcher migu-1m-regular.ttf -s -l -w -c --careful --progressbars -out patched
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;結果、全然アカン... &lt;code&gt;-s, --mono, --use-single-width-glyphs&lt;/code&gt;オプションを有効にすると全グリフが single-width になってしまい日本語フォントとして使いものにならなくなる。&lt;/p&gt;&lt;p&gt;逆にこの完璧な M+が惚れ惚れする出来なので、こちらに半濁音を移植するだけでいい気がしてきた。&lt;/p&gt;&lt;h2 id="font-merger-再び"&gt;font-merger 再び&lt;/h2&gt;&lt;p&gt;コードポイントがわからないので、取得するための関数を PowerShell で作る。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function UC {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true,
            Position = 0,
            ValueFromPipeline = $true,
            ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNullOrEmpty()]
        [String[]]$s
    )
    process {
        foreach ($c in $s) {
            [Convert]::ToInt32($c -as [char]).ToString("x")
        }
    }
}

('がぎぐげござじずぜぞだぢづでどばぱびぴぶぷべぺぼぽゔ'+''+''+'ゞガギグゲゴザジズゼゾダヂヅデドバパビピブプベペボポヴヷヸヹヺ').ToCharArray() | UC
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これで置き換えたい文字(Migu のチャーミングな濁音半濁音たち)のコードポイントを取れるよにした。
特定のコードポイントの移植といえば font-merger 使えるやん！というところではあるが、ほしいコードポイントは連続せず細切れになっているので、これを 1 個ずつ設定に書くのはめんどい...
ということで font-merger の改造をした。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/fontmerger/commit/33c775ef4f1fd47f90b6359f5ae74529552a87a6"&gt;Add codepoint option to copy glyph from specific code points. · krymtkts/fontmerger@33c775e&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;/usr/bin/fontforge -script fontmerger/__init__.py -x migu-1m-regular -o patched --suffix=migu -- ./source/M+1mNerdFontCompleteWindowsCompatible.ttf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;コードポイントを個別に指定できるようにしまして実行したところ、なんかそれっぽく半濁点が反映されてる。
いや待てよ...微妙に縦長になってしまった...これは M+と Migu でフォントの縦横比が異なるせいやろな。&lt;/p&gt;&lt;p&gt;もう FontForge のスクリプティング真面目にやってくしか残された将来はない気がしてきた。😰&lt;/p&gt;&lt;h2 id="font-merger-再び-再び"&gt;font-merger 再び 再び&lt;/h2&gt;&lt;p&gt;Nerd Fonts の font-patcher を読んでいるときに気づいたのが、&lt;code&gt;--mono&lt;/code&gt; オプションを有効にしている場合すべての glyph に narrow 幅を設定するようになっていたこと。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/ryanoasis/nerd-fonts/blob/master/font-patcher#L71-L74"&gt;nerd-fonts/font-patcher at master · ryanoasis/nerd-fonts · GitHub&lt;/a&gt;&lt;/p&gt;&lt;p&gt;日本語フォントの場合 wide 幅を書き換えてしまうから先述の通り Nerf Fonts はえらいことになってしまっていたので、これをパッチするグリフにのみ適用すれば良いという力技に気づく。
ということで更に font-merger を改造した。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/fontmerger/commit/25ed2b1dfd547d6599417793fb679ea9fdbe4548"&gt;Adds mono command line option that forces glyph to be single width. · krymtkts/fontmerger@25ed2b1&lt;/a&gt;&lt;/p&gt;&lt;h2 id="現状"&gt;現状&lt;/h2&gt;&lt;p&gt;これにより全ての追加したアイコングリフが narrow 幅になることで、漸く Windows Terminal でもﾐﾆﾐﾆアイコンフォントにならずに表示できるようになった。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2021-05-07-terminal/mypowerline.png" alt="現在のpowerline。左向き三角が残念" /&gt;&lt;/p&gt;&lt;p&gt;しかしご覧の通り、右に寄るべきフォントの見た目が非常に残念なので、今後もちょいちょいいじらねばならない。完成はいつになるのか...😪
(幅 500 以上になってるためずれる)&lt;/p&gt;&lt;p&gt;なんとなく、次は Powerline グリフの narrow 幅を大きく超過するものを左右の align をつけて変形しないといけない気がしている。
この辺の頂点の xmax, ymax からどないか計算できんかな →
&lt;a href="https://fontforge.org/docs/scripting/python/fontforge.html#fontforge.contour.boundingBox"&gt;fontforge — FontForge 20201107 documentation&lt;/a&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;[x] お亡くなりになられた fontmerger を Python3 化して動かす&lt;/li&gt;&lt;li&gt;[x] 最新の Migu に対して fontmerger で Nerd font patch する&lt;/li&gt;&lt;li&gt;[x] &lt;code&gt;0xE0B0&lt;/code&gt; を始めとした Cascadia でだけうまく表示されるグリフを Migu に移植する
&lt;ul&gt;&lt;li&gt;そして効果なし！&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;[x] Nerd Fonts の font-patcher で Migu にパッチしてみる
&lt;ul&gt;&lt;li&gt;フォントが使い物にならなくなった&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;[x] Migu のチャーミングな部分を M+に移植
&lt;ul&gt;&lt;li&gt;縦横比の違いから縦長に...&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;[x] font-merger がパッチするグリフのみ narrow 幅にしてみる
&lt;ul&gt;&lt;li&gt;おしい！右よりフォントが残念&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;[ ] 完璧な Migu の完成！
&lt;ul&gt;&lt;li&gt;To Be Continued...&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</description><pubDate>Fri, 07 May 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-05-06-simple-way-to-update-pwsh-special-module</guid><link>https://krymtkts.github.io/posts/2021-05-06-simple-way-to-update-pwsh-special-module</link><title>PowerShell の特殊なモジュールを更新する方法</title><description>&lt;p&gt;&lt;code&gt;PSReadLine&lt;/code&gt; のような特殊な PowerShell モジュールを更新する術として、以下の方法を使うようにしている。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;管理者権限で起動したコマンドプロンプトから&lt;/li&gt;&lt;li&gt;非対話モードで&lt;/li&gt;&lt;li&gt;PSReadline を読み込んでるプロファイルを読み込まずに&lt;/li&gt;&lt;li&gt;プレリリース許可＆全ユーザ＆サイドバイサイド でインストール&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class="bat"&gt;REM 、かつ、-NonInteractive でPowerShell Coreを実行
pwsh -NonInteractive -NoProfile -Command "Install-Module PSReadLine -AllowPrerelease -Scope AllUsers -Force"
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Remove-Module&lt;/code&gt; さえちゃんとできてたら更新できると思うんやけど、プロファイルとの組み合わせで意図せず&lt;code&gt;Import-Module&lt;/code&gt;してしまい、しょっちゅうエラーしてしまうので上記手順が楽。
ほんとは pwsh 内からいい感じに処理できればよいのだけどトラシューの時間をこんなとこに割きたくない関係で、更新の都度初手一発でうまくいく手順をやりがち。&lt;/p&gt;&lt;p&gt;エラーになりがちな奴ら。ワイの profile が依存してる関係でエラーになりがち。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;PSReadLine&lt;/li&gt;&lt;li&gt;PowerShellGet&lt;/li&gt;&lt;li&gt;posh-git&lt;/li&gt;&lt;li&gt;Pester&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href="https://docs.microsoft.com/ja-jp/powershell/module/microsoft.powershell.core/about/about_pwsh?view=powershell-7.1"&gt;about_Pwsh - PowerShell | Microsoft Docs&lt;/a&gt;&lt;/p&gt;</description><pubDate>Thu, 06 May 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-04-11-consideration-of-difference-between-cascadia-and-migu</guid><link>https://krymtkts.github.io/posts/2021-04-11-consideration-of-difference-between-cascadia-and-migu</link><title>Cascadia Code PL と Migu Nerd Font の違い</title><description>&lt;p&gt;注意: アイコンフォントのコピペを多用しているので、対応していないフォントを使われている豆腐が見えます。&lt;/p&gt;&lt;h3 id="tldr"&gt;TL;DR&lt;/h3&gt;&lt;p&gt;これはズブのフォント素人による try&amp;amp;error なので大いに間違っている可能性もある。&lt;/p&gt;&lt;p&gt;結論から言うとまだ納得の行く改造版 Migu の作成には至っていない。&lt;/p&gt;&lt;p&gt;Cascadia も Hack も Narrow な Powerline グリフが埋め込まれているっぽい。
ここに来て Migu に直接 Narrow な Powerline グリフを埋め込んだらええやんけ、という Nerd Fonts 回帰案が浮上した(うまく行った試しないのだけど)。&lt;/p&gt;&lt;p&gt;To be Continued...&lt;/p&gt;&lt;h3 id="経緯"&gt;経緯&lt;/h3&gt;&lt;p&gt;長年 Migu を愛用している。&lt;/p&gt;&lt;p&gt;Migu の良さはそのスリムでシンプルな見栄えだけでなく、Proportional と Monospace で同じ字体を使えることだ。
しかし最近の開発環境で使うにはアイコンフォントが同梱されないことで不便を感じることが多い。特に Powerline を使っているとアイコンフォントは必須。
ということで 5 年ほど前から &lt;a href="https://github.com/iij/fontmerger"&gt;iij/fontmerger&lt;/a&gt; を使って Nerd fonts などを追加した自作フォントを使っている。&lt;/p&gt;&lt;p&gt;しかしこれがここ 1,2 年くらいで Windows Terminal を使い始めたことで納得いかない点が出てきた。
"Ambiguous"なフォントについては全部 Narrow サイズになる ≒ Certain なフォントについてはサイズが適用される？だと？&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/microsoft/terminal/pull/2928/commits"&gt;TermControl: force all ambiguous glyphs to be narrow by DHowett-MSFT · Pull Request #2928 · microsoft/terminal&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Windows Terminal とともに提供される &lt;a href="https://github.com/microsoft/cascadia-code"&gt;Cascadia&lt;/a&gt; に関してはどうもこの問題が発生しない。&lt;strong&gt;Powerline グリフに関しては完璧なのだ&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;フォント素人のわたしはこの時こう考えた。&lt;/p&gt;&lt;p&gt;改造 Migu と Cascadia でコードポイントは同じだけどフォントを切り替えるだけで表示サイズが異なってくる。
→ つまり Cascadia フォントでは、コードポイント&lt;code&gt;0xE0B0&lt;/code&gt;とかになんかの情報を入れ込んでるのではないか？と...！&lt;/p&gt;&lt;p&gt;グリフのサイズを目視確認するための一覧用コード。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# Helper function to show Unicode character
function U {
    param
    (
        [int] $Code
    )

    if ((0 -le $Code) -and ($Code -le 0xFFFF)) {
        return [char] $Code
    }

    if ((0x10000 -le $Code) -and ($Code -le 0x10FFFF)) {
        return [char]::ConvertFromUtf32($Code)
    }

    throw "Invalid character code $Code"
}

# 数値は[Convert]::ToInt32('0xE080', 16)でHEX変換する
((170..61278) | %{U $_}) -join ''
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;全然わからない...クソむずすぎる。でも特定のグリフを移植するだけなら、元々改造 Migu を作るのに使っていた fontmerger が利用できる。とおもてたら DEPRECATED になっておった、そら Python2 やからな...&lt;/p&gt;&lt;p&gt;とりあえず最終目標までの段階的目標を立てた。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;お亡くなりになられた fontmerger を Python3 化して動かす&lt;/li&gt;&lt;li&gt;最新の Migu に対して fontmerger で Nerd font patch する&lt;/li&gt;&lt;li&gt;&lt;code&gt;0xE0B0&lt;/code&gt; を始めとした Cascadia でだけうまく表示されるグリフを Migu に移植する&lt;/li&gt;&lt;li&gt;完璧な Migu の完成！&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="2021-03-13"&gt;2021-03-13&lt;/h3&gt;&lt;p&gt;Cascadia を CLI で簡単に落としてくる方法はないものか？&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Invoke-WebRequest -Uri https://github.com/microsoft/cascadia-code/releases/download/v2102.25/CascadiaCode-2102.25.zip -OutFile CascadiaCode-2102.25.zip
Expand-Archive -Path .\CascadiaCode-2102.25.zip -DestinationPath CascadiaCode-2102.25
cd .\CascadiaCode-2102.25\
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="powershell"&gt;                                                                                                                   2021-03-13 15:27
 takatoshi  ~\.\CascadiaCode-2102.25  ll

        Directory: C:\Users\takatoshi\desktop\CascadiaCode-2102.25


Mode                LastWriteTime         Length Name
----                -------------         ------ ----
la---        2021-03-13     15:24                  otf
la---        2021-03-13     15:24                  ttf
la---        2021-03-13     15:24                  woff2

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;フォントの拡張子がわからなくなったのでおさらい。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;otf ... Open Type Font
&lt;ul&gt;&lt;li&gt;Adobe と MS で作った。MS 商標。今や一般的。リガチャ使うならこっちしか無理&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;ttf ... True Type Font
&lt;ul&gt;&lt;li&gt;Apple 作った。プラットフォーム互換がない&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;woff ... Web Open Font Format 2
&lt;ul&gt;&lt;li&gt;Web&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class="powershell"&gt; takatoshi  ~\.\CascadiaCode-2102.25  ll .\otf\static\

        Directory: C:\Users\takatoshi\desktop\CascadiaCode-2102.25\otf\static


Mode                LastWriteTime         Length Name
----                -------------         ------ ----
la---        2021-02-25     20:32         161908   CascadiaCode-Bold.otf
la---        2021-02-25     20:32         150456   CascadiaCode-ExtraLight.otf
la---        2021-02-25     20:32         158652   CascadiaCode-Light.otf
la---        2021-02-25     20:32         158244   CascadiaCode-Regular.otf
la---        2021-02-25     20:32         161960   CascadiaCode-SemiBold.otf
la---        2021-02-25     20:32         159372   CascadiaCode-SemiLight.otf
la---        2021-02-25     20:32         185320   CascadiaCodePL-Bold.otf
la---        2021-02-25     20:32         175352   CascadiaCodePL-ExtraLight.otf
la---        2021-02-25     20:32         181752   CascadiaCodePL-Light.otf
la---        2021-02-25     20:32         181376   CascadiaCodePL-Regular.otf
la---        2021-02-25     20:32         185540   CascadiaCodePL-SemiBold.otf
la---        2021-02-25     20:32         182740   CascadiaCodePL-SemiLight.otf
la---        2021-02-25     20:32         145316   CascadiaMono-Bold.otf
la---        2021-02-25     20:32         133864   CascadiaMono-ExtraLight.otf
la---        2021-02-25     20:32         142060   CascadiaMono-Light.otf
la---        2021-02-25     20:32         141652   CascadiaMono-Regular.otf
la---        2021-02-25     20:32         145368   CascadiaMono-SemiBold.otf
la---        2021-02-25     20:32         142780   CascadiaMono-SemiLight.otf
la---        2021-02-25     20:32         168588   CascadiaMonoPL-Bold.otf
la---        2021-02-25     20:32         158620   CascadiaMonoPL-ExtraLight.otf
la---        2021-02-25     20:32         165020   CascadiaMonoPL-Light.otf
la---        2021-02-25     20:32         164644   CascadiaMonoPL-Regular.otf
la---        2021-02-25     20:32         168808   CascadiaMonoPL-SemiBold.otf
la---        2021-02-25     20:32         166008   CascadiaMonoPL-SemiLight.otf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ここで対象になるのは MonoPL(monospace の PowerLine 版)。まだリガチャを受け入れるだけの心のゆとりができていない。&lt;/p&gt;&lt;p&gt;次に [Migu][https://mix-mplus-ipa.osdn.jp/migu/] を落とす。OSDN のリダイレクトかまされ迂回方法がわからないので手で落とした。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt; takatoshi  ~\desktop  cd .\migu-1m-20200307\
 takatoshi  ~\.\migu-1m-20200307  ll .\migu-1m-20200307\

        Directory: C:\Users\takatoshi\desktop\migu-1m-20200307\migu-1m-20200307


Mode                LastWriteTime         Length Name
----                -------------         ------ ----
la---        2021-03-13     15:39                  ipag00303
la---        2021-03-13     15:39                  mplus-TESTFLIGHT-063a
la---        2020-03-07     22:14        3401580   migu-1m-bold.ttf
la---        2020-03-07     22:12        3144556   migu-1m-regular.ttf
la---        2020-03-08     16:00           2344   migu-README.txt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;fontmerger のスクリプトがちょっと Windows では使いにくそうに見えたので、一旦 Ubuntu(WSL2)でやる。&lt;/p&gt;&lt;p&gt;でも Ubuntu16LTS の fontforge は 2019 年までのやつで古かったので、一旦 WSL2 の Ubuntu を更新することにする。&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;sudo apt update
sudo apt upgrade
sudo do-release-upgrade
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;途中で sshd_config が編集されとんぞ！？と言われて新しいのとローカルのどっち使うか選ばねばいけなかった。ここは新しい方を有効化。この流れで Ubuntu20LTS まで上げた。
Ubuntu20 では fontforge はデフォルトのパッケージではなくなったので、パッケージソースを追加する必要がある。&lt;/p&gt;&lt;p&gt;&lt;a href="https://packages.ubuntu.com/focal/x11/fontforge"&gt;Ubuntu – Details of package fontforge in focal&lt;/a&gt;&lt;/p&gt;&lt;p&gt;universe にあるのがわかったので追加。&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;sudo apt-add-repository universe
sudo apt update
sudo apt install fontforge
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="sh"&gt;mkdir ./patched
./bin/fontmerger --all -o patched --suffix=with-icons -- migu-1m-regular.ttf migu-1m-bold.ttf migu-1c-regular.ttf migu-1c-bold.ttf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;結果、無反応。&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;krymtkts@krymtkts-stealth:/mnt/c/Users/takatoshi/dev/github.com/krymtkts/fontmerger$ /usr/bin/fontforge -script fontmerger/__init__.py
 --all -o patched --suffix=with-icons -- migu-1m-regular.ttf migu-1m-bold.ttf migu-1c-regular.ttf migu-1c-bold.ttf
Copyright (c) 2000-2020. See AUTHORS for Contributors.
 License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
 with many parts BSD &amp;lt;http://fontforge.org/license.html&amp;gt;. Please read LICENSE.
 Version: 20190801
 Based on sources from 03:10 UTC  6-Mar-2020-ML-D-GDK3.
  File "fontmerger/__init__.py", line 103
    except Exception, e:
                    ^
SyntaxError: invalid syntax
Error in sys.excepthook:
Traceback (most recent call last):
  File "/usr/lib/python3.8/subprocess.py", line 64, in &amp;lt;module&amp;gt;
    import msvcrt
ModuleNotFoundError: No module named 'msvcrt'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/usr/lib/python3/dist-packages/apport_python_hook.py", line 72, in apport_excepthook
    from apport.fileutils import likely_packaged, get_recent_crashes
  File "/usr/lib/python3/dist-packages/apport/__init__.py", line 5, in &amp;lt;module&amp;gt;
    from apport.report import Report
  File "/usr/lib/python3/dist-packages/apport/report.py", line 12, in &amp;lt;module&amp;gt;
    import subprocess, tempfile, os.path, re, pwd, grp, os, time, io
  File "/usr/lib/python3.8/subprocess.py", line 69, in &amp;lt;module&amp;gt;
    import _posixsubprocess
ModuleNotFoundError: No module named '_posixsubprocess'

Original exception was:
  File "fontmerger/__init__.py", line 103
    except Exception, e:
                    ^
SyntaxError: invalid syntax
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;あー、Python2 の構文によるエラーね。解消して再実行してみる。引数も間違ってたし。&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;krymtkts@krymtkts-stealth:/mnt/c/Users/takatoshi/dev/github.com/krymtkts/fontmerger$ /usr/bin/fontforge -script fontmerger/__init__.py --all -o patched --suffix=with-icons -- ./source/migu-1m-regular.ttf ./source/migu-1m-bold.ttf ./source/migu-1c-regular.ttf ./source/migu-1c-bold.ttf
Copyright (c) 2000-2020. See AUTHORS for Contributors.
 License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
 with many parts BSD &amp;lt;http://fontforge.org/license.html&amp;gt;. Please read LICENSE.
 Version: 20190801
 Based on sources from 03:10 UTC  6-Mar-2020-ML-D-GDK3.
The following table(s) in the font have been ignored by FontForge
  Ignoring 'EPAR'
The glyph named asterisk is mapped to U+F069.
  But its name indicates it should be mapped to U+002A.
The glyph named plus is mapped to U+F067.
  But its name indicates it should be mapped to U+002B.
The glyph named question is mapped to U+F128.
  But its name indicates it should be mapped to U+003F.
The glyph named minus is mapped to U+F068.
  But its name indicates it should be mapped to U+2212.
The glyph named heart is mapped to U+F004.
  But its name indicates it should be mapped to U+2665.
The glyph named home is mapped to U+F015.
  But its name indicates it should be mapped to U+21B8.
The glyph named check is mapped to U+F046.
  But its name indicates it should be mapped to U+2713.
The glyph named bell is mapped to U+F0A2.
  But its name indicates it should be mapped to U+2407.
The glyph named lessequal is mapped to U+F500.
  But its name indicates it should be mapped to U+2264.
The glyph named circle is mapped to U+F111.
  But its name indicates it should be mapped to U+25CB.
The glyph named smile is mapped to U+F118.
  But its name indicates it should be mapped to U+263A.
The glyph named frown is mapped to U+F119.
  But its name indicates it should be mapped to U+2322.
The glyph named bullseye is mapped to U+F140.
  But its name indicates it should be mapped to U+25CE.
The glyph named compass is mapped to U+F14E.
  But its name indicates it should be mapped to U+263C.
The glyph named female is mapped to U+F182.
  But its name indicates it should be mapped to U+2640.
The glyph named male is mapped to U+F183.
  But its name indicates it should be mapped to U+2642.
The glyph named sun is mapped to U+F185.
  But its name indicates it should be mapped to U+263C.
The glyph named venus is mapped to U+F221.
  But its name indicates it should be mapped to U+2640.
The glyph named slash is mapped to U+E016.
  But its name indicates it should be mapped to U+002F.
The glyph named pi is mapped to U+E02C.
  But its name indicates it should be mapped to U+03C0.
The glyph named ring is mapped to U+E03D.
  But its name indicates it should be mapped to U+02DA.
The glyph named infinity is mapped to U+E055.
  But its name indicates it should be mapped to U+221E.
The glyph named equal is mapped to U+E079.
  But its name indicates it should be mapped to U+003D.
The glyph named question is mapped to U+F02C.
  But its name indicates it should be mapped to U+003F.
The glyph named check is mapped to U+F03A.
  But its name indicates it should be mapped to U+2713.
The glyph named plus is mapped to U+F05D.
  But its name indicates it should be mapped to U+002B.
The glyph named x is mapped to U+F081.
  But its name indicates it should be mapped to U+0078.
The glyph named home is mapped to U+F08D.
  But its name indicates it should be mapped to U+21B8.
The glyph named ellipsis is mapped to U+F09A.
  But its name indicates it should be mapped to U+2026.
The glyph named bell is mapped to U+F0DE.
  But its name indicates it should be mapped to U+2407.
The following table(s) in the font have been ignored by FontForge
  Ignoring 'EPAR'
The glyph named asterisk is mapped to U+F069.
  But its name indicates it should be mapped to U+002A.
The glyph named plus is mapped to U+F067.
  But its name indicates it should be mapped to U+002B.
The glyph named question is mapped to U+F128.
  But its name indicates it should be mapped to U+003F.
The glyph named minus is mapped to U+F068.
  But its name indicates it should be mapped to U+2212.
The glyph named heart is mapped to U+F004.
  But its name indicates it should be mapped to U+2665.
The glyph named home is mapped to U+F015.
  But its name indicates it should be mapped to U+21B8.
The glyph named check is mapped to U+F046.
  But its name indicates it should be mapped to U+2713.
The glyph named bell is mapped to U+F0A2.
  But its name indicates it should be mapped to U+2407.
The glyph named lessequal is mapped to U+F500.
  But its name indicates it should be mapped to U+2264.
The glyph named circle is mapped to U+F111.
  But its name indicates it should be mapped to U+25CB.
The glyph named smile is mapped to U+F118.
  But its name indicates it should be mapped to U+263A.
The glyph named frown is mapped to U+F119.
  But its name indicates it should be mapped to U+2322.
The glyph named bullseye is mapped to U+F140.
  But its name indicates it should be mapped to U+25CE.
The glyph named compass is mapped to U+F14E.
  But its name indicates it should be mapped to U+263C.
The glyph named female is mapped to U+F182.
  But its name indicates it should be mapped to U+2640.
The glyph named male is mapped to U+F183.
  But its name indicates it should be mapped to U+2642.
The glyph named sun is mapped to U+F185.
  But its name indicates it should be mapped to U+263C.
The glyph named venus is mapped to U+F221.
  But its name indicates it should be mapped to U+2640.
The glyph named slash is mapped to U+E016.
  But its name indicates it should be mapped to U+002F.
The glyph named pi is mapped to U+E02C.
  But its name indicates it should be mapped to U+03C0.
The glyph named ring is mapped to U+E03D.
  But its name indicates it should be mapped to U+02DA.
The glyph named infinity is mapped to U+E055.
  But its name indicates it should be mapped to U+221E.
The glyph named equal is mapped to U+E079.
  But its name indicates it should be mapped to U+003D.
The glyph named question is mapped to U+F02C.
  But its name indicates it should be mapped to U+003F.
The glyph named check is mapped to U+F03A.
  But its name indicates it should be mapped to U+2713.
The glyph named plus is mapped to U+F05D.
  But its name indicates it should be mapped to U+002B.
The glyph named x is mapped to U+F081.
  But its name indicates it should be mapped to U+0078.
The glyph named home is mapped to U+F08D.
  But its name indicates it should be mapped to U+21B8.
The glyph named ellipsis is mapped to U+F09A.
  But its name indicates it should be mapped to U+2026.
The glyph named bell is mapped to U+F0DE.
  But its name indicates it should be mapped to U+2407.
The following table(s) in the font have been ignored by FontForge
  Ignoring 'EPAR'
The glyph named asterisk is mapped to U+F069.
  But its name indicates it should be mapped to U+002A.
The glyph named plus is mapped to U+F067.
  But its name indicates it should be mapped to U+002B.
The glyph named question is mapped to U+F128.
  But its name indicates it should be mapped to U+003F.
The glyph named minus is mapped to U+F068.
  But its name indicates it should be mapped to U+2212.
The glyph named heart is mapped to U+F004.
  But its name indicates it should be mapped to U+2665.
The glyph named home is mapped to U+F015.
  But its name indicates it should be mapped to U+21B8.
The glyph named check is mapped to U+F046.
  But its name indicates it should be mapped to U+2713.
The glyph named bell is mapped to U+F0A2.
  But its name indicates it should be mapped to U+2407.
The glyph named lessequal is mapped to U+F500.
  But its name indicates it should be mapped to U+2264.
The glyph named circle is mapped to U+F111.
  But its name indicates it should be mapped to U+25CB.
The glyph named smile is mapped to U+F118.
  But its name indicates it should be mapped to U+263A.
The glyph named frown is mapped to U+F119.
  But its name indicates it should be mapped to U+2322.
The glyph named bullseye is mapped to U+F140.
  But its name indicates it should be mapped to U+25CE.
The glyph named compass is mapped to U+F14E.
  But its name indicates it should be mapped to U+263C.
The glyph named female is mapped to U+F182.
  But its name indicates it should be mapped to U+2640.
The glyph named male is mapped to U+F183.
  But its name indicates it should be mapped to U+2642.
The glyph named sun is mapped to U+F185.
  But its name indicates it should be mapped to U+263C.
The glyph named venus is mapped to U+F221.
  But its name indicates it should be mapped to U+2640.
The glyph named slash is mapped to U+E016.
  But its name indicates it should be mapped to U+002F.
The glyph named pi is mapped to U+E02C.
  But its name indicates it should be mapped to U+03C0.
The glyph named ring is mapped to U+E03D.
  But its name indicates it should be mapped to U+02DA.
The glyph named infinity is mapped to U+E055.
  But its name indicates it should be mapped to U+221E.
The glyph named equal is mapped to U+E079.
  But its name indicates it should be mapped to U+003D.
The glyph named question is mapped to U+F02C.
  But its name indicates it should be mapped to U+003F.
The glyph named check is mapped to U+F03A.
  But its name indicates it should be mapped to U+2713.
The glyph named plus is mapped to U+F05D.
  But its name indicates it should be mapped to U+002B.
The glyph named x is mapped to U+F081.
  But its name indicates it should be mapped to U+0078.
The glyph named home is mapped to U+F08D.
  But its name indicates it should be mapped to U+21B8.
The glyph named ellipsis is mapped to U+F09A.
  But its name indicates it should be mapped to U+2026.
The glyph named bell is mapped to U+F0DE.
  But its name indicates it should be mapped to U+2407.
The following table(s) in the font have been ignored by FontForge
  Ignoring 'EPAR'
The glyph named asterisk is mapped to U+F069.
  But its name indicates it should be mapped to U+002A.
The glyph named plus is mapped to U+F067.
  But its name indicates it should be mapped to U+002B.
The glyph named question is mapped to U+F128.
  But its name indicates it should be mapped to U+003F.
The glyph named minus is mapped to U+F068.
  But its name indicates it should be mapped to U+2212.
The glyph named heart is mapped to U+F004.
  But its name indicates it should be mapped to U+2665.
The glyph named home is mapped to U+F015.
  But its name indicates it should be mapped to U+21B8.
The glyph named check is mapped to U+F046.
  But its name indicates it should be mapped to U+2713.
The glyph named bell is mapped to U+F0A2.
  But its name indicates it should be mapped to U+2407.
The glyph named lessequal is mapped to U+F500.
  But its name indicates it should be mapped to U+2264.
The glyph named circle is mapped to U+F111.
  But its name indicates it should be mapped to U+25CB.
The glyph named smile is mapped to U+F118.
  But its name indicates it should be mapped to U+263A.
The glyph named frown is mapped to U+F119.
  But its name indicates it should be mapped to U+2322.
The glyph named bullseye is mapped to U+F140.
  But its name indicates it should be mapped to U+25CE.
The glyph named compass is mapped to U+F14E.
  But its name indicates it should be mapped to U+263C.
The glyph named female is mapped to U+F182.
  But its name indicates it should be mapped to U+2640.
The glyph named male is mapped to U+F183.
  But its name indicates it should be mapped to U+2642.
The glyph named sun is mapped to U+F185.
  But its name indicates it should be mapped to U+263C.
The glyph named venus is mapped to U+F221.
  But its name indicates it should be mapped to U+2640.
The glyph named slash is mapped to U+E016.
  But its name indicates it should be mapped to U+002F.
The glyph named pi is mapped to U+E02C.
  But its name indicates it should be mapped to U+03C0.
The glyph named ring is mapped to U+E03D.
  But its name indicates it should be mapped to U+02DA.
The glyph named infinity is mapped to U+E055.
  But its name indicates it should be mapped to U+221E.
The glyph named equal is mapped to U+E079.
  But its name indicates it should be mapped to U+003D.
The glyph named question is mapped to U+F02C.
  But its name indicates it should be mapped to U+003F.
The glyph named check is mapped to U+F03A.
  But its name indicates it should be mapped to U+2713.
The glyph named plus is mapped to U+F05D.
  But its name indicates it should be mapped to U+002B.
The glyph named x is mapped to U+F081.
  But its name indicates it should be mapped to U+0078.
The glyph named home is mapped to U+F08D.
  But its name indicates it should be mapped to U+21B8.
The glyph named ellipsis is mapped to U+F09A.
  But its name indicates it should be mapped to U+2026.
The glyph named bell is mapped to U+F0DE.
  But its name indicates it should be mapped to U+2407.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;警告出るがフォントの生成完了。開いてみるも、いやフォントが壊れてるわ...なんでや？&lt;/p&gt;&lt;p&gt;理由がわかった。fontmerger の実行後に出力先フォルダからフォントを移動するとプレビューできる。出力先フォルダに fontforge の謎のハンドルが残っている様子。&lt;/p&gt;&lt;p&gt;fontmerger の Python3 化が完了した。&lt;a href="https://github.com/krymtkts/fontmerger"&gt;GitHub - krymtkts/fontmerger: FontForge script for to merge any fonts&lt;/a&gt;&lt;/p&gt;&lt;h3 id="2021-04-10"&gt;2021-04-10&lt;/h3&gt;&lt;p&gt;Cascadia からコピる範囲を決める。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt; takatoshi  ~\.\.\.\fontmerger   master ≣ +1 ~2 -6 !  [Convert]::ToInt32('0xE0A0', 16)
57504
 takatoshi  ~\.\.\.\fontmerger   master ≣ +1 ~2 -6 !  [Convert]::ToInt32('0xE0D4', 16)
57556                                                                                                             2021-04-10 15:17
 takatoshi  ~\.\.\.\fontmerger   master ≣ +1 ~2 -6 !  ((57504..57556) | %{U $_}) -join ''

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Cascadia には Powerline の拡張グリフくらいしか入っていないので Powerline の部分を抜き出して Migu にコピーする。&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;/usr/bin/fontforge -script fontmerger/__init__.py --all -o patched --suffix=cascadia -- ./source/migu-1m-regular.ttf ./source/migu-1m-bold.ttf ./source/migu-1c-regular.ttf ./source/migu-1c-bold.ttf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;結果は Cascadia からコピーした領域は以前 Ambiguous なままだった...なんでだろう。以下が追加の Cascadia からコピる設定。&lt;/p&gt;&lt;pre&gt;&lt;code class="json"&gt;{
    "id": "cascadia-powerline",
    "name": "Cascadia Powerline Symbols",
    "description": "Powerline symbols copied from Cascadia Code. https://github.com/microsoft/cascadia-code",
    "filename": "./fonts/cascadia/CascadiaCodePL-Regular.otf",
    "unicode_range": [
      "E0A0",
      "E0D4"
    ]
  },
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;コピっても解消しないのか...と思ってた矢先、フォカのフォントを参考に調べていて &lt;a href="https://github.com/yuru7/HackGen"&gt;GitHub - yuru7/HackGen: HackGen is Japanese programming font which is a composed of Hack and GenJyuu-Gothic.&lt;/a&gt; なるフォントを見つけた。&lt;/p&gt;&lt;p&gt;あれ、このフォント Powerline グリフが Windows Terminal でも崩れないし、見た目も結構好みでこれちょっとよいかも...と浮気しそうになるも、やはり字幅の広さが気に入らず Migu に返り咲くワイ。&lt;/p&gt;&lt;p&gt;それはそうと Powerline グリフが崩れないのはなんでか？と思ってみてたところ、これ Symbol フォントが Narrow スペースなのね。Cascadia もそう。つまり問題なのはフォント幅じゃね？と気づく。
更に々々、Nerd Fonts から提供されている Hack を使うと、PowerShell モジュールの Terminal Icons で表示されるファイルアイコンすらも小さくならずに表示できるではないかい！これやろ答え。&lt;/p&gt;&lt;p&gt;数年前に試してうまくいったことがないのが心配のタネだが、ここは原点回帰して Nerd Fonts の font-patcher で Migu に Narrow スペースでパッチしてみるか～という気持ちになった。&lt;/p&gt;&lt;h3 id="現状"&gt;現状&lt;/h3&gt;&lt;p&gt;ただ単に Migu の最新版にパッチしただけの状態になっているのだが、途中経過をまとめておかないと着手する時加齢に忘れてて辛いので一旦状況をまとめた。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;[x] お亡くなりになられた fontmerger を Python3 化して動かす&lt;/li&gt;&lt;li&gt;[x] 最新の Migu に対して fontmerger で Nerd font patch する&lt;/li&gt;&lt;li&gt;[x] &lt;code&gt;0xE0B0&lt;/code&gt; を始めとした Cascadia でだけうまく表示されるグリフを Migu に移植する
&lt;ul&gt;&lt;li&gt;そして効果なし！&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;[ ] Nerd Fonts の font-patcher で Migu にパッチしてみる &amp;lt;- &lt;strong&gt;NEW!!!&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;[ ] 完璧な Migu の完成！&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;俺たちの戦いはこれからだ！😭😭😭&lt;/p&gt;</description><pubDate>Sun, 11 Apr 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-03-06-fix-publish-failure-to-powershell-gallery</guid><link>https://krymtkts.github.io/posts/2021-03-06-fix-publish-failure-to-powershell-gallery</link><title>PSGallery への公開つまづき 2021</title><description>&lt;p&gt;今年のはじめに&lt;a href="https://github.com/krymtkts/Get-GzipContent"&gt;krymtkts/Get-GzipContent: Get-Content for gzip files.&lt;/a&gt;の更新を行った際に、PoweShell Gallery への公開で手間取った。その 2 ヶ月遅れの記録である。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/PowerShell/PowerShellGetv2/issues/303#issuecomment-433139506"&gt;Publish-Module throws error "Failed to generate the compressed file for module 'Microsoft (R) Build Engine version 15.7.179.6572 for .NET Core'" · Issue #303 · PowerShell/PowerShellGetv2&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Invoke-WebRequest -Uri https://dist.nuget.org/win-x86-commandline/latest/nuget.exe -OutFile "$env:LOCALAPPDATA\Microsoft\Windows\PowerShell\PowerShellGet\NuGet.exe"
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;いやまあこれで直ったんやけど、わからなさすぎてこの記事も見た。&lt;/p&gt;&lt;p&gt;&lt;a href="https://sqldbawithabeard.com/2019/11/26/fixing-the-failed-to-generate-the-compressed-file-for-module-cprogram-filesdotnetdotnet-exe-error-when-deploying-to-the-powershell-gallery-using-azure-devops/"&gt;Fixing the ‘Failed to generate the compressed file for module ‘C:\Program Files\dotnet\dotnet.exe’ error when deploying to the PowerShell Gallery using Azure DevOps | SQL DBA with A Beard&lt;/a&gt;&lt;/p&gt;&lt;p&gt;これは一時しのぎなので最終的に目指すのは配置している&lt;code&gt;nuget.exe&lt;/code&gt;を消し去っても動くようになることだ。とはいえまた次公開するときまで使うときがないので試すのめんどくせええ＆次試そうと思っても忘れる...ということで一旦 Chocolatey で NuGet を入れておいて保険とした。でもこれ自体も本来バイナリ不要で動いてたことからしたら蛇足のはずやねんけどな、Issue に進捗なく Close されてるからわからん。まあ日記にも書いたからエラーしたときにきっと振り返れる、未来のワイ。&lt;/p&gt;&lt;p&gt;あと年に数回しか PowerShell Gallery に公開しないとやり方とか色々忘れるのだけど、一番忘れるのが API キーの寿命が短く設定してあって切れてるということ。今回期限切れの API キーを再有効化できるってのを知ったので、それはそれで良。&lt;/p&gt;&lt;p&gt;&lt;a href="https://docs.microsoft.com/ja-jp/powershell/scripting/gallery/how-to/managing-profile/creating-apikeys?view=powershell-7.1#editing-and-deleting-existing-api-keys"&gt;API キーの管理 - PowerShell | Microsoft Docs&lt;/a&gt;&lt;/p&gt;</description><pubDate>Sat, 06 Mar 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-02-12-various-stories-about-starting-to-use-nodist</guid><link>https://krymtkts.github.io/posts/2021-02-12-various-stories-about-starting-to-use-nodist</link><title>色々あって Nodist を使い始めた話</title><description>&lt;p&gt;重い腰を上げて、&lt;a href="https://github.com/krymtkts/mccall-bot"&gt;Slackbot のマッコールさん&lt;/a&gt;の Typo を直す気になった。
タイポの修正と追加のセンテンスを登録して、いざ deploy しようとしたら、Serverless Framework がエラーを吐くようになっていた。↓ らしい。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/serverless/serverless/issues/8794"&gt;Unable to deploy to Serverless due to 'empty zip' · Issue #8794 · serverless/serverless&lt;/a&gt;&lt;/p&gt;&lt;p&gt;aws-cdk の方も同様のバグがあるらしいけど、あっちは直してくれてるみたい。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/aws/aws-cdk/issues/12536"&gt;lambda: corrupt zip archive asset produced when using node v15.6 · Issue #12536 · aws/aws-cdk&lt;/a&gt;&lt;/p&gt;&lt;p&gt;残念ながら Serverless Framework の方は直してないっぽなので、Node.js のバージョンを 15 から 14 に落とす必要が出てきた。この時リアルタイムで友人に &lt;a href="https://github.com/nullivex/nodist"&gt;nodist&lt;/a&gt; を教えてもらったので、これを使って複数の系を利用できるようにした。&lt;/p&gt;&lt;p&gt;&lt;del&gt;(というか Chocolatey で Node.js の v15 を uninstall して v14 入れようとしてもなんかエラーになって、ログ見たら「新しい版いるから失敗するね！」てあって「はぁ!?」と調べたら&lt;code&gt;choco uninstall nodejs&lt;/code&gt;は仕事してくれへんらしい。古き良き Chocolatey 流儀はやめろ。で日頃使ってた node modules も全部吹っ飛んで災難やで...)&lt;/del&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;choco install nodist -y
# RapidEE で PATH に `C:\Program Files (x86)\Nodist\bin` を追加した

# nodist と一緒に install される系は古い
nodist list
  (x64)
&amp;gt; 11.13.0
# 15 系と 14 系の最新を入れる
nodist add 15.8.0
nodist add 14.15.5
# 14 系を選択
nodist 14.15.5
# npm も古い
nodist npm list
&amp;gt; 6.9.0
# 選択中の node と合わせる
nodist npm match
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href="https://nodejs.org/ja/download/releases/"&gt;Node.js のリリース一覧&lt;/a&gt;から node と npm の対応を見て選んでってやってもいいけど、そんなんめんどすぎるので &lt;code&gt;nodist npm match&lt;/code&gt; の一度ではないかと考える。
もし、厳密に指定のバージョン使いたいとかあったら加初環境をコンテナに構築したりすればいいし、そもそも nodist を使ってローカル PC のグローバル node をこねくったりしてないはず。&lt;/p&gt;&lt;p&gt;ちょっとおもしろいのが、node/npm の version を変えても install した node_modules は同じものを使えるところ。 v14.15.5 で入れたモジュールが v15.8.0 でも見れた。何度も同じモジュールをインストールしなくていいのは楽やけど、バージョン互換性の厳しいモジュールは使うのが難しいのでは。&lt;/p&gt;&lt;p&gt;node、npm、モジュールの実態はそれぞれ、&lt;code&gt;$env:NODIST_PREFIX/v-x64&lt;/code&gt;(32bit が&lt;code&gt;$env:NODIST_PREFIX/v&lt;/code&gt;?) &lt;code&gt;$env:NODIST_PREFIX/npmv&lt;/code&gt; &lt;code&gt;$env:NODIST_PREFIX/bin/node_modules&lt;/code&gt; 配下にインストールされる様子。&lt;/p&gt;&lt;p&gt;nodist、どうも 2019 年を最後にメンテが止まっている様子(単にマジで変更がないのかも知れん)。現時点でこいつが最後 &lt;a href="https://github.com/nullivex/nodist/commit/bb099ba3723027469bf46e3159f51171b5dd4b59"&gt;Fix deprecated use of Tar.Extract in npm.js, release 0.9.1 · nullivex/nodist@bb099ba&lt;/a&gt;&lt;/p&gt;&lt;p&gt;とはいえ便利なので不都合ない限り利用してみるつもり。&lt;/p&gt;&lt;p&gt;と色々やったことでようやくマッコールさん Bot の最新版を deploy できるようになったとさ。めでたし x2。&lt;/p&gt;</description><pubDate>Fri, 12 Feb 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-02-01-go-map-key-tips</guid><link>https://krymtkts.github.io/posts/2021-02-01-go-map-key-tips</link><title>go の map のキーの Tips</title><description>&lt;ul&gt;&lt;li&gt;知ってた
&lt;ul&gt;&lt;li&gt;&lt;code&gt;map&lt;/code&gt;のキーには&lt;code&gt;struct&lt;/code&gt;が使える&lt;/li&gt;&lt;li&gt;キーがポインタやポインタを含む&lt;code&gt;struct&lt;/code&gt;の場合、ポインタの指す値が同じでもポインタ値自体が比較されるため異なるキーとなる&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;知らなかった
&lt;ul&gt;&lt;li&gt;&lt;code&gt;interface&lt;/code&gt;もキーにできる
&lt;ul&gt;&lt;li&gt;キーを追加するときにポインタを使ってないこと&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;time.Time&lt;/code&gt;はキーにつこたらあかん
&lt;ul&gt;&lt;li&gt;&lt;a href="https://go.googlesource.com/go/+/go1.15.6/src/time/time.go#147"&gt;src/time/time.go - go - Git at Google&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://pkg.go.dev/time#Time"&gt;time · pkg.go.dev&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;blockquote&gt;&lt;p&gt;Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. Therefore, Time values should not be used as map or database keys without first guaranteeing that the identical Location has been set for all values, which can be achieved through use of the UTC or Local method, and that the monotonic clock reading has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u) to t == u, since t.Equal uses the most accurate comparison available and correctly handles the case when only one of its arguments has a monotonic clock reading.&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;UT では一致しちゃいバグを見つけられなかった...😥&lt;/li&gt;&lt;li&gt;まだわかってないのが、&lt;code&gt;Location&lt;/code&gt;が必ず同じになるようにしてた＆年月日だけの情報しか持ってなかったのにずれとんのかい！？というところ&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href="https://play.golang.org/p/Rd5OJ2S37AT"&gt;コード&lt;/a&gt;。このコードでは&lt;code&gt;time.Time&lt;/code&gt;のキーのズレは再現しないけど。&lt;/p&gt;&lt;pre&gt;&lt;code class="go"&gt;package main

import (
	"fmt"
	"time"
)

type Key interface {
}

type KeyA struct {
	s string
}

type KeyB struct {
	s string
	i int
}

type KeyC struct {
	t time.Time
}

type KeyD struct {
	a *KeyA
}

func checkInterfaceKey() {
	m := map[Key]int{}
	m[KeyA{
		s: "A1",
	}] = 1
	m[KeyA{
		s: "A1",
	}] = 2
	m[KeyA{
		s: "A2",
	}] = 3
	m[KeyB{
		s: "B1",
		i: 1,
	}] = 4
	m[KeyB{
		s: "B1",
		i: 1,
	}] = 5
	m[KeyB{
		s: "B1",
		i: 2,
	}] = 6
	fmt.Printf("%v\n", m)
}

func init() {
	location := "Asia/Tokyo"
	loc, err := time.LoadLocation(location)
	if err != nil {
		loc = time.FixedZone(location, 9*60*60)
	}
	time.Local = loc
	fmt.Printf("%v\n", loc)
}

func checkPointerIncludedKey() {
	m := map[Key]int{}
	m[KeyC{
		t: time.Date(2021, 2, 1, 0, 0, 0, 0, time.Local),
	}] = 1
	m[KeyC{
		t: time.Date(2021, 2, 1, 0, 0, 0, 0, time.Local),
	}] = 2
	m[KeyD{
		a: &amp;amp;KeyA{
			s: "D1",
		},
	}] = 3
	m[KeyD{
		a: &amp;amp;KeyA{
			s: "D1",
		},
	}] = 4
	fmt.Printf("%v\n", m)
}

func main() {
	checkInterfaceKey()
	checkPointerIncludedKey()
}

&lt;/code&gt;&lt;/pre&gt;</description><pubDate>Mon, 01 Feb 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-01-30-beware-to-update-aws-tools</guid><link>https://krymtkts.github.io/posts/2021-01-30-beware-to-update-aws-tools</link><title>AWS.Tools.Installer で入れたモジュールの更新は気をつけろよ</title><description>&lt;pre&gt;&lt;code class="powershell"&gt;Install-Package: C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\PowerShellGet\2.2.5\PSModule.psm1:13069
 Line |
13069 |  …           $sid = PackageManagement\Install-Package @PSBoundParameters
      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      | Unable to find repository 'C:\Users\takatoshi\AppData\Local\Temp\xeqcnbnp.pgl'. Use Get-PSRepository to see all available repositories.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;普段 PowerShell Module を一括更新しているのだけど、変なエラーが出るよになった。&lt;/p&gt;&lt;p&gt;一括更新は、 &lt;code&gt;Get-InstalledModule | Update-Module -AllowPrerelease&lt;/code&gt; で。&lt;/p&gt;&lt;p&gt;ちょうど最近、 &lt;a href="https://github.com/PowerShell/PowerShellGetv2/issues/303"&gt;Publish-Module うまくいかない問題&lt;/a&gt; を解消したり Win10 の更新したりしてたので、そのへんかなーと思い NuGet の Provider の登録し直しとか色々やっても直らず 😥&lt;/p&gt;&lt;p&gt;初心に帰って、↑ のログを見てみたら「何やねんこの謎 repo」というのに気づき、 改めて&lt;code&gt;Get-InstalledModule&lt;/code&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code class="PowerShell"&gt; ⚡ takatoshi  ~  Get-InstalledModule

Version              Name                                Repository           Description
-------              ----                                ----------           -----------
4.1.7.0              AWS.Tools.Amplify                   C:\Users\takatoshi\… The Amplify module of AWS Tools for PowerShell lets developers and administrators manage AWS Amplify from the PowerShell scripting environment. In order to manage each AWS service, install th…
4.1.7.0              AWS.Tools.CloudFormation            C:\Users\takatoshi\… The CloudFormation module of AWS Tools for PowerShell lets developers and administrators manage AWS CloudFormation from the PowerShell scripting environment. In order to manage each AWS servi…
4.1.7.0              AWS.Tools.Common                    C:\Users\takatoshi\… The AWS Tools for PowerShell lets developers and administrators manage their AWS services from the PowerShell scripting environment. In order to manage each AWS service, install the correspon…
4.1.7.0              AWS.Tools.EC2                       C:\Users\takatoshi\… The EC2 module of AWS Tools for PowerShell lets developers and administrators manage Amazon Elastic Compute Cloud (EC2) from the PowerShell scripting environment. In order to manage each AWS …
4.1.7.0              AWS.Tools.IdentityManagement        C:\Users\takatoshi\… The IdentityManagement module of AWS Tools for PowerShell lets developers and administrators manage AWS Identity and Access Management from the PowerShell scripting environment. In order to m…
1.0.2.0              AWS.Tools.Installer                 PSGallery            The AWS.Tools.Installer module makes it easier to install, update and uninstall other AWS.Tools modules (see https://www.powershellgallery.com/packages/AWS.Tools.Common/).…
4.1.7.0              AWS.Tools.Lambda                    C:\Users\takatoshi\… The Lambda module of AWS Tools for PowerShell lets developers and administrators manage AWS Lambda from the PowerShell scripting environment. In order to manage each AWS service, install the …
4.1.7.0              AWS.Tools.S3                        C:\Users\takatoshi\… The S3 module of AWS Tools for PowerShell lets developers and administrators manage Amazon Simple Storage Service (S3) from the PowerShell scripting environment. In order to manage each AWS s…
4.1.7.0              AWS.Tools.SecretsManager            C:\Users\takatoshi\… The SecretsManager module of AWS Tools for PowerShell lets developers and administrators manage AWS Secrets Manager from the PowerShell scripting environment. In order to manage each AWS serv…
0.1.8                ClipboardText                       PSGallery            Support for text-based clipboard operations for PowerShell Core (cross-platform) and older versions of Windows PowerShell
1.3.1                Configuration                       PSGallery            A module for storing and reading configuration values, with full PS Data serialization, automatic configuration for modules and scripts, etc.
1.2010.0.201211      DockerCompletion                    PSGallery            Docker command completion for PowerShell.
1.27.0.200908        DockerComposeCompletion             PSGallery            Docker Compose command completion for PowerShell.
0.16.2.190903        DockerMachineCompletion             PSGallery            Docker Machine command completion for PowerShell.
0.2                  MavenAutoCompletion                 PSGallery            Maven Auto Completion provides a simple auto completion of Maven 3 to PowerShell.
3.75.0-beta          oh-my-posh                          PSGallery            A prompt theme engine for any shell
1.4.7                PackageManagement                   PSGallery            PackageManagement (a.k.a. OneGet) is a new way to discover and install software packages from around the web.…
5.1.0-rc1            Pester                              PSGallery            Pester provides a framework for running BDD style Tests to execute and validate PowerShell commands inside of PowerShell and offers a powerful set of Mocking Functions that allow tests to mim…
1.1.0                poco                                PSGallery            Interactive filtering command based on peco
1.0.0-beta3          posh-git                            PSGallery            Provides prompt with Git status summary information and tab completion for Git commands, parameters, remotes and branch names.
0.16.0               PowerShellForGitHub                 PSGallery            PowerShell wrapper for GitHub API
3.0.0-beta10         PowerShellGet                       PSGallery            PowerShell module with commands for discovering, installing, updating and publishing the PowerShell artifacts like Modules, DSC Resources, Role Capabilities and Scripts.
4.9.0                psake                               PSGallery            psake is a build automation tool written in PowerShell.
2.2.0-beta1          PSReadLine                          PSGallery            Great command line editing in the PowerShell console host
1.19.1               PSScriptAnalyzer                    PSGallery            PSScriptAnalyzer provides script analysis and checks for potential code defects in the scripts by applying a group of built-in or customized rules on the scripts being analyzed.
0.2.2                Terminal-Icons                      PSGallery            PowerShell module to add file icons to terminal based on file extension
2.2.0                Get-ChildItemColor                  PSGallery            Get-ChildItemColor provides colored versions of Get-ChildItem Cmdlet and Get-ChildItem | Format-Wide (ls equivalent)
0.1.2                Get-GzipContent                     PSGallery            Gets the content of the gzip archive at the specified location.
1.0.1.10             GoogleCloud                         PSGallery            PowerShell cmdlets for the Google Cloud Platform.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ﾌｷﾞｬｰ、AWS.Tools.Installer で入れたモジュールは全て repo が一時ファイルになっとるやんけ！😇&lt;/p&gt;&lt;p&gt;これは事案ですね。ということでとりま暫定対処として Repository が PSGallery のやつだけにした。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Get-InstalledModule | Where-Object -Property Repository -eq 'PSGallery' | Update-Module -AllowPrerelease
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href="https://github.com/aws/aws-tools-for-powershell/issues?q=is%3Aissue+is%3Aopen+unable+to+find+repository"&gt;AWS Tools の GitHub&lt;/a&gt; を見てみても誰も同じような話はしてないし、みんな真面目に&lt;code&gt;Update-AWSToolsModule&lt;/code&gt;と&lt;code&gt;Update-Module&lt;/code&gt;使い分けれてんねな～エライ！というのに気づいた一日であった。&lt;/p&gt;&lt;p&gt;ﾁｬﾝﾁｬﾝ。&lt;/p&gt;</description><pubDate>Sat, 30 Jan 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2021-01-04-planning</guid><link>https://krymtkts.github.io/posts/2021-01-04-planning</link><title>2021</title><description>&lt;p&gt;年始めに抱負を明文化しておくのと年末振り返りしやすいから例年通りやっとく。
なんか定量的なやつと定性的なやつがごっちゃになっとるけど、ええんや。&lt;/p&gt;&lt;h4 id="テーマ-自分を大事に"&gt;テーマ: 自分を大事に&lt;/h4&gt;&lt;p&gt;これは仕事と自己学習の両方でだ。&lt;/p&gt;&lt;p&gt;仕事の方は、年末年始ずっと働き詰めだった。土日以外で完全な休みは今日 2020-01-04 となってしまった。もちろん家族への負担も大きかったし、年末年始でやろうと思っていた勉強だったり久しぶりにゲームやっちゃうかな？といった Fun な部分も全て蔑ろにしてしまった。
何でもかんでも「ワイがやらなあかんねや」と意気込むのは良いのだが、そこで得られるものとは如何に？刮目せなあかん。
数年前にエッセンシャル思考を読んだあと、立ち振舞を改めたときの状況に似ている。同じ轍を踏んでもーたわけでみっともない話や。&lt;/p&gt;&lt;p&gt;わたしが働くのは、楽しくプログラムを書いて自分を高め、かつ日銭を稼ぐことのできる都合が良い仕事だからだ。自身の人生を蔑ろにしたいわけではない。ここを改めて強調していきたい。&lt;/p&gt;&lt;p&gt;自己学習においても同様、WFH 歴もあと数ヶ月で 1 年となるけど、家のことをやる時間だけが増殖して、本を読む機会を失ってしまった。このように自分の考えを文章にまとめる機会すら少なくなっていた。これはよろしくない。
新しい技術などは極力仕事で取り組めるように取りなしているが、そこから溢れるものは私生活で掬うしかない。
学習習慣を日常生活に浸透させることでこの状況を打破したい。&lt;/p&gt;&lt;h3 id="2021-年の目標"&gt;2021 年の目標&lt;/h3&gt;&lt;p&gt;継続するテーマと新しい奴ら。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;NEW!&lt;/strong&gt; 住みたい場所を決める
&lt;ul&gt;&lt;li&gt;長年田舎に住みたいと思っているのだけど、昨年色々あって目当てだったところは住むのが難しそうになった。とりあえず今年はふんわりとでも候補地を固めるのが目標。&lt;/li&gt;&lt;li&gt;現職は WFH やからいいけどもし転職したら...とか考えると成約ばかりにで嫌気がさすが、そこは縛りゲーばりに割り切ってフルリモートの仕事しか選ばん所存。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;NEW!&lt;/strong&gt; 仕事上の掃除
&lt;ul&gt;&lt;li&gt;&lt;code&gt;組織とビジネスは潰す、ひとつずつ、一ドルずつ、一人ずつ - ロバート・マッコール&lt;/code&gt;&lt;/li&gt;&lt;li&gt;壊れたままの〇〇
&lt;ul&gt;&lt;li&gt;CI パイプライン直す&lt;/li&gt;&lt;li&gt;テスト直す&lt;/li&gt;&lt;li&gt;チーム直す&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;これはまず家を建てる前に土台を固めるのと同じことなので、この障害を取り除かんとアプリをもりもり書くのも難しい&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;昇給
&lt;ul&gt;&lt;li&gt;やってることが間違っていなけれ場評価は勝手についてくるのだが、金額はついてこないので、ここは要相談やな&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;積ん読の消化
&lt;ul&gt;&lt;li&gt;月に 1 冊を消化する&lt;/li&gt;&lt;li&gt;いま SNS 殆どやってないけど、Chrome のサジェストや RSS のフィードを読む時間増えてるので、そこを読書に置き換える&lt;/li&gt;&lt;li&gt;手の届くとこに読んでる本数冊を置くとか？&lt;/li&gt;&lt;li&gt;いま昼飯時間も仕事してるからそれを単純に読書に置き換えるのも良い&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;OSS へのコントリビューション
&lt;ul&gt;&lt;li&gt;気が向いたら。とりあえず今は身の回りのこと優先なので低く。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;自作ツールの更新
&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/Get-GzipContent"&gt;krymtkts/Get-GzipContent: Get-Content for gzip files.&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;*&lt;/code&gt; ファイルに対応させる(最近できてへんのに気づいた)&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/mccall-bot"&gt;mccall-bot&lt;/a&gt;&lt;ul&gt;&lt;li&gt;Typo 修正、マルチチャンネル対応したい...&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;ギター練習を 30 分/週 3 回
&lt;ul&gt;&lt;li&gt;&lt;a href="https://aristidesinstruments.com/guitar/h-08"&gt;真に求めていたスペックのギター&lt;/a&gt;が現れたのだけど、スキルのほうが劣化しすぎて...一から出直すため&lt;/li&gt;&lt;li&gt;バンド練習は COVID19 のこともあるし当面無理かな&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://krymtkts.github.io/"&gt;このブログ&lt;/a&gt;を毎月更新する
&lt;ul&gt;&lt;li&gt;いつも未達なので&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;NEW!&lt;/strong&gt; 日頃使ってるスニペット的なのを Gist に登録していく
&lt;ul&gt;&lt;li&gt;Evernote に書いたりローカルに残してるよりも、こっちのほうが良さそうやから&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</description><pubDate>Mon, 04 Jan 2021 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2020-12-27-ns-record-of-route53-hosted-zone</guid><link>https://krymtkts.github.io/posts/2020-12-27-ns-record-of-route53-hosted-zone</link><title>Rote53 ホストゾーンの NS レコード</title><description>&lt;p&gt;これで 12 月だいぶ躓いたので書いとくわ。思い出じゃ。&lt;/p&gt;&lt;p&gt;NS レコードは Simple Routing しかサポートしてへん。まずそれは AWS Management Console でわかる。
これを AWSPowerShell のパラメータでどうやんのかがわからんかった。ワタシが阿呆やからに違いない。&lt;/p&gt;&lt;script src="https://gist.github.com/krymtkts/7774bb65f2f0351697a47383aefe9ec9.js"&gt;&lt;/script&gt;&lt;p&gt;はまったところ。&lt;/p&gt;&lt;p&gt;&lt;a href="https://docs.aws.amazon.com/cli/latest/reference/route53/change-resource-record-sets.html"&gt;change-resource-record-sets — AWS CLI 1.18.203 Command Reference&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;SetIdentifier -&amp;gt; (string)&lt;/p&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;p&gt;Resource record sets that have a routing policy other than simple: An identifier that differentiates among multiple resource record sets that have the same combination of name and type, such as multiple weighted resource record sets named acme.example.com that have a type of A. In a group of resource record sets that have the same name and type, the value of SetIdentifier must be unique for each resource record set.&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;For information about routing policies, see Choosing a Routing Policy in the Amazon Route 53 Developer Guide .&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;p&gt;Alias レコードのパラメータからコピペしてたので&lt;code&gt;SetIdentifier&lt;/code&gt;を残したままにしてしまっていた。NS レコードは Simple Routing のみを許可するのでエラーになるのね。↓&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;  52 |  Edit-R53ResourceRecordSet -HostedZoneId $ParentHostedZone.Id -ChangeB …
     |  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     | Invalid request: Expected exactly one of [Weight, Region, Failover, GeoLocation, or MultiValueAnswer], but found none in Change with [Action=CREATE, Name=test.testtest.com, Type=NS, SetIdentifier=nandeyanen]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;わかりにくぅ！&lt;/p&gt;&lt;p&gt;おわり 😭&lt;/p&gt;</description><pubDate>Sun, 27 Dec 2020 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2020-12-26-retrospective2020</guid><link>https://krymtkts.github.io/posts/2020-12-26-retrospective2020</link><title>振り返り 2020 年</title><description>&lt;p&gt;2020 年を振り返る。&lt;/p&gt;&lt;p&gt;2020 年は自分の人生の中でも全く予想のつかない年であったと同時に、停滞感を感ずる年でもあった。以下ダイジェスト。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一人でサブシステム&lt;/li&gt;&lt;li&gt;COVID-19 流行からのフルリモートワーク&lt;/li&gt;&lt;li&gt;チームメンバのクビ&lt;/li&gt;&lt;li&gt;フラストレーションの多い下半期&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="一人でサブシステム"&gt;一人でサブシステム&lt;/h3&gt;&lt;p&gt;ほとんど偶然の流れでサーバーレスな ETL を一人で作る機会を得た。&lt;/p&gt;&lt;p&gt;すぐに作って初夏までにリリース的な感じのやつでやった。サービスの見込みが「ほんまにそんなにユーザとれんのか？おお？」的なきな臭い感じだったので極力維持費をかけないようにサーバーレスに。そしたら案の定、年末までほとんど利用されることなかったんでこの選択は我ながら良いとおもた。サブシステム単体の原価が 1 日 40 円程度とめちゃくちゃ安い、ものすごく利益率がいいので、使ってもらえれば儲かる。
結果的に Go on AWS Step Functions &amp;amp; AWS Lambda を組み合わせて作った。その際に Aurora Serverless やら Cognito やら使ったことないサービスを利用でけたこと、IaC 大前提でイチから権限の設計だったりできたのはかなりいい経験になったなーとおもとる。
というか今年のハイライトはここちゃうか...という気もしなくない。裁量という面においては。&lt;/p&gt;&lt;p&gt;もちろんヘマこいたところもいっぱいあるんやけど、それすら次に活かそうという気持ちになれるやつらでヒジョーにポジティブに考えれていた時期。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;運用用途で 1 日のデータ量の集計を Aurora Serverless に保持するようにしたが、これは結果的に要らなかった
&lt;ul&gt;&lt;li&gt;DynamoDB にエントリを作っといて、後でからスクリプトなり最近増えた SQL のサポートで良かったんじゃないか、的な。そうすれば維持費ももっと抑えれた&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Cognito むずすぎ
&lt;ul&gt;&lt;li&gt;S3 へのアクセス制御を Cognito で行った。結果的にバケツへアクセスする一時クリデンシャルを作成する形にしたが、これはどうも OAuth2 仕様だと機器間認証を使うべきだったらしい。わからん&lt;/li&gt;&lt;li&gt;こんなの？&lt;a href="https://medium.com/faun/setting-up-a-machine-to-machine-authentication-system-with-amazon-cognito-4c8e2de41c2e"&gt;Machine-to-machine authentication with Amazon Cognito | FAUN&lt;/a&gt;&lt;/li&gt;&lt;li&gt;あと秒間の initiate auth 上限がしょぼくて同時ログイン多いと使えない。AWS SA の方にも Auth0 にしとけって言われてしまう始末。とはいえ料金的にこっちのが安くて選んだ&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Go の熟れてなかった感
&lt;ul&gt;&lt;li&gt;複数エンドポイント作るのにオレオレディレクトリ構造で作ったのでややこしい形に
&lt;ul&gt;&lt;li&gt;すぐ良くないのがわかったので次の Go 経験で&lt;a href="https://github.com/golang-standards/project-layout"&gt;golang-standards/project-layout: Standard Go Project Layout&lt;/a&gt; を速攻取り込んで改善した&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;JSON＆ファイルストリーム操作がいまいち
&lt;ul&gt;&lt;li&gt;aws-go-sdk で S3 から gzip された JSON 取り込むのにパイプを使ってうまく空間計算量を減らしたが、まだちょっとイケてない部分が残ってて極端にファイルサイズが大きいと死にうる。これをもっとうまくできたろうと思う&lt;/li&gt;&lt;li&gt;JSON のパースエラーを親切にする方法はこわかったので、次の経験で活かした&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;channel や独自の型は相性が良かったのか難なく。後のデスマーチプロジェクトでもそれが活きた&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Aurora Serverless Data API の使いこなし
&lt;ul&gt;&lt;li&gt;接続時に最大 1 分くらい応答がないけど Data API ではタイムアウト時間を延ばせず(標準 50 秒くらい)、そのエラーハンドリングが下手くそだった。結果的にリリース後相当経ってからの対応になったが error 型でリトライ可能エラーとか切り分けた&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="covid-19-流行からのフルリモートワーク"&gt;COVID-19 流行からのフルリモートワーク&lt;/h3&gt;&lt;p&gt;これは IT 系ならどこもそうだろうと思うが、ついにフルリモートワークになった。もともと子守で週に数回在宅勤務時間を設けていたが、フルリモートとなるとその労働体験は全く異なる。&lt;/p&gt;&lt;p&gt;通勤時間 2 時間がまるっとなくなった分かなり楽になったが、逆に駆けつけ 3 杯だったり、思考しながら歩いたりといった息抜きのタイミングがなくなった。家庭へのサポートの負担がより増えたことで読書や自習の時間も確保しにくく、それこそ自身の学びのスタイルを再構築する程度には追い詰められたのかなと思う。もちろん自走できるエンジニアにとしては労働体験は向上したのだけど。&lt;/p&gt;&lt;p&gt;半年以上フルリモートワークなのだけど、この状況に合わせた最良の方法は、まだ模索中。&lt;/p&gt;&lt;p&gt;少しずつ習慣化していたワークアウトは、こういった状況だと有無の効果がわかりやすかった(メンタル面の安定において)。でも引っ越し後機会を取れていなくバランスを崩している。&lt;/p&gt;&lt;h3 id="チームメンバのクビ"&gt;チームメンバのクビ&lt;/h3&gt;&lt;p&gt;これは自身の労働体験では一番悪い出来事だった。1 年半ほどずっと同じチームメンバとして働いてきて、コンテキストの共有もできていたし、ようやくチーム開発が回りだすなという状況だったが、いなくなってしまった。優秀な方で、鼓を打てば響くがごとく(個人的には)よいチームワークやと感じていただけに非常に残念だったし、前職チームリーダ時代にメンバのおじさまエンジニアの年俸 150 万をふっとばしてしまった経験と同列くらいで、自分の至らなさを悔やみ続ける事件になった。
チーム開発がしたかったけど、これは当面できなくなってしまった。これが結局フラストレーションを溜め始める 1 要素になったのは間違いない。
その後を埋める形で？優秀なメンバを得れたのだけど、自律性といった意味では前任者が天才的だったのと、1 年半の間の積み重ねが灰燼に帰したこともあって傷心チックな状態は今も続いている。&lt;/p&gt;&lt;p&gt;その中で唯一救われたのは、件の方がエンジニアとしてのキャリアを見定めて次の活動をすでに始めている点。これだけは本当に良かった。幸多からんことを。&lt;/p&gt;&lt;h3 id="フラストレーションの多い下半期"&gt;フラストレーションの多い下半期&lt;/h3&gt;&lt;p&gt;チーム開発 ≒ わたしのなかではコラボレーションができない仕事というのは、自分の出力以上のものが期待できないのと同時に学びや気づきも自発的なもの以外にないという面白くない状態でであって、これが半年間の間続いたことで相当に気分が参ってしまった。この下半期の間続いていたデスマーチ的な案件も、参加メンバは多いのに情報連携の齟齬がこれでもかというくらいにあって、まあ色々疲れてしまった。件の方もこのプロジェクトに参加中にいなくなったにもかかわらず、開発者は補充されなかったのでけっきょくワイ一人で開発してたよーな気分。
この間にでかい会社のリクルータが面談の話を持ってきたので挑んでみたが、これまた全然だめだった。知識もメンタルも準備大事。&lt;/p&gt;&lt;p&gt;苛々する時期だったが、年の瀬には曲りなりにもアプリケーションは本番稼働し、面談で感じた自分の至らなさから改めて自身のエッセンシャルな選択肢を掘り起こす事ができたので、プラスマイナス 0 くらいの経験になったのではないか？とは思っている。
今振り返ると、ETL の失敗経験からこのデスマーチに取り組んだ改善点は相当数あって、そういった進歩を楽しめていなかった点でもわたし自身気分が落ちてたんやろなーというのが明らかや。&lt;/p&gt;&lt;p&gt;このデスマーチの裏では別の Fury Road が残ってて、年末年始も働くのだ。でも全然気持ちのしんどさが違う。&lt;/p&gt;&lt;p&gt;※デスマーチゝいうてるけど肉体的な労働負荷は全然大したことない。偏に 8 時間と少ししか働けない自身の限られた時間内でやるべきでないしょうもないことに時間を浪費してしまっていたり、そういったところがデスなマーチなのだ。アドレナリンジャンキーになれていたらもっと追い込んで働けたろうに。リモートワークではそこまで中毒できないんちゃうかな？&lt;/p&gt;&lt;h3 id="2020-年目標と成果"&gt;2020 年目標と成果&lt;/h3&gt;&lt;p&gt;年初に以下の目標を羅列した。その結果は次の通り。惨憺たる結果。まず目標が多い、多すぎるわ。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;家庭
&lt;ul&gt;&lt;li&gt;⭕️ 引越
&lt;ul&gt;&lt;li&gt;時期はかなりずれ込んだが完了&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;🔺 親族
&lt;ul&gt;&lt;li&gt;半分完了的な形。およそ 5 年後に延期&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;仕事
&lt;ul&gt;&lt;li&gt;⭕️ リモートワーク
&lt;ul&gt;&lt;li&gt;意図せずフルリモート化した&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;🔺 昇給
&lt;ul&gt;&lt;li&gt;源泉がまだだが年間 40~50 万 UP 程度で期待のとおりでなかった&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;⭕️ リード的な活動
&lt;ul&gt;&lt;li&gt;できていたが、件のメンバ離脱でちょっと空回り気味&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;自分のこと
&lt;ul&gt;&lt;li&gt;❌ 積ん読の消化
&lt;ul&gt;&lt;li&gt;無理すぎた&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;🔺 OSS へのコントリビューション
&lt;ul&gt;&lt;li&gt;おしい
&lt;ul&gt;&lt;li&gt;ドキュメント修正やフォーマットだけの PR で 3 回だけ&lt;/li&gt;&lt;li&gt;Terminal Icons の Issue にコメントして助けたのが 1 回&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;❌ 自作ツールの更新
&lt;ul&gt;&lt;li&gt;ほぼなしか。TODO はあるけど&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;❌ 音楽活動
&lt;ul&gt;&lt;li&gt;これも全然できず。というか COVID-19 で無理んなった&lt;/li&gt;&lt;li&gt;下期は忙しくて死ぬほどギターが下手くそになった&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;❌ &lt;a href="https://krymtkts.github.io/"&gt;このブログ&lt;/a&gt;を毎月更新する
&lt;ul&gt;&lt;li&gt;途中から落とした...&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;自分のことが後回しになるのは年を経るとよくあることやと思うけど、ちょっとひどい。
今年溜め込んだ知識というか、使い回せるスクリプトもあるので、年末年始の落ち着いた時期にそういう宝物を Gist にガンガン登録していこう。&lt;/p&gt;&lt;p&gt;おわり。&lt;/p&gt;</description><pubDate>Sat, 26 Dec 2020 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2020-11-01-terminal-icons-not-work-case</guid><link>https://krymtkts.github.io/posts/2020-11-01-terminal-icons-not-work-case</link><title>Terminal Icons が動かなくなるケース</title><description>&lt;p&gt;9 月&amp;amp;10 月と文字起こしするのをサボった 😪&lt;/p&gt;&lt;p&gt;肉親の不幸やトラブルがあったりで気乗りしなかったのもあるが、お仕事の方で WFH になって以降最高潮に忙しさのピークを迎えていたというのもある。この辺はチームビルディングぽい要素大いにあったのでまたなんかまとめたい所存 🤔&lt;/p&gt;&lt;p&gt;この間、OSS 活動も特に何のアクションもなく過ごしたが、ただ無為に過ごしたわけではない(と言い聞かせたい)のでなんか貢献したぽいことをネタに記事に残そうと思う。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;先日&lt;a href="https://devblogs.microsoft.com/commandline/windows-terminal-tips-and-tricks/"&gt;Windows Terminal Tips and Tricks | Windows Command Line&lt;/a&gt;を見てたら、愛すべき oh my posh の紹介の後に &lt;a href="https://github.com/devblackops/Terminal-Icons"&gt;Terminal-Icons: A PowerShell module to show file and folder icons in the terminal&lt;/a&gt; が紹介されていた。
なんじゃこりゃー即導入せねばなるまいな、という感じで導入してみたのだが、初回は&lt;code&gt;Get-ChildItem&lt;/code&gt;の結果に可愛らしいアイコンフォントが付与されるのに、2 回目以降は普通の見た目に戻ってしまい、なんでや...とトラシューしてみた。&lt;/p&gt;&lt;p&gt;わかったのは、一緒に使っていた &lt;a href="https://github.com/joonro/Get-ChildItemColor"&gt;Get-ChildItemColor: Add coloring to the output of Get-ChildItem Cmdlet of PowerShell.&lt;/a&gt; の実行後に、Terminal Icons のアイコンフォントが反映されなくなること。
試しに &lt;code&gt;Remove-Module Get-ChildItemColor&lt;/code&gt; すればあ～ら不思議、アイコンが復活するのである。&lt;/p&gt;&lt;p&gt;Terminal Icons では&lt;code&gt;format.ps1xml&lt;/code&gt; で表示内容の改変を行っているのだけど、&lt;code&gt;Get-ChildItemColor&lt;/code&gt;も色の改変をしてるし、競合してるのだろう。詳しくは追っていくのがめんどくて競合できないという結論だけだした。↓ の Issue で同じく困ってる人がいたので共有してあげた。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/devblackops/Terminal-Icons/issues/12"&gt;No icons after installation. · Issue #12 · devblackops/Terminal-Icons · GitHub&lt;/a&gt;&lt;/p&gt;</description><pubDate>Sun, 01 Nov 2020 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2020-08-31-how-do-i-manage-todos</guid><link>https://krymtkts.github.io/posts/2020-08-31-how-do-i-manage-todos</link><title>TODO の管理どないしてまっか？</title><description>&lt;p&gt;最近、TODO 管理のやり方を変えたので記しておく。&lt;/p&gt;&lt;p&gt;いろんなタスク管理術がある。昔は Remember the Milk 使ってみたり、Evernote に TODO リスト書いたり。最近では Google Tasks 使ってみたり。へーしゃ内では Getting Things Done が優勢なんかな。
とはいえ結局の所いずれの手段もわたしにはうまく使いこなせず、結局日報的なものに落ちつていた、もう 7 年以上？日報のようなお仕事日記をつけている。&lt;/p&gt;&lt;p&gt;ところが、そのスタイルに狂いが生じだしたのが、COVID-19 流行による出社自粛 →WFH を始めてからだ。&lt;/p&gt;&lt;p&gt;WFH になってかなり仕事とプライベートの距離感が急接近。結果どういうわけか仕事と私生活の両方において、タスクの消化をそれまでの様にできない状態になりつつあった。7,8 割くらいのパフォが出たらいい感じ。実際はもっと悪い。&lt;/p&gt;&lt;p&gt;思うに、往復 2 時間の通勤時間でコンテキストスイッチを緩やかに行っていたり、処理すべきタスクの組み換えとかを行っていたのだろう。歩く時間も 30 分はあったし。
スキマ時間がなくなったことで、ギアが上がりきらないままタスク消化を急いで空回りでもしてたのだろうか。
もともと仕事の日記にはプライベートのタスクを書かずに続けていたのだけど、とりあえずコンテキストスイッチを抑えるために、仕事と私生活のタスクを一括管理しようと考えた。とはいえお仕事日記は自身の振り返りのためにも使っていて、あまり私生活のノイジー？な内容を書いていくのもどうかなと。
そんな時ちょうど Chrome のサジェスト記事で &lt;a href="https://marketplace.visualstudio.com/items?itemName=davraamides.todotxt-mode"&gt;todotxt-mode - Visual Studio Marketplace&lt;/a&gt; の存在を知ったので、&lt;a href="https://github.com/todotxt/todo.txt"&gt;todo.txt&lt;/a&gt; で、単純にタスクの管理だけを一括管理することにした。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/todotxt/todo.txt"&gt;todo.txt&lt;/a&gt;はシンプルにフォーマットが決まっているのがありがたい。また詳細を note に切り出せるのでタスク自体をシンプルに保てるのが気に入っている。&lt;/p&gt;&lt;p&gt;複数の端末でこの「TODO を記したプレーンテキスト」を同期する必要があるが、これについては現状 &lt;a href="https://marketplace.visualstudio.com/items?itemName=GustavoASC.google-drive-vscode"&gt;Google Drive™ for VSCode - Visual Studio Marketplace&lt;/a&gt; を使っている。
Upload したファイルが上書きじゃなく、都度新しいファイルになるのがかなり気に食わないけど、生のテキストファイルが使えることを優先してのチョイスだ。&lt;/p&gt;&lt;p&gt;今の所はゆるく todo.txt のフォーマットの一部(priority, context, due ぐらいしか使えてない)だけ運用している。
数年来のタスク管理を変える機会なので慣れないことも多いが、折角の変化の機会なので楽しんで模索してみたい。&lt;/p&gt;</description><pubDate>Mon, 31 Aug 2020 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2020-07-31-partial-decode-uniqid</guid><link>https://krymtkts.github.io/posts/2020-07-31-partial-decode-uniqid</link><title>PHP の uniqid をデコードする</title><description>&lt;p&gt;なんか一意っぽい値を PHP で生成する場合の楽な手段として、 &lt;code&gt;uniqid&lt;/code&gt; がある。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/php/php-src/blob/91fbd12d5736b3cc9fc6bc2545e877dd65be1f6c/ext/standard/uniqid.c"&gt;php-src/uniqid.c at 91fbd12d5736b3cc9fc6bc2545e877dd65be1f6c · php/php-src&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;prefix を除いた先頭 8 桁が unixtime を 16 進数で出してるだけっぽいので、こいつが何時生成されたのかを知りたい時に、以下の手順が踏める。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://www.php.net/manual/ja/function.uniqid.php#95001"&gt;PHP: uniqid - Manual&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;ここのコメントのまま使える。&lt;code&gt;more_entropy&lt;/code&gt;が有効な値で試す。&lt;/p&gt;&lt;pre&gt;&lt;code class="php"&gt;// &amp;lt;?php
$s = "5ef4f46e0e40f9.59913527";
$d = date("r",hexdec(substr($s,0,8)));
echo($d . PHP_EOL);
// Thu, 25 Jun 2020 19:01:02 +0000
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;しかし手前は PHP をインストールしてなくて repl を持ってない(↑ の Repl.it でやった)ので、これを PowerShell でやる！(ついでに JST)&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/10781697/convert-unix-time-with-powershell"&gt;epoch - Convert Unix time with PowerShell - Stack Overflow&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$s = "5ef4f46e0e40f9.59913527";
(Get-Date '1970-1-1').AddSeconds([System.Convert]::ToInt32($s.Substring(0, 8), 16)).ToLocalTime()
# 2020年6月26日 04:01:02
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ちょっとした小技が必要だったので覚書しておく。
無駄に PHP のコードを読んでしまった...😂&lt;/p&gt;</description><pubDate>Fri, 31 Jul 2020 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2020-06-29-contextual-sfn-example</guid><link>https://krymtkts.github.io/posts/2020-06-29-contextual-sfn-example</link><title>Step Functions のステートをまたいでパラメータを伝播するパターン</title><description>&lt;p&gt;&lt;a href="2020-04-30-context-like-sfn"&gt;前の記事&lt;/a&gt;で記したアイデアの実装例を残しておいた。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/contextual-sfn"&gt;krymtkts/contextual-sfn: Example for passing parameters across states.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;現時点で実際にお仕事で使っているパターンなのだけど、前述の通りペイロードが大幅に大きくなると問題になり得るので、より良くするすべはないものかと考え中。&lt;/p&gt;&lt;h3 id="おさらい"&gt;おさらい&lt;/h3&gt;&lt;p&gt;StateMachine の構成。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Task&lt;/li&gt;&lt;li&gt;Map&lt;/li&gt;&lt;li&gt;Reduce&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;のステートがあるとする。Task は文字列、配列 A、配列 B を Output する。これらのデータについては以下の通りとする。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;文字列(&lt;code&gt;t&lt;/code&gt;)は、フロー全体に渡って使用したいデータ。&lt;/li&gt;&lt;li&gt;配列 A(&lt;code&gt;ia&lt;/code&gt;) は、1 つ目の Map タスクで分散したいデータ。&lt;/li&gt;&lt;li&gt;配列 B(&lt;code&gt;sa&lt;/code&gt;) は、2 つ目の Map タスクで分散したいデータ。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;このパターンを実装した背景としては以下の通り。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Map と Reduce で使いたいデータを Aurora Serverless から取得する必要がある&lt;/li&gt;&lt;li&gt;普段停止しているクラスタは結構起動に時間がかかる&lt;/li&gt;&lt;li&gt;Map では Reduce のパラメータも利用したい&lt;/li&gt;&lt;li&gt;フローの最初に全部取ってしまおう！&lt;/li&gt;&lt;/ul&gt;&lt;h4 id="1-task"&gt;1. Task&lt;/h4&gt;&lt;p&gt;Lambda からの出力がこんなのだとする。&lt;/p&gt;&lt;pre&gt;&lt;code class="json"&gt;{
  "t": "nanigashi",
  "ia": [1, 2, 4, 8, 16, 32, 64],
  "sa": ["A", "B", "C", "D", "E"]
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;ResultPath&lt;/code&gt;を&lt;code&gt;$.data&lt;/code&gt;にしておくと Task1 ステートの出力は ↓ になる。&lt;/p&gt;&lt;pre&gt;&lt;code class="json"&gt;{
  "data": {
    "t": "nanigashi",
    "ia": [1, 2, 4, 8, 16, 32, 64],
    "sa": ["A", "B", "C", "D", "E"]
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;YAML はこう。&lt;/p&gt;&lt;pre&gt;&lt;code class="yml"&gt;Entrypoint:
  Type: Task
  Resource:
    Fn::GetAtt: [task, Arn]
  ResultPath: $.data
  Next: Map
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id="2-map"&gt;2. Map&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;ItemsPath&lt;/code&gt; に &lt;code&gt;$.data.ia&lt;/code&gt; を指定し、配列 A でイテレーションする&lt;/li&gt;&lt;li&gt;&lt;code&gt;Parameters&lt;/code&gt; に Lambda へ渡したいパラメータを指定する。以下の通り
&lt;ul&gt;&lt;li&gt;マッピングの各要素は&lt;code&gt;$$.Map.Item.Value&lt;/code&gt;&lt;/li&gt;&lt;li&gt;追加で渡したいパラメータを &lt;code&gt;$.data.t&lt;/code&gt;, &lt;code&gt;$.data.sa&lt;/code&gt;&lt;/li&gt;&lt;li&gt;パラメータ名末尾の&lt;code&gt;.$&lt;/code&gt;忘れがち&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;OutputPath&lt;/code&gt; に前のタスクの出力 &lt;code&gt;$.data&lt;/code&gt; を指定すれば、同じパラメータを次のステートに回せる&lt;/li&gt;&lt;li&gt;ここではマッピングの出力は無視するとして、&lt;code&gt;ResultPath&lt;/code&gt;に&lt;code&gt;$.null&lt;/code&gt;など&lt;code&gt;OutputPath&lt;/code&gt;に含まれないパスを指定する&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class="yml"&gt;Map:
  Type: Map
  MaxConcurrency: 10
  Parameters:
    k.$: $$.Map.Item.Value
    t.$: $.data.t
    a.$: $.data.sa
  ItemsPath: $.data.ia
  ResultPath: $.null
  OutputPath: $.data
  Iterator:
    StartAt: MapTask
    States:
      MapTask:
        Type: Task
        Resource: !GetAtt [map, Arn]
        End: true
  Next: Reduce
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id="3-reduce"&gt;3. Reduce&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;ItemsPath&lt;/code&gt; に &lt;code&gt;$.sa&lt;/code&gt; を指定し、配列 B でイテレーションする&lt;/li&gt;&lt;li&gt;&lt;code&gt;Parameters&lt;/code&gt; に Lambda へ渡したいパラメータを指定する。以下の通り
&lt;ul&gt;&lt;li&gt;マッピングの各要素は&lt;code&gt;$$.Map.Item.Value&lt;/code&gt;&lt;/li&gt;&lt;li&gt;追加で渡したいパラメータを &lt;code&gt;$.data.t&lt;/code&gt;&lt;/li&gt;&lt;li&gt;パラメータ名末尾の&lt;code&gt;.$&lt;/code&gt;忘れがち(2 回目)&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;出力を制御したい場合は、Map 同様に&lt;code&gt;OutputPath&lt;/code&gt;、&lt;code&gt;ResultPath&lt;/code&gt;を指定仕分ける&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class="yml"&gt;Reduce:
  Type: Map
  Parameters:
    k.$: $$.Map.Item.Value
    t.$: $.t
  ItemsPath: $.sa
  ResultPath: $.null
  OutputPath: $.t
  Iterator:
    StartAt: ReduceTask
    States:
      ReduceTask:
        Type: Task
        Resource: !GetAtt [reduce, Arn]
        End: true
  End: true
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="まとめ"&gt;まとめ&lt;/h3&gt;&lt;p&gt;こういう例、ググっても見つからずあまり使われないパターンかも知れない。
必要だった＆実現できたので制限を理解した上で、容量用法守って使えれば良いかな。&lt;/p&gt;</description><pubDate>Mon, 29 Jun 2020 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2020-05-09-try-to-elm-handson</guid><link>https://krymtkts.github.io/posts/2020-05-09-try-to-elm-handson</link><title>Elm のハンズオンを試した</title><description>&lt;p&gt;会社の勉強会で Elm のハンズオンをしてみた。それだけ。&lt;/p&gt;&lt;h3 id="elm-とわたし"&gt;Elm とわたし&lt;/h3&gt;&lt;p&gt;いつ頃 Elm を知ったのだろう。なんか前職ですごい H 本の輪読会をした 2015 年らへんか、2016 年とかそのあたりに知ったような気がする。&lt;/p&gt;&lt;p&gt;爆発炎上中の新製品開発(Backbone.js なのに誰も使えてなくてやばい製品だった)のヘルプに入ってちょっとした頃。フロントエンドを全然知らなかったので一通り新しめの情報をさらってて、その中に Elm を見つけたような気がしている。&lt;/p&gt;&lt;p&gt;最近までずっと Elm と付き合うことなく来た&lt;sup id="fnref-1"&gt;&lt;a class="footnote-ref" href="#fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt;が、ちょうどへーしゃにてフロントエンド刷新の機運があると聞き、Elm 一択ですね！と押し込むためにも開催してみた。今思えばこいつ何様やねん 🤔&lt;/p&gt;&lt;h3 id="勉強会について"&gt;勉強会について&lt;/h3&gt;&lt;p&gt;&lt;a href="https://github.com/mather/elm-handson"&gt;mather/elm-handson: ハンズオン資料&lt;/a&gt; を流用させていただいた。めちゃくちゃやりやすかったですありがとうございました。&lt;/p&gt;&lt;p&gt;カンペ用にわたしは回答例みたいなのを fork して添えさせていただいた。&lt;a href="https://github.com/krymtkts/elm-handson"&gt;krymtkts/elm-handson: ハンズオン資料&lt;/a&gt;&lt;/p&gt;&lt;p&gt;元々はデータストアがあって、CRUD 操作ができて、みたいなバックエンドも含めたやつをやろうとしてた。
のだけど、わたしに Elm でハンズオンを作りきるパワーもなく、「う、めんどくせえ！」となり、またインターネッツで探してみるもめぼしいものを見つけられなかった。&lt;/p&gt;&lt;p&gt;やはり導入部ということもあり、もっとシンプルにできるものはないか－と探していたところ、前述のハンズオンにたどり着いたのだ。&lt;/p&gt;&lt;h3 id="やってみた感想"&gt;やってみた感想&lt;/h3&gt;&lt;p&gt;へーしゃのフロントエンドに Elm を採用するのには至らなそうだけど、他のエンジニアに興味を持ってもらえり静的型付け＆関数型言語のパワーを知ってもらったのは良かった。Message を足したり型変えたらめちゃくちゃ親切なコンパイルエラーになるやでー、が結構ウケた印象。
現行が複雑怪奇な PHP(Smarty)や jQuery でメンテも苦痛なところに、Elm が爽やかな風を送り込んでくれたのだから、そりゃエンジニアの認識が変わるのも必然やで。&lt;/p&gt;&lt;p&gt;最終的に CRUD ある画面のハンズオンを目指す。遊び用 AWS 垢が支給されてるし、Amplify で Sample 探すか。
まだ何回か企画してるので、刺激を与えていきたい所存。&lt;/p&gt;&lt;div class="footnotes"&gt;&lt;hr /&gt;&lt;ol&gt;&lt;li id="fn-1"&gt;&lt;p&gt;&lt;a href="https://www.amazon.co.jp/dp/4863542224/"&gt;基礎からわかる Elm&lt;/a&gt;はもちろん読んでるで。ポチってからかなり待ったけど、無事出版され、読むことができてホッとした。&lt;/p&gt;&lt;a href="#fnref-1" class="footnote-backref"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description><pubDate>Sat, 09 May 2020 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2020-04-30-context-like-sfn</guid><link>https://krymtkts.github.io/posts/2020-04-30-context-like-sfn</link><title>Step Functions のステートをまたいでパラメータを伝播する</title><description>&lt;p&gt;仕事でシンプルなバッチを組む必要があり、ちょうどワークフローみたいな感じだったので Step Functions で Lambda をつないで作っている。&lt;/p&gt;&lt;p&gt;3 つ Lambda が登場するのだけど、1 つ目の Lambda の Output を 2 つ目 3 つ目で使いたい。
でも、こいつらが Map ステートなのもあり Output でつなぐのはちょっと違う。
代わりに &lt;code&gt;ResultPath&lt;/code&gt;, &lt;code&gt;OutputPath&lt;/code&gt;, &lt;code&gt;ItemPath&lt;/code&gt;, &lt;code&gt;Parameters&lt;/code&gt; の組み合わせれば、Lambda の Output にない後続のステートにつなげるのがわかったのでメモしておく。&lt;/p&gt;&lt;h3 id="参考資料"&gt;参考資料&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://docs.aws.amazon.com/ja_jp/step-functions/latest/dg/input-output-example.html"&gt;InputPath、ResultPath、および OutputPath 例 - AWS Step Functions&lt;/a&gt;&lt;ul&gt;&lt;li&gt;これは読んでもナンノコッチャよくわからんかった&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://dev.classmethod.jp/articles/step-functions-parameters/"&gt;Step Functions の入出力処理の制御パラメータ（InputPath、 Parameters、ResultPath および OutputPath）を理解するために参照したドキュメント | Developers.IO&lt;/a&gt;&lt;ul&gt;&lt;li&gt;流石のクラスメソッドさん、わかりやすかった&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="構成"&gt;構成&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;Task&lt;/li&gt;&lt;li&gt;Map&lt;/li&gt;&lt;li&gt;Map&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;のステートがあるとする。Task は文字列、配列 A、配列 B を Output する。これらのデータについては以下の通りとする。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;文字列は、StateMachine 全体に渡って使用したいデータ。&lt;/li&gt;&lt;li&gt;配列 A は、1 つ目の Map タスクで分散したいデータ。&lt;/li&gt;&lt;li&gt;配列 B は、2 つ目の Map タスクで分散したいデータ。&lt;/li&gt;&lt;/ul&gt;&lt;h4 id="1-task1"&gt;1. Task1&lt;/h4&gt;&lt;p&gt;Lambda からの出力がこんなのだとする。&lt;/p&gt;&lt;pre&gt;&lt;code class="json"&gt;{
  "string": "nanigashi",
  "arrayA": [
      0, 1, 2, 3, 4, 5, 6
  ],
  "arrayB": {
      "A", "B", "C", "D", "E"
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;ResultPath&lt;/code&gt;を&lt;code&gt;$.key&lt;/code&gt;にしておくと Task1 ステートの出力は ↓ になる。&lt;/p&gt;&lt;pre&gt;&lt;code class="json"&gt;{
  "key": {
    "string": "nanigashi",
    "arrayA": [
        0, 1, 2, 3, 4, 5, 6
    ],
    "arrayB": {
        "A", "B", "C", "D", "E"
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id="2-map1"&gt;2. Map1&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;ItemPath&lt;/code&gt; に &lt;code&gt;$.key.arrayA&lt;/code&gt; を指定し、配列 A でイテレーションする&lt;/li&gt;&lt;li&gt;&lt;code&gt;Parameters&lt;/code&gt; に Lambda へ渡したいパラメータを指定する。以下の通り
&lt;ul&gt;&lt;li&gt;マッピングの各要素は&lt;code&gt;$$.Map.Item.Value&lt;/code&gt;&lt;/li&gt;&lt;li&gt;追加で渡したいパラメータを &lt;code&gt;$.key.string&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;OutputPath&lt;/code&gt; に前のタスクの出力 &lt;code&gt;$.key&lt;/code&gt; を指定する&lt;/li&gt;&lt;li&gt;マッピング処理の出力は無視したいので、&lt;code&gt;ResultPath&lt;/code&gt;に&lt;code&gt;$.null&lt;/code&gt;など&lt;code&gt;OutputPath&lt;/code&gt;に含まれないパスを指定する&lt;/li&gt;&lt;/ul&gt;&lt;h4 id="3-map2"&gt;3. Map2&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;ItemPath&lt;/code&gt; に &lt;code&gt;$.arrayB&lt;/code&gt; を指定し、配列 B でイテレーションする&lt;/li&gt;&lt;li&gt;&lt;code&gt;Parameters&lt;/code&gt; に Lambda へ渡したいパラメータを指定する。以下の通り
&lt;ul&gt;&lt;li&gt;マッピングの各要素は&lt;code&gt;$$.Map.Item.Value&lt;/code&gt;&lt;/li&gt;&lt;li&gt;追加で渡したいパラメータを &lt;code&gt;$.key.string&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;出力を制御したい場合は、Map1 同様に&lt;code&gt;OutputPath&lt;/code&gt;、&lt;code&gt;ResultPath&lt;/code&gt;を指定仕分ける&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;これで Task1 の出力を Map1 をまたいで Map2 で利用できる。&lt;/p&gt;&lt;h3 id="まとめ"&gt;まとめ&lt;/h3&gt;&lt;p&gt;これで最初の Lambda の Output を加工せずそのまま後ろ 2 つの Lambda まで伝播できた。やったね 😂
文章だけじゃわからなさすぎる気がしてきた...今度サンプルコードを起こすことにする。&lt;/p&gt;&lt;p&gt;ただし懸念点として以下の気になる 2 点も備えており、どうしたもんかなと言う感じでもある 🤔&lt;/p&gt;&lt;ol&gt;&lt;li&gt;伝播したい回数だけ階層化しないといけないのではないか
&lt;ul&gt;&lt;li&gt;出力を無視するためにはセクションを切り分けないといけなくなってるから&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;可変長のパラメータを伝播する場合、ペイロードの上限値に注意しないといけない
&lt;ul&gt;&lt;li&gt;ダブルクォートは&lt;code&gt;\&lt;/code&gt;エスケープされるようだし計算が大変&lt;/li&gt;&lt;li&gt;だからセクションを切り分けるしかなくなってる&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;出力無視することさえできたら階層化いらんなー 🤔&lt;/p&gt;</description><pubDate>Thu, 30 Apr 2020 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2020-03-31_oh-my-posh-theme</guid><link>https://krymtkts.github.io/posts/2020-03-31_oh-my-posh-theme</link><title>My own oh-my-posh theme</title><description>&lt;p&gt;oh-my-posh の話。
ご存じない？ &lt;a href="https://github.com/JanDeDobbeleer/oh-my-posh"&gt;JanDeDobbeleer/oh-my-posh: A prompt theming engine for Powershell&lt;/a&gt;&lt;/p&gt;&lt;p&gt;元々、Agnoster のシンボルを変えるだけで使ってた。&lt;/p&gt;&lt;p&gt;が、最近になって諸々の不満点 ↓ を解決したくなって、自分用のテーマを作ろうと思ったのがきっかけ。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;コマンドを打った時間を出したくなった
&lt;ul&gt;&lt;li&gt;分割して Terminal を使うことが多いので仕事で CLI を使ったときにどこがいちばん最後に使ったかわかりやすくしたい&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;階層が深いディレクトリで仕事することが多く working directory の短縮表示をもっと短くしたかった
&lt;ul&gt;&lt;li&gt;デフォルトの&lt;code&gt;..&lt;/code&gt;を&lt;code&gt;.&lt;/code&gt;にする(ほんとは頭文字にしたいが)&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Windows10 のいつの Version からか忘れたが一部の絵文字の表示が化ける(管理者権限には 💪 を使ってた)
&lt;ul&gt;&lt;li&gt;⚡ に戻す&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;作ったのはこれ。&lt;a href="https://gist.github.com/krymtkts/6f7e365fd1683d6edeb7e531f725d280"&gt;My own oh-my-posh theme.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;oh-my-posh のテーマを作るのはかんたん。その作り方を以下に記す。&lt;/p&gt;&lt;h2 id="how-to-make-it"&gt;How to make it&lt;/h2&gt;&lt;p&gt;テンプレを生成してくれる機能とかはない。そのため theme の PS モジュールは手で配置することになる。ちなみに export されている function たちは以下の通りである。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/JanDeDobbeleer/oh-my-posh/blob/master/oh-my-posh.psd1#L48"&gt;oh-my-posh/oh-my-posh.psd1 at master · JanDeDobbeleer/oh-my-posh&lt;/a&gt;&lt;/p&gt;&lt;p&gt;ユーザ定義のテーマは &lt;code&gt;$ThemeSettings.MyThemesLocation&lt;/code&gt; に配置する(&lt;code&gt;Get-ThemesLocation&lt;/code&gt;でも同じ様子)。フォルダがなければ合わせて作成する。&lt;/p&gt;&lt;p&gt;元ファイルはいまあるテーマからコピって作るのが手っ取り早い。わたしは&lt;a href="https://github.com/JanDeDobbeleer/oh-my-posh/blob/master/Themes/Agnoster.psm1"&gt;Agnoster.psm1&lt;/a&gt;から作成した。
今あるテーマの配置フォルダを知るには&lt;code&gt;Get-Theme&lt;/code&gt;を実行すれば良い。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS&amp;gt; Get-Theme

Name                  Type     Location
----                  ----     --------
krymtkts              User     C:\Users\takatoshi\OneDrive\Documents\PowerShell\PoshThemes\krymtkts.psm1
Agnoster              Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\Agnoster.psm1
Avit                  Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\Avit.psm1
Darkblood             Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\Darkblood.psm1
Fish                  Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\Fish.psm1
Honukai               Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\Honukai.psm1
Paradox               Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\Paradox.psm1
Powerlevel10k-Classic Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\Powerlevel10k-Classic.psm1
Powerlevel10k-Lean    Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\Powerlevel10k-Lean.psm1
PowerLine             Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\PowerLine.psm1
pure                  Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\pure.psm1
robbyrussell          Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\robbyrussell.psm1
Sorin                 Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\Sorin.psm1
tehrob                Defaults C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\oh-my-posh\2.0.399\Themes\tehrob.psm1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Agnoster とわたしのテーマの差分は次の通り。&lt;code&gt;Compare-Object&lt;/code&gt;だと差分が見にくいことこの上なし！誰得 😂 なので wsl の bash から diff した。PowerSheller 失格だね(&lt;code&gt;Compare-Object&lt;/code&gt;がひどいのよ)。&lt;/p&gt;&lt;p&gt;Unified diff でみたらこの通り。&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;$ diff ./Modules/oh-my-posh/2.0.399/Themes/Agnoster.psm1 ./PoshThemes/krymtkts.psm1 -u
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="diff"&gt;--- ./Modules/oh-my-posh/2.0.399/Themes/Agnoster.psm1   2020-03-13 13:22:52.000000000 +0900
+++ ./PoshThemes/krymtkts.psm1  2020-02-24 16:03:51.912063800 +0900
@@ -11,12 +11,27 @@

     $lastColor = $sl.Colors.PromptBackgroundColor

-    $prompt = Write-Prompt -Object $sl.PromptSymbols.StartSymbol -ForegroundColor $sl.Colors.SessionInfoForegroundColor -BackgroundColor $sl.Colors.SessionInfoBackgroundColor
-
+    $now = Get-Date -UFormat '%Y-%m-%d %R'
+    $backwardSymbol = "$($sl.PromptSymbols.SegmentBackwardSymbol)"
     #check the last command state and indicate if failed
     If ($lastCommandFailed) {
-        $prompt += Write-Prompt -Object "$($sl.PromptSymbols.FailedCommandSymbol) " -ForegroundColor $sl.Colors.CommandFailedIconForegroundColor -BackgroundColor $sl.Colors.SessionInfoBackgroundColor
+        $rightText = " $($sl.PromptSymbols.FailedCommandSymbol) $now "
+        $rightLength = $rightText.Length + $backwardSymbol.Length + 1 # care the symbol size blur.
+        $foregroundColor = $ThemeSettings.Colors.CommandFailedIconForegroundColor
     }
+    else {
+        $rightText = " $now "
+        $rightLength = $rightText.Length + $backwardSymbol.Length
+        $foregroundColor = $ThemeSettings.Colors.PromptForegroundColor
+    }
+    $prompt += Set-CursorUp -lines 1
+    $prompt += Set-CursorForRightBlockWrite -textLength $rightLength
+    $prompt += Write-Prompt $backwardSymbol -ForegroundColor $sl.Colors.PromptBackgroundColor -BackgroundColor $sl.Colors.SessionInfoBackgroundColor
+    $prompt += Write-Prompt $rightText -ForegroundColor $foregroundColor -BackgroundColor $sl.Colors.PromptBackgroundColor
+
+    # Write the prompt
+    $prompt += Set-Newline
+    $prompt += Write-Prompt -Object $sl.PromptSymbols.StartSymbol -ForegroundColor $sl.Colors.SessionInfoForegroundColor -BackgroundColor $sl.Colors.SessionInfoBackgroundColor

     #check for elevated prompt
     If (Test-Administrator) {
@@ -24,9 +39,8 @@
     }

     $user = $sl.CurrentUser
-    $computer = $sl.CurrentHostname
     if (Test-NotDefaultUser($user)) {
-        $prompt += Write-Prompt -Object "$user@$computer " -ForegroundColor $sl.Colors.SessionInfoForegroundColor -BackgroundColor $sl.Colors.SessionInfoBackgroundColor
+        $prompt += Write-Prompt -Object "$user " -ForegroundColor $sl.Colors.SessionInfoForegroundColor -BackgroundColor $sl.Colors.SessionInfoBackgroundColor
     }

     if (Test-VirtualEnv) {
@@ -63,7 +77,11 @@
 }

 $sl = $global:ThemeSettings #local settings
+$sl.PromptSymbols.ElevatedSymbol = [char]::ConvertFromUtf32(0x26A1)
+$sl.PromptSymbols.FailedCommandSymbol = [char]::ConvertFromUtf32(0x274C)
 $sl.PromptSymbols.SegmentForwardSymbol = [char]::ConvertFromUtf32(0xE0B0)
+$sl.PromptSymbols.SegmentBackwardSymbol = [char]::ConvertFromUtf32(0xe0b2)
+$sl.PromptSymbols.TruncatedFolderSymbol = '.'
 $sl.Colors.PromptForegroundColor = [ConsoleColor]::White
 $sl.Colors.PromptSymbolColor = [ConsoleColor]::White
 $sl.Colors.PromptHighlightColor = [ConsoleColor]::DarkBlue
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ちょっと実行時間のあたりが Cmder で出した場合にずれてしまうことがあって、微妙に余白をとってたりする。
でもこれでだいたい Cmder で見ても Windows Terminal でみても美しく出力される様になっている。
Windows Terminal ではシンボルフォントがめちゃくちゃ小さくなってしまうバグが有るのでまだ 100%最高とはいけないけど(&lt;a href="https://github.com/microsoft/terminal/issues/900"&gt;Certain "emoji" are still half-sized · Issue #900 · microsoft/terminal&lt;/a&gt;)&lt;/p&gt;&lt;p&gt;余談だが、こんかい自作テーマの作成にあたり、既存テーマの PS モジュールにフォーマットの崩れを見つけたので PR 送ったら受け入れてもらえた。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/JanDeDobbeleer/oh-my-posh/pull/211"&gt;Format some themes. by krymtkts · Pull Request #211 · JanDeDobbeleer/oh-my-posh&lt;/a&gt;&lt;/p&gt;&lt;p&gt;自分の気に入っている OSS に PR を受けれてもらえるのはちょっとした感動があるな 😚&lt;/p&gt;</description><pubDate>Tue, 31 Mar 2020 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2020-02-22-maven-auto-completion-0.2</guid><link>https://krymtkts.github.io/posts/2020-02-22-maven-auto-completion-0.2</link><title>MavenAutoCompletion v0.2</title><description>&lt;p&gt;およそ 1 年の時を経て、MavenAutoCompletion を更新した。とても小さな更新だ。&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.powershellgallery.com/packages/MavenAutoCompletion/0.2"&gt;PowerShell Gallery | MavenAutoCompletion 0.2&lt;/a&gt;&lt;/p&gt;&lt;p&gt;この 3 連休はひとりで暇なので、しょうもない更新をするのも億劫でない。&lt;/p&gt;&lt;p&gt;&lt;a href="/posts/2019-04-02-pubslish-first-module-to-powershell-gallery"&gt;前回&lt;/a&gt;やった PSGallery への公開でのミスは、スクリプトを作成していたおかげもあり、1 年ぶりでもミスらなかった。&lt;/p&gt;&lt;p&gt;ただ...色々イケてないところも見つかっている。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;このモジュール、公開するものをサブディレクトリへコピペして公開しているのだけど、これってもともとそのディレクトリで開発してたらいい話&lt;/li&gt;&lt;li&gt;補完の定義が大量なので 1 ファイルの見通しが悪くなってる
&lt;ul&gt;&lt;li&gt;更に非推奨にしたい補完候補の説明を追加できない構造&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;対応するの忘れてる非推奨タグ残したままになってる
&lt;ul&gt;&lt;li&gt;&lt;code&gt;�x��: &amp;lt;licenseUrl&amp;gt; element will be deprecated, please consider switching to specifying the license in the package. Learn more: https://aka.ms/deprecateLicenseUrl.&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;とりあえず Issue を作っといて、忘れていても暇なときに課題を解消していけるように準備しておくかあ 😅&lt;/p&gt;</description><pubDate>Sat, 22 Feb 2020 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2020-01-29-plannning</guid><link>https://krymtkts.github.io/posts/2020-01-29-plannning</link><title>2020</title><description>&lt;p&gt;書こう書こうと思って書けていなかった。
明文化する必要もないのかもしれんが、改めて書くことによって再認識したい、というのがこのポストの目的。&lt;/p&gt;&lt;h3 id="2020-年の目標"&gt;2020 年の目標&lt;/h3&gt;&lt;p&gt;大きく分けて 3 つ。家庭、仕事、自分のことだ。&lt;/p&gt;&lt;h4 id="家庭"&gt;家庭&lt;/h4&gt;&lt;ol&gt;&lt;li&gt;引越
&lt;ul&gt;&lt;li&gt;候補地の選定は終えている&lt;/li&gt;&lt;li&gt;永続的に住む場所ではないので次の候補も頭に浮かべておく&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;親族
&lt;ul&gt;&lt;li&gt;10 年来の、シンプルにいってくだらないが制御不可能な、問題があるため今年上半期に対応を決める&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 id="仕事"&gt;仕事&lt;/h4&gt;&lt;ol&gt;&lt;li&gt;リモートワーク
&lt;ul&gt;&lt;li&gt;現状 5 営業日中、固定の曜日で 2 時間だけ&lt;/li&gt;&lt;li&gt;子供の送り迎えの関係もあり、春から毎日 4 時間は事務所、残りはリモートにする&lt;/li&gt;&lt;li&gt;比較的コントローラブルな部分なので必ず達成する&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;昇給
&lt;ul&gt;&lt;li&gt;職位はないが Job Rank みたいな給与の等級はあって、それは前年上がったので、今年は金額的な上昇に注力する
&lt;ul&gt;&lt;li&gt;金額に注力するのは、ランクアップ時の昇給額が大したことなく、今のランクで継続的に(相対的に)良い評価を刻み続けることで上がるらしいため(へーしゃの場合)&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;リード的な活動
&lt;ul&gt;&lt;li&gt;主に CI/CD といった DevOps プラクティス, Serverless Architecture 面で貢献したい。ここに書く内容でもないが意思表明として&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 id="自分のこと"&gt;自分のこと&lt;/h4&gt;&lt;p&gt;これが一番ないがしろになりがち、継続的にケアする方法も同時進行で考えたい。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;積ん読の消化
&lt;ul&gt;&lt;li&gt;月に 1 冊を消化する
&lt;ul&gt;&lt;li&gt;積ん読はもう何冊あるかわからないが、減らしていく習慣を今年確立する&lt;/li&gt;&lt;li&gt;とりあえず 1 月は、witcher① で攻略済み&lt;/li&gt;&lt;li&gt;これは自身の可能性を広げるためなので、最も優先する&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;OSS へのコントリビューション
&lt;ul&gt;&lt;li&gt;今年 5 回は PR や Issue でコントリビューションしたい&lt;/li&gt;&lt;li&gt;1 回目は AWS Docs への PR で攻略済み&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;自作ツールの更新
&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/MavenAutoCompletion"&gt;MavenAutoCompletion&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/krymtkts/mccall-bot"&gt;mccall-bot&lt;/a&gt;&lt;/li&gt;&lt;li&gt;他、気が向いたら&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;音楽活動
&lt;ul&gt;&lt;li&gt;ギター練習を 30 分/週 3 回&lt;/li&gt;&lt;li&gt;バンド練習を年 4 回&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://krymtkts.github.io/"&gt;このブログ&lt;/a&gt;を毎月更新する&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;4 は他より優先度が低く、かつ制御不可能な部分が多いためハードルが下がりがち。なのでかならず達成したいところ。&lt;/p&gt;&lt;p&gt;5 は去年落とした目標なので今年こそは(それでもこのポスト時点でギリギリ 😂)&lt;/p&gt;&lt;p&gt;救いのない社会だが、自分・家族の人生にいい影響をもたらそう。エッセンシャル思考とマッコーリズムの実践だ。&lt;/p&gt;</description><pubDate>Wed, 29 Jan 2020 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-12-29-retrospective2019</guid><link>https://krymtkts.github.io/posts/2019-12-29-retrospective2019</link><title>振り返り 2019 年</title><description>&lt;p&gt;ことし 2019 年も残すところあと僅か。2019 年の自身の成長などを振り返ろう。&lt;/p&gt;&lt;p&gt;短くまとめると、2019 年は新しいことを始めた年になった。&lt;/p&gt;&lt;p&gt;転職し、未体験の事業領域の企業で働き始めた。
会社の後押しもあって積極的に未経験の技術を取り入れ、部分的ではあるが在宅ワークもしてみた。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;前職は、実にチョロいかいしゃだったので、6 年ほどの在職中に入社前の 8 割ほど昇給できたのはこの会社のおかげ(前々職がリーマンのあおりもあって給料安すぎたのだけど)。
しかしながら、従業員に対する評価や報酬については不誠実極まりなかったし、自分の思い描くエンジニア像に必要な経験を積めなくなったのは一番痛かった。
やる気と実力を以て希望さえすれば挑戦させてくれる、入社時にあったような腕を磨ける環境が失われていくのは、1 度ならずこの会社を最後の会社にできそうだと心に思った自分には辛いものがあった。これは過去の話だけど。&lt;/p&gt;&lt;p&gt;転職して今の会社に入れたのもよかった。適切な判断を下すのにインフラ、クラウドの知識を求められ、わたしの技術スタックのうすーいところを絶妙に攻め立ててくれる。
おかげで徐々にではあるが弱いところを克服できている。
また強みである積極性と吸収スピードの高さが上手く活かせて、CI/CD の補填、未体験だったのにサーバーレスアーキテクチャや Python を選ばせてくれたり。
カンファレンスに積極的に参加して、社内に情報を持ち帰ったり、やりたかったことが色々でき始めた。
会社での評価も今のところは順調で、現場での自身の成長スピードを増幅できていると感じる。&lt;/p&gt;&lt;p&gt;心配事があるとしたら、前職の 1 年目年末もこんなのだったので、同じ轍を踏みたくないなというところか 😅&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;自分でも御しきれていなかったのは、在宅ワークの部分。
今は子供の面倒を見る機会を平日は週に 1 回設けて、その日を早く帰って在宅ワークの日としている。
在宅中の仕事の進め方と家族との関わり方の両立が難しくて、まだ納得の行く形になっていない。そりゃ家族からしたら、家にいるのだから色々やってほしいことができてしまうし、このままだと単純に自身の過重労働だなあと思っている。
こういった我が家のパターンだと、在宅ワークよりもちょっとカフェとかで仕事するとかがよいのか。
通勤時間を削る＆家族とも連絡を断つ、という手段がいるのかも、ただしそれは元々わたしの考えていた在宅ワークの動機と違うけど。
この辺は来年 2020 年になってからも、また別の手段を検討していきたい。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;最後に今年密かに目標としていた、1 年間毎月投稿を書く、について。
どこにも宣言してなかったけどブログを継続するという習慣づくりのためにこの目標を据えた。
結果は未達。11 月が現職の障害対応で気持ちに余裕がなかったため。まあ投稿の数は平均月 2 のペースになってたので、この点は目をつぶろう 🙈&lt;/p&gt;&lt;p&gt;来年も目標をゆるくだが設定して邁進したく。もっと情報に触れて、コードを書いて、という生活に昇華しよう。&lt;/p&gt;&lt;p&gt;(きょうの投稿には 1 文字もコードがなかったけど、特例日 😆)&lt;/p&gt;</description><pubDate>Sun, 29 Dec 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-10-14-how-to-handle-waiter-of-boto3</guid><link>https://krymtkts.github.io/posts/2019-10-14-how-to-handle-waiter-of-boto3</link><title>boto3 の Waiter さんとの戯れ</title><description>&lt;p&gt;こないだの仕事。AWS Certificate Manager で証明書をごにょごにょするアプリを書いた。&lt;/p&gt;&lt;p&gt;Python で書いたので AWS のリソースを操作するのに &lt;a href="https://boto3.amazonaws.com/v1/documentation/api/latest/index.html"&gt;Boto3&lt;/a&gt; というライブラリを利用した。証明書を発行したあと検証済みになるまでの待受処理が&lt;code&gt;Waiter&lt;/code&gt;という機能で提供されていたり、非常に便利で大変お世話になっている。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/acm.html#ACM.Waiter.CertificateValidated"&gt;ACM.Waiter.CertificateValidated — Boto 3 Docs 1.9.248 documentation&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;ただ、一つバグらせてしまったところがあった。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Waiter&lt;/code&gt;さんは AWS のリソースを操作する API をラップしているだけ&lt;sup id="fnref-1"&gt;&lt;a class="footnote-ref" href="#fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt;なので、API がエラーを発生させた場合と待受処理がタイムアウトした場合のどちらとも、&lt;code&gt;WaiterError&lt;/code&gt;を発生させる。つまり単純にキャッチするだけの例外処理では違いに気づけないのだ 😱&lt;/p&gt;&lt;p&gt;どのようにハンドリングするか？&lt;code&gt;WaiterError&lt;/code&gt;さんの属性を調べてあげれば良い。&lt;/p&gt;&lt;p&gt;&lt;code&gt;dir&lt;/code&gt;したら&lt;code&gt;last_response&lt;/code&gt;なる属性があったのでそいつを見たら、もとのエラーが何だったのかは分かる形にはなってた。&lt;/p&gt;&lt;p&gt;エラーの場合、&lt;code&gt;WaiterError.last_response['Error']&lt;/code&gt;にエラー情報が格納される。&lt;code&gt;Waiter&lt;/code&gt;さんがリトライ回数の上限に達して&lt;code&gt;WaiterError&lt;/code&gt;をぶん投げてきた場合は、&lt;code&gt;last_response&lt;/code&gt;には&lt;code&gt;Waiter&lt;/code&gt;さんが内包する API の戻り値が架空されるので、それをもとにエラー処理すれば良いのがわかった。以下イメージ。&lt;/p&gt;&lt;pre&gt;&lt;code class="python"&gt;{'Error': {'Message': 'Could not find certificate arn:aws:acm:ap-northeast-1:xxxxxxxxxxxx:certificate/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx in account xxxxxxxxxxxx.', 'Code': 'ResourceNotFoundException'}, 'ResponseMetadata': {'RequestId': 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx', 'HTTPStatusCode': 400, 'HTTPHeaders': {'x-amzn-requestid': 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx', 'content-type': 'application/x-amz-json-1.1', 'content-length': '191', 'date': 'Fri, 11 Oct 2019 03:51:10 GMT', 'connection': 'close'}, 'RetryAttempts': 0}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;👍&lt;/p&gt;&lt;div class="footnotes"&gt;&lt;hr /&gt;&lt;ol&gt;&lt;li id="fn-1"&gt;&lt;p&gt;証明書の検証済みを待つ&lt;code&gt;ACM.Waiter.CertificateValidated&lt;/code&gt;の場合は&lt;code&gt;ACM.Client.describe_certificate()&lt;/code&gt;をラップしている。&lt;/p&gt;&lt;a href="#fnref-1" class="footnote-backref"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description><pubDate>Mon, 14 Oct 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-10-13-docker-toolbox-with-powershell</guid><link>https://krymtkts.github.io/posts/2019-10-13-docker-toolbox-with-powershell</link><title>PowerShell で Docker Toolbox を使う</title><description>&lt;p&gt;へーしゃはちょっといけてなくて、秘伝の古い VM をコンテナ化しない&lt;del&gt;できない&lt;/del&gt;まま使っている。&lt;/p&gt;&lt;p&gt;加えて社内は Windows ユーザと Mac ユーザがごちゃまぜなので VM が VirtualBox のため、Windows ユーザであるわたしは Docker on Windows を使えず。&lt;/p&gt;&lt;p&gt;Docker Toolbox を日常使いしているのだが、&lt;code&gt;docker&lt;/code&gt;に&lt;code&gt;docker-compose&lt;/code&gt;に&lt;code&gt;docker-machine&lt;/code&gt;まで現れたらコマンドやオプションが覚えきれないのが現状である 😭&lt;/p&gt;&lt;p&gt;これらを PowerShell で楽ちんに使おう。いますぐ以下のモジュールを PSGallery からゲットしよう。これらを発見したときは狂喜乱舞した。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://www.powershellgallery.com/packages/DockerCompletion/1.1903.0.190723"&gt;PowerShell Gallery | DockerCompletion 1.1903.0.190723&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://www.powershellgallery.com/packages/DockerComposeCompletion/1.24.0.190329"&gt;PowerShell Gallery | DockerComposeCompletion 1.24.0.190329&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://www.powershellgallery.com/packages/DockerMachineCompletion/0.16.2.190903"&gt;PowerShell Gallery | DockerMachineCompletion 0.16.2.190903&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以下、雑なインストール例。もちろん PowerShell Guys(勝手にそう呼んでいる)なら自前の Profile に追記しよう。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Install-Module -Name DockerCompletion,DockerComposeCompletion,DockerMachineCompletion
Import-Module -Name DockerCompletion,DockerComposeCompletion,DockerMachineCompletion
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これで&lt;code&gt;docker-machine start&lt;/code&gt;に始まり&lt;code&gt;docker&lt;/code&gt;やら&lt;code&gt;docker-compose&lt;/code&gt;でのイメージ・コンテナの名前補完とか諸々できるようになる。世の中、すごいモジュールを作る方がいるもんやねえ 🤔&lt;/p&gt;</description><pubDate>Sun, 13 Oct 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-09-22-limitaion-of-remove-certificates</guid><link>https://krymtkts.github.io/posts/2019-09-22-limitaion-of-remove-certificates</link><title>ALBのListenerから証明書を削除するときの制限</title><description>&lt;p&gt;タイトルの通り。&lt;/p&gt;&lt;p&gt;仕事中にわかっただけで2つある。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;ALBのListenerに登録された証明書を一度にまとめて消せる上限は10件ぽい&lt;/li&gt;&lt;li&gt;ALBのListenerから証明書を消したあと、証明書に関連づいたリソースが消えるまで待たないといけない&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;上記はPython(boto3)からAWSのリソースを操作した際のもの。boto3はpipでインストールできる最新のv1.9.233。&lt;/p&gt;&lt;h3 id="1-albのlistenerに登録された証明書を一度にまとめて消せる上限は10件ぽい"&gt;1. ALBのListenerに登録された証明書を一度にまとめて消せる上限は10件ぽい&lt;/h3&gt;&lt;p&gt;ドキュメントには書かれてない気がする。少なくとも&lt;a href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/elbv2.html#ElasticLoadBalancingv2.Client.remove_listener_certificates"&gt;boto3&lt;/a&gt;と&lt;a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_RemoveListenerCertificates.html"&gt;ELBのAPIリファレンス&lt;/a&gt;のどちらにも記載がない。&lt;/p&gt;&lt;p&gt;問い合わせして聞いてないねんけど、書いてあったら教えてほしい🤔&lt;/p&gt;&lt;p&gt;以下はListener Certificatesの上限25件全部を一気に消そうとしたときのログ。センシティブな部分は削ってある。&lt;/p&gt;&lt;pre&gt;&lt;code class="log"&gt;Traceback (most recent call last):
  File "C:\workspace\alb-batch\albbatch\elbapi.py", line 102, in remove_cerificates
    Certificates=params)
  File "C:\Users\takatoshi_kuriyama\.virtualenvs\alb-batch-J4EQQ8Xf\lib\site-packages\botocore\client.py", line 357, in _api_call
    return self._make_api_call(operation_name, kwargs)
  File "C:\Users\takatoshi_kuriyama\.virtualenvs\alb-batch-J4EQQ8Xf\lib\site-packages\botocore\client.py", line 661, in _make_api_call
    raise error_class(parsed_response, operation_name)
botocore.exceptions.ClientError: An error occurred (ValidationError) when calling the RemoveListenerCertificates operation: Up to '10' certificate ARNs can be specified, but '25' were specified
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="2-albのlistenerから証明書を消したあと証明書に関連づいたリソースが消えるまで待たないといけない"&gt;2. ALBのListenerから証明書を消したあと、証明書に関連づいたリソースが消えるまで待たないといけない&lt;/h3&gt;&lt;p&gt;ACMで証明書を削除する場合、その証明書が他のAWSリソースに関連付けられていると&lt;code&gt;ResourceInUseException&lt;/code&gt;(boto3では&lt;code&gt;ClientError&lt;/code&gt;)で削除できない。&lt;/p&gt;&lt;p&gt;&lt;a href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/acm.html#ACM.Client.delete_certificate"&gt;ACM.Client.delete_certificate&lt;/a&gt; から抜粋。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;You cannot delete an ACM certificate that is being used by another AWS service. To delete a certificate that is in use, the certificate association must first be removed.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;なのでまず関連付けられたLoad BalancerのListenerなどから証明書を取り除いた後、かつ証明書の情報からもその関連付けが取り除かれたことを確認しないと安全に削除できない😱&lt;/p&gt;&lt;p&gt;どうすればよいかというと、ACMの&lt;code&gt;DescribeCertificate&lt;/code&gt;のレスポンスに含まれる&lt;code&gt;InUseBy&lt;/code&gt;リストの中が空になってたら、それらの関連付けが取り除かれた状態なので安全に削除できる。&lt;/p&gt;&lt;p&gt;ACMで提供されてる&lt;code&gt;Waiter&lt;/code&gt;は検証待ちのみで、それ用にはないみたいなので、以下のように手動で待ち合わせする...🤔&lt;/p&gt;&lt;pre&gt;&lt;code class="python"&gt;def wait_until_certificate_unused(self, arn: str):
    cert = self.acm_client.describe_certificate(CertificateArn=arn)
    while len(cert['InUseBy']) &amp;gt; 0:
        time.sleep(1)
        cert = self.acm_client.describe_certificate(CertificateArn=arn)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;めんどくせえええええ、こんなsnipetレベルのモノは&lt;code&gt;Waiter&lt;/code&gt;作って欲しいわ😭&lt;/p&gt;</description><pubDate>Sun, 22 Sep 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-09-01-aws-lambda-cloud-front-and-serverless</guid><link>https://krymtkts.github.io/posts/2019-09-01-aws-lambda-cloud-front-and-serverless</link><title>Serverless FrameworkでAWS LambdaとCloudFront</title><description>&lt;p&gt;AWS Lambdaって書くのはホント簡単。&lt;/p&gt;&lt;p&gt;でも手動でデプロイするのはほんまに勘弁してほしいわ...って感じだったのでAWS強メンの同僚に相談してみたところ、&lt;a href="https://serverless.com/framework/"&gt;Serverless Framework&lt;/a&gt;ってのがいい具合に抽象化してくれてるので試しに使ってみては？と助言いただけた。&lt;/p&gt;&lt;h3 id="使ってみた"&gt;使ってみた&lt;/h3&gt;&lt;p&gt;事前にNodeが必要なことくらい。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# global install
$ npm install -g serverless

# installed version
$ serverless --version
Framework Core: 1.51.0
Plugin: 1.3.10
SDK: 2.1.0

# generate boilerplate
$ serverless create --template aws-python3
Serverless: Generating boilerplate...
 _______                             __
|   _   .-----.----.--.--.-----.----|  .-----.-----.-----.
|   |___|  -__|   _|  |  |  -__|   _|  |  -__|__ --|__ --|
|____   |_____|__|  \___/|_____|__| |__|_____|_____|_____|
|   |   |             The Serverless Application Framework
|       |                           serverless.com, v1.51.0
 -------'

Serverless: Successfully generated boilerplate for template: "aws-python3"
Serverless: NOTE: Please update the "service" property in serverless.yml with your service name
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これで生成された関数に処理を書くだけ。あ～らかんたん😁&lt;/p&gt;&lt;p&gt;デプロイも超簡単なので、これならCDに組み込むのも楽そう。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;# deploy
serverless deploy -v

# deploy to specific stage
serverless deploy -v --stage dev
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="cloudfrontを添えて"&gt;CloudFrontを添えて&lt;/h3&gt;&lt;p&gt;今回の仕事ではちょっと特殊な事情でCloudFrontを経由してLambdaのエンドポイントURLへリクエストする必要があった。&lt;/p&gt;&lt;p&gt;プラグインを使えばかんたんに記述することもできる。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/Droplr/serverless-api-cloudfront"&gt;Droplr/serverless-api-cloudfront: Serverless Plugin - CloudFront distribution in front of your API Gateway&lt;/a&gt;&lt;/p&gt;&lt;p&gt;が、かんたんに記述できる＝かんたんな内容しかいじれない、のため片手落ちな点が多かった。諸々のパラメータの指定ができなくて細かな指定をする場合は結局&lt;code&gt;resources&lt;/code&gt;セクションに自力でCloudFormationを書くことになった。&lt;/p&gt;&lt;p&gt;以下はresourceセクションのサンプル。&lt;code&gt;DomainName&lt;/code&gt;の解決は以下のStackoverflowからヒントを得た。&lt;/p&gt;&lt;p&gt;&lt;a href="https://stackoverflow.com/questions/50931730/deploying-lambda-api-gateway-cloudfront-through-serverless-framework-at-a-ti"&gt;amazon web services - Deploying Lambda + API-gateway + CloudFront through serverless framework at a time - Stack Overflow&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="yaml"&gt;resources:
  Resources:
    LambdaDistribution:
      Type: AWS::CloudFront::Distribution
      Properties:
        DistributionConfig:
          Enabled: true
          Comment: "managed by serverless framewrok"
          HttpVersion: http2
          PriceClass: PriceClass_All
          Origins:
            - Id: ApiGateway
              DomainName: !Join
                - "."
                - - !Ref ApiGatewayRestApi
                  - execute-api
                  - !Ref AWS::Region
                  - amazonaws.com
              OriginPath: /
              CustomOriginConfig:
                HTTPPort: 80
                HTTPSPort: 443
                OriginProtocolPolicy: https-only
                OriginReadTimeout: 10
                OriginSSLProtocols:
                  - "SSLv3"
                  - "TLSv1"
                  - "TLSv1.1"
                  - "TLSv1.2"
          DefaultCacheBehavior:
            AllowedMethods:
              - HEAD
              - DELETE
              - POST
              - GET
              - OPTIONS
              - PUT
              - PATCH
            Compress: false
            DefaultTTL: 0
            MaxTTL: 0
            MinTTL: 0
            ForwardedValues:
              Cookies:
                Forward: none
              Headers:
                - x-api-key
              QueryString: false
            TargetOriginId: ApiGateway
            ViewerProtocolPolicy: redirect-to-https
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ちなみにLambda@Edgeにはまだ対応していないみたいでプラグインの利用が必須となっている様子。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/serverless/serverless/issues/3944"&gt;Support for Lambda@Edge · Issue #3944 · serverless/serverless&lt;/a&gt;&lt;/p&gt;&lt;h3 id="感想"&gt;感想&lt;/h3&gt;&lt;p&gt;AWSだけにベンダーロックインせずServeless Computingの開発ができるよーな抽象化層を提供するようなCLIのイメージ。&lt;/p&gt;&lt;p&gt;誕生は数年前でまだまだ新し目のため、web上には新旧の情報が玉石混交の状態であるからして、細かなYAMLの記述内容の確認なんかは&lt;a href="https://serverless.com/framework/docs/"&gt;Serverless Framework Documentation&lt;/a&gt;を参考にし、大まかな書き方はそのへんのブログなどから引っこ抜いてくるのが良いと思われる。&lt;/p&gt;&lt;p&gt;まだ1プロダクトでしか使ってないけど、いい感触を得た。YAMLの記述内容は、AWSの場合でいうとresourcesはまんまCloudFormationなので、そのへんの知識があれば使いこなせそう。SaaSのやつはまだ使ってないので感触なし。&lt;/p&gt;&lt;h3 id="おまけ-slsというコマンド名"&gt;おまけ: &lt;code&gt;sls&lt;/code&gt;というコマンド名&lt;/h3&gt;&lt;p&gt;ばかみたいな話なんやけど、Serverless Frameworkの短縮形コマンド&lt;code&gt;sls&lt;/code&gt;はPowerShellで言うところの&lt;code&gt;Select-String&lt;/code&gt;コマンドレットにエイリアスされてるので使えねえｗ&lt;/p&gt;&lt;p&gt;ではアデュー😘&lt;/p&gt;</description><pubDate>Sun, 01 Sep 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-08-11-test-lambda-with-pwsh</guid><link>https://krymtkts.github.io/posts/2019-08-11-test-lambda-with-pwsh</link><title>AWS LambdaをPowershellでテスト実行する</title><description>&lt;p&gt;へーしゃの支援によりGoogle Cloud Next Tokyo 2019へ参加できた。&lt;/p&gt;&lt;p&gt;とても有意義な時間を過ごせたのでブログをしたためたかったのだけど、日が経つにつれ仕事もメモもとっ散らかってしまい清書もできず、現時点でのブログへのまとめは断念中😫&lt;/p&gt;&lt;p&gt;代わりに小ネタを投稿する。&lt;/p&gt;&lt;h3 id="curlの代わりのpowershell"&gt;curlの代わりのPowershell&lt;/h3&gt;&lt;p&gt;最近仕事でAWS Lambdaを使う機会を得た。へーしゃはAWSもGCPもどっちでもアリだが、現状はAWS優勢。わたしはGCPがいいけど。
元々最初にCloud WatchとAWS Lambdaで作った方が良いのでは？という提案をしていたのだが、大した理由もなく却下。その後追加された機能がLambdaじゃないと実行環境を準備するのが難しいというのが判明して、棚からぼた餅なチャンス到来。&lt;/p&gt;&lt;p&gt;本題に入ろう。今回作ったLambdaはAPI Gatewayと組み合わせてWeb APIとして利用する。&lt;/p&gt;&lt;p&gt;そのためAPI Key(&lt;code&gt;x-api-key&lt;/code&gt;)をRequest Headerに付与してリクエストされる想定でいる(現時点で)。&lt;/p&gt;&lt;p&gt;なのでブラウザなんかでテスト実行出来ないので、大抵のやつはcurlなんかでURLを叩く。しかしここはPowershellでやってみよう。&lt;/p&gt;&lt;p&gt;Web-APIを叩くのなら&lt;code&gt;Invoke-WebRequest&lt;/code&gt;がよかろう。追加のヘッダーは&lt;code&gt;-Headers&lt;/code&gt;にhashtableとして渡せるのだ。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Invoke-WebRequest -Uri https://omae-no-api-endpoint/helloworld -Headers @{'x-api-key' = 'omae-no-api-key!!!'}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;こうなる。そんだけ😉&lt;/p&gt;</description><pubDate>Sun, 11 Aug 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-07-28-have-a-good-day-with-poco</guid><link>https://krymtkts.github.io/posts/2019-07-28-have-a-good-day-with-poco</link><title>pocoで捗る日常生活</title><description>&lt;p&gt;&lt;a href="/posts/2019-06-23-poco"&gt;以前ちょっとだけ触れたpoco&lt;/a&gt;を使いだしてから、よく使うディレクトリへの移動とか、&lt;code&gt;PSReadline&lt;/code&gt;のHistoryからよく使うコマンドを引っ張り出すとかの、インタラクティブなコマンドが作りやすくとて捗っている。&lt;/p&gt;&lt;p&gt;&lt;a href="https://gist.github.com/krymtkts/f8af667c32b16fc28a815243b316c5be"&gt;Gistにあげたプロファイル&lt;/a&gt;にまるっと書いているのだけど、ココではコメントも添えて書いておく。&lt;/p&gt;&lt;h3 id="psreadlineのhistoryを見る実行する"&gt;&lt;code&gt;PSReadline&lt;/code&gt;のhistoryを見る/実行する&lt;/h3&gt;&lt;p&gt;作った関数は以下の通り。似たようなモジュールはPSGalleryに何個かあるけど、pocoで書きたかったので自作した次第。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function Show-ReadLineHistory() {
    Get-Content -Path (Get-PSReadlineOption).HistorySavePath | Select-Object -Unique | Select-Poco -CaseSensitive
}
Set-Alias pghy Show-ReadLineHistory -Option AllScope

function Invoke-ReadLineHistory() {
    Show-ReadLineHistory | Select-Object -First 1 | Invoke-Expression
}
Set-Alias pihy Invoke-ReadLineHistory -Option AllScope
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;途中で&lt;code&gt;Select-Object -Unique&lt;/code&gt;を挟んでいるのは、わたしがやたら同じコマンドを繰り返すので重複を省くため😅&lt;/p&gt;&lt;p&gt;&lt;code&gt;Select-Object -First 1&lt;/code&gt;はpoco自体の機能不足(選択機能がない)のを補うためである😭&lt;/p&gt;&lt;p&gt;ちなみにPowerShellのHistoryが謎な件についてはソースはこの辺。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://qiita.com/yuta0801/items/ad0cf608144fb1546e54"&gt;PowerShellの完全な履歴を取得する - Qiita&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/44104043/how-can-i-see-the-command-history-across-all-powershell-sessions-in-windows-serv"&gt;How can I see the command history across all PowerShell sessions in Windows Server 2016? - Stack Overflow&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;code&gt;Get-History&lt;/code&gt;は現在のセッションの情報しか取らない。でも実は&lt;code&gt;(Get-PSREeadlineOption).HistorySavePath&lt;/code&gt;に保存されている、という話🤔&lt;/p&gt;&lt;p&gt;&lt;code&gt;~\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt&lt;/code&gt;な感じでテキストファイルに保存されている。&lt;/p&gt;&lt;p&gt;ちなみに本来の&lt;code&gt;Get-History&lt;/code&gt;実行結果のような履歴ごとにIDを振るのはやってない。&lt;/p&gt;&lt;h3 id="お気に入りのディレクトリへ移動する"&gt;お気に入りのディレクトリへ移動する&lt;/h3&gt;&lt;p&gt;これはパクリ。仕事で使うリポジトリはghqを使わないで決められたディレクトリへcloneすることを期待されてたりするので、そのときにこういう任意のディレクトリへの移動ができるやつが重宝してる。&lt;/p&gt;&lt;p&gt;&lt;a href="https://mattn.kaoriya.net/software/peco.htm"&gt;Big Sky :: Windows のコマンドプロンプトを10倍便利にするコマンド「peco」&lt;/a&gt;&lt;/p&gt;&lt;p&gt;あと編集機能は未実装。わたしの用途では編集よりも削除機能のほうが良いかなと思ったりしてるところ🤔&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function Set-SelectedLocation {
    param(
        [ValidateSet("Add", "Move", "Edit")]$Mode = "Move",
        [string]$Location
    )
    switch ($Mode) {
        "Add" {
            if ($Location) {
                Write-Output "$Location" | Out-File -Append -Encoding UTF8 "~/.poco-cd"
                break
            }
        }
        "Move" {
            Get-Content -Path "~/.poco-cd" | Select-Poco -CaseSensitive | Select-Object -First 1 | Set-Location
            break
        }
        "Edit" {
            break
        }
    }
}
Set-Alias pcd Set-SelectedLocation -Option AllScope
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="雑なまとめ"&gt;雑なまとめ&lt;/h3&gt;&lt;p&gt;これらのツールをpocoの補完ツールとしてもうちと洗練してもいいかもしれんなあと思ったりしてる🤔&lt;/p&gt;</description><pubDate>Sun, 28 Jul 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-07-07-cement-the-cli-framework</guid><link>https://krymtkts.github.io/posts/2019-07-07-cement-the-cli-framework</link><title>CementというCLIフレームワーク</title><description>&lt;p&gt;仕事で、なんかDBに通信しながらAWSのAPIをぶん殴ってゴニョゴニョするバックエンド処理を書く必要があって、Pythonで書くことになった。&lt;/p&gt;&lt;p&gt;&lt;a href="https://python-guideja.readthedocs.io/ja/latest/index.html"&gt;Python ヒッチハイク・ガイド — The Hitchhiker's Guide to Python&lt;/a&gt;を参考にCLIのフレームワークを見ていって、サンプル的に作ってみた感じや継続的にメンテされてることとかで&lt;a href="https://builtoncement.com/"&gt;Cement Framework&lt;/a&gt;を採用することにした。&lt;/p&gt;&lt;p&gt;簡潔に説明すると、CLIアプリケーション作成を容易にするためのフレームワーク。なんとAWS Elastic Beanstalkに使われてるらしい。&lt;/p&gt;&lt;p&gt;数少ない日本語の資料。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://qiita.com/ma2saka/items/9aacc46e20b9886ec156"&gt;自分が必要とする最低限の Cement の情報 - Qiita&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;ほんとに少ないのでなんか自分用にメモを取ろうとこの記事をしたためた次第である。&lt;/p&gt;&lt;p&gt;ボイラープレートでCLIのベースはできてしまうので、あとはその中身を書いていくだけ。ちょっとAPIドキュメントがわかりにくい気もするが、YAMLの設定ファイル読み込みやロギングなども拡張機能としてある。今の所はとてもよくできた使いやすいFWだと思っている。こんどコードの生成らへんの簡単な手順をまとめてみたい。&lt;/p&gt;&lt;p&gt;すでに途中までCementをベースに開発しているのだけど、少し困った点がある。&lt;/p&gt;&lt;h3 id="困った点"&gt;困った点&lt;/h3&gt;&lt;p&gt;&lt;a href="https://github.com/datafolklabs/cement/issues/549"&gt;Cement not compatible with pipenv · Issue #549 · datafolklabs/cement&lt;/a&gt;&lt;/p&gt;&lt;p&gt;バグでpipenvは&lt;code&gt;setup.py&lt;/code&gt;をインストール出来ないのでエラーで死ぬのだ😭わたしが考えた対策としてはイカのトーリである。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;開発環境
&lt;ul&gt;&lt;li&gt;&lt;code&gt;pipenv install -r requirement.txt&lt;/code&gt;などを使いつつ開発&lt;/li&gt;&lt;li&gt;実行時には作業ディレクトリでスクリプト実行する感じ&lt;code&gt;python -m myapp.main&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;製品環境
&lt;ul&gt;&lt;li&gt;&lt;code&gt;pip&lt;/code&gt;を使ったインストール及び&lt;code&gt;setup.py&lt;/code&gt;でモジュールをインストール&lt;/li&gt;&lt;li&gt;モジュール実行を行うのでどこでもok(なはず)&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;まだ開発途上なので、製品環境の想定がそのままうまくいくかはビミョーなところ🤔また試行錯誤しなくては。&lt;/p&gt;&lt;p&gt;最近は[Poetry(https://cocoatomo.github.io/poetry-ja/index.html)のほうがイケてると聞くし、はじめからPipenvを使わないようにしてたら良かった感はしなくはない😭&lt;/p&gt;</description><pubDate>Sun, 07 Jul 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-06-29-season-of-openssh-error</guid><link>https://krymtkts.github.io/posts/2019-06-29-season-of-openssh-error</link><title>またOpenSSHが動かなくなる季節がやってきた</title><description>&lt;p&gt;アップデートの度に何かあるので、もはや風物詩と化したOpenSSHのエラー。&lt;/p&gt;&lt;p&gt;&lt;a href="/posts/2019-03-31-win-openssh-is-gone"&gt;前回のエラー&lt;/a&gt;&lt;/p&gt;&lt;p&gt;きょうChocolateyでパッケージ更新したらWindowsのOpenSSHがアップデートされた様子。&lt;a href="https://github.com/PowerShell/Win32-OpenSSH/releases/tag/v8.0.0.0p1-Beta"&gt;Release v8.0.0.0p1-Beta · PowerShell/Win32-OpenSSH&lt;/a&gt;かな？&lt;/p&gt;&lt;p&gt;それに伴い&lt;code&gt;ssh-agent&lt;/code&gt;サービスが消え去ってしまった。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ Get-Service -Name 'ssh-agent'
Get-Service : Cannot find any service with service name 'ssh-agent'.
At line:1 char:1
+ Get-Service -Name 'ssh-agent'
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ CategoryInfo          : ObjectNotFound: (ssh-agent:String) [Get-Service], ServiceCommandException
+ FullyQualifiedErrorId : NoServiceFoundForGivenName,Microsoft.PowerShell.Commands.GetServiceCommand
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;単純に再インストールしても自動でサービス登録はされなかったのだけど、同梱されているファイルを見てみたところそれらしいスクリプト&lt;code&gt;install-sshd.ps1&lt;/code&gt;を発見した。Wikiにも記載がある。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/PowerShell/Win32-OpenSSH/wiki/Install-Win32-OpenSSH#install-win32-openssh-test-release"&gt;Install Win32 OpenSSH · PowerShell/Win32-OpenSSH Wiki&lt;/a&gt;&lt;/p&gt;&lt;p&gt;実行してみたところ無事にサービスが作成されたので一安心。サービス自動起動の設定をしておいて完了した。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ .\install-sshd.ps1
[SC] SetServiceObjectSecurity SUCCESS
[SC] ChangeServiceConfig2 SUCCESS
[SC] ChangeServiceConfig2 SUCCESS
sshd and ssh-agent services successfully installed
$ Get-Service 'ssh-agent'

Status   Name               DisplayName
------   ----               -----------
Stopped  ssh-agent          OpenSSH Authentication Agent

$ Set-Service -name "ssh-agent" -startuptype "automatic"
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ふう🙃&lt;/p&gt;</description><pubDate>Sat, 29 Jun 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-06-23-poco</guid><link>https://krymtkts.github.io/posts/2019-06-23-poco</link><title>Poco</title><description>&lt;p&gt;5月以降outputのリズムが崩れております🤔&lt;/p&gt;&lt;p&gt;時間の使い方の改善を目論み、ポモドーロを導入するなど。まだ効果の程は見えていないので今日はPowerShell版pecoのpocoを紹介する。&lt;/p&gt;&lt;h3 id="peco"&gt;peco&lt;/h3&gt;&lt;p&gt;まずpecoってなんじゃこらって感じでもあるのだが、linuxなどで使えるインクリメンタルなフィルタリングコマンドらしい。&lt;/p&gt;&lt;p&gt;&lt;a href="http://tm.root-n.com/unix:command:peco"&gt;Unix :: コマンド / peco [Tipsというかメモ]&lt;/a&gt;&lt;/p&gt;&lt;p&gt;こんなに便利な機能なので、もちろんWindowsでも使えるようになってある &lt;a href="https://github.com/peco/peco"&gt;peco/peco: Simplistic interactive filtering tool&lt;/a&gt;&lt;/p&gt;&lt;p&gt;ただ日常使いのシェルをPowerShellにしている身としては、単純なテキストの絞り込みじゃなくてオブジェクトを扱えるやつが望ましいわけで...&lt;/p&gt;&lt;h3 id="poco"&gt;poco&lt;/h3&gt;&lt;p&gt;というふうに思ってたら普通にPowerShell Galleryにあったわ😲&lt;/p&gt;&lt;p&gt;PowerShellの場合は&lt;a href="https://gist.github.com/yumura/8df37c22ae1b7942dec7"&gt;powershell peco&lt;/a&gt;というのがあって、それを使ったPSModuleがPSGalleryに上がっている...!!!これは使わない手はないぞよ🤔&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://www.powershellgallery.com/packages/poco/1.1.0"&gt;PowerShell Gallery | poco 1.1.0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/jasonmarcher/poco"&gt;jasonmarcher/poco: Interactive pipeline filtering in PowerShell (a port of peco).&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;ただしこのモジュール、&lt;a href="https://gist.github.com/yumura/8df37c22ae1b7942dec7"&gt;powershell peco&lt;/a&gt;のコードをそのまま使ってるのが現状みたいで、作者の方が書かれている改善点そのまま残ってるくさい😭&lt;/p&gt;&lt;p&gt;&lt;a href="https://qiita.com/yumura_s/items/a068329769c6338471dd"&gt;PowerShell で peco (インタラクティブ・フィルタリングツール)っぽいものを作った - Qiita&lt;/a&gt;&lt;/p&gt;&lt;p&gt;という具合に不完全なできであるのは確かなんやが、雰囲気でCLIにPowerShellを使っているようなワイには非常に便利なツールなのである。&lt;/p&gt;&lt;h3 id="pocoを使ってなにか書こう"&gt;pocoを使ってなにか書こう&lt;/h3&gt;&lt;p&gt;例えば、PowerShellではCLIの完全な入力履歴を取ろうとしたら&lt;code&gt;PSReadLine&lt;/code&gt;に頼ることになるのだが、こいつをインタラクティブにフィルタリングするコマンドをぺぺっと書いてしまうこともできる↓&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;function Show-ReadLineHistory() {
    Get-Content -Path (Get-PSReadlineOption).HistorySavePath | poco
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;こんな風な単純なやつは正直なところpecoで十分なのだけど...&lt;/p&gt;&lt;p&gt;あと、検索結果の1行を選んで即実行なんしたいのだけど、pocoの機能不足でリストアップされた検索結果をarrow keyで選んだりとかできないので、今のところかなり癖のある使い方になってる😅&lt;/p&gt;&lt;p&gt;そんな感じPowerShellにも育てたい？ツールがあって使っていくモチベーションみたいなもんが湧いてきますな？🤔現状至らないところ多いからなんかコントリビュートしたい。
でもまず時間を作らなあかんな🤔&lt;/p&gt;</description><pubDate>Sun, 23 Jun 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-06-02_install-shfmt-to-win-using-cli</guid><link>https://krymtkts.github.io/posts/2019-06-02_install-shfmt-to-win-using-cli</link><title>シェルスクリプトのフォーマッタをCLIでインストールする</title><description>&lt;p&gt;小ネタ。&lt;/p&gt;&lt;p&gt;へーしゃの仕事では、Bashで書かれたスクリプトの出番がめちゃくちゃ多い。&lt;/p&gt;&lt;p&gt;Bashが得意じゃないマンのわたしにとっては、そういったスクリプトを読み書きに慣れてないこともあり、結構疲れる仕事である。&lt;/p&gt;&lt;p&gt;そこでせめて書くのだけは少しでも楽したいと思って、フォーマッタを導入しようと思った。&lt;/p&gt;&lt;h3 id="ツールを導入する"&gt;ツールを導入する&lt;/h3&gt;&lt;p&gt;shfmtというgolang製のツールがあるので、それを採択。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/mvdan/sh"&gt;mvdan/sh: A shell parser, formatter, and interpreter (POSIX/Bash/mksh)&lt;/a&gt;&lt;/p&gt;&lt;p&gt;しかし悲しいかな、Windows用に提供されてるパッケージはScoopのみ(リンク切れてるけど)でChocolateyにない様子🤔(筆者はChocolateyユーザである)。&lt;/p&gt;&lt;p&gt;代わりにCLIでのインストールを使うことにする。&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;cd $(mktemp -d); go mod init tmp; go get mvdan.cc/sh/v3/cmd/shfmt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;でも&lt;code&gt;mktemp&lt;/code&gt;コマンドはPowerShellにはないし...そこは&lt;code&gt;mkdir&lt;/code&gt;で茶を濁す。あとtmpフォルダの後始末もする。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;cd $(mkdir tmp); go mod init tmp; go get mvdan.cc/sh/v3/cmd/shfmt; cd ../; rm -r tmp
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ええがな。&lt;/p&gt;&lt;h3 id="雑記"&gt;雑記&lt;/h3&gt;&lt;p&gt;5月後半はうまく波に乗れずブログを書けなかった。まだアウトプットが習慣化していないようなので、きちんと積み重ねしていきたいもんやで🤔&lt;/p&gt;</description><pubDate>Sun, 02 Jun 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-05-11-pipenv-skeleton</guid><link>https://krymtkts.github.io/posts/2019-05-11-pipenv-skeleton</link><title>Pipenvのテンプレを作った</title><description>&lt;p&gt;&lt;a href="/posts/2019-04-29-bias-amp-2issue"&gt;前回&lt;/a&gt;の最後に触れた、仕事で経験を得た2019年のイケてそうなPython開発環境構築について。&lt;/p&gt;&lt;p&gt;この度新し目と思われるPythonのプロジェクト構築について学んだので、次回Pythonを触ることがあったとしてもぱぱっと始められるようにテンプレートを作ろうと思った次第である。&lt;/p&gt;&lt;p&gt;過去のeasy_installとかpipまでで知識が止まってたが、新たにpipenvを知ってかなり便利に使えるいい感じの印象を得たのもあって、動機付けされた感じ。&lt;/p&gt;&lt;p&gt;なので、勉強がてらGW中のお楽しみにちょろっと作った。&lt;/p&gt;&lt;h3 id="作ったもの"&gt;作ったもの&lt;/h3&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/pipenv-skeleton"&gt;krymtkts/pipenv-skeleton&lt;/a&gt;&lt;/p&gt;&lt;p&gt;いろいろとググって、pipとかvirtualenvの時代は過ぎ去っており、いまはpienvがイケていると直感を得た。
なのでpipenvについて以下の記事などを参考にこのテンプレを作った。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://pipenv-ja.readthedocs.io/ja/translate-ja/"&gt;Pipenv: 人間のためのPython開発ワークフロー — pipenv 2018.11.27.dev0 ドキュメント&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://www.natsukium.com/blog/2019-02-18/python/"&gt;Python環境構築ベストプラクティス2019 - ばいおいんふぉっぽいの！&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://qiita.com/youkidkk/items/b6a6e39ee3a109001c75"&gt;Windows + Python 3.6 + PipEnv + Visual Studio Code でPython開発環境 - Qiita&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://qiita.com/tonluqclml/items/b09f4a5ed04ebcbd0af1"&gt;既存プロジェクトに pipenv を導入した方法 - Qiita&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;予めLinterやらFormatterやらをdevPackageとして用意している。LinterにはPylintを用意したが、エラーの自動修正がないようなのでautopep8も用意した。&lt;/p&gt;&lt;p&gt;あと静的型付けに守られた世界で仕事できるように、MyPyも用意している。Better Bashとして使うときは大げさかもしれないけど、その時は単にMyPyを使わなかったらいいだけ。&lt;/p&gt;&lt;p&gt;このプロジェクトをコピペして、moduleのところをこねこねして使うイメージ。&lt;/p&gt;&lt;p&gt;Pythonのモジュールシステムについてはまだ理解が浅い。以下を参考にドキュメントをあたって、&lt;code&gt;__init.py__&lt;/code&gt;,&lt;code&gt;__main.py__&lt;/code&gt;のらへんを定型化した感じ。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/448271/what-is-init-py-for"&gt;python - What is &lt;strong&gt;init&lt;/strong&gt;.py for? - Stack Overflow&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/4042905/what-is-main-py"&gt;python - What is &lt;strong&gt;main&lt;/strong&gt;.py? - Stack Overflow&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;ただ、&lt;code&gt;__init.py__&lt;/code&gt;は名前空間パッケージではなくていいようだし、よりモダンな方法に寄せたいので再検討するかな。単に今はわたしの知識がそこまで及んでない😭Pythonの言語仕様もちゃんと勉強したいのう。&lt;/p&gt;&lt;p&gt;いろいろ足りない点があるが、それらは今後改善できれば良いかな。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;moduleの名前をいろいろ変えないといけないのが面倒なので、なんか改善ができれば良。&lt;/li&gt;&lt;li&gt;テストがないので足したい。&lt;/li&gt;&lt;li&gt;なんかバッジ足したい。ビルドとか...&lt;/li&gt;&lt;li&gt;mypyで&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="まとめ"&gt;まとめ&lt;/h3&gt;&lt;p&gt;Python3たのしい。&lt;/p&gt;&lt;p&gt;せっかくテンプレを作ったので、なんかゴミスクリプトでも良いのでちまちま書いていきたい所存🤔&lt;/p&gt;&lt;p&gt;mypyについてもメモためていこ。&lt;/p&gt;</description><pubDate>Sat, 11 May 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-04-29-bias-amp-2issue</guid><link>https://krymtkts.github.io/posts/2019-04-29-bias-amp-2issue</link><title>BIAS Amp 2で保存したアンプが消える問題</title><description>&lt;p&gt;小ネタ。&lt;/p&gt;&lt;p&gt;個人的に、2019年からPositive Grid社のBIAS Amp miniを導入した。&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.positivegrid.com/bias-mini-guitar/"&gt;BIAS MINI Guitar - Positive Grid&lt;/a&gt;&lt;/p&gt;&lt;p&gt;平たく言うと、ギターアンプの部品をいじくり回すことでサウンドメイクする、というアイデアのデジタルアンプ。そのサウンドメイクの幅の広さ、自分好みのサウンドを手探りする面白さから、とても気に入っている。&lt;/p&gt;&lt;p&gt;ただちょっと、バグが多いように思う。現時点で2つのバグらしい挙動を見つけている。&lt;/p&gt;&lt;h3 id="1line-outが出力されない問題"&gt;1.Line OUTが出力されない問題&lt;/h3&gt;&lt;p&gt;見出しの通りである。出る場合と出ない場合があるのか、パターンを絞り出せていない。&lt;/p&gt;&lt;p&gt;Line OUTはスタジオで試したときに気づいたので、まだすべての状況において出力がないのかは調べ尽くしていない。&lt;/p&gt;&lt;h3 id="2保存したアンプが消える問題"&gt;2.保存したアンプが消える問題&lt;/h3&gt;&lt;p&gt;購入したBIAS Amp miniには、同社のモデリングソフトウェアBIAS Amp 2が付属し、それで作ったアンプモデルをBIAS Amp miniに書き込むことができる。&lt;/p&gt;&lt;p&gt;今確認している範囲では、以下のパターンで書き込んだアンプが、消失する時がある。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;BIAS Amp 2でキャプチャしたアンプ(AMP MATCH)をTone Cloudで入手する&lt;/li&gt;&lt;li&gt;入手したアンプのパラメータを変える&lt;/li&gt;&lt;li&gt;BIAS Amp miniをdesconnect後にスキンを変更する&lt;/li&gt;&lt;li&gt;再度BIAS Amp miniを接続し、変更したアンプを書き込む&lt;/li&gt;&lt;li&gt;電源OFFから数時間後に消失&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;ただ、このパターンで2回消えたのだが、3回目の再現ができていないので別の変数が関与してそう🤔ややこしい。&lt;/p&gt;&lt;h3 id="まとめ"&gt;まとめ&lt;/h3&gt;&lt;p&gt;いずれも割とまじで困る系の障害なので、ちゃんと条件を調べた上でサポートに問い合わせしたいところだけど、まだ全然出来てない状態...&lt;/p&gt;&lt;p&gt;2の保存したアンプが消える問題は一応着手中。ライブ本番とかにモデルが消えてたらほんま笑い事じゃないからな...&lt;/p&gt;&lt;p&gt;しょうもないネタを書き記すことが増えてきたので、次回は仕事で経験を得た、2019年のイケてそうなPython開発環境構築について書きたい所存🤔&lt;/p&gt;</description><pubDate>Mon, 29 Apr 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-04-20_disable-touch-screen</guid><link>https://krymtkts.github.io/posts/2019-04-20_disable-touch-screen</link><title>Windows10でタッチスクリーンを無効化する</title><description>&lt;p&gt;小ネタ。&lt;/p&gt;&lt;p&gt;自機は、Razer Blade Stealth 2018のタッチスクリーン対応のやつだ。&lt;/p&gt;&lt;p&gt;ディスプレイを閉じた状態から再度開いたときに、たま～に謎に画面が連続タップされまくって制御不能になるポルターガイスト現象(偽)が起こることがあった。&lt;/p&gt;&lt;p&gt;それ以来タッチスクリーンの無効化をしているんやが、これがWindowsの大規模アップデートがあると設定が無効になって、都度再設定が必要になってる感じ🤔&lt;/p&gt;&lt;p&gt;最近ver1803が降りてきたことで再度必要になったので覚書。&lt;/p&gt;&lt;h3 id="手順"&gt;手順&lt;/h3&gt;&lt;p&gt;&lt;a href="https://support.microsoft.com/ja-jp/help/4028019/windows-enable-and-disable-your-touchscreen-in-windows-10"&gt;Windows 10 でタッチスクリーンを有効/無効にする&lt;/a&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;デバイスマネージャを開く&lt;/li&gt;&lt;li&gt;HID準拠タッチスクリーンのデバイスを無効化する&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;THE END&lt;/p&gt;</description><pubDate>Sat, 20 Apr 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-04-14-add-a-badge</guid><link>https://krymtkts.github.io/posts/2019-04-14-add-a-badge</link><title>プロジェクトにバッジを貼ろう</title><description>&lt;p&gt;&lt;a href="https://www.powershellgallery.com/packages/MavenAutoCompletion/0.1"&gt;先日PowerShell Galleryにモジュールを公開した&lt;/a&gt;ついでに、プロジェクトのGitHubにバッジを貼ってみた。&lt;/p&gt;&lt;p&gt;のでその覚書。&lt;/p&gt;&lt;h3 id="バッジを貼ろう"&gt;バッジを貼ろう&lt;/h3&gt;&lt;p&gt;なんかいろいろサービスがあるようだけど、わたしは&lt;a href="https://shields.io/"&gt;Shields.io: Quality metadata badges for open source projects&lt;/a&gt;にしてみた。&lt;/p&gt;&lt;p&gt;いろんなバッジが提供されてるみたいやし、利用するためのハードルが低い(とにかく楽な)のが良い。&lt;/p&gt;&lt;p&gt;PowerShell GalleryのDownload数を表示するバッチがあったので、それを利用してみた。&lt;/p&gt;&lt;p&gt;&lt;a href="https://shields.io/category/downloads"&gt;Shields.io: Quality metadata badges for open source projects&lt;/a&gt;&lt;/p&gt;&lt;p&gt;利用は簡単でURLを貼るだけ。なんかよそのOSSとか見ててたらもっと簡単な方法がありそうだが、普通のMarkdownで書いた。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/MavenAutoCompletion/blob/master/README.md"&gt;MavenAutoCompletion/README.md at master · krymtkts/MavenAutoCompletion&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="md"&gt;[![PowerShell Gallery](https://img.shields.io/powershellgallery/dt/MavenAutoCompletion.svg?style=flat-square)](https://www.powershellgallery.com/packages/MavenAutoCompletion)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;コレがこうなる↓&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2019-04-14-badge/badge.png" alt="バッジ" /&gt;&lt;/p&gt;&lt;p&gt;いいね～😚&lt;/p&gt;&lt;p&gt;つかDLすっくねえ！！！&lt;/p&gt;&lt;p&gt;まあ自分のDLは、家、家リトライ、職場の3回だけで、残りの7回は世界のどこかで使われてるということがわかった。
ので良しとしよう🤔&lt;/p&gt;&lt;p&gt;こうなるともっとバッジをペタペタ貼りたくなりますな～。&lt;/p&gt;</description><pubDate>Sun, 14 Apr 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-04-07-lint-my-statement</guid><link>https://krymtkts.github.io/posts/2019-04-07-lint-my-statement</link><title>下手な文章を Lint する</title><description>&lt;p&gt;転職してから 2 ヶ月の間、海外労働者の同僚から、日本語のドキュメントも英語のドキュメントもレビューコメントをいただいていてつらい。&lt;/p&gt;&lt;p&gt;英語だけならまだしろ、わしゃ日本語もろくに扱えん日本人なんかと思うと涙ちょちょぎれる次第であります。&lt;/p&gt;&lt;p&gt;なので自分の文章に Lint をかけようと思った。&lt;/p&gt;&lt;h3 id="textlint"&gt;textlint&lt;/h3&gt;&lt;p&gt;いつだったか文章の Linter についてググってたら、以下のようなものを見つけた。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/textlint/textlint"&gt;GitHub - textlint/textlint&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://qiita.com/azu/items/2c565a38df5ed4c9f4e1"&gt;Qiita - VS Code で textlint を使って文章をチェックする&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/textlint-ja/textlint-rule-preset-ja-technical-writing"&gt;textlint-ja/textlint-rule-preset-ja-technical-writing: 技術文書向けの textlint ルールプリセット&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;...すげえな！近い内に使えるようにしよう。と思ってから数ヶ月後、実務でまともな文章を書く能力が必要になるとわ...😭
というか vscode-textlint ってホイル焼きで有名な方の作品なのですね。敬意を払うべきプロダクトだ。&lt;/p&gt;&lt;p&gt;以下にわたしのセットアップ手順を記す(実行は PowerShell だよ)。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;VSCode で vscode-textlin を入れる&lt;/li&gt;&lt;li&gt;&lt;code&gt;npm i -g textlint textlint-rule-preset-ja-technical-writing&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;cd ~&lt;/code&gt;で&lt;code&gt;textlint --init&lt;/code&gt;してルールを書き込み&lt;/li&gt;&lt;li&gt;VSCode では設定ファイルを絶対パスで利用するからどうしたものか...(複数端末で Sync してる関係で)
&lt;ol&gt;&lt;li&gt;&lt;code&gt;~/,textlint&lt;/code&gt;にしたらユーザ名とか考えなくていいから、なんかいい 😁&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;ついかパッケージ &lt;code&gt;npm i -g textlint-rule-date-weekday-mismatch textlint-rule-terminology textlint-rule-ginger&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;これで簡単な typo は減らせるんじゃないかな。&lt;/p&gt;&lt;p&gt;お気に入りのルールは&lt;code&gt;textlint-rule-date-weekday-mismatch&lt;/code&gt;。これからのオレが曜日を間違うことはないぜええええ？(フラグ&lt;/p&gt;</description><pubDate>Sun, 07 Apr 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-04-02-pubslish-first-module-to-powershell-gallery</guid><link>https://krymtkts.github.io/posts/2019-04-02-pubslish-first-module-to-powershell-gallery</link><title>はじめてのPowerShell Galleryへの公開</title><description>&lt;p&gt;先日、自前のモジュールをPowerShell Galleryに公開したので、その時のメモを記す。&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.powershellgallery.com/packages/MavenAutoCompletion/0.1"&gt;PowerShell Gallery | MavenAutoCompletion 0.1&lt;/a&gt;&lt;/p&gt;&lt;p&gt;PowerShell Galleryのアカウントを作るだとか、モジュールのAnalysisだとかはまた別で書こう。ここではモジュールの公開の部分だけ。&lt;/p&gt;&lt;h3 id="tldr"&gt;TL;DR&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Poblish-Module&lt;/code&gt;は除外ファイル設定とかないから公開時には注意しましょう😭&lt;/p&gt;&lt;h3 id="モジュールの公開"&gt;モジュールの公開&lt;/h3&gt;&lt;p&gt;以下の手順に従う。&lt;/p&gt;&lt;p&gt;&lt;a href="https://docs.microsoft.com/ja-jp/powershell/gallery/how-to/publishing-packages/publishing-a-package"&gt;アイテムの作成と公開 | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;事前にチェックしろよな！！！と書いてるのでそれに従い以下のコマンドを実行する&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Publish-Module -Path ".\MavenAutoCompletion" -NugetAPIKey "キーは見せられないよ" -WhatIf -Verbose
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;途中で最新のNuGet入れるかい？と聞かれるのでそれはYesで。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ Publish-Module -Path ".\MavenAutoCompletion" -NugetAPIKey "キーは見せられないよ" -WhatIf -Verbose
VERBOSE: Acquiring providers for assembly: C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\PackageManagement\1.3.1\coreclr\netstandard2.0\Microsoft.PackageManagement.NuGetProvider.dll
VERBOSE: Acquiring providers for assembly: C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\PackageManagement\1.3.1\coreclr\netstandard2.0\Microsoft.PackageManagement.MetaProvider.PowerShell.dll
VERBOSE: Acquiring providers for assembly: C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\PackageManagement\1.3.1\coreclr\netstandard2.0\Microsoft.PackageManagement.ArchiverProviders.dll
VERBOSE: Acquiring providers for assembly: C:\Users\takatoshi\OneDrive\Documents\PowerShell\Modules\PackageManagement\1.3.1\coreclr\netstandard2.0\Microsoft.PackageManagement.CoreProviders.dll

NuGet.exe is required to continue
This version of PowerShellGet requires minimum version '4.1.0' of NuGet.exe to publish an item to the
NuGet-based repositories. NuGet.exe must be available in
'C:\ProgramData\Microsoft\Windows\PowerShell\PowerShellGet\' or
'C:\Users\takatoshi\AppData\Local\Microsoft\Windows\PowerShell\PowerShellGet\', or under one of the
paths specified in PATH environment variable value. NuGet.exe can be downloaded from
https://aka.ms/psget-nugetexe. For more information, see https://aka.ms/installing-powershellget . Do
you want PowerShellGet to install the latest version of NuGet.exe now?
[Y] Yes  [N] No  [S] Suspend  [?] Help (default is "Y"): y
VERBOSE: Installing NuGet.exe.
VERBOSE: GET https://aka.ms/psget-nugetexe with 0-byte payload
VERBOSE: received 5690456-byte response of content type application/x-msdownload
VERBOSE: Repository details, Name = 'PSGallery', Location = 'https://www.powershellgallery.com/api/v2/'; IsTrusted = 'True'; IsRegistered = 'True'.
VERBOSE: Repository details, Name = 'PSGallery', Location = 'https://www.powershellgallery.com/api/v2/'; IsTrusted = 'True'; IsRegistered = 'True'.
VERBOSE: Publish Location:'https://www.powershellgallery.com/api/v2/package/'.
VERBOSE: Module 'MavenAutoCompletion' was found in 'C:\Users\takatoshi\dev\powershell\MavenAutoCompletion'.
VERBOSE: Repository details, Name = 'PSGallery', Location = 'https://www.powershellgallery.com/api/v2/'; IsTrusted = 'True'; IsRegistered = 'True'.
VERBOSE: Using the provider 'PowerShellGet' for searching packages.
VERBOSE: Using the specified source names : 'PSGallery'.
VERBOSE: Getting the provider object for the PackageManagement Provider 'NuGet'.
VERBOSE: The specified Location is 'https://www.powershellgallery.com/api/v2/items/psscript/' and PackageManagementProvider is 'NuGet'.
VERBOSE: Searching repository 'https://www.powershellgallery.com/api/v2/items/psscript/FindPackagesById()?id='MavenAutoCompletion'' for ''.
VERBOSE: Total package yield:'0' for the specified package 'MavenAutoCompletion'.
VERBOSE: Repository details, Name = 'PSGallery', Location = 'https://www.powershellgallery.com/api/v2/'; IsTrusted = 'True'; IsRegistered = 'True'.
VERBOSE: Using the provider 'PowerShellGet' for searching packages.
VERBOSE: Using the specified source names : 'PSGallery'.
VERBOSE: Getting the provider object for the PackageManagement Provider 'NuGet'.
VERBOSE: The specified Location is 'https://www.powershellgallery.com/api/v2/' and PackageManagementProvider is 'NuGet'.
VERBOSE: Searching repository 'https://www.powershellgallery.com/api/v2/FindPackagesById()?id='MavenAutoCompletion'' for ''.
VERBOSE: Total package yield:'0' for the specified package 'MavenAutoCompletion'.
What if: Performing the operation "Publish-Module" on target "Version '0.0.1' of module 'MavenAutoCompletion'".
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;それらしいエラーも警告も出ないので、実行に移す。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ Publish-Module -Path ".\MavenAutoCompletion" -NugetAPIKey "キーは見せられないよ" -Verbose
VERBOSE: Repository details, Name = 'PSGallery', Location = 'https://www.powershellgallery.com/api/v2/'; IsTrusted = 'True'; IsRegistered = 'True'.
VERBOSE: Repository details, Name = 'PSGallery', Location = 'https://www.powershellgallery.com/api/v2/'; IsTrusted = 'True'; IsRegistered = 'True'.
VERBOSE: Publish Location:'https://www.powershellgallery.com/api/v2/package/'.
VERBOSE: Module 'MavenAutoCompletion' was found in 'C:\Users\takatoshi\dev\powershell\MavenAutoCompletion'.
VERBOSE: Repository details, Name = 'PSGallery', Location = 'https://www.powershellgallery.com/api/v2/'; IsTrusted = 'True'; IsRegistered = 'True'.
VERBOSE: Using the provider 'PowerShellGet' for searching packages.
VERBOSE: Using the specified source names : 'PSGallery'.
VERBOSE: Getting the provider object for the PackageManagement Provider 'NuGet'.
VERBOSE: The specified Location is 'https://www.powershellgallery.com/api/v2/items/psscript/' and PackageManagementProvider is 'NuGet'.
VERBOSE: Searching repository 'https://www.powershellgallery.com/api/v2/items/psscript/FindPackagesById()?id='MavenAutoCompletion'' for ''.
VERBOSE: Total package yield:'0' for the specified package 'MavenAutoCompletion'.
VERBOSE: Repository details, Name = 'PSGallery', Location = 'https://www.powershellgallery.com/api/v2/'; IsTrusted = 'True'; IsRegistered = 'True'.
VERBOSE: Using the provider 'PowerShellGet' for searching packages.
VERBOSE: Using the specified source names : 'PSGallery'.
VERBOSE: Getting the provider object for the PackageManagement Provider 'NuGet'.
VERBOSE: The specified Location is 'https://www.powershellgallery.com/api/v2/' and PackageManagementProvider is 'NuGet'.
VERBOSE: Searching repository 'https://www.powershellgallery.com/api/v2/FindPackagesById()?id='MavenAutoCompletion'' for ''.
VERBOSE: Total package yield:'0' for the specified package 'MavenAutoCompletion'.
VERBOSE: Performing the operation "Publish-Module" on target "Version '0.0.1' of module 'MavenAutoCompletion'".
VERBOSE: Pushing MavenAutoCompletion.0.0.1.nupkg to 'https://www.powershellgallery.com/api/v2/package/'...
  PUT https://www.powershellgallery.com/api/v2/package/
�x��: &amp;lt;licenseUrl&amp;gt; element will be deprecated, please consider switching to specifying the license in
the package. Learn more: https://aka.ms/deprecateLicenseUrl.
  Created https://www.powershellgallery.com/api/v2/package/ 3489ms
Your package was pushed.

VERBOSE: Successfully published module 'MavenAutoCompletion' to the module publish location 'https://www.powershellgallery.com/api/v2/package/'. Please allow few minutes for 'MavenAutoCompletion' to show up in the search results.
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;�x��: &lt;licenseUrl&gt; element will be deprecated, please consider switching to specifying the license in
the package. Learn more: https://aka.ms/deprecateLicenseUrl.&lt;/licenseUrl&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;う、モジュールのマニフェストでdeprecatedな属性があるが...いけたっぽい。この文字化けはemojiかな(Win10 1809ではterminalでemoji化けがあるのは既知)&lt;/p&gt;&lt;h3 id="いけてない"&gt;いけて...ない！&lt;/h3&gt;&lt;p&gt;困ったことにイケてなかった...gitのオブジェクトとかそういうのまで全部publishedなかんじでまじで笑えねえ...とりあえずPowerShell Gallery上でリスト表示しないリクエストを出しておいたが笑えねえ😭&lt;/p&gt;&lt;p&gt;どうもこれはPowerShell Getの既知の問題？みたい...事前調査が足りてなかったぜえ...😭&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/PowerShell/PowerShellGet/issues/191"&gt;Ignore files when using &lt;code&gt;Publish-Module&lt;/code&gt; · Issue #191 · PowerShell/PowerShellGet&lt;/a&gt;&lt;/p&gt;&lt;p&gt;現状できることとしては、別にモジュールと同名のフォルダを作って、その中にpublishしたいファイルをコピーし、&lt;code&gt;Publish-Module&lt;/code&gt;を実行するしかないのではないかなと思う🤔&lt;/p&gt;&lt;p&gt;この際なので↑の取りなしでvr0.1として公開することにする。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ Publish-Module -Path ".\MavenAutoCompletion" -NugetAPIKey "キーは見せられないよ" -Verbose
VERBOSE: Repository details, Name = 'PSGallery', Location = 'https://www.powershellgallery.com/api/v2/'; IsTrusted = 'True'; IsRegistered = 'True'.
VERBOSE: Repository details, Name = 'PSGallery', Location = 'https://www.powershellgallery.com/api/v2/'; IsTrusted = 'True'; IsRegistered = 'True'.
VERBOSE: Publish Location:'https://www.powershellgallery.com/api/v2/package/'.
VERBOSE: Module 'MavenAutoCompletion' was found in 'C:\Users\takatoshi\dev\powershell\MavenAutoCompletion\publish\MavenAutoCompletion'.
VERBOSE: Repository details, Name = 'PSGallery', Location = 'https://www.powershellgallery.com/api/v2/'; IsTrusted = 'True'; IsRegistered = 'True'.
VERBOSE: Using the provider 'PowerShellGet' for searching packages.
VERBOSE: Using the specified source names : 'PSGallery'.
VERBOSE: Getting the provider object for the PackageManagement Provider 'NuGet'.
VERBOSE: The specified Location is 'https://www.powershellgallery.com/api/v2/items/psscript/' and PackageManagementProvider is 'NuGet'.
VERBOSE: Searching repository 'https://www.powershellgallery.com/api/v2/items/psscript/FindPackagesById()?id='MavenAutoCompletion'' for ''.
VERBOSE: Total package yield:'0' for the specified package 'MavenAutoCompletion'.
VERBOSE: Repository details, Name = 'PSGallery', Location = 'https://www.powershellgallery.com/api/v2/'; IsTrusted = 'True'; IsRegistered = 'True'.
VERBOSE: Using the provider 'PowerShellGet' for searching packages.
VERBOSE: Using the specified source names : 'PSGallery'.
VERBOSE: Getting the provider object for the PackageManagement Provider 'NuGet'.
VERBOSE: The specified Location is 'https://www.powershellgallery.com/api/v2/' and PackageManagementProvider is 'NuGet'.
VERBOSE: Searching repository 'https://www.powershellgallery.com/api/v2/FindPackagesById()?id='MavenAutoCompletion'' for ''.
VERBOSE: Total package yield:'1' for the specified package 'MavenAutoCompletion'.
VERBOSE: Performing the operation "Publish-Module" on target "Version '0.1' of module 'MavenAutoCompletion'".
VERBOSE: Pushing MavenAutoCompletion.0.1.0.nupkg to 'https://www.powershellgallery.com/api/v2/package/'...
  PUT https://www.powershellgallery.com/api/v2/package/
�x��: &amp;lt;licenseUrl&amp;gt; element will be deprecated, please consider switching to specifying the license in
the package. Learn more: https://aka.ms/deprecateLicenseUrl.
  Created https://www.powershellgallery.com/api/v2/package/ 4558ms
Your package was pushed.

VERBOSE: Successfully published module 'MavenAutoCompletion' to the module publish location 'https://www.powershellgallery.com/api/v2/package/'. Please allow few minutes for 'MavenAutoCompletion' to show up in the search results.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これによって一応無事にPowerShell Getでの公開はできたし、一旦コレでええか😅&lt;/p&gt;&lt;p&gt;今度非推奨になってる&lt;code&gt;&amp;lt;licenseUrl&amp;gt;&lt;/code&gt;を変えなあかんな。&lt;/p&gt;&lt;p&gt;ファイルコピって公開するためのスクリプトを起こしたので、次回はそれでやろうと思う。&lt;/p&gt;</description><pubDate>Tue, 02 Apr 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-03-31-win-openssh-is-gone</guid><link>https://krymtkts.github.io/posts/2019-03-31-win-openssh-is-gone</link><title>Windows10の更新でOpenSSHが逝った</title><description>&lt;p&gt;今更ながら、Raser Blade Stealth 2018にもWindows10 ver1809の更新が来てたようだった。&lt;/p&gt;&lt;p&gt;何の気なしに更新してみたところ、更新自体はすぐに終わってあっさりいったなと思っていたのだが、terminalを立ち上げると...&lt;/p&gt;&lt;h3 id="tldr"&gt;TL;DR&lt;/h3&gt;&lt;p&gt;Windows10 ver1809のOpenSSHは既知のバグがあるのでOpenSSH Portableを入れ直そう。&lt;/p&gt;&lt;h3 id="まずssh-agentのサービスが無効になってた"&gt;まずSSH Agentのサービスが無効になってた&lt;/h3&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Get-Process : Cannot find a process with the name "ssh-agent". Verify the process name and call the cmdlet again.
At C:\Users\takatoshi\OneDrive\Documents\PowerShell\Microsoft.PowerShell_profile.ps1:40 char:8
+ if (! (Get-Process -Name 'ssh-agent')) {
+        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ CategoryInfo          : ObjectNotFound: (ssh-agent:String) [Get-Process], ProcessCommandException
+ FullyQualifiedErrorId : NoProcessFoundForGivenName,Microsoft.PowerShell.Commands.GetProcessCommand
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;PowerShellのprofileで&lt;code&gt;ssh-agent&lt;/code&gt;のプロセスの存在を確認するようにしてたのだけど、Windowsの更新でサービスの自動実行が無効になってたようなのでこのエラーが...とりあえず今回は手動で自動実行するように変えて終わった。&lt;/p&gt;&lt;p&gt;あとどういうわけかわからないが、PC起動時のサービスの立ち上がりがめちゃくちゃ遅くなった気がする(体感)。PC起動後にすぐterminalを立ち上げると同じエラーがまだ出るから。根治させるにはprofileをいじらないといけないかな🤔&lt;/p&gt;&lt;p&gt;後述の問題に比べれば、こちらは楽しいアクシデント程度のものだ。&lt;/p&gt;&lt;h3 id="win10備え付けのopensshに既知のバグが有るとか云々"&gt;Win10備え付けのOpenSSHに既知のバグが有るとか云々&lt;/h3&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ git remote show origin
warning: agent returned different signature type ssh-rsa (expected rsa-sha2-512)
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;↑この警告が常時出るようになった。むかつく💢&lt;/p&gt;&lt;p&gt;直さな...😭と思ってググってみると...&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/PowerShell/Win32-OpenSSH/issues/1263"&gt;ssh-agent: agent returned different signature type · Issue #1263 · PowerShell/Win32-OpenSSH&lt;/a&gt;&lt;/p&gt;&lt;p&gt;これの様子🤔&lt;/p&gt;&lt;p&gt;更に調べると、これマジIssueやなと思わざるを得ない... -&amp;gt; &lt;a href="https://github.com/PowerShell/openssh-portable/pull/366"&gt;Fixes to ssh-agent issues by manojampalam · Pull Request #366 · PowerShell/openssh-portable&lt;/a&gt;&lt;/p&gt;&lt;p&gt;つまりはバグが直ったOpenSSH-Portbale入れないと解決しないってんでFAかな...キレそう❤&lt;/p&gt;&lt;p&gt;&lt;a href="https://blog.frankfu.com.au/2019/03/21/moving-from-windows-1809s-openssh-to-openssh-portable/"&gt;Moving from Windows 1809's OpenSSH to OpenSSH Portable&lt;/a&gt;&lt;/p&gt;&lt;p&gt;幸いにも同じ障害を解消したブログがあったので助かる🙏&lt;/p&gt;&lt;h4 id="処置する"&gt;処置する&lt;/h4&gt;&lt;p&gt;&lt;a href="https://blog.frankfu.com.au/2019/03/21/moving-from-windows-1809s-openssh-to-openssh-portable/"&gt;Moving from Windows 1809's OpenSSH to OpenSSH Portable&lt;/a&gt;&lt;/p&gt;&lt;p&gt;この記事にそのまま従えばいける。&lt;/p&gt;&lt;p&gt;Windowsに関わる操作はPowerShell Coreではできないので、PowerShell CoreとWindowsPowerShellを使い分けた(WindowsPowerShellで全部やればいいものを...😅)&lt;/p&gt;&lt;p&gt;Coreでできる範囲から始める。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ Get-Service -Name ssh-agent | Stop-Service
$ sc.exe delete ssh-agent
[SC] DeleteService SUCCESS
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;WindowsPowerShellでしかできない範囲&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ Remove-WindowsCapability -Online -Name "OpenSSH.Client~~~~0.0.1.0"


Path          :
Online        : True
RestartNeeded : False



$  Remove-WindowsCapability -Online -Name "OpenSSH.Server~~~~0.0.1.0"


Path          :
Online        : True
RestartNeeded : False
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Coreで続きをやる&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ choco install openssh --package-parameters="/SSHAgentFeature"
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;Chocolatey v0.10.13
2 validations performed. 1 success(es), 1 warning(s), and 0 error(s).

Validation Warnings:
 - A pending system reboot request has been detected, however, this is
   being ignored due to the current Chocolatey configuration.  If you
   want to halt when this occurs, then either set the global feature
   using:
     choco feature enable -name=exitOnRebootDetected
   or pass the option --exit-when-reboot-detected.

Installing the following packages:
openssh
By installing you accept licenses for the packages.
Progress: Downloading openssh 7.9.0.1... 100%

openssh v7.9.0.1 [Approved]
openssh package files install completed. Performing other installation steps.
The package openssh wants to run 'chocolateyinstall.ps1'.
Note: If you don't run this script, the installation will fail.
Note: To confirm automatically next time, use '-y' or consider:
choco feature enable -n allowGlobalConfirmation
Do you want to run the script?([Y]es/[N]o/[P]rint): y

Running on: Windows 10 Home, (Core)
Windows Version: 10.0.17763

************************************************************************************
************************************************************************************
This package is a Universal Installer and can ALSO install Win32-OpenSSH on
Nano, Server Core, Docker Containers and more WITHOUT using Chocolatey.

See the following for more details:
https://github.com/DarwinJS/ChocoPackages/blob/master/openssh/readme.md
************************************************************************************
************************************************************************************

/SSHAgentFeature was used, including SSH Agent Service.
Extracting C:\ProgramData\chocolatey\lib\openssh\tools\OpenSSH-Win64.zip to C:\Users\takatoshi\AppData\Local\Temp\chocolatey\OpenSSHTemp...
C:\Users\takatoshi\AppData\Local\Temp\chocolatey\OpenSSHTemp
Source files are internal to the package, checksums are not required nor checked.
C:\Program Files\OpenSSH-Win64
C:\Program Files\OpenSSH-Win64\FixHostFilePermissions.ps1
C:\Program Files\OpenSSH-Win64\FixUserFilePermissions.ps1
C:\Program Files\OpenSSH-Win64\install-sshd.ps1
C:\Program Files\OpenSSH-Win64\libcrypto.dll
C:\Program Files\OpenSSH-Win64\openssh-events.man
C:\Program Files\OpenSSH-Win64\OpenSSHUtils.psd1
C:\Program Files\OpenSSH-Win64\OpenSSHUtils.psm1
C:\Program Files\OpenSSH-Win64\scp.exe
C:\Program Files\OpenSSH-Win64\sftp-server.exe
C:\Program Files\OpenSSH-Win64\sftp.exe
C:\Program Files\OpenSSH-Win64\ssh-add.exe
C:\Program Files\OpenSSH-Win64\ssh-agent.exe
C:\Program Files\OpenSSH-Win64\ssh-keygen.exe
C:\Program Files\OpenSSH-Win64\ssh-keyscan.exe
C:\Program Files\OpenSSH-Win64\ssh-shellhost.exe
C:\Program Files\OpenSSH-Win64\ssh.exe
C:\Program Files\OpenSSH-Win64\sshd.exe
C:\Program Files\OpenSSH-Win64\sshd_config_default
C:\Program Files\OpenSSH-Win64\uninstall-sshd.ps1
C:\Program Files\OpenSSH-Win64\Set-SSHDefaultShell.ps1
PATH environment variable does not have C:\Program Files\OpenSSH-Win64 in it. Adding...
Updating machine environment variable TERM from "" to ""
[SC] SetServiceObjectSecurity SUCCESS
Starting SSH-Agent...

NEW VERSIONS OF SSH EXES:

FileName                                         FileVersion
--------                                         -----------
C:\Program Files\OpenSSH-Win64\scp.exe           7.9.0.0
C:\Program Files\OpenSSH-Win64\sftp-server.exe   7.9.0.0
C:\Program Files\OpenSSH-Win64\sftp.exe          7.9.0.0
C:\Program Files\OpenSSH-Win64\ssh-add.exe       7.9.0.0
C:\Program Files\OpenSSH-Win64\ssh-agent.exe     7.9.0.0
C:\Program Files\OpenSSH-Win64\ssh-keygen.exe    7.9.0.0
C:\Program Files\OpenSSH-Win64\ssh-keyscan.exe   7.9.0.0
C:\Program Files\OpenSSH-Win64\ssh-shellhost.exe 7.9.0.0
C:\Program Files\OpenSSH-Win64\ssh.exe           7.9.0.0
C:\Program Files\OpenSSH-Win64\sshd.exe          7.9.0.0




WARNING: You must start a new prompt, or use the command 'refreshenv' (provided by your chocolatey install) to re-read the environment for the tools to be available in this shell session.
Environment Vars (like PATH) have changed. Close/reopen your shell to
 see the changes (or in powershell/cmd.exe just type `refreshenv`).
 The install of openssh was successful.
  Software installed to 'C:\Users\takatoshi\AppData\Local\Temp\chocolatey\OpenSSHTemp'

Chocolatey installed 1/1 packages.
 See the log for details (C:\ProgramData\chocolatey\logs\chocolatey.log).
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ Get-Service ssh-agent

Status   Name               DisplayName
------   ----               -----------
Running  ssh-agent          ssh-agent
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ git config --global core.sshCommand "'C:\Program Files\OpenSSH-Win64\ssh.exe'"
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;環境変数PATHを反映させてから、terminalでwariningが消えたのを確認&lt;/p&gt;&lt;h3 id="振り返り"&gt;振り返り&lt;/h3&gt;&lt;p&gt;Windowsのでかい更新の際はちゃんと注意して取り組まなあかんな🤔(めんどい)&lt;/p&gt;&lt;p&gt;あとこれまた既知の別件なのだけど、ver1809だとterminalのemojiの表示が中点とかに化けるので、これもなんとかしたいわ...&lt;/p&gt;&lt;p&gt;Cmder/ConEmuじゃなくてWindows自体の問題みたい。&lt;/p&gt;</description><pubDate>Sun, 31 Mar 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-03-24_coverage-of-qunt-puppeteer</guid><link>https://krymtkts.github.io/posts/2019-03-24_coverage-of-qunt-puppeteer</link><title>QUnit で CI したい その 2</title><description>&lt;p&gt;&lt;a href="./2019-03-21_want-to-run-qunit-in-cli.md"&gt;前回&lt;/a&gt;、QUnit のユニットテストを puppeteer で CLI 実行できるようにした&lt;/p&gt;&lt;p&gt;今回は code coverage を計測できるようにする。&lt;/p&gt;&lt;h3 id="前回のおさらい"&gt;前回のおさらい&lt;/h3&gt;&lt;p&gt;puppeteer で JavaScript のカバレッジを計測することができる(&lt;a href="https://developers.google.com/web/updates/2017/04/devtools-release-notes"&gt;What's New In DevTools (Chrome 59)  |  Web  |  Google Developers&lt;/a&gt;)のだが、現状利用している&lt;a href="https://www.npmjs.com/package/node-qunit-puppeteer"&gt;node-qunit-puppeteer&lt;/a&gt;だと、puppeteer の部分をモジュール外部から触れないので利用できなくて困った、ということろまで書いた。&lt;/p&gt;&lt;p&gt;理想ではユニットテストの実施と同時にカバレッジを計測したいところなのだが、一旦は簡単のために別々に、つまりユニットテストの実行後さらにカバレッジ取得のためにユニットテスを再実行する、というかたちで楽しようと考えた。ユニットテストの実行が軽いうちは 2 度実行したところで大した負荷にならないというのもあり。&lt;/p&gt;&lt;h3 id="やったこと"&gt;やったこと&lt;/h3&gt;&lt;p&gt;これ ↓&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/istanbuljs/puppeteer-to-istanbul"&gt;istanbuljs/puppeteer-to-istanbul: given coverage information output by puppeteer's API output a format consumable by Istanbul reports&lt;/a&gt;&lt;/p&gt;&lt;p&gt;puppeteer で計測したカバレッジを istanbul(nyc)で利用できる形に書き出すモジュールを使う。&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/qunit-trial/blob/master/test/run.js"&gt;すでにある node-qunit-puppeteer のテストランナー&lt;/a&gt;と一緒には使えないので、カバレッジ計測のためのスクリプトも新たに書く(無駄)。&lt;/p&gt;&lt;pre&gt;&lt;code class="js"&gt;const pti = require("puppeteer-to-istanbul");
const puppeteer = require("puppeteer");
const path = require("path");

(async () =&amp;gt; {
  try {
    const browser = await puppeteer.launch();
    const page = await browser.newPage();

    await page.coverage.startJSCoverage();
    await page.goto(`file://${path.join(__dirname, "/index.html")}`);
    const jsCoverage = await page.coverage.stopJSCoverage();

    pti.write(jsCoverage);
    await browser.close();
  } catch (error) {
    console.error(error);
  }
})();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これもほぼサンプルママで使えた。読み込ませるページのパスだけ工夫が必要ってだけ。&lt;/p&gt;&lt;p&gt;あとはカバレッジ計測に成功したら nyc のレポート作成を実行するだけでおｋ。これを npm のタスクにする。&lt;/p&gt;&lt;pre&gt;&lt;code class="sh"&gt;node test/coverage.js &amp;amp;&amp;amp; nyc report --reporter=html
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これでページを開いたときに読み込まれる JS のカバレッジを計測できた。ただしこのままだと、QUnit やユニットテスト自体のカバレッジも含まれてしまうので、仕事の CI で使う場合なんかには特定のファイルのカバレッジだけを見るか、あるいは除外設定があればいいのだけど。&lt;/p&gt;&lt;h3 id="まとめ"&gt;まとめ&lt;/h3&gt;&lt;p&gt;また今回試した内容は以下の repo に反映してある&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/qunit-trial"&gt;krymtkts/qunit-trial: sandbox to enhance legacy QUnit test.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;2 回ユニットテストを実行していて無駄感があるので、node-qunit-puppeteer に手を入れることも検討していいかも 🤔&lt;/p&gt;&lt;p&gt;続く&lt;/p&gt;</description><pubDate>Sun, 24 Mar 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-03-21_want-to-run-qunit-in-cli</guid><link>https://krymtkts.github.io/posts/2019-03-21_want-to-run-qunit-in-cli</link><title>QUnit で CI したい その 1</title><description>&lt;p&gt;2 月に転職した。&lt;/p&gt;&lt;p&gt;へーしゃでの初めての仕事はフロントエンド、と言ってもトラッキングに関わる部分である。&lt;/p&gt;&lt;p&gt;生の ES5 で書かれてて&lt;a href="https://github.com/google/closure-compiler"&gt;Google Closure Compiler&lt;/a&gt;で minify されてるようなのだけど、困ったことにユニットテストがない様子？
どこそこのチームで作ってたことがあったらしいという情報は得たので、それを CI に組み込めたらいいかなと思っていた。&lt;/p&gt;&lt;p&gt;蓋を開けてみると、2 年間ほどメンテされていない死んだユニットテストで、最新のコードベースに対するテストでなかった(テストコードと同ディレクトリにテスト対象のコードがコピられてて)🤔&lt;/p&gt;&lt;p&gt;CI に組み込まれないテストは陳腐化すると云うが、まさかそれを身をもって実感することになろうとは思わなんだ。&lt;/p&gt;&lt;p&gt;&lt;del&gt;仕方ないので&lt;/del&gt;既存の資産を活かすためにも、テスティングフレームワークなど既存のものを利用して少なくとも CI に組み込めるところまでは持っていこうと考えた。CI に組み込まれればビルド失敗の通知を恐れてみんなユニットテストを書くのをサボらなくなる。&lt;/p&gt;&lt;p&gt;というわけで、許可を取り付けた上で仕事の合間を縫ってユニットテストの整備を行うことにした。&lt;/p&gt;&lt;h3 id="現状把握と展望"&gt;現状把握と展望&lt;/h3&gt;&lt;p&gt;ユニットテストは&lt;a href="https://qunitjs.com/"&gt;QUnit&lt;/a&gt;で書かれていて、モッキングフレームワークには&lt;a href="https://sinonjs.org/"&gt;Sinon.JS&lt;/a&gt;が使われていた。&lt;/p&gt;&lt;p&gt;linter は&lt;a href="https://eslint.org/"&gt;ESLint - Pluggable JavaScript linter&lt;/a&gt;を用意してあるようなのだけどどうも長らく利用されてなかったようで、試しに実行すると 41 件の autofix 可能なエラーが...😅&lt;/p&gt;&lt;p&gt;ブラウザで&lt;code&gt;index.html&lt;/code&gt;を開くことでテストが実行されるタイプのやつで、CLI での実行は用意されてなかった。
プロダクトコードが&lt;code&gt;window&lt;/code&gt;オブジェクトに依存してることもあって、QUnit のテストをヘッドレスブラウザで実行するのが良さげかな。&lt;/p&gt;&lt;p&gt;ここにカバレッジ計測も追加して、最終的にはプルリクをトリガーにした自動テストが CI に組み込まれるのが良さげかなと思う。&lt;/p&gt;&lt;h3 id="やったことやらなかったこと"&gt;やったこと＆やらなかったこと&lt;/h3&gt;&lt;p&gt;とりあえずカバレッジは置いといて今ある QUnit の CLI 実行を優先した。&lt;/p&gt;&lt;p&gt;node でのカバレッジ計測に関しては知らないことが多かったので軽く下調べだけした。
istabul というやつが node 界隈で強かったみたいだが、こいつは 2 年ほどメンテされてなくて、後続の&lt;a href="https://www.npmjs.com/package/nyc"&gt;nyc - npm&lt;/a&gt;と言うやつがみつかる 👀
puppeteer もそれ単体でカバレッジが測れるようす ↓&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://www.philkrie.me/2018/07/04/extracting-coverage.html"&gt;Using Puppeteer to Extract Code Coverage Data from Chrome Dev Tools&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/istanbuljs/puppeteer-to-istanbul"&gt;istanbuljs/puppeteer-to-istanbul: given coverage information output by puppeteer's API output a format consumable by Istanbul reports&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 id="やったこと"&gt;やったこと&lt;/h4&gt;&lt;p&gt;まず元々ある QUnit もそのまま使えないとブラウザで見つつの開発の利便性も下がっちゃうので、そこは担保したかった。
(&lt;code&gt;window&lt;/code&gt;オブジェクトがないので CommonJS は死ぬ)&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.npmjs.com/package/qunit-puppeteer"&gt;qunit-puppeteer - npm&lt;/a&gt;は簡単にテスト実行できて楽だったのだけど、テストの url を絶対パスで指定しないといけず＆自分で URL をこねくり回せなくて却下。&lt;/p&gt;&lt;p&gt;なのでそのへん柔軟な&lt;a href="https://www.npmjs.com/package/node-qunit-puppeteer"&gt;node-qunit-puppeteer - npm&lt;/a&gt;しか選択肢が残らなかったわけだ。&lt;/p&gt;&lt;p&gt;とりま&lt;code&gt;eslint&lt;/code&gt;だけあるからソイツはそのままに、QUnit を headless browser 実行するための module だけ足す。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;npm install --save-dev node-qunit-puppeteer
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;package.json&lt;/code&gt;は以下のような感じにした&lt;/p&gt;&lt;pre&gt;&lt;code class="json"&gt;  "scripts": {
    "lint": "eslint --fix ./",
    "test": "node test/run.js"
  },
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;lint&lt;/code&gt;はメンテされてなかった関係で 40 件くらいの error があるけど、最終的には実行できるようになる(ハズな)ので用意しておく。&lt;/p&gt;&lt;p&gt;&lt;code&gt;test/run.js&lt;/code&gt;は以下の通りで、&lt;a href="https://github.com/ameshkov/node-qunit-puppeteer"&gt;ameshkov/node-qunit-puppeteer: A simple node module for running qunit tests with headless Chromium&lt;/a&gt;の Example とほぼ同じで行ける便利さ。しびれる。&lt;/p&gt;&lt;pre&gt;&lt;code class="js"&gt;#! /usr/bin/env node
// almost the same as the sample code :-p
// https://github.com/ameshkov/node-qunit-puppeteer

const path = require("path");
const { runQunitPuppeteer, printOutput } = require("node-qunit-puppeteer");

const qunitArgs = {
  targetUrl: `file://${path.join(__dirname, "/index.html")}`,
  redirectConsole: true,
};

runQunitPuppeteer(qunitArgs)
  .then((result) =&amp;gt; {
    // Print the test result to the output
    printOutput(result, console);
    if (result.stats.failed &amp;gt; 0) {
      // Handle the failed test run
      // currently notghing to do.
    }
  })
  .catch((ex) =&amp;gt; {
    console.error(ex);
  });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;実行結果は以下のような感じで出る。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$ npm run test

&amp;gt; qunit@1.0.0 test C:\Users\takatoshi\dev\javascript\qunit
&amp;gt; node test/run.js

Module: hello module
  hello test
    Status: success
    Passed assertions: 2 of 2
    Elapsed: 1ms

Test run result: success
Total tests: 1
  Assertions: 2
  Passed assertions: 2
  Failed assertions: 0
  Elapsed: 8ms
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;と、ここまで書いた内容を会社のコードに組み込んだのだけど、会社で作ったものは外に出せないので模倣したゴミプロジェクトを作った ↓&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/qunit-trial"&gt;krymtkts/qunit-trial: sandbox to enhance legacy QUnit test.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;今後いじくり回すときの砂場としても使おうかな。&lt;/p&gt;&lt;h4 id="あとやりたいこと"&gt;あとやりたいこと&lt;/h4&gt;&lt;p&gt;ユニットテストだけあってカバレッジ計測がないのはちょっとアレなので早々に追加したい所存 🤔&lt;/p&gt;&lt;p&gt;そもそもユニットテスト書くにしてもどの経路通ったとかわからないのでテスト品質を保証しづらく、コード網羅率 Level C1 を 100%にしたいマンなのもありカバレッジ必須。&lt;/p&gt;&lt;p&gt;でも事前に調べてた nyc や puppeteer での方法だと、現状の node-qunit-puppeteer を使ったテストのカバレッジ計測できなさそう...&lt;/p&gt;&lt;p&gt;もう少し調べる必要がありそう 😳&lt;/p&gt;&lt;p&gt;続く&lt;/p&gt;</description><pubDate>Thu, 21 Mar 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-02-24_lein-ring-server-error</guid><link>https://krymtkts.github.io/posts/2019-02-24_lein-ring-server-error</link><title>lein ringでエラーが発生した</title><description>&lt;p&gt;&lt;a href="./2019-02-20-instead-of-ping.md"&gt;前回&lt;/a&gt;以下のコメントを残した&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;この記事をしたためておるときに&lt;code&gt;lein ring server&lt;/code&gt;でエラーが出るようになってたのを解消したので、メモがてら次回に記す。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;どのような状況だったかを以下に記すと&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;lein ring server
clojure.lang.Compiler$CompilerException: Syntax error macroexpanding clojure.core/fn at (clojure/core/unify.clj:83:18).
#:clojure.error{:phase :macro-syntax-check, :line 83, :column 18, :source "clojure/core/unify.clj", :symbol clojure.core/fn}
 at clojure.lang.Compiler.checkSpecs (Compiler.java:6971)
    clojure.lang.Compiler.macroexpand1 (Compiler.java:6987)
    clojure.lang.Compiler.analyzeSeq (Compiler.java:7092)
    clojure.lang.Compiler.analyze (Compiler.java:6789)
    clojure.lang.Compiler.analyzeSeq (Compiler.java:7094)
    clojure.lang.Compiler.analyze (Compiler.java:6789)
    clojure.lang.Compiler.access$300 (Compiler.java:38)
    clojure.lang.Compiler$DefExpr$Parser.parse (Compiler.java:596)
    clojure.lang.Compiler.analyzeSeq (Compiler.java:7106)
    clojure.lang.Compiler.analyze (Compiler.java:6789)
    clojure.lang.Compiler.analyze (Compiler.java:6745)
    clojure.lang.Compiler.eval (Compiler.java:7180)
    clojure.lang.Compiler.load (Compiler.java:7635)
    clojure.lang.RT.loadResourceScript (RT.java:381)
    clojure.lang.RT.loadResourceScript (RT.java:372)
    clojure.lang.RT.load (RT.java:463)
    clojure.lang.RT.load (RT.java:428)
    clojure.core$load$fn__6824.invoke (core.clj:6126)
    clojure.core$load.invokeStatic (core.clj:6125)
    clojure.core$load.doInvoke (core.clj:6109)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    clojure.core$load_one.invokeStatic (core.clj:5908)
    clojure.core$load_one.invoke (core.clj:5903)
    clojure.core$load_lib$fn__6765.invoke (core.clj:5948)
    clojure.core$load_lib.invokeStatic (core.clj:5947)
    clojure.core$load_lib.doInvoke (core.clj:5928)
    clojure.lang.RestFn.applyTo (RestFn.java:142)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$load_libs.invokeStatic (core.clj:5985)
    clojure.core$load_libs.doInvoke (core.clj:5969)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$require.invokeStatic (core.clj:6007)
    clojure.core$require.doInvoke (core.clj:6007)
    clojure.lang.RestFn.invoke (RestFn.java:421)
    clojure.core.contracts.impl.transformers$eval690$loading__6706__auto____691.invoke (transformers.clj:1)
    clojure.core.contracts.impl.transformers$eval690.invokeStatic (transformers.clj:1)
    clojure.core.contracts.impl.transformers$eval690.invoke (transformers.clj:1)
    clojure.lang.Compiler.eval (Compiler.java:7176)
    clojure.lang.Compiler.eval (Compiler.java:7165)
    clojure.lang.Compiler.load (Compiler.java:7635)
    clojure.lang.RT.loadResourceScript (RT.java:381)
    clojure.lang.RT.loadResourceScript (RT.java:372)
    clojure.lang.RT.load (RT.java:463)
    clojure.lang.RT.load (RT.java:428)
    clojure.core$load$fn__6824.invoke (core.clj:6126)
    clojure.core$load.invokeStatic (core.clj:6125)
    clojure.core$load.doInvoke (core.clj:6109)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    clojure.core$load_one.invokeStatic (core.clj:5908)
    clojure.core$load_one.invoke (core.clj:5903)
    clojure.core$load_lib$fn__6765.invoke (core.clj:5948)
    clojure.core$load_lib.invokeStatic (core.clj:5947)
    clojure.core$load_lib.doInvoke (core.clj:5928)
    clojure.lang.RestFn.applyTo (RestFn.java:142)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$load_libs.invokeStatic (core.clj:5985)
    clojure.core$load_libs.doInvoke (core.clj:5969)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$require.invokeStatic (core.clj:6007)
    clojure.core$require.doInvoke (core.clj:6007)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    leinjacker.defconstrainedfn$eval684$loading__6706__auto____685.invoke (defconstrainedfn.clj:1)
    leinjacker.defconstrainedfn$eval684.invokeStatic (defconstrainedfn.clj:1)
    leinjacker.defconstrainedfn$eval684.invoke (defconstrainedfn.clj:1)
    clojure.lang.Compiler.eval (Compiler.java:7176)
    clojure.lang.Compiler.eval (Compiler.java:7165)
    clojure.lang.Compiler.load (Compiler.java:7635)
    clojure.lang.RT.loadResourceScript (RT.java:381)
    clojure.lang.RT.loadResourceScript (RT.java:372)
    clojure.lang.RT.load (RT.java:463)
    clojure.lang.RT.load (RT.java:428)
    clojure.core$load$fn__6824.invoke (core.clj:6126)
    clojure.core$load.invokeStatic (core.clj:6125)
    clojure.core$load.doInvoke (core.clj:6109)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    clojure.core$load_one.invokeStatic (core.clj:5908)
    clojure.core$load_one.invoke (core.clj:5903)
    clojure.core$load_lib$fn__6765.invoke (core.clj:5948)
    clojure.core$load_lib.invokeStatic (core.clj:5947)
    clojure.core$load_lib.doInvoke (core.clj:5928)
    clojure.lang.RestFn.applyTo (RestFn.java:142)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$load_libs.invokeStatic (core.clj:5985)
    clojure.core$load_libs.doInvoke (core.clj:5969)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.core$apply.invokeStatic (core.clj:669)
    clojure.core$use.invokeStatic (core.clj:6093)
    clojure.core$use.doInvoke (core.clj:6093)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    leinjacker.deps$eval676$loading__6706__auto____677.invoke (deps.clj:1)
    leinjacker.deps$eval676.invokeStatic (deps.clj:1)
    leinjacker.deps$eval676.invoke (deps.clj:1)
    clojure.lang.Compiler.eval (Compiler.java:7176)
    clojure.lang.Compiler.eval (Compiler.java:7165)
    clojure.lang.Compiler.load (Compiler.java:7635)
    clojure.lang.RT.loadResourceScript (RT.java:381)
    clojure.lang.RT.loadResourceScript (RT.java:372)
    clojure.lang.RT.load (RT.java:463)
    clojure.lang.RT.load (RT.java:428)
    clojure.core$load$fn__6824.invoke (core.clj:6126)
    clojure.core$load.invokeStatic (core.clj:6125)
    clojure.core$load.doInvoke (core.clj:6109)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    clojure.core$load_one.invokeStatic (core.clj:5908)
    clojure.core$load_one.invoke (core.clj:5903)
    clojure.core$load_lib$fn__6765.invoke (core.clj:5948)
    clojure.core$load_lib.invokeStatic (core.clj:5947)
    clojure.core$load_lib.doInvoke (core.clj:5928)
    clojure.lang.RestFn.applyTo (RestFn.java:142)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$load_libs.invokeStatic (core.clj:5985)
    clojure.core$load_libs.doInvoke (core.clj:5969)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$require.invokeStatic (core.clj:6007)
    clojure.core$require.doInvoke (core.clj:6007)
    clojure.lang.RestFn.invoke (RestFn.java:436)
    leiningen.ring.server$eval668$loading__6706__auto____669.invoke (server.clj:1)
    leiningen.ring.server$eval668.invokeStatic (server.clj:1)
    leiningen.ring.server$eval668.invoke (server.clj:1)
    clojure.lang.Compiler.eval (Compiler.java:7176)
    clojure.lang.Compiler.eval (Compiler.java:7165)
    clojure.lang.Compiler.load (Compiler.java:7635)
    clojure.lang.RT.loadResourceScript (RT.java:381)
    clojure.lang.RT.loadResourceScript (RT.java:372)
    clojure.lang.RT.load (RT.java:463)
    clojure.lang.RT.load (RT.java:428)
    clojure.core$load$fn__6824.invoke (core.clj:6126)
    clojure.core$load.invokeStatic (core.clj:6125)
    clojure.core$load.doInvoke (core.clj:6109)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    clojure.core$load_one.invokeStatic (core.clj:5908)
    clojure.core$load_one.invoke (core.clj:5903)
    clojure.core$load_lib$fn__6765.invoke (core.clj:5948)
    clojure.core$load_lib.invokeStatic (core.clj:5947)
    clojure.core$load_lib.doInvoke (core.clj:5928)
    clojure.lang.RestFn.applyTo (RestFn.java:142)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$load_libs.invokeStatic (core.clj:5985)
    clojure.core$load_libs.doInvoke (core.clj:5969)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.core$apply.invokeStatic (core.clj:669)
    clojure.core$use.invokeStatic (core.clj:6093)
    clojure.core$use.doInvoke (core.clj:6093)
    clojure.lang.RestFn.invoke (RestFn.java:551)
    leiningen.ring$eval662$loading__6706__auto____663.invoke (ring.clj:1)
    leiningen.ring$eval662.invokeStatic (ring.clj:1)
    leiningen.ring$eval662.invoke (ring.clj:1)
    clojure.lang.Compiler.eval (Compiler.java:7176)
    clojure.lang.Compiler.eval (Compiler.java:7165)
    clojure.lang.Compiler.load (Compiler.java:7635)
    clojure.lang.RT.loadResourceScript (RT.java:381)
    clojure.lang.RT.loadResourceScript (RT.java:372)
    clojure.lang.RT.load (RT.java:463)
    clojure.lang.RT.load (RT.java:428)
    clojure.core$load$fn__6824.invoke (core.clj:6126)
    clojure.core$load.invokeStatic (core.clj:6125)
    clojure.core$load.doInvoke (core.clj:6109)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    clojure.core$load_one.invokeStatic (core.clj:5908)
    clojure.core$load_one.invoke (core.clj:5903)
    clojure.core$load_lib$fn__6765.invoke (core.clj:5948)
    clojure.core$load_lib.invokeStatic (core.clj:5947)
    clojure.core$load_lib.doInvoke (core.clj:5928)
    clojure.lang.RestFn.applyTo (RestFn.java:142)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$load_libs.invokeStatic (core.clj:5985)
    clojure.core$load_libs.doInvoke (core.clj:5969)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$require.invokeStatic (core.clj:6007)
    clojure.core$require.doInvoke (core.clj:6007)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    leiningen.core.utils$require_resolve.invokeStatic (utils.clj:102)
    leiningen.core.utils$require_resolve.invoke (utils.clj:95)
    leiningen.core.utils$require_resolve.invokeStatic (utils.clj:105)
    leiningen.core.utils$require_resolve.invoke (utils.clj:95)
    leiningen.core.main$lookup_task_var.invokeStatic (main.clj:69)
    leiningen.core.main$lookup_task_var.invoke (main.clj:65)
    leiningen.core.main$pass_through_help_QMARK_.invokeStatic (main.clj:79)
    leiningen.core.main$pass_through_help_QMARK_.invoke (main.clj:73)
    leiningen.core.main$task_args.invokeStatic (main.clj:82)
    leiningen.core.main$task_args.invoke (main.clj:81)
    leiningen.core.main$resolve_and_apply.invokeStatic (main.clj:339)
    leiningen.core.main$resolve_and_apply.invoke (main.clj:336)
    leiningen.core.main$_main$fn__6771.invoke (main.clj:449)
    leiningen.core.main$_main.invokeStatic (main.clj:439)
    leiningen.core.main$_main.doInvoke (main.clj:436)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.lang.Var.applyTo (Var.java:705)
    clojure.core$apply.invokeStatic (core.clj:665)
    clojure.main$main_opt.invokeStatic (main.clj:491)
    clojure.main$main_opt.invoke (main.clj:487)
    clojure.main$main.invokeStatic (main.clj:598)
    clojure.main$main.doInvoke (main.clj:561)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.lang.Var.applyTo (Var.java:705)
    clojure.main.main (main.java:37)
Caused by: clojure.lang.ExceptionInfo: Call to clojure.core/fn did not conform to spec.
#:clojure.spec.alpha{:problems ({:path [:fn-tail :arity-1 :params], :pred clojure.core/vector?, :val clojure.core.unify/var-unify, :via [:clojure.core.specs.alpha/params+body :clojure.core.specs.alpha/param-list :clojure.core.specs.alpha/param-list], :in [0]} {:path [:fn-tail :arity-n], :pred (clojure.core/fn [%] (clojure.core/or (clojure.core/nil? %) (clojure.core/sequential? %))), :val clojure.core.unify/var-unify, :via [:clojure.core.specs.alpha/params+body :clojure.core.specs.alpha/params+body], :in [0]}),
:spec #object[clojure.spec.alpha$regex_spec_impl$reify__2509 0x4f379769 "clojure.spec.alpha$regex_spec_impl$reify__2509@4f379769"], :value (clojure.core.unify/var-unify [G__800 G__801 G__802 G__803] (clojure.core/if-let [vb__793__auto__ (G__803 G__801)] (clojure.core.unify/garner-unifiers G__800 vb__793__auto__ G__802 G__803) (clojure.core/if-let [vexpr__794__auto__ (clojure.core/and (G__800 G__802) (G__803 G__802))] (clojure.core.unify/garner-unifiers G__800 G__801 vexpr__794__auto__ G__803) (if (clojure.core.unify/occurs? G__800 G__801 G__802 G__803) (throw (java.lang.IllegalStateException. (clojure.core/str "Cycle found in the path " G__802))) (clojure.core.unify/bind-phase G__803 G__801 G__802))))), :args (clojure.core.unify/var-unify [G__800 G__801 G__802 G__803] (clojure.core/if-let [vb__793__auto__ (G__803 G__801)] (clojure.core.unify/garner-unifiers G__800 vb__793__auto__ G__802 G__803) (clojure.core/if-let [vexpr__794__auto__ (clojure.core/and (G__800 G__802) (G__803 G__802))] (clojure.core.unify/garner-unifiers G__800 G__801 vexpr__794__auto__ G__803) (if (clojure.core.unify/occurs? G__800 G__801 G__802 G__803) (throw (java.lang.IllegalStateException. (clojure.core/str "Cycle found in the path " G__802))) (clojure.core.unify/bind-phase G__803 G__801 G__802)))))}
 at clojure.spec.alpha$macroexpand_check.invokeStatic (alpha.clj:705)
    clojure.spec.alpha$macroexpand_check.invoke (alpha.clj:697)
    clojure.lang.AFn.applyToHelper (AFn.java:156)
    clojure.lang.AFn.applyTo (AFn.java:144)
    clojure.lang.Var.applyTo (Var.java:705)
    clojure.lang.Compiler.checkSpecs (Compiler.java:6969)
    clojure.lang.Compiler.macroexpand1 (Compiler.java:6987)
    clojure.lang.Compiler.analyzeSeq (Compiler.java:7092)
    clojure.lang.Compiler.analyze (Compiler.java:6789)
    clojure.lang.Compiler.analyzeSeq (Compiler.java:7094)
    clojure.lang.Compiler.analyze (Compiler.java:6789)
    clojure.lang.Compiler.access$300 (Compiler.java:38)
    clojure.lang.Compiler$DefExpr$Parser.parse (Compiler.java:596)
    clojure.lang.Compiler.analyzeSeq (Compiler.java:7106)
    clojure.lang.Compiler.analyze (Compiler.java:6789)
    clojure.lang.Compiler.analyze (Compiler.java:6745)
    clojure.lang.Compiler.eval (Compiler.java:7180)
    clojure.lang.Compiler.load (Compiler.java:7635)
    clojure.lang.RT.loadResourceScript (RT.java:381)
    clojure.lang.RT.loadResourceScript (RT.java:372)
    clojure.lang.RT.load (RT.java:463)
    clojure.lang.RT.load (RT.java:428)
    clojure.core$load$fn__6824.invoke (core.clj:6126)
    clojure.core$load.invokeStatic (core.clj:6125)
    clojure.core$load.doInvoke (core.clj:6109)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    clojure.core$load_one.invokeStatic (core.clj:5908)
    clojure.core$load_one.invoke (core.clj:5903)
    clojure.core$load_lib$fn__6765.invoke (core.clj:5948)
    clojure.core$load_lib.invokeStatic (core.clj:5947)
    clojure.core$load_lib.doInvoke (core.clj:5928)
    clojure.lang.RestFn.applyTo (RestFn.java:142)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$load_libs.invokeStatic (core.clj:5985)
    clojure.core$load_libs.doInvoke (core.clj:5969)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$require.invokeStatic (core.clj:6007)
    clojure.core$require.doInvoke (core.clj:6007)
    clojure.lang.RestFn.invoke (RestFn.java:421)
    clojure.core.contracts.impl.transformers$eval690$loading__6706__auto____691.invoke (transformers.clj:1)
    clojure.core.contracts.impl.transformers$eval690.invokeStatic (transformers.clj:1)
    clojure.core.contracts.impl.transformers$eval690.invoke (transformers.clj:1)
    clojure.lang.Compiler.eval (Compiler.java:7176)
    clojure.lang.Compiler.eval (Compiler.java:7165)
    clojure.lang.Compiler.load (Compiler.java:7635)
    clojure.lang.RT.loadResourceScript (RT.java:381)
    clojure.lang.RT.loadResourceScript (RT.java:372)
    clojure.lang.RT.load (RT.java:463)
    clojure.lang.RT.load (RT.java:428)
    clojure.core$load$fn__6824.invoke (core.clj:6126)
    clojure.core$load.invokeStatic (core.clj:6125)
    clojure.core$load.doInvoke (core.clj:6109)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    clojure.core$load_one.invokeStatic (core.clj:5908)
    clojure.core$load_one.invoke (core.clj:5903)
    clojure.core$load_lib$fn__6765.invoke (core.clj:5948)
    clojure.core$load_lib.invokeStatic (core.clj:5947)
    clojure.core$load_lib.doInvoke (core.clj:5928)
    clojure.lang.RestFn.applyTo (RestFn.java:142)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$load_libs.invokeStatic (core.clj:5985)
    clojure.core$load_libs.doInvoke (core.clj:5969)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$require.invokeStatic (core.clj:6007)
    clojure.core$require.doInvoke (core.clj:6007)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    leinjacker.defconstrainedfn$eval684$loading__6706__auto____685.invoke (defconstrainedfn.clj:1)
    leinjacker.defconstrainedfn$eval684.invokeStatic (defconstrainedfn.clj:1)
    leinjacker.defconstrainedfn$eval684.invoke (defconstrainedfn.clj:1)
    clojure.lang.Compiler.eval (Compiler.java:7176)
    clojure.lang.Compiler.eval (Compiler.java:7165)
    clojure.lang.Compiler.load (Compiler.java:7635)
    clojure.lang.RT.loadResourceScript (RT.java:381)
    clojure.lang.RT.loadResourceScript (RT.java:372)
    clojure.lang.RT.load (RT.java:463)
    clojure.lang.RT.load (RT.java:428)
    clojure.core$load$fn__6824.invoke (core.clj:6126)
    clojure.core$load.invokeStatic (core.clj:6125)
    clojure.core$load.doInvoke (core.clj:6109)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    clojure.core$load_one.invokeStatic (core.clj:5908)
    clojure.core$load_one.invoke (core.clj:5903)
    clojure.core$load_lib$fn__6765.invoke (core.clj:5948)
    clojure.core$load_lib.invokeStatic (core.clj:5947)
    clojure.core$load_lib.doInvoke (core.clj:5928)
    clojure.lang.RestFn.applyTo (RestFn.java:142)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$load_libs.invokeStatic (core.clj:5985)
    clojure.core$load_libs.doInvoke (core.clj:5969)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.core$apply.invokeStatic (core.clj:669)
    clojure.core$use.invokeStatic (core.clj:6093)
    clojure.core$use.doInvoke (core.clj:6093)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    leinjacker.deps$eval676$loading__6706__auto____677.invoke (deps.clj:1)
    leinjacker.deps$eval676.invokeStatic (deps.clj:1)
    leinjacker.deps$eval676.invoke (deps.clj:1)
    clojure.lang.Compiler.eval (Compiler.java:7176)
    clojure.lang.Compiler.eval (Compiler.java:7165)
    clojure.lang.Compiler.load (Compiler.java:7635)
    clojure.lang.RT.loadResourceScript (RT.java:381)
    clojure.lang.RT.loadResourceScript (RT.java:372)
    clojure.lang.RT.load (RT.java:463)
    clojure.lang.RT.load (RT.java:428)
    clojure.core$load$fn__6824.invoke (core.clj:6126)
    clojure.core$load.invokeStatic (core.clj:6125)
    clojure.core$load.doInvoke (core.clj:6109)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    clojure.core$load_one.invokeStatic (core.clj:5908)
    clojure.core$load_one.invoke (core.clj:5903)
    clojure.core$load_lib$fn__6765.invoke (core.clj:5948)
    clojure.core$load_lib.invokeStatic (core.clj:5947)
    clojure.core$load_lib.doInvoke (core.clj:5928)
    clojure.lang.RestFn.applyTo (RestFn.java:142)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$load_libs.invokeStatic (core.clj:5985)
    clojure.core$load_libs.doInvoke (core.clj:5969)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$require.invokeStatic (core.clj:6007)
    clojure.core$require.doInvoke (core.clj:6007)
    clojure.lang.RestFn.invoke (RestFn.java:436)
    leiningen.ring.server$eval668$loading__6706__auto____669.invoke (server.clj:1)
    leiningen.ring.server$eval668.invokeStatic (server.clj:1)
    leiningen.ring.server$eval668.invoke (server.clj:1)
    clojure.lang.Compiler.eval (Compiler.java:7176)
    clojure.lang.Compiler.eval (Compiler.java:7165)
    clojure.lang.Compiler.load (Compiler.java:7635)
    clojure.lang.RT.loadResourceScript (RT.java:381)
    clojure.lang.RT.loadResourceScript (RT.java:372)
    clojure.lang.RT.load (RT.java:463)
    clojure.lang.RT.load (RT.java:428)
    clojure.core$load$fn__6824.invoke (core.clj:6126)
    clojure.core$load.invokeStatic (core.clj:6125)
    clojure.core$load.doInvoke (core.clj:6109)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    clojure.core$load_one.invokeStatic (core.clj:5908)
    clojure.core$load_one.invoke (core.clj:5903)
    clojure.core$load_lib$fn__6765.invoke (core.clj:5948)
    clojure.core$load_lib.invokeStatic (core.clj:5947)
    clojure.core$load_lib.doInvoke (core.clj:5928)
    clojure.lang.RestFn.applyTo (RestFn.java:142)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$load_libs.invokeStatic (core.clj:5985)
    clojure.core$load_libs.doInvoke (core.clj:5969)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.core$apply.invokeStatic (core.clj:669)
    clojure.core$use.invokeStatic (core.clj:6093)
    clojure.core$use.doInvoke (core.clj:6093)
    clojure.lang.RestFn.invoke (RestFn.java:551)
    leiningen.ring$eval662$loading__6706__auto____663.invoke (ring.clj:1)
    leiningen.ring$eval662.invokeStatic (ring.clj:1)
    leiningen.ring$eval662.invoke (ring.clj:1)
    clojure.lang.Compiler.eval (Compiler.java:7176)
    clojure.lang.Compiler.eval (Compiler.java:7165)
    clojure.lang.Compiler.load (Compiler.java:7635)
    clojure.lang.RT.loadResourceScript (RT.java:381)
    clojure.lang.RT.loadResourceScript (RT.java:372)
    clojure.lang.RT.load (RT.java:463)
    clojure.lang.RT.load (RT.java:428)
    clojure.core$load$fn__6824.invoke (core.clj:6126)
    clojure.core$load.invokeStatic (core.clj:6125)
    clojure.core$load.doInvoke (core.clj:6109)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    clojure.core$load_one.invokeStatic (core.clj:5908)
    clojure.core$load_one.invoke (core.clj:5903)
    clojure.core$load_lib$fn__6765.invoke (core.clj:5948)
    clojure.core$load_lib.invokeStatic (core.clj:5947)
    clojure.core$load_lib.doInvoke (core.clj:5928)
    clojure.lang.RestFn.applyTo (RestFn.java:142)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$load_libs.invokeStatic (core.clj:5985)
    clojure.core$load_libs.doInvoke (core.clj:5969)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.core$apply.invokeStatic (core.clj:667)
    clojure.core$require.invokeStatic (core.clj:6007)
    clojure.core$require.doInvoke (core.clj:6007)
    clojure.lang.RestFn.invoke (RestFn.java:408)
    leiningen.core.utils$require_resolve.invokeStatic (utils.clj:102)
    leiningen.core.utils$require_resolve.invoke (utils.clj:95)
    leiningen.core.utils$require_resolve.invokeStatic (utils.clj:105)
    leiningen.core.utils$require_resolve.invoke (utils.clj:95)
    leiningen.core.main$lookup_task_var.invokeStatic (main.clj:69)
    leiningen.core.main$lookup_task_var.invoke (main.clj:65)
    leiningen.core.main$pass_through_help_QMARK_.invokeStatic (main.clj:79)
    leiningen.core.main$pass_through_help_QMARK_.invoke (main.clj:73)
    leiningen.core.main$task_args.invokeStatic (main.clj:82)
    leiningen.core.main$task_args.invoke (main.clj:81)
    leiningen.core.main$resolve_and_apply.invokeStatic (main.clj:339)
    leiningen.core.main$resolve_and_apply.invoke (main.clj:336)
    leiningen.core.main$_main$fn__6771.invoke (main.clj:449)
    leiningen.core.main$_main.invokeStatic (main.clj:439)
    leiningen.core.main$_main.doInvoke (main.clj:436)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.lang.Var.applyTo (Var.java:705)
    clojure.core$apply.invokeStatic (core.clj:665)
    clojure.main$main_opt.invokeStatic (main.clj:491)
    clojure.main$main_opt.invoke (main.clj:487)
    clojure.main$main.invokeStatic (main.clj:598)
    clojure.main$main.doInvoke (main.clj:561)
    clojure.lang.RestFn.applyTo (RestFn.java:137)
    clojure.lang.Var.applyTo (Var.java:705)
    clojure.main.main (main.java:37)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;lein ring server&lt;/code&gt;がエラーを吐くようになった。&lt;/p&gt;&lt;p&gt;&lt;code&gt;lein help&lt;/code&gt;で見てみてもringだけエラーが出てる&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;lein help
Leiningen is a tool for working with Clojure projects.

Several tasks are available:
change              Rewrite project.clj with f applied to the value at key-or-path.
check               Check syntax and warn on reflection.
classpath           Write the classpath of the current project to output-file.
clean               Removes all files from paths in clean-targets for a project
compile             Compile Clojure source into .class files.
deploy              Deploy jar and pom to remote repository.
deps                Show details about dependencies.
do                  Higher-order task to perform other tasks in succession.
help                Display a list of tasks or help for a given task or subtask.
install             Install jar and pom to the local repository; typically ~/.m2.
jar                 Package up all the project's files into a jar file.
javac               Compile Java source files.
new                 Generate scaffolding for a new project based on a template.
plugin              DEPRECATED. Please use the :user profile instead.
pom                 Write a pom.xml file to disk for Maven interoperability.
release             Perform release tasks.
repl                Start a repl session either with the current project or standalone.
retest              Run only the test namespaces which failed last time around.
leiningen.ring  Problem loading: Syntax error macroexpanding clojure.core/fn at (clojure/core/unify.clj:83:18).
run                 Run the project's -main function.
search              Search Central and Clojars for published artifacts.
show-profiles       List all available profiles or display one if given an argument.
test                Run the project's tests.
trampoline          Run a task without nesting the project's JVM inside Leiningen's.
uberjar             Package up the project files and all dependencies into a jar file.
update-in           Perform arbitrary transformations on your project map.
upgrade             Upgrade Leiningen to specified version or latest stable.
vcs                 Interact with the version control system.
version             Print version for Leiningen and the current JVM.
with-profile        Apply the given task with the profile(s) specified.

Run `lein help $TASK` for details.

Global Options:
  -o             Run a task offline.
  -U             Run a task after forcing update of snapshots.
  -h, --help     Print this help or help for a specific task.
  -v, --version  Print Leiningen's version.

These aliases are available:
downgrade, expands to upgrade

See also: readme, faq, tutorial, news, sample, profiles, deploying, gpg,
mixed-source, templates, and copying.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;この前後にPCのソフトウェア更新など諸々してたしJDK更新したからか？と云う気もしたが原因はわからず。&lt;/p&gt;&lt;p&gt;ブログを作るだけなら&lt;code&gt;lein run&lt;/code&gt;すりゃいいだけなのでなくてもよいのだが、見れたほうが良いので他のversionだとどうか試してみたところ、
0.12.5以上でならイケることがわかったので、cryogenの&lt;code&gt;project.clj&lt;/code&gt;に記述されてる&lt;code&gt;lein-ring&lt;/code&gt;のversionを上げることで障害を解消した。&lt;/p&gt;&lt;p&gt;ブログを書くための見えない部分の障害なので最も楽な解決方法でいったが、プロダクトでこれが起こってたらもっとエラーの原因を深掘りしたであろうな🤔&lt;/p&gt;</description><pubDate>Sun, 24 Feb 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-02-20-instead-of-ping</guid><link>https://krymtkts.github.io/posts/2019-02-20-instead-of-ping</link><title>`ping`の代わりに`Test-Connection`を使う</title><description>&lt;p&gt;PowerShellには&lt;code&gt;Test-Connection&lt;/code&gt;というやつがあるのを今更ながら知った。&lt;/p&gt;&lt;p&gt;今の仕事では、仮想マシン(dockerでない)を複数立ち上げて作業することが常になってるのだが、結構立ち上げ忘れてたりしてうっかりSSHしたときに繋げないのである😢&lt;/p&gt;&lt;p&gt;疎通確認と合わせてSSHするすべを探してたところ、これを知ったので以下のようなスクリプトを作ってCmderのTaskに登録して使っている。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;$waken = Test-Connection -TargetName $ip -Count 1 -Quiet
if (!$waken) {
    Write-Output "target not found. please start up $ip"
    $Host.UI.RawUI.ReadKey() | Out-Null
    exit
}
ssh "admin@$ip"
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href="https://blog.shibata.tech/entry/2016/06/16/231239"&gt;Test-Connectionが遅い理由と対策方法について - しばたテックブログ&lt;/a&gt;&lt;/p&gt;&lt;p&gt;↑このような話もあるようなので目を通しておきたいところ🤔&lt;/p&gt;&lt;h3 id="おまけ"&gt;おまけ&lt;/h3&gt;&lt;p&gt;&lt;a href="https://qiita.com/twinkfrag/items/f3ecf79b68ea09eadec2"&gt;PowerShellでPause - Qiita&lt;/a&gt;&lt;/p&gt;&lt;p&gt;最近のPowerShellには&lt;code&gt;Pause&lt;/code&gt;なるもんがデフォで入ってるが、古来からの方法でEnter以外のキーでも使えるようにしておくのが良いであらうか？&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Write-Output "type key to continue..."
$Host.UI.RawUI.ReadKey() | Out-Null
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;スクリプトの中でコレを呼んだら、なんかのキーを押すまで止まる。&lt;/p&gt;&lt;p&gt;戻り値が標準出力されないようにするために&lt;code&gt;Out-Null&lt;/code&gt;にパイプラインする。&lt;code&gt;$null&lt;/code&gt;に代入でもよいが。&lt;/p&gt;&lt;h3 id="余談"&gt;余談&lt;/h3&gt;&lt;p&gt;この記事をしたためておるときに&lt;code&gt;lein ring server&lt;/code&gt;でエラーが出るようになってたのを解消したので、メモがてら次回に記す。&lt;/p&gt;</description><pubDate>Wed, 20 Feb 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-02-11-Register-ArgumentCompleter2</guid><link>https://krymtkts.github.io/posts/2019-02-11-Register-ArgumentCompleter2</link><title>Register-ArgumentCompleterのScriptBlockの引数</title><description>&lt;p&gt;&lt;a href="./2019-02-04-Register-ArgumentCompleter.md"&gt;前回&lt;/a&gt;の続き。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Register-ArgumentCompleter -Native -CommandName mvn -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;↑こんなんいるやん？&lt;/p&gt;&lt;p&gt;&lt;code&gt;wordToComplete&lt;/code&gt;には入力中の文字列が入ってくる。&lt;/p&gt;&lt;p&gt;&lt;code&gt;$commandAst&lt;/code&gt;にはコマンドラインが全部載ってくる。&lt;/p&gt;&lt;p&gt;でも実際詳しく知らんので、たとえば&lt;code&gt;maven clean install -pl :module1 -&lt;/code&gt;ってとこまで入力してCtrl+Spaceやったときにはどういうパラメータになるかわからんので調べた。&lt;/p&gt;&lt;p&gt;結論から言うと&lt;code&gt;$commandAst&lt;/code&gt;はASTが乗ってくる。&lt;code&gt;mvn clean install --d&lt;/code&gt;でtabしたときのデバッガでの出力は以下の通り(デバッグ実行にはISEを利用した)。 &lt;a href="https://docs.microsoft.com/ja-jp/powershell/scripting/components/ise/exploring-the-windows-powershell-ise?view=powershell-6"&gt;Windows PowerShell ISE の操作 | Microsoft Docs&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;PS C:\Users\takatoshi\Desktop\maven&amp;gt; mvn clean install --d
ヒット 'C:\Users\takatoshi\dev\powershell\MavenAutoCompletion\MavenAutoCompletion.ps1:152' の行のブレークポイント
[DBG]: PS C:\Users\takatoshi\Desktop\maven&amp;gt;&amp;gt; $commandAst


CommandElements    : {mvn, clean, install, --d}
InvocationOperator : Unknown
DefiningKeyword    :
Redirections       : {}
Extent             : mvn clean install --d
Parent             : mvn clean install --d




[DBG]: PS C:\Users\takatoshi\Desktop\maven&amp;gt;&amp;gt; $wordToComplete
--d
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;mvn clean install --projects :&lt;/code&gt;でtabした場合↓&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;[DBG]: PS C:\Users\takatoshi\Desktop\maven&amp;gt;&amp;gt;
mvn clean install --projects :
ヒット 'C:\Users\takatoshi\dev\powershell\MavenAutoCompletion\MavenAutoCompletion.ps1:152' の行のブレークポイント
[DBG]: PS C:\Users\takatoshi\Desktop\maven&amp;gt;&amp;gt; $commandAst


CommandElements    : {mvn, clean, install, --projects...}
InvocationOperator : Unknown
DefiningKeyword    :
Redirections       : {}
Extent             : mvn clean install --projects :
Parent             : mvn clean install --projects :




[DBG]: PS C:\Users\takatoshi\Desktop\maven&amp;gt;&amp;gt; $commandAst.CommandElements


StringConstantType : BareWord
Value              : mvn
StaticType         : System.String
Extent             : mvn
Parent             : mvn clean install --projects :

StringConstantType : BareWord
Value              : clean
StaticType         : System.String
Extent             : clean
Parent             : mvn clean install --projects :

StringConstantType : BareWord
Value              : install
StaticType         : System.String
Extent             : install
Parent             : mvn clean install --projects :

StringConstantType : BareWord
Value              : --projects
StaticType         : System.String
Extent             : --projects
Parent             : mvn clean install --projects :

StringConstantType : BareWord
Value              : :
StaticType         : System.String
Extent             : :
Parent             : mvn clean install --projects :
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;wordToComplete&lt;/code&gt; こいつはまじでただの文字列。&lt;code&gt;commandAst.CommandElements&lt;/code&gt;の最後の要素の&lt;code&gt;value&lt;/code&gt;が出てる。&lt;/p&gt;&lt;p&gt;という感じだったので、MavenAutoCompletion的には&lt;code&gt;commandAst.CommandElements&lt;/code&gt;の最後から2要素を対象に正規表現してやれば、だいたい望みのことができるのがわかったのであった。&lt;/p&gt;&lt;h3 id="余談"&gt;余談&lt;/h3&gt;&lt;p&gt;PowerShellで配列の任意の連続した要素を抜き出すのに、slice的なんがないんかと調べたところ、以下のようにするようだ。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;&amp;gt; $a = @('mvn', 'clean', 'install', '-pl', ':')
&amp;gt; $a[($a.Length -2)..$a.Length]
-pl
:
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;cool😉&lt;/p&gt;</description><pubDate>Mon, 11 Feb 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-02-04-Register-ArgumentCompleter</guid><link>https://krymtkts.github.io/posts/2019-02-04-Register-ArgumentCompleter</link><title>Register-ArgumentCompleter</title><description>&lt;p&gt;まだoutputが習慣化してなくて随分空いてしまった🤔&lt;/p&gt;&lt;h3 id="register-argumentcompleter"&gt;&lt;a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/register-argumentcompleter?view=powershell-6"&gt;Register-ArgumentCompleter&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;PowerShell5から、従来の&lt;code&gt;TabExpansion&lt;/code&gt;に代わる&lt;code&gt;Register-ArgumentCompleter&lt;/code&gt;なるモノが現れたのは、PowerShellerなら知っているだろう(わたしは去年まで知らんかったのでPowerShellerではないのだ)。&lt;/p&gt;&lt;h3 id="サンプル書いてみた"&gt;サンプル書いてみた&lt;/h3&gt;&lt;p&gt;Mavenのよく使うコマンドでお試し。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Register-ArgumentCompleter -Native -CommandName mvn -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)

    echo -- clean install eclipse:eclipse |
        Where-Object { $_ -like "$wordToComplete*" } |
        Sort-Object |
        ForEach-Object {
            [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;めちゃんこ簡単。&lt;/p&gt;&lt;h3 id="作ったもの"&gt;作ったもの&lt;/h3&gt;&lt;p&gt;当時仕事で巨大なMavenプロジェクトを使っていて、コマンド打つのも億劫だったのでPowerShellで自動補完がほしいなと思っていたのだが、&lt;code&gt;TabExpantion&lt;/code&gt;はちょっと自分には使いこなせなかった。関数のオーバーライドをしたりのおまじないが必要だし。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Register-ArgumentCompleter&lt;/code&gt;なら簡単に作れたので、APIが進化してる感をひしと感じたのであった。以下成果物↓&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/krymtkts/MavenAutoCompletion"&gt;krymtkts/MavenAutoCompletion: MavenAutoCompletion provides a simple auto completion of Maven 3 to PowerShell.&lt;/a&gt;&lt;/p&gt;&lt;h3 id="既知のバグ"&gt;既知のバグ&lt;/h3&gt;&lt;p&gt;PowerShell5だと&lt;code&gt;-Native&lt;/code&gt;オプションありの場合に&lt;code&gt;-&lt;/code&gt;を利用した補完ができないバグがあって、前述の自動補完がうまく使えなくて辛い...&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/PowerShell/PowerShell/issues/2912"&gt;Native ArgumentCompleter not invoked for inputs that begin with hyphen (-) · Issue #2912 · PowerShell/PowerShell&lt;/a&gt;&lt;/p&gt;&lt;p&gt;PowerShell5.xでも使えないものかと試してみたところ、Trickyな回避策として&lt;code&gt;`&lt;/code&gt;で&lt;code&gt;-&lt;/code&gt;をエスケープしたらイケるというのを見つけたが...posh-gitもchocolateyもそれで従来からの&lt;code&gt;TabExpantion&lt;/code&gt;を使ってたのかーという気付きは得られた。&lt;/p&gt;&lt;p&gt;ちなみにわたしはPowerShell6を使ってるのでかんけーないのだ😜&lt;/p&gt;&lt;h3 id="残"&gt;残&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Register-ArgumentCompleter&lt;/code&gt;のScriptBlockの引数をちまちま調べたのがあるけど、長いから別に書こう。&lt;/p&gt;</description><pubDate>Mon, 04 Feb 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-01-17-build-qmk-firmware-of-planck</guid><link>https://krymtkts.github.io/posts/2019-01-17-build-qmk-firmware-of-planck</link><title>Planckのキーマップをビルドする</title><description>&lt;blockquote&gt;&lt;p&gt;当時使ってたPCではプログラミングしなくなったのと、改めてQMK firmwareのdocument見たらbuild toolsんとこの記事が変わってるので、今度環境構築がてら再確認してfirmwareのとこだけ新しく書こうと思う。&lt;/p&gt;&lt;p&gt;わたしのkeymapのrepo(&lt;a href="https://github.com/krymtkts/qmk_firmware"&gt;krymtkts/qmk_firmware&lt;/a&gt;)は「デフォのキーマップをコピった」的なコミットを最後に止まってるので、旧PCに遺物が残されてそう...作り直したほうが早いわ😅&lt;/p&gt;&lt;p&gt;去年はWSLで書き込む方法が確か使えてたはずだけど今は非推奨になってて、MSYS2を使う方法が主流になった？？？謎い🤔&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;a href="./2019-01-14-ortho-linear-keyboard-planck"&gt;前回&lt;/a&gt;のこの辺の続き。&lt;/p&gt;&lt;h3 id="ビルド環境をセットアップする"&gt;ビルド環境をセットアップする&lt;/h3&gt;&lt;p&gt;ドキュメント&lt;a href="https://docs.qmk.fm/#/getting_started_build_tools"&gt;QMK Firmware - Installing Build Tools&lt;/a&gt;に記載のWSLの手順をそのままでOK。ちょっとWSLを使いたかったのでMSYS2でのやつではあえてやらなかった。&lt;/p&gt;&lt;p&gt;WSL用のセットアップは&lt;code&gt;util/wsl_install.sh&lt;/code&gt;で行う。&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ cd ./c/qmk_firmware/
$ ./util/wsl_install.sh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;途中ドライバを全部入れる？と聞かれて、それは流石に...と思ったのでConnectedという接続したドライバだけ入れるやつ&lt;code&gt;C&lt;/code&gt;にした。&lt;/p&gt;&lt;p&gt;Flip入れる？と聞かれたけどつかわないだろうし必要なときに、と思ったので&lt;code&gt;N&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;wsl_install.sh&lt;/code&gt;完了後にPlanckのrev4のdefaultキーマップを試しにコンパイルする。&lt;/p&gt;&lt;p&gt;bashを再起動してサンプルのコマンドを実行する。&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ make planck/rev4:default
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;でバイナリが吐き出されたのでOK。&lt;/p&gt;&lt;h3 id="planckのfirmwareをビルドする"&gt;Planckのfirmwareをビルドする&lt;/h3&gt;&lt;p&gt;わたしのキーマップはこちら→&lt;a href="https://github.com/krymtkts/qmk_firmware/blob/master/keyboards/planck/keymaps/krymtkts/keymap.c"&gt;qmk_firmware/keymap.c at master · krymtkts/qmk_firmware&lt;/a&gt;&lt;/p&gt;&lt;p&gt;2017年末頃にビルドしたころとは&lt;code&gt;keyboards/planck/&lt;/code&gt;配下のコードが結構変わってるようなので、作成済みのキーマップを削除して新しく&lt;code&gt;default&lt;/code&gt;キーマップを作成する。それ用のシェルがあるので使う。&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ ./util/new_keymap.sh planck krymtkts
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これで一旦ビルドする。revisionはわからんけど時期的に5だと思う。[要出典?]&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ make planck/rev5:krymtkts
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;コマンドラインでfirmwareを書き込む。revision5では以下のコマンドが正しい。&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ make planck/rev5:krymtkts:dfu
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;でもエラーになった。なんかエラーが無限に繰り返される。CTRL+Cで中断&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ make planck/rev5:krymtkts:dfu
QMK Firmware 0.6.228
Making planck/rev5 with keymap krymtkts and target dfu

avr-gcc (GCC) 4.9.2
Copyright (C) 2014 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

Size before:
text    data     bss     dec     hex filename
    0   26614       0   26614    67f6 .build/planck_rev5_krymtkts.hex

Compiling: keyboards/planck/keymaps/krymtkts/keymap.c                                               [OK]
Linking: .build/planck_rev5_krymtkts.elf                                                            [OK]
Creating load file for flashing: .build/planck_rev5_krymtkts.hex                                    [OK]
Copying planck_rev5_krymtkts.hex to qmk_firmware folder                                             [OK]
Checking file size of planck_rev5_krymtkts.hex                                                      [OK]
* The firmware size is fine - 26614/28672 (2058 bytes free)
Error: Bootloader not found. Trying again in 5s.
Error: Bootloader not found. Trying again in 5s.
Error: Bootloader not found. Trying again in 5s.
Error: Bootloader not found. Trying again in 5s.
Error: Bootloader not found. Trying again in 5s.
^Ctmk_core/avr.mk:141: recipe for target 'dfu' failed
make[1]: *** [dfu] Interrupt
Makefile:529: recipe for target 'planck/rev5:krymtkts:dfu' failed
make: *** [planck/rev5:krymtkts:dfu] Interrupt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;エラーダイアログで「libusb0.dllがない」というような旨が表示される。WSLでやろうとしたからダメだったのか？&lt;/p&gt;&lt;p&gt;コマンドラインで焼くのを一旦諦めて、&lt;code&gt;qmk_tookbox.exe&lt;/code&gt;を使うことにしたら一発成功、Planckに自分のキーマップを焼くことに成功した。&lt;/p&gt;&lt;p&gt;でもコマンドラインで焼けないのは困るので、PlanckのMakefileの&lt;code&gt;rules.mk&lt;/code&gt;見てみたところ、&lt;/p&gt;&lt;pre&gt;&lt;code class="makefile"&gt;ifeq ($(strip $(KEYBOARD)), planck/rev4)
    BOOTLOADER = atmel-dfu
endif
ifeq ($(strip $(KEYBOARD)), planck/rev5)
    BOOTLOADER = qmk-dfu
endif
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;とあって、rev4と4rev5でbootloaderが変わってることから、あれ？わたしのPlanckもしかしてrev4じゃ？と思って試してみたところ...&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ make planck/rev4:krymtkts:dfu
QMK Firmware 0.6.228
Making planck/rev4 with keymap krymtkts and target dfu

avr-gcc (GCC) 4.9.2
Copyright (C) 2014 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

Compiling: quantum/audio/muse.c                                                                     [OK]
Compiling: keyboards/planck/planck.c                                                                [OK]
Compiling: keyboards/planck/keymaps/krymtkts/keymap.c                                               [OK]
Compiling: quantum/quantum.c                                                                        [OK]
Compiling: quantum/keymap_common.c                                                                  [OK]
Compiling: quantum/keycode_config.c                                                                 [OK]
Compiling: quantum/matrix.c                                                                         [OK]
Compiling: quantum/process_keycode/process_audio.c                                                  [OK]
Compiling: quantum/process_keycode/process_clicky.c                                                 [OK]
Compiling: quantum/audio/audio.c                                                                    [OK]
Compiling: quantum/audio/voices.c                                                                   [OK]
Compiling: quantum/audio/luts.c                                                                     [OK]
Compiling: quantum/process_keycode/process_music.c                                                  [OK]
Compiling: tmk_core/common/host.c                                                                   [OK]
Compiling: tmk_core/common/keyboard.c                                                               [OK]
Compiling: tmk_core/common/action.c                                                                 [OK]
Compiling: tmk_core/common/action_tapping.c                                                         [OK]
Compiling: tmk_core/common/action_macro.c                                                           [OK]
Compiling: tmk_core/common/action_layer.c                                                           [OK]
Compiling: tmk_core/common/action_util.c                                                            [OK]
Compiling: tmk_core/common/print.c                                                                  [OK]
Compiling: tmk_core/common/debug.c                                                                  [OK]
Compiling: tmk_core/common/util.c                                                                   [OK]
Compiling: tmk_core/common/eeconfig.c                                                               [OK]
Compiling: tmk_core/common/report.c                                                                 [OK]
Compiling: tmk_core/common/avr/suspend.c                                                            [OK]
Compiling: tmk_core/common/avr/timer.c                                                              [OK]
Compiling: tmk_core/common/avr/bootloader.c                                                         [OK]
Assembling: tmk_core/common/avr/xprintf.S                                                           [OK]
Compiling: tmk_core/common/magic.c                                                                  [OK]
Compiling: tmk_core/protocol/lufa/lufa.c                                                            [OK]
Compiling: tmk_core/protocol/usb_descriptor.c                                                       [OK]
Compiling: tmk_core/protocol/lufa/outputselect.c                                                    [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Class/Common/HIDParser.c                                       [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/AVR8/Device_AVR8.c                                        [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/AVR8/EndpointStream_AVR8.c                                [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/AVR8/Endpoint_AVR8.c                                      [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/AVR8/Host_AVR8.c                                          [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/AVR8/PipeStream_AVR8.c                                    [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/AVR8/Pipe_AVR8.c                                          [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.c                                 [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/AVR8/USBInterrupt_AVR8.c                                  [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/ConfigDescriptors.c                                       [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/DeviceStandardReq.c                                       [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/Events.c                                                  [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/HostStandardReq.c                                         [OK]
Compiling: lib/lufa/LUFA/Drivers/USB/Core/USBTask.c                                                 [OK]
Linking: .build/planck_rev4_krymtkts.elf                                                            [OK]
Creating load file for flashing: .build/planck_rev4_krymtkts.hex                                    [OK]
Copying planck_rev4_krymtkts.hex to qmk_firmware folder                                             [OK]
Checking file size of planck_rev4_krymtkts.hex                                                      [OK]
 * The firmware size is fine - 26614/28672 (2058 bytes free)
Bootloader Version: 0x00 (0)
Erasing flash...  Success
Checking memory from 0x0 to 0x6FFF...  Empty.
Checking memory from 0x0 to 0x67FF...  Empty.
0%                            100%  Programming 0x6800 bytes...
[&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;]  Success
0%                            100%  Reading 0x7000 bytes...
[&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;]  Success
Validating...  Success
0x6800 bytes written into 0x7000 bytes memory (92.86%).
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;成功した。時期的にrev5だと思ってたけどrev4だったとは😅まあうまくいってよかった。&lt;/p&gt;&lt;p&gt;キーマップはまだしっくり来ていないのでちまちま更新する予定。&lt;/p&gt;</description><pubDate>Thu, 17 Jan 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-01-14-ortho-linear-keyboard-planck</guid><link>https://krymtkts.github.io/posts/2019-01-14-ortho-linear-keyboard-planck</link><title>Ortho-Linear Keyboard "Planck"</title><description>&lt;p&gt;わたしが&lt;a href="https://olkb.com/planck/"&gt;Planck&lt;/a&gt;を手に入れたのは割と遅めのタイミング。&lt;/p&gt;&lt;p&gt;2017年の春に&lt;a href="https://www.massdrop.com/"&gt;Massdrop&lt;/a&gt;で買って、6月末に届く予定だったのだけど、手元に届いたのが秋頃だった。jackhumbertさん(OLKBの中の人)随分忙しかったようで遅れまくり。&lt;/p&gt;&lt;p&gt;普段の仕事では&lt;a href="https://ergodox-ez.com/"&gt;Ergodox EZ&lt;/a&gt;を使ってるんやが、持ち運びに便利なminimalなキーボードが欲しくて買った。&lt;/p&gt;&lt;p&gt;以下はその作業ログである。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;&lt;em&gt;date: 2017-10-07&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2019-01-14-planck/planck-case-keyswitches.jpg" alt="者共" /&gt;&lt;/p&gt;&lt;p&gt;ケース付き、キースイッチ付きでDIYキットを購入。キースイッチはCherry MX Clear。&lt;/p&gt;&lt;h3 id="はじめに"&gt;はじめに&lt;/h3&gt;&lt;h4 id="手順の理解"&gt;手順の理解&lt;/h4&gt;&lt;p&gt;Jack Humbert氏のYoutubeを見てイメージを掴む。&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=S2FApwzVxAQ"&gt;How to Actually Build a Planck (or Preonic or Atomic) from OLKB&lt;/a&gt;&lt;/p&gt;&lt;p&gt;説明動画を見てケッコー以外だったのが、key switchの端子の歪みを素手で直してた所。ピンセットとか使わないんや...&lt;/p&gt;&lt;h3 id="作業に入る"&gt;作業に入る&lt;/h3&gt;&lt;h4 id="検品"&gt;検品&lt;/h4&gt;&lt;p&gt;&lt;img src="/img/2019-01-14-planck/planck-picking.jpg" alt="パーツ欠品確認" /&gt;&lt;/p&gt;&lt;p&gt;パーツは全部揃っている。数も数えたしOK&lt;/p&gt;&lt;p&gt;一箇所Switch Plateに多分プレス時にズレかなんかあったであろう痕があってちょっと残念。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2019-01-14-planck/planck-unfortunate.jpg" alt="プレスミス？" /&gt;&lt;/p&gt;&lt;p&gt;PCBはUSBに接続して音がなればOKとのこと。ファンシーなnoiseが奏でられた&lt;/p&gt;&lt;p&gt;PlanckはLEDにも対応してるけど、今回はデフォ実装するためナシ。でも今後欲しい感じもする。&lt;/p&gt;&lt;h4 id="switchはめ込み"&gt;Switchはめ込み&lt;/h4&gt;&lt;p&gt;Sitch PlateにKey Switchをはめる&lt;/p&gt;&lt;p&gt;48Keyで使う。ちょっと数が多いしはめ込むのは面倒だけど、黙々とやる。
KeySwitchの端子がひん曲がっているやつはピンで直しながらはめ込んでいきく。&lt;/p&gt;&lt;p&gt;真ん中の1 or 2 keyがえらべるところはPCBにはんだ付けするまでswitchがスライドするので注意。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2019-01-14-planck/planck-half.jpg" alt="半分まではめ込んだ" /&gt;&lt;/p&gt;&lt;p&gt;全部はめ込んだ痕でSwitch Plateの裏表があるっぽいことに気づく。裏側のほうがピカピカしてる。でも傷が多いので今のままで行こうと決定&lt;/p&gt;&lt;h4 id="soldering"&gt;Soldering&lt;/h4&gt;&lt;p&gt;マスクを着用。&lt;/p&gt;&lt;p&gt;今回ハンダゴテを新調した。白光のいいやつで温度調節ができる。調べた感じだとkeyboardのPCBにはんだ付けする最適温度が350とのことなので、それがえらべるのが良い。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2019-01-14-planck/planck-solders.jpg" alt="ハンダゴテ比較" /&gt;&lt;/p&gt;&lt;p&gt;ギターの配線用に使ってた旧・ハンダゴテとは随分と違う...&lt;/p&gt;&lt;p&gt;黙々とはんだ付けする。格子状に並んでいるので非常に楽。いやハンダゴテが良いモノだからなのかも。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2019-01-14-planck/planck-soldering.jpg" alt="作業中" /&gt;&lt;/p&gt;&lt;p&gt;はんだ付け完了したのがこちら。&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2019-01-14-planck/planck-soldered.jpg" alt="はんだ付け完了" /&gt;&lt;/p&gt;&lt;p&gt;ところどころ熱で弾けたであろうヤニが付いてるので、組込前に掃除にした。&lt;/p&gt;&lt;h4 id="keycapはめ込み"&gt;keycapはめ込み&lt;/h4&gt;&lt;p&gt;今回keycapはセットで買えたXDAのやつにした。もちろん印字なんかは不要。&lt;/p&gt;&lt;p&gt;作業中の写真なし。無念の撮り忘れ😭&lt;/p&gt;&lt;p&gt;完成！&lt;/p&gt;&lt;p&gt;&lt;img src="/img/2019-01-14-planck/planck-complete.jpg" alt="美しい完成品" /&gt;&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;...最後のfirmwareのビルドのところがログに残ってないのだけど、Ergodox EZのキーマップをビルドするDockerでできてたような気がする。firmwareも書き込み済み。&lt;/p&gt;&lt;p&gt;当時使ってたPCではプログラミングしなくなったのと、改めてQMK firmwareのdocument見たらbuild toolsんとこの記事が変わってるので、今度環境構築がてら再確認してfirmwareのとこだけ新しく書こうと思ってる(作業中)。&lt;/p&gt;&lt;p&gt;わたしのkeymapのrepo(&lt;a href="https://github.com/krymtkts/qmk_firmware"&gt;krymtkts/qmk_firmware&lt;/a&gt;)は「デフォのキーマップをコピった」的なコミットを最後に止まってるので、旧PCに遺物が残されてそう😅&lt;/p&gt;&lt;p&gt;去年はWSLで書き込む方法が確か使えてたはずだけど今は非推奨になってて、MSYS2を使う方法が主流になった？？？謎い🤔&lt;/p&gt;&lt;p&gt;にしてもや、この文章を認めるためにOLKBのページを久しぶりに見たが、今のPCBはrevision.6で、hot swappableなkey switch、接続はUSB Type-Cという進化っぷりに驚きを隠せない😰わたしのはrev.5かそれ以前(忘れた)&lt;/p&gt;</description><pubDate>Mon, 14 Jan 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-01-10-make-blog-with-clojure</guid><link>https://krymtkts.github.io/posts/2019-01-10-make-blog-with-clojure</link><title>Clojureでブログを作った</title><description>&lt;p&gt;このブログはClojure製の静的サイトジェネレータ&lt;a href="http://cryogenweb.org/"&gt;Cryogen&lt;/a&gt;で作った。&lt;/p&gt;&lt;h3 id="動機"&gt;動機&lt;/h3&gt;&lt;p&gt;現在有給消化中のため暇である。プログラマ的暇潰しが必要だったのだが、ブログを作るのはそれなりに楽しめそうな気がした。&lt;/p&gt;&lt;p&gt;あと、過去にブログサービスを使ってたときブログが長続きしなかった理由に、わたしは物書きじゃあないので簡単にブログが書けるとかいう部分が琴線に触れない、というようなものが根底にあるような気もする🤔&lt;/p&gt;&lt;p&gt;自分で作るならその心配はない。&lt;/p&gt;&lt;p&gt;ついでに折角GitHubのアカウントも持ってるので、GitHub Pagesを使わない手はない。blogのコードをrepoに登録しておけば芝生も青々としてええな！的な。&lt;/p&gt;&lt;p&gt;また別の観点としてブログサービスを選ぶとなった場合、書く記事の内容が技術的なものだったり単なる趣味の話だったり内容がブレると思うので、利用規約に触れて垢バンされるようなサービスは選び辛い。ちょうど良い選択かも知れない。&lt;/p&gt;&lt;p&gt;そこで今回はブログ自体を自分で作ってしまおうと決めた。&lt;/p&gt;&lt;p&gt;因みにClojureを選んだのは個人的な好みである。&lt;/p&gt;&lt;h3 id="静的サイトジェネレータの選定"&gt;静的サイトジェネレータの選定&lt;/h3&gt;&lt;p&gt;普通にググって調べようと思ってたけど、いまはこんなのクソ便利なんがあるのね...→&lt;a href="https://www.staticgen.com/"&gt;StaticGen&lt;/a&gt;&lt;/p&gt;&lt;p&gt;LanguageをClojureにしたら3個hitしたのでそれぞれ見てみた。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/cryogen-project/cryogen"&gt;Cryogen&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/liquidz/misaki"&gt;Misaki&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/hashobject/perun"&gt;Perun&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Misakiは永らくメンテされてないからなし。
CryogenもPerunも、検索したら日本語の情報にhitするのでやりがいに違いはなさそう。
単純に⭐が多いのとBootを使ったことがないというだけの理由で&lt;a href="https://github.com/cryogen-project/cryogen"&gt;Cryogen&lt;/a&gt;を使うことにした。&lt;/p&gt;&lt;p&gt;(後知恵だが、ここはもっと慎重に考えた方が良かった)&lt;/p&gt;&lt;h3 id="cryogenを使ってぶろぐを作ろうぜ"&gt;&lt;a href="https://github.com/cryogen-project/cryogen"&gt;Cryogen&lt;/a&gt;を使ってぶろぐを作ろうぜ&lt;/h3&gt;&lt;p&gt;ドキュメントが充実してるので、書いたてることに従うだけで簡単にできた。&lt;/p&gt;&lt;p&gt;出来上がったコードはこちら→&lt;a href="https://github.com/krymtkts/blog-cryogen"&gt;My personal blog project&lt;/a&gt;&lt;/p&gt;&lt;p&gt;以降に記すコマンド例はPowerShellで実行したものである。筆者はWindows10ユーザなので。&lt;/p&gt;&lt;h4 id="手始めに"&gt;手始めに&lt;/h4&gt;&lt;p&gt;Leiningenでテンプレートを作成する。&lt;/p&gt;&lt;pre&gt;&lt;code class="poershell"&gt;lein new cryogen blog
Retrieving cryogen/lein-template/0.3.7/lein-template-0.3.7.pom from clojars
Retrieving leinjacker/leinjacker/0.4.2/leinjacker-0.4.2.pom from clojars
Retrieving org/clojure/core.contracts/0.0.1/core.contracts-0.0.1.pom from central
Retrieving org/clojure/pom.contrib/0.0.26/pom.contrib-0.0.26.pom from central
Retrieving org/clojure/core.unify/0.5.3/core.unify-0.5.3.pom from central
Retrieving cryogen/lein-template/0.3.7/lein-template-0.3.7.jar from clojars
Retrieving org/clojure/core.contracts/0.0.1/core.contracts-0.0.1.jar from central
Retrieving org/clojure/core.unify/0.5.3/core.unify-0.5.3.jar from central
Retrieving org/clojure/clojure/1.4.0/clojure-1.4.0.jar from central
Retrieving leinjacker/leinjacker/0.4.2/leinjacker-0.4.2.jar from clojars
Generating fresh 'lein new' Cryogen project.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ブログを動かしてみよう&lt;/p&gt;&lt;pre&gt;&lt;code class="poershell"&gt;lein ring server
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ブラウザに表示された。OK👍&lt;/p&gt;&lt;h4 id="コンテンツを整理する"&gt;コンテンツを整理する&lt;/h4&gt;&lt;p&gt;わたしの場合はMarkdownで書くのでAsciiDocのディレクトリは消してしまう。サーバ起動中にこれをやると例外が発生する、止めてからやるのが良いだろう。&lt;/p&gt;&lt;pre&gt;&lt;code class="powershell"&gt;Remove-Item -Recurse -Path ./resources/templates/ascii
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;あとsampleで置いてあるpostやaboutを自分用に書き換えるなど。&lt;/p&gt;&lt;h4 id="テーマを作る"&gt;テーマを作る&lt;/h4&gt;&lt;p&gt;themeはデフォで&lt;code&gt;blue&lt;/code&gt;, &lt;code&gt;blue_centered&lt;/code&gt;, &lt;code&gt;lotus&lt;/code&gt;, &lt;code&gt;nucleus&lt;/code&gt;の4種類置いてある。&lt;code&gt;lotus&lt;/code&gt;を使うとエラーになったけど、これを直すのが目的じゃないので無視した🙈&lt;/p&gt;&lt;p&gt;自分用のテーマとしては何が良いかな？と検討して、お気に入りのSolarizedにしようと決めた。terminalやeditorはSolarized darkを使っているが、ブログはlightでやろうと思う。syntax highlightingについてはいつも通りのdarkを採用することにした。&lt;/p&gt;&lt;p&gt;&lt;a href="https://ethanschoonover.com/solarized/"&gt;Solarized&lt;/a&gt;を参考に自分でthemeを作る。元にするのは&lt;code&gt;blue_centered&lt;/code&gt;にした。ブラウザの開発者ツールで見てみてもレスポンシブデザインになってたし、cssのコード量も少なくてシンプルなのがいい。&lt;/p&gt;&lt;p&gt;&lt;code&gt;resources/templates/themes&lt;/code&gt;にファイル名&lt;code&gt;solarized_light&lt;/code&gt;でコピって書き換える。&lt;/p&gt;&lt;p&gt;基本は書いたあるルールに沿うけど一部それとなく変える。カラーコードの編集はsassにしたら楽だろうけどコピった元はそうじゃないので、該当する箇所を書き換えるだけに留めた。&lt;/p&gt;&lt;p&gt;Cryogenのsyntax highlightingは&lt;code&gt;highlight.js&lt;/code&gt;が採用されている。
デフォの24種だと使わないやつもいるので削って、使いそうな言語を足したものを&lt;a href="https://highlightjs.org/download/"&gt;highlight.js&lt;/a&gt;で作ってダウンロードする。
これは手動でダウンロードして、デフォの&lt;code&gt;highlight.pack.js&lt;/code&gt;に上書きした。&lt;/p&gt;&lt;p&gt;スタイルは&lt;code&gt;base.html&lt;/code&gt;で&lt;code&gt;default&lt;/code&gt;が指定されているので&lt;code&gt;solarized_dark&lt;/code&gt;を選ぶ。ついでにhighlight.jsのversionも9.7から9.13.1へ上げちゃう。&lt;/p&gt;&lt;p&gt;404 Page not foundのときのページがどうやって表示されるのかわからなかったが、GitHub Pagesの機能で提供されるルールに従えば良い様子。&lt;/p&gt;&lt;p&gt;&lt;a href="https://help.github.com/articles/creating-a-custom-404-page-for-your-github-pages-site/"&gt;Customizing GitHub Pages / Creating a custom 404 page for your GitHub Pages site&lt;/a&gt;&lt;/p&gt;&lt;p&gt;デフォの404ページのスタイルが他のページとぜんぜん違うので、スタイルに合わせておいた。&lt;/p&gt;&lt;p&gt;ページが縦に長くなって垂直スクロールバーが出るとコンテンツのズレが生じるのだけど、これ多分bootstrapに起因する問題か🤔悩ましいが一旦そのままに。&lt;/p&gt;&lt;p&gt;これでおおよそのデザイン面は完成した。&lt;/p&gt;&lt;p&gt;作業中のコードは一旦BitBucketのprivate repoにブチ込んでおいたのだけど、GitHubの無償アカウントでもprivate repoが使えるようになって分ける理由がなくなってしまった...まあよし。&lt;/p&gt;&lt;p&gt;あと、&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Bootstrap3から4に上げたい&lt;/li&gt;&lt;li&gt;Google Analytics&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;など残しているが、一旦はコンテンツの公開を優先して後回しにする予定。&lt;/p&gt;&lt;h4 id="github-pagesにうｐる"&gt;GitHub Pagesにうｐる&lt;/h4&gt;&lt;p&gt;&lt;a href="https://pages.github.com/"&gt;GitHub Pages&lt;/a&gt;の説明と&lt;a href="http://cryogenweb.org/docs/deploying-to-github-pages.html"&gt;Cryogen - GitHub Pages&lt;/a&gt;を見たらできる。&lt;/p&gt;&lt;p&gt;作るのはユーザーのpageなので、まず&lt;code&gt;krymtkts.github.io&lt;/code&gt;のrepoを作る。
中身は空で。Licenseの選択もなし。&lt;/p&gt;&lt;p&gt;Cryogenのドキュメントに従い、&lt;code&gt;config.edn&lt;/code&gt;の&lt;code&gt;blog-prefix&lt;/code&gt;キーの値は空にする。&lt;/p&gt;&lt;p&gt;あとはCryogenが出力した&lt;code&gt;resource/public&lt;/code&gt;を先程作ったrepoのmasterブランチにpushするのみ。&lt;/p&gt;&lt;p&gt;この出力先&lt;code&gt;resource/public&lt;/code&gt;を変更する方法がわからなかったので、&lt;code&gt;krymtkts.github.io&lt;/code&gt;という名前のシンボリックリンクを作って、あたかもそういう名前のフォルダをGitで管理してる感を醸し出して茶を濁した。&lt;/p&gt;&lt;pre&gt;&lt;code class="poershell"&gt;New-Item -Value '.\blog\resources\public\' -Path './' -Name 'krymtkts.github.io' -ItemType SymbolicLink
cd krymtkts.github.io
git init
echo "# krymtkts.github.io" &amp;gt;&amp;gt; README.md
git add README.md
git commit -m "First commit"
git add .
git commit -m 'Add contents'
git remote add origin git@github.com:krymtkts/krymtkts.github.io.git
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これでわたしのブログがpublishされたのであった🎉&lt;/p&gt;&lt;p&gt;めでたしめでたし...&lt;/p&gt;&lt;h3 id="to-be-continued"&gt;To be continued&lt;/h3&gt;&lt;p&gt;で終わらなかった。&lt;/p&gt;&lt;p&gt;これを作りきって、急激にCryogenに興味がなくなってしまった。&lt;/p&gt;&lt;p&gt;結局の所、テンプレートエンジンにSelmerを使ってることで、HTMLやスタイルの編集自体にClojure感の薄さがあってなんか楽しみがないのかなと。最初から予想できそうな結果やけどな🤔&lt;/p&gt;&lt;p&gt;コンテンツ自体はMarkdownで書くし可搬性があるので記事の更新はしつつ、次段階としてPerunで作り直してみようと思う。&lt;/p&gt;&lt;p&gt;破壊と創造こそが人類の本質ですね(違う&lt;/p&gt;</description><pubDate>Thu, 10 Jan 2019 00:00:00 +0900</pubDate></item><item><guid>https://krymtkts.github.io/posts/2019-01-08-first-post</guid><link>https://krymtkts.github.io/posts/2019-01-08-first-post</link><title>ブログを始めた</title><description>&lt;p&gt;ブログを始めてみた。&lt;/p&gt;&lt;p&gt;自分のメモを取るのには永らくEvernoteを使ってるのだけど、そういったものをまとめてアウトプットできるものが欲しいなー、と常々思ってた。&lt;/p&gt;&lt;p&gt;ただ過去にブログサービスを使ってたときは大して続かなく、また中等半端にやめかねないなという気持ちもあったのだが、去年アラフォーになったことであるし、不惑ということで一歩踏み出してみたのである。&lt;/p&gt;&lt;p&gt;自己紹介は&lt;a href="../../pages/about"&gt;About Me&lt;/a&gt;を参照いただきたく🙇&lt;/p&gt;&lt;p&gt;当面は自分の作業ログを清書したものを書いていくつもりやけど、もし誰かの目に留まって、何かの役に立ったなら幸いである。&lt;/p&gt;</description><pubDate>Tue, 08 Jan 2019 00:00:00 +0900</pubDate></item></channel></rss>