- date: 2025-02-01
  bookTitle: プログラマーのための CPU 入門 CPU は如何にしてソフトウェアを高速に実行するか
  pages: 87 ~ 90
  notes: |
    第 6 章 仮想記憶。
    仮想記憶の中核となるのは、仮想アドレス空間(virtual address space)と物理アドレス空間(physical address space)を対応付けるアドレス変換(address translation)を行う機能。
    主記憶よりも大きなメモリがあるように見せかける等メモリの使い勝手を飛躍的に高める。
    この対応付けはページテーブル(page table)と呼ばれるデータ構造によって行われ、ページサイズ(page size)の単位で行われる。
    主記憶上のページテーブルから変換ルールを読み出すのをテーブルウォーク(table walk)と呼ぶ。
    このため本来のアクセスに加えテーブルウォークのため 2 回主記憶にアクセスが必要になり、無駄に長いサイクルがかかる。
    この本を読んでると、一難去ってまた一難という感じで次々に課題と緩和策の繰り返しから CPU のありがたみが沁みるよな。
- date: 2025-02-02
  bookTitle: プログラマーのための CPU 入門 CPU は如何にしてソフトウェアを高速に実行するか
  pages: 91 ~ 94
  notes: |
    第 6 章 仮想記憶。
    TLB(Translation Lookaside Buffer)はページテーブルの一部を高速に主記憶から読み込んでおくためのハードウェアで、テーブルウォークの遅さを緩和する。
    ページテーブルと TLB は主記憶とキャッシュメモリの関係に近い。
    TLB は主に 4KB のページ単位のため、空間局所性が高ければより発生しにくいが、ミスは発生しうる。これを TLB ミス(TLB miss)と呼ぶ。キャッシュミスよりその頻度は低いが、コストはより高い。 TLB ミスの要因やダメージもキャッシュと同様。
    ただしフルアソシティブ(full associtive)の TLB はキャッシュは競合性ミスが発生しない。
    TLB は流石に初めて聞いた気がする。ここでも緩和のための仕組みがさらなる複雑さを...
- date: 2025-02-03
  bookTitle: プログラマーのための CPU 入門 CPU は如何にしてソフトウェアを高速に実行するか
  pages: 94 ~ 100
  notes: |
    第 6 章 仮想記憶。
    仮想記憶のソフトウェア制御は OS の仕事なので(開発者が書く)ソフトウェアで対処できるようなものではない。
    それでも TLB ミスはキャッシュミスと共通する点(初期参照ミス・容量性ミス・競合性ミス)があり同じ手法が有効。
    仮想記憶にはアドレス変換の他に重大なダメージをもたらすページフォールト(page fault)(disk I/O が発生する)ある。
    ここまで来るとソフトウェア的な対策は一定程度可能とはいえ CPU 毎にも異なるからどうしようもない感出てくるな。
- date: 2025-02-04
  bookTitle: プログラマーのための CPU 入門 CPU は如何にしてソフトウェアを高速に実行するか
  pages: 101 ~ 106
  notes: |
    第 7 章 I/O。
    本書では CPU の外部デバイスの内主記憶を除くデバイスへの操作を I/O アクセスと呼ぶ。
    I/O アクセスはメモリのように見せかけるメモリマップド I/O(memory-mapped I/O)とデバイス専用アドレス空間を用いる I/O アドレス空間(I/O address space)を用いる I/O 専用命令がある。
    I/O アクセスにより、デバイスへの指示(I/O デバイスへの書き込み)、状態の取得(I/O デバイスからの読み込み)、ネットワークからの受信とかディスクへの書き出しといったデータ転送(I/O デバイス→レジスタ→主記憶の転送)といった操作が実現できる。
    この章は I/O bound の話なので多少イメージつきやすそう。逆に今までよく掘り下げずに来たなという自戒...
- date: 2025-02-05
  bookTitle: プログラマーのための CPU 入門 CPU は如何にしてソフトウェアを高速に実行するか
  pages: 106 ~ 111
  notes: |
    第 7 章 I/O。
    I/O デバイスはコストと消費電力の観点から CPU に比べると動作周波数が低いため CPU から見て遅い。
    I/O バスもそれ同様なのと、多数のデバイスを識別する新規デバイスへの対応、動的な着脱、バスの規格やプロトコル・複数のバスをまたぐことで、遅い。
    また I/O デバイス自体がキャッシュ・バッファ・プリフェッチといった高速化手法を使えず、遅い。
    これらの特性は汎用的な対処が難しいので CPU 的に割り込み要求(interrupt request)、 CPU を介さずメモリ間でデータ転送する DMA(Direct Memory Access) といった I/O アクセス自体を減らす仕組みがある。
    CPU によっては I/O アクセスを制御する命令、 I/O デバイスから主記憶に直接アクセス可能、 I/O デバイスと CPU が L3 キャッシュを共有するなどの工夫もある。
    I/O デバイスの遅さを緩和するためなら何でもやるなという印象。
- date: 2025-02-06
  bookTitle: プログラマーのための CPU 入門 CPU は如何にしてソフトウェアを高速に実行するか
  pages: 111 ~ 118
  notes: |
    第 7 章 I/O。
    ソフトウェア的な I/O デバイスの遅さを緩和する方法は基本的に I/O アクセスの回数を減らす方法。
    I/O デバイスへのアクセスをページキャッシュ・バッファキャッシュで減らす、また 1 回の I/O アクセスにまとめる等。
    ただし I/O デバイスへのアクセス回数の減少はそのまま応答性の劣化につながると。ここでいう応答性はリアルタイム性能？
    計測実験は RTC(Real Time Clock) と PCI Express 。
    I/O なくしてソフトウェアは成り立たないのでなくすことはできないが緩和策を使ってうまく付き合おう、というわけか。悩ましいな。
- date: 2025-02-07
  bookTitle: プログラマーのための CPU 入門 CPU は如何にしてソフトウェアを高速に実行するか
  pages: 119 ~ 122
  notes: |
    第 8 章 システムコール、例外、割り込み。
    分岐命令の他に命令流の特別な切り替えが存在する。それらの呼び方や定義は CPU によってまちまちなので、本書では例外・割り込み系と総称する。
    システムコール(内部的に特権レベルの変更命令で明示的に発生)、例外(内部的に命令実行時のエラーなどハードウェアが検知し暗黙的に発生)、割り込み(外部的要求により発生)の 3 つに分類する。
    発生頻度が比較的稀であること、ソフトウェア的な観点で対策が難しく、もっと低いレイヤでの対応が主。
    この図がわかり良いよな言葉に出来ないけど。発生する場所とか考えたことなかった。
- date: 2025-02-08
  bookTitle: 分子調理の日本食
  pages: 1 ~ 13
  readCount: 2
  notes: |
    今日は酔っ払っており、手元にある本を読んだ。
    2021 年の本だが、この本の仮想のレシピ集は気合を入れれば日常的にできそうだなという感触を掴めた(恐らく記述時点でそれを狙ってたのであろうが)。
    しかしスノードームふろふき大根、これの茹で汁を捨てるんだ～と思い、煮汁の味を凝縮して提供できないのかと思ったわたしは、教科書的には NG だろうか。
    このような読者に対しては、まず実践してからモノを言えと。酔っ払ってないときにご飯を作って実践したいと思いますんません。
