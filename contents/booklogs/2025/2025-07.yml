- date: 2025-07-01
  bookTitle: 型システムのしくみ TypeScript で実装しながら学ぶ型とプログラミング言語
  pages: i ~ ix, 1 ~ 7
  notes: |
    型システムの背景にある数学的に証明された理論を小型の型検査器を実装して体感し、型システムを学ぶためのきっかけを作るのが本書の目的。
    ステップとしては本書 → TAPL(Types and Programming Languages) → TypeScript の型システム(Gradual Typing)。
    第 1 章 型システムとは、プログラムの未定義動作に対処する手段の一つ。
    プログラムを操作的意味論で定義し、型検査器が OK と判定したプログラムは未定義動作を起こさない性質、型安全性が証明される。
    型安全性を意識した型システムが設計された OCaml や Haskell と違い、 TypeScript は JavaScript に後付で型システムが導入されているため、 JavaScript としては未定義動作がない。このため型安全性はそれほど重要視されてない様子。
    TAPL 積読状態なので、まずは本書を読み進めていく。
- date: 2025-07-02
  bookTitle: 型システムのしくみ TypeScript で実装しながら学ぶ型とプログラミング言語
  pages: 8 ~ 22
  notes: |
    第 2 章 真偽値の型と数値の型
    まず真偽値と数値のリテラル、条件・加算の演算子を持つ言語を作る。 TAPL の型無算術式・型付き算術式に相当する。
    型検査器の判定基準と抽象構文木(Abstract Syntax Tree)の設計。
    プログラムを読み込んで AST を生成するパーサーの実装。
    型検査器を実装して動かす。エラー時の挙動もここで決める。
    TypeScript での実装なので型と AST は discriminated union での実装になってる。
    TypeScript が OK/NG にした設計意図の話も面白い。
- date: 2025-07-03
  bookTitle: 型システムのしくみ TypeScript で実装しながら学ぶ型とプログラミング言語
  pages: 23 ~ 39
  notes: |
    第 3 章 関数型
    関数の型の実装。この章は変数参照・無名関数・関数呼び出しをやる。 TAPL の単純型付きラムダ式に相当する。
    変数参照では定義済み変数を管理する型環境(型付け文脈)を実装する。型環境に見つからない＝未定義変数のエラー。
    型環境を更新する際は破壊的更新を行うと静的スコープ外の変数が参照できてしまうので、非破壊的更新を行う。
    関数の型の等価判定で仮引数の名前を比較すると仮引数の名前が違う実引数を渡せなくなるので、この実装では比較しない。
    argument 実引数と parameter 仮引数の使い分けの経緯おもしろ。
- date: 2025-07-04
  bookTitle: 型システムのしくみ TypeScript で実装しながら学ぶ型とプログラミング言語
  pages: 40 ~ 56
  notes: |
    第 4 章 逐次実行と変数定義
    関数の型の続き。 TAPL の単純な拡張の中の派生形式・ let 束縛に相当する。
    本書では TAPL にならい変数の再定義を許す。 shadowing は同一 block での再定義を禁じて下位 block で許可するやつ。
    逐次実行と変数定義の AST が再帰的なのは ML 風で配列での実装もできる。
    ここまでで作った型システムは必ず停止する正規化可能性が保証されるので、発散コンビネータ・ omega のようなコードは書けない。
    また前方参照は許可していない。
    型設計として発生しうるパターンでも parser で生成しないようにしてるってのはちょっと目からウロコ。実装の簡便さのためかな。
- date: 2025-07-05
  bookTitle: 型システムのしくみ TypeScript で実装しながら学ぶ型とプログラミング言語
  pages: 57 ~ 67
  notes: |
    第 5 章 オブジェクト型
    ここで対応するのは構造体とか record と呼ばれる複数の値にラベルをつけてまとめるデータ型。
    TAPL の単純な拡張の中のレコードに相当する。
    なので AST でオブジェクト生成の構文は複数の値を持てるように定義する。 record の実装自体は難しくない。
    等価判定の時間計算量が気になったけど今気にするところじゃないのかな。
    variant のひとつ union を実装するのは TAPL の範囲を超えてしまい難しいが、 TypeScript の tagged union ならまだましなので演習問題ではそれに挑戦するようになってる(それでも難しい)。
    なるほど読み終えてから見直してみるかあ。
- date: 2025-07-06
  bookTitle: 型システムのしくみ TypeScript で実装しながら学ぶ型とプログラミング言語
  pages: 68 ~ 78
  notes: |
    第 6 章 再帰関数
    本書の再帰関数は ML 流の型推論の実装が難しいので戻り値の型を明示する。そのため宣言文も専用のものを用意する。
    TAPL の単純な拡張の中の一般的再帰に相当する。
    型検査器では戻り値の型の検査、また後続処理では再帰関数自身のみを含む型環境での型検査を行う。
    このような特別な構文を用いなくても不動点コンビネータ(発散コンビネータの発展型)を利用すれば再帰関数が書ける。
    ここで特別な構文を用いたのは抽象度が上がって説明が難しくなるためとのこと。
    章の内容はわかったが用語がわからんの後追いで勉強が必要だわ。
- date: 2025-07-07
  bookTitle: 型システムのしくみ TypeScript で実装しながら学ぶ型とプログラミング言語
  pages: 79 ~ 91
  notes: |
    第 7 章 部分型付け
    TAPL の部分型付けと部分型付けのメタ理論の一部に相当する。
    TypeScript でできるような部分型付け(subtyping) という型システムの拡張。
    この章ではオブジェクト型の部分型付けを実装するが、文脈によっては異なる型の間や関数の型の部分型付けも可能。
    型の代入可能性、共変(covariant)と反変(contravariant)の概念。
    条件演算子の型を実装すると join(型の結び)・ meet(型の交わり) で実装が冗長になるので本書は除外。
    variance support の波が F# に迫って来そうなので共変・反変ちゃんと覚えようと思ってたらこんなところでばったり出会うとは。
